import {
  MDCFloatingLabel,
  MDCLineRipple,
  MDCNotchedOutline,
  dist_default as dist_default2,
  dist_default2 as dist_default3,
  dist_default3 as dist_default4
} from "./chunk-PYNMXI5K.js";
import {
  classAdderBuilder
} from "./chunk-HQIZ4DBT.js";
import {
  ContextFragment_default
} from "./chunk-ZSIG2HMK.js";
import {
  MDCComponent,
  MDCFoundation,
  MDCRipple,
  MDCRippleFoundation,
  applyPassive,
  classMap,
  dispatch,
  dist_default,
  events_exports,
  exclude,
  forwardEventsBuilder,
  matches,
  prefixFilter,
  useActions
} from "./chunk-QH7DRB7N.js";
import {
  __assign,
  __extends,
  __values
} from "./chunk-3L2CPHNC.js";
import "./chunk-RAXL67E4.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-NLMIYH64.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@material/textfield/character-counter/constants.js
var cssClasses = {
  ROOT: "mdc-text-field-character-counter"
};
var strings = {
  ROOT_SELECTOR: "." + cssClasses.ROOT
};

// node_modules/@material/textfield/character-counter/foundation.js
var MDCTextFieldCharacterCounterFoundation = function(_super) {
  __extends(MDCTextFieldCharacterCounterFoundation2, _super);
  function MDCTextFieldCharacterCounterFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCTextFieldCharacterCounterFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCTextFieldCharacterCounterFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldCharacterCounterFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldCharacterCounterFoundation2, "defaultAdapter", {
    get: function() {
      return {
        setContent: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldCharacterCounterFoundation2.prototype.setCounterValue = function(currentLength, maxLength) {
    currentLength = Math.min(currentLength, maxLength);
    this.adapter.setContent(currentLength + " / " + maxLength);
  };
  return MDCTextFieldCharacterCounterFoundation2;
}(MDCFoundation);

// node_modules/@material/textfield/character-counter/component.js
var MDCTextFieldCharacterCounter = function(_super) {
  __extends(MDCTextFieldCharacterCounter2, _super);
  function MDCTextFieldCharacterCounter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTextFieldCharacterCounter2.attachTo = function(root) {
    return new MDCTextFieldCharacterCounter2(root);
  };
  Object.defineProperty(MDCTextFieldCharacterCounter2.prototype, "foundationForTextField", {
    get: function() {
      return this.foundation;
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldCharacterCounter2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      setContent: function(content) {
        _this.root.textContent = content;
      }
    };
    return new MDCTextFieldCharacterCounterFoundation(adapter);
  };
  return MDCTextFieldCharacterCounter2;
}(MDCComponent);

// node_modules/@material/textfield/constants.js
var strings2 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  INPUT_SELECTOR: ".mdc-text-field__input",
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
  SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
  TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
};
var cssClasses2 = {
  DISABLED: "mdc-text-field--disabled",
  FOCUSED: "mdc-text-field--focused",
  HELPER_LINE: "mdc-text-field-helper-line",
  INVALID: "mdc-text-field--invalid",
  LABEL_FLOATING: "mdc-text-field--label-floating",
  NO_LABEL: "mdc-text-field--no-label",
  OUTLINED: "mdc-text-field--outlined",
  ROOT: "mdc-text-field",
  TEXTAREA: "mdc-text-field--textarea",
  WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
  WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon",
  WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter"
};
var numbers = {
  LABEL_SCALE: 0.75
};
var VALIDATION_ATTR_WHITELIST = [
  "pattern",
  "min",
  "max",
  "required",
  "step",
  "minlength",
  "maxlength"
];
var ALWAYS_FLOAT_TYPES = [
  "color",
  "date",
  "datetime-local",
  "month",
  "range",
  "time",
  "week"
];

// node_modules/@material/textfield/foundation.js
var POINTERDOWN_EVENTS = ["mousedown", "touchstart"];
var INTERACTION_EVENTS = ["click", "keydown"];
var MDCTextFieldFoundation = function(_super) {
  __extends(MDCTextFieldFoundation2, _super);
  function MDCTextFieldFoundation2(adapter, foundationMap) {
    if (foundationMap === void 0) {
      foundationMap = {};
    }
    var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation2.defaultAdapter), adapter)) || this;
    _this.isFocused = false;
    _this.receivedUserInput = false;
    _this.valid = true;
    _this.useNativeValidation = true;
    _this.validateOnValueChange = true;
    _this.helperText = foundationMap.helperText;
    _this.characterCounter = foundationMap.characterCounter;
    _this.leadingIcon = foundationMap.leadingIcon;
    _this.trailingIcon = foundationMap.trailingIcon;
    _this.inputFocusHandler = function() {
      _this.activateFocus();
    };
    _this.inputBlurHandler = function() {
      _this.deactivateFocus();
    };
    _this.inputInputHandler = function() {
      _this.handleInput();
    };
    _this.setPointerXOffset = function(evt) {
      _this.setTransformOrigin(evt);
    };
    _this.textFieldInteractionHandler = function() {
      _this.handleTextFieldInteraction();
    };
    _this.validationAttributeChangeHandler = function(attributesList) {
      _this.handleValidationAttributeChange(attributesList);
    };
    return _this;
  }
  Object.defineProperty(MDCTextFieldFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "strings", {
    get: function() {
      return strings2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldAlwaysFloat", {
    get: function() {
      var type = this.getNativeInput().type;
      return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldFloat", {
    get: function() {
      return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2.prototype, "shouldShake", {
    get: function() {
      return !this.isFocused && !this.isValid() && !!this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return true;
        },
        setInputAttr: function() {
          return void 0;
        },
        removeInputAttr: function() {
          return void 0;
        },
        registerTextFieldInteractionHandler: function() {
          return void 0;
        },
        deregisterTextFieldInteractionHandler: function() {
          return void 0;
        },
        registerInputInteractionHandler: function() {
          return void 0;
        },
        deregisterInputInteractionHandler: function() {
          return void 0;
        },
        registerValidationAttributeChangeHandler: function() {
          return new MutationObserver(function() {
            return void 0;
          });
        },
        deregisterValidationAttributeChangeHandler: function() {
          return void 0;
        },
        getNativeInput: function() {
          return null;
        },
        isFocused: function() {
          return false;
        },
        activateLineRipple: function() {
          return void 0;
        },
        deactivateLineRipple: function() {
          return void 0;
        },
        setLineRippleTransformOrigin: function() {
          return void 0;
        },
        shakeLabel: function() {
          return void 0;
        },
        floatLabel: function() {
          return void 0;
        },
        setLabelRequired: function() {
          return void 0;
        },
        hasLabel: function() {
          return false;
        },
        getLabelWidth: function() {
          return 0;
        },
        hasOutline: function() {
          return false;
        },
        notchOutline: function() {
          return void 0;
        },
        closeOutline: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldFoundation2.prototype.init = function() {
    var e_1, _a, e_2, _b;
    if (this.adapter.hasLabel() && this.getNativeInput().required) {
      this.adapter.setLabelRequired(true);
    }
    if (this.adapter.isFocused()) {
      this.inputFocusHandler();
    } else if (this.adapter.hasLabel() && this.shouldFloat) {
      this.notchOutline(true);
      this.adapter.floatLabel(true);
      this.styleFloating(true);
    }
    this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_1 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next(); !POINTERDOWN_EVENTS_1_1.done; POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next()) {
        var evtType = POINTERDOWN_EVENTS_1_1.value;
        this.adapter.registerInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_1_1 && !POINTERDOWN_EVENTS_1_1.done && (_a = POINTERDOWN_EVENTS_1.return))
          _a.call(POINTERDOWN_EVENTS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
        var evtType = INTERACTION_EVENTS_1_1.value;
        this.adapter.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_b = INTERACTION_EVENTS_1.return))
          _b.call(INTERACTION_EVENTS_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler);
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.destroy = function() {
    var e_3, _a, e_4, _b;
    this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler);
    this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler);
    this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var POINTERDOWN_EVENTS_2 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next(); !POINTERDOWN_EVENTS_2_1.done; POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next()) {
        var evtType = POINTERDOWN_EVENTS_2_1.value;
        this.adapter.deregisterInputInteractionHandler(evtType, this.setPointerXOffset);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (POINTERDOWN_EVENTS_2_1 && !POINTERDOWN_EVENTS_2_1.done && (_a = POINTERDOWN_EVENTS_2.return))
          _a.call(POINTERDOWN_EVENTS_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    try {
      for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
        var evtType = INTERACTION_EVENTS_2_1.value;
        this.adapter.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_b = INTERACTION_EVENTS_2.return))
          _b.call(INTERACTION_EVENTS_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
  };
  MDCTextFieldFoundation2.prototype.handleTextFieldInteraction = function() {
    var nativeInput = this.adapter.getNativeInput();
    if (nativeInput && nativeInput.disabled) {
      return;
    }
    this.receivedUserInput = true;
  };
  MDCTextFieldFoundation2.prototype.handleValidationAttributeChange = function(attributesList) {
    var _this = this;
    attributesList.some(function(attributeName) {
      if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
        _this.styleValidity(true);
        _this.adapter.setLabelRequired(_this.getNativeInput().required);
        return true;
      }
      return false;
    });
    if (attributesList.indexOf("maxlength") > -1) {
      this.setcharacterCounter(this.getValue().length);
    }
  };
  MDCTextFieldFoundation2.prototype.notchOutline = function(openNotch) {
    if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
      return;
    }
    if (openNotch) {
      var labelWidth = this.adapter.getLabelWidth() * numbers.LABEL_SCALE;
      this.adapter.notchOutline(labelWidth);
    } else {
      this.adapter.closeOutline();
    }
  };
  MDCTextFieldFoundation2.prototype.activateFocus = function() {
    this.isFocused = true;
    this.styleFocused(this.isFocused);
    this.adapter.activateLineRipple();
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (this.helperText && (this.helperText.isPersistent() || !this.helperText.isValidation() || !this.valid)) {
      this.helperText.showToScreenReader();
    }
  };
  MDCTextFieldFoundation2.prototype.setTransformOrigin = function(evt) {
    if (this.isDisabled() || this.adapter.hasOutline()) {
      return;
    }
    var touches = evt.touches;
    var targetEvent = touches ? touches[0] : evt;
    var targetClientRect = targetEvent.target.getBoundingClientRect();
    var normalizedX = targetEvent.clientX - targetClientRect.left;
    this.adapter.setLineRippleTransformOrigin(normalizedX);
  };
  MDCTextFieldFoundation2.prototype.handleInput = function() {
    this.autoCompleteFocus();
    this.setcharacterCounter(this.getValue().length);
  };
  MDCTextFieldFoundation2.prototype.autoCompleteFocus = function() {
    if (!this.receivedUserInput) {
      this.activateFocus();
    }
  };
  MDCTextFieldFoundation2.prototype.deactivateFocus = function() {
    this.isFocused = false;
    this.adapter.deactivateLineRipple();
    var isValid = this.isValid();
    this.styleValidity(isValid);
    this.styleFocused(this.isFocused);
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      this.adapter.shakeLabel(this.shouldShake);
    }
    if (!this.shouldFloat) {
      this.receivedUserInput = false;
    }
  };
  MDCTextFieldFoundation2.prototype.getValue = function() {
    return this.getNativeInput().value;
  };
  MDCTextFieldFoundation2.prototype.setValue = function(value) {
    if (this.getValue() !== value) {
      this.getNativeInput().value = value;
    }
    this.setcharacterCounter(value.length);
    if (this.validateOnValueChange) {
      var isValid = this.isValid();
      this.styleValidity(isValid);
    }
    if (this.adapter.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter.floatLabel(this.shouldFloat);
      this.styleFloating(this.shouldFloat);
      if (this.validateOnValueChange) {
        this.adapter.shakeLabel(this.shouldShake);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.isValid = function() {
    return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
  };
  MDCTextFieldFoundation2.prototype.setValid = function(isValid) {
    this.valid = isValid;
    this.styleValidity(isValid);
    var shouldShake = !isValid && !this.isFocused && !!this.getValue();
    if (this.adapter.hasLabel()) {
      this.adapter.shakeLabel(shouldShake);
    }
  };
  MDCTextFieldFoundation2.prototype.setValidateOnValueChange = function(shouldValidate) {
    this.validateOnValueChange = shouldValidate;
  };
  MDCTextFieldFoundation2.prototype.getValidateOnValueChange = function() {
    return this.validateOnValueChange;
  };
  MDCTextFieldFoundation2.prototype.setUseNativeValidation = function(useNativeValidation) {
    this.useNativeValidation = useNativeValidation;
  };
  MDCTextFieldFoundation2.prototype.isDisabled = function() {
    return this.getNativeInput().disabled;
  };
  MDCTextFieldFoundation2.prototype.setDisabled = function(disabled) {
    this.getNativeInput().disabled = disabled;
    this.styleDisabled(disabled);
  };
  MDCTextFieldFoundation2.prototype.setHelperTextContent = function(content) {
    if (this.helperText) {
      this.helperText.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
    if (this.leadingIcon) {
      this.leadingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setLeadingIconContent = function(content) {
    if (this.leadingIcon) {
      this.leadingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconAriaLabel = function(label) {
    if (this.trailingIcon) {
      this.trailingIcon.setAriaLabel(label);
    }
  };
  MDCTextFieldFoundation2.prototype.setTrailingIconContent = function(content) {
    if (this.trailingIcon) {
      this.trailingIcon.setContent(content);
    }
  };
  MDCTextFieldFoundation2.prototype.setcharacterCounter = function(currentLength) {
    if (!this.characterCounter) {
      return;
    }
    var maxLength = this.getNativeInput().maxLength;
    if (maxLength === -1) {
      throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
    }
    this.characterCounter.setCounterValue(currentLength, maxLength);
  };
  MDCTextFieldFoundation2.prototype.isBadInput = function() {
    return this.getNativeInput().validity.badInput || false;
  };
  MDCTextFieldFoundation2.prototype.isNativeInputValid = function() {
    return this.getNativeInput().validity.valid;
  };
  MDCTextFieldFoundation2.prototype.styleValidity = function(isValid) {
    var INVALID = MDCTextFieldFoundation2.cssClasses.INVALID;
    if (isValid) {
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.addClass(INVALID);
    }
    if (this.helperText) {
      this.helperText.setValidity(isValid);
      var helperTextValidation = this.helperText.isValidation();
      if (!helperTextValidation) {
        return;
      }
      var helperTextVisible = this.helperText.isVisible();
      var helperTextId = this.helperText.getId();
      if (helperTextVisible && helperTextId) {
        this.adapter.setInputAttr(strings2.ARIA_DESCRIBEDBY, helperTextId);
      } else {
        this.adapter.removeInputAttr(strings2.ARIA_DESCRIBEDBY);
      }
    }
  };
  MDCTextFieldFoundation2.prototype.styleFocused = function(isFocused) {
    var FOCUSED = MDCTextFieldFoundation2.cssClasses.FOCUSED;
    if (isFocused) {
      this.adapter.addClass(FOCUSED);
    } else {
      this.adapter.removeClass(FOCUSED);
    }
  };
  MDCTextFieldFoundation2.prototype.styleDisabled = function(isDisabled) {
    var _a = MDCTextFieldFoundation2.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
    if (isDisabled) {
      this.adapter.addClass(DISABLED);
      this.adapter.removeClass(INVALID);
    } else {
      this.adapter.removeClass(DISABLED);
    }
    if (this.leadingIcon) {
      this.leadingIcon.setDisabled(isDisabled);
    }
    if (this.trailingIcon) {
      this.trailingIcon.setDisabled(isDisabled);
    }
  };
  MDCTextFieldFoundation2.prototype.styleFloating = function(isFloating) {
    var LABEL_FLOATING = MDCTextFieldFoundation2.cssClasses.LABEL_FLOATING;
    if (isFloating) {
      this.adapter.addClass(LABEL_FLOATING);
    } else {
      this.adapter.removeClass(LABEL_FLOATING);
    }
  };
  MDCTextFieldFoundation2.prototype.getNativeInput = function() {
    var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
    return nativeInput || {
      disabled: false,
      maxLength: -1,
      required: false,
      type: "input",
      validity: {
        badInput: false,
        valid: true
      },
      value: ""
    };
  };
  return MDCTextFieldFoundation2;
}(MDCFoundation);

// node_modules/@material/textfield/helper-text/constants.js
var cssClasses3 = {
  HELPER_TEXT_PERSISTENT: "mdc-text-field-helper-text--persistent",
  HELPER_TEXT_VALIDATION_MSG: "mdc-text-field-helper-text--validation-msg",
  ROOT: "mdc-text-field-helper-text"
};
var strings3 = {
  ARIA_HIDDEN: "aria-hidden",
  ROLE: "role",
  ROOT_SELECTOR: "." + cssClasses3.ROOT
};

// node_modules/@material/textfield/helper-text/foundation.js
var MDCTextFieldHelperTextFoundation = function(_super) {
  __extends(MDCTextFieldHelperTextFoundation2, _super);
  function MDCTextFieldHelperTextFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "cssClasses", {
    get: function() {
      return cssClasses3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "strings", {
    get: function() {
      return strings3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldHelperTextFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        },
        removeAttr: function() {
          return void 0;
        },
        setContent: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldHelperTextFoundation2.prototype.getId = function() {
    return this.adapter.getAttr("id");
  };
  MDCTextFieldHelperTextFoundation2.prototype.isVisible = function() {
    return this.adapter.getAttr(strings3.ARIA_HIDDEN) !== "true";
  };
  MDCTextFieldHelperTextFoundation2.prototype.setContent = function(content) {
    this.adapter.setContent(content);
  };
  MDCTextFieldHelperTextFoundation2.prototype.isPersistent = function() {
    return this.adapter.hasClass(cssClasses3.HELPER_TEXT_PERSISTENT);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setPersistent = function(isPersistent) {
    if (isPersistent) {
      this.adapter.addClass(cssClasses3.HELPER_TEXT_PERSISTENT);
    } else {
      this.adapter.removeClass(cssClasses3.HELPER_TEXT_PERSISTENT);
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.isValidation = function() {
    return this.adapter.hasClass(cssClasses3.HELPER_TEXT_VALIDATION_MSG);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setValidation = function(isValidation) {
    if (isValidation) {
      this.adapter.addClass(cssClasses3.HELPER_TEXT_VALIDATION_MSG);
    } else {
      this.adapter.removeClass(cssClasses3.HELPER_TEXT_VALIDATION_MSG);
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.showToScreenReader = function() {
    this.adapter.removeAttr(strings3.ARIA_HIDDEN);
  };
  MDCTextFieldHelperTextFoundation2.prototype.setValidity = function(inputIsValid) {
    var helperTextIsPersistent = this.adapter.hasClass(cssClasses3.HELPER_TEXT_PERSISTENT);
    var helperTextIsValidationMsg = this.adapter.hasClass(cssClasses3.HELPER_TEXT_VALIDATION_MSG);
    var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
    if (validationMsgNeedsDisplay) {
      this.showToScreenReader();
      if (this.adapter.getAttr(strings3.ROLE) === "alert") {
        this.refreshAlertRole();
      } else {
        this.adapter.setAttr(strings3.ROLE, "alert");
      }
    } else {
      this.adapter.removeAttr(strings3.ROLE);
    }
    if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
      this.hide();
    }
  };
  MDCTextFieldHelperTextFoundation2.prototype.hide = function() {
    this.adapter.setAttr(strings3.ARIA_HIDDEN, "true");
  };
  MDCTextFieldHelperTextFoundation2.prototype.refreshAlertRole = function() {
    var _this = this;
    this.adapter.removeAttr(strings3.ROLE);
    requestAnimationFrame(function() {
      _this.adapter.setAttr(strings3.ROLE, "alert");
    });
  };
  return MDCTextFieldHelperTextFoundation2;
}(MDCFoundation);

// node_modules/@material/textfield/helper-text/component.js
var MDCTextFieldHelperText = function(_super) {
  __extends(MDCTextFieldHelperText2, _super);
  function MDCTextFieldHelperText2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTextFieldHelperText2.attachTo = function(root) {
    return new MDCTextFieldHelperText2(root);
  };
  Object.defineProperty(MDCTextFieldHelperText2.prototype, "foundationForTextField", {
    get: function() {
      return this.foundation;
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldHelperText2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      getAttr: function(attr) {
        return _this.root.getAttribute(attr);
      },
      setAttr: function(attr, value) {
        return _this.root.setAttribute(attr, value);
      },
      removeAttr: function(attr) {
        return _this.root.removeAttribute(attr);
      },
      setContent: function(content) {
        _this.root.textContent = content;
      }
    };
    return new MDCTextFieldHelperTextFoundation(adapter);
  };
  return MDCTextFieldHelperText2;
}(MDCComponent);

// node_modules/@material/textfield/icon/constants.js
var strings4 = {
  ICON_EVENT: "MDCTextField:icon",
  ICON_ROLE: "button"
};
var cssClasses4 = {
  ROOT: "mdc-text-field__icon"
};

// node_modules/@material/textfield/icon/foundation.js
var INTERACTION_EVENTS2 = ["click", "keydown"];
var MDCTextFieldIconFoundation = function(_super) {
  __extends(MDCTextFieldIconFoundation2, _super);
  function MDCTextFieldIconFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCTextFieldIconFoundation2.defaultAdapter), adapter)) || this;
    _this.savedTabIndex = null;
    _this.interactionHandler = function(evt) {
      _this.handleInteraction(evt);
    };
    return _this;
  }
  Object.defineProperty(MDCTextFieldIconFoundation2, "strings", {
    get: function() {
      return strings4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldIconFoundation2, "cssClasses", {
    get: function() {
      return cssClasses4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldIconFoundation2, "defaultAdapter", {
    get: function() {
      return {
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        },
        removeAttr: function() {
          return void 0;
        },
        setContent: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        notifyIconAction: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldIconFoundation2.prototype.init = function() {
    var e_1, _a;
    this.savedTabIndex = this.adapter.getAttr("tabindex");
    try {
      for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS2), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
        var evtType = INTERACTION_EVENTS_1_1.value;
        this.adapter.registerInteractionHandler(evtType, this.interactionHandler);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_a = INTERACTION_EVENTS_1.return))
          _a.call(INTERACTION_EVENTS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCTextFieldIconFoundation2.prototype.destroy = function() {
    var e_2, _a;
    try {
      for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS2), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
        var evtType = INTERACTION_EVENTS_2_1.value;
        this.adapter.deregisterInteractionHandler(evtType, this.interactionHandler);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_a = INTERACTION_EVENTS_2.return))
          _a.call(INTERACTION_EVENTS_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  MDCTextFieldIconFoundation2.prototype.setDisabled = function(disabled) {
    if (!this.savedTabIndex) {
      return;
    }
    if (disabled) {
      this.adapter.setAttr("tabindex", "-1");
      this.adapter.removeAttr("role");
    } else {
      this.adapter.setAttr("tabindex", this.savedTabIndex);
      this.adapter.setAttr("role", strings4.ICON_ROLE);
    }
  };
  MDCTextFieldIconFoundation2.prototype.setAriaLabel = function(label) {
    this.adapter.setAttr("aria-label", label);
  };
  MDCTextFieldIconFoundation2.prototype.setContent = function(content) {
    this.adapter.setContent(content);
  };
  MDCTextFieldIconFoundation2.prototype.handleInteraction = function(evt) {
    var isEnterKey = evt.key === "Enter" || evt.keyCode === 13;
    if (evt.type === "click" || isEnterKey) {
      evt.preventDefault();
      this.adapter.notifyIconAction();
    }
  };
  return MDCTextFieldIconFoundation2;
}(MDCFoundation);

// node_modules/@material/textfield/icon/component.js
var MDCTextFieldIcon = function(_super) {
  __extends(MDCTextFieldIcon2, _super);
  function MDCTextFieldIcon2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTextFieldIcon2.attachTo = function(root) {
    return new MDCTextFieldIcon2(root);
  };
  Object.defineProperty(MDCTextFieldIcon2.prototype, "foundationForTextField", {
    get: function() {
      return this.foundation;
    },
    enumerable: false,
    configurable: true
  });
  MDCTextFieldIcon2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      getAttr: function(attr) {
        return _this.root.getAttribute(attr);
      },
      setAttr: function(attr, value) {
        return _this.root.setAttribute(attr, value);
      },
      removeAttr: function(attr) {
        return _this.root.removeAttribute(attr);
      },
      setContent: function(content) {
        _this.root.textContent = content;
      },
      registerInteractionHandler: function(evtType, handler) {
        return _this.listen(evtType, handler);
      },
      deregisterInteractionHandler: function(evtType, handler) {
        return _this.unlisten(evtType, handler);
      },
      notifyIconAction: function() {
        return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {}, true);
      }
    };
    return new MDCTextFieldIconFoundation(adapter);
  };
  return MDCTextFieldIcon2;
}(MDCComponent);

// node_modules/@material/textfield/component.js
var MDCTextField = function(_super) {
  __extends(MDCTextField2, _super);
  function MDCTextField2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTextField2.attachTo = function(root) {
    return new MDCTextField2(root);
  };
  MDCTextField2.prototype.initialize = function(rippleFactory, lineRippleFactory, helperTextFactory, characterCounterFactory, iconFactory, labelFactory, outlineFactory) {
    if (rippleFactory === void 0) {
      rippleFactory = function(el, foundation) {
        return new MDCRipple(el, foundation);
      };
    }
    if (lineRippleFactory === void 0) {
      lineRippleFactory = function(el) {
        return new MDCLineRipple(el);
      };
    }
    if (helperTextFactory === void 0) {
      helperTextFactory = function(el) {
        return new MDCTextFieldHelperText(el);
      };
    }
    if (characterCounterFactory === void 0) {
      characterCounterFactory = function(el) {
        return new MDCTextFieldCharacterCounter(el);
      };
    }
    if (iconFactory === void 0) {
      iconFactory = function(el) {
        return new MDCTextFieldIcon(el);
      };
    }
    if (labelFactory === void 0) {
      labelFactory = function(el) {
        return new MDCFloatingLabel(el);
      };
    }
    if (outlineFactory === void 0) {
      outlineFactory = function(el) {
        return new MDCNotchedOutline(el);
      };
    }
    this.input = this.root.querySelector(strings2.INPUT_SELECTOR);
    var labelElement = this.root.querySelector(strings2.LABEL_SELECTOR);
    this.label = labelElement ? labelFactory(labelElement) : null;
    var lineRippleElement = this.root.querySelector(strings2.LINE_RIPPLE_SELECTOR);
    this.lineRipple = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
    var outlineElement = this.root.querySelector(strings2.OUTLINE_SELECTOR);
    this.outline = outlineElement ? outlineFactory(outlineElement) : null;
    var helperTextStrings = MDCTextFieldHelperTextFoundation.strings;
    var nextElementSibling = this.root.nextElementSibling;
    var hasHelperLine = nextElementSibling && nextElementSibling.classList.contains(cssClasses2.HELPER_LINE);
    var helperTextEl = hasHelperLine && nextElementSibling && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);
    this.helperText = helperTextEl ? helperTextFactory(helperTextEl) : null;
    var characterCounterStrings = MDCTextFieldCharacterCounterFoundation.strings;
    var characterCounterEl = this.root.querySelector(characterCounterStrings.ROOT_SELECTOR);
    if (!characterCounterEl && hasHelperLine && nextElementSibling) {
      characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
    }
    this.characterCounter = characterCounterEl ? characterCounterFactory(characterCounterEl) : null;
    var leadingIconEl = this.root.querySelector(strings2.LEADING_ICON_SELECTOR);
    this.leadingIcon = leadingIconEl ? iconFactory(leadingIconEl) : null;
    var trailingIconEl = this.root.querySelector(strings2.TRAILING_ICON_SELECTOR);
    this.trailingIcon = trailingIconEl ? iconFactory(trailingIconEl) : null;
    this.prefix = this.root.querySelector(strings2.PREFIX_SELECTOR);
    this.suffix = this.root.querySelector(strings2.SUFFIX_SELECTOR);
    this.ripple = this.createRipple(rippleFactory);
  };
  MDCTextField2.prototype.destroy = function() {
    if (this.ripple) {
      this.ripple.destroy();
    }
    if (this.lineRipple) {
      this.lineRipple.destroy();
    }
    if (this.helperText) {
      this.helperText.destroy();
    }
    if (this.characterCounter) {
      this.characterCounter.destroy();
    }
    if (this.leadingIcon) {
      this.leadingIcon.destroy();
    }
    if (this.trailingIcon) {
      this.trailingIcon.destroy();
    }
    if (this.label) {
      this.label.destroy();
    }
    if (this.outline) {
      this.outline.destroy();
    }
    _super.prototype.destroy.call(this);
  };
  MDCTextField2.prototype.initialSyncWithDOM = function() {
    this.disabled = this.input.disabled;
  };
  Object.defineProperty(MDCTextField2.prototype, "value", {
    get: function() {
      return this.foundation.getValue();
    },
    set: function(value) {
      this.foundation.setValue(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "disabled", {
    get: function() {
      return this.foundation.isDisabled();
    },
    set: function(disabled) {
      this.foundation.setDisabled(disabled);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "valid", {
    get: function() {
      return this.foundation.isValid();
    },
    set: function(valid) {
      this.foundation.setValid(valid);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "required", {
    get: function() {
      return this.input.required;
    },
    set: function(required) {
      this.input.required = required;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "pattern", {
    get: function() {
      return this.input.pattern;
    },
    set: function(pattern) {
      this.input.pattern = pattern;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "minLength", {
    get: function() {
      return this.input.minLength;
    },
    set: function(minLength) {
      this.input.minLength = minLength;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "maxLength", {
    get: function() {
      return this.input.maxLength;
    },
    set: function(maxLength) {
      if (maxLength < 0) {
        this.input.removeAttribute("maxLength");
      } else {
        this.input.maxLength = maxLength;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "min", {
    get: function() {
      return this.input.min;
    },
    set: function(min) {
      this.input.min = min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "max", {
    get: function() {
      return this.input.max;
    },
    set: function(max) {
      this.input.max = max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "step", {
    get: function() {
      return this.input.step;
    },
    set: function(step) {
      this.input.step = step;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "helperTextContent", {
    set: function(content) {
      this.foundation.setHelperTextContent(content);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "leadingIconAriaLabel", {
    set: function(label) {
      this.foundation.setLeadingIconAriaLabel(label);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "leadingIconContent", {
    set: function(content) {
      this.foundation.setLeadingIconContent(content);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "trailingIconAriaLabel", {
    set: function(label) {
      this.foundation.setTrailingIconAriaLabel(label);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "trailingIconContent", {
    set: function(content) {
      this.foundation.setTrailingIconContent(content);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "useNativeValidation", {
    set: function(useNativeValidation) {
      this.foundation.setUseNativeValidation(useNativeValidation);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "prefixText", {
    get: function() {
      return this.prefix ? this.prefix.textContent : null;
    },
    set: function(prefixText) {
      if (this.prefix) {
        this.prefix.textContent = prefixText;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTextField2.prototype, "suffixText", {
    get: function() {
      return this.suffix ? this.suffix.textContent : null;
    },
    set: function(suffixText) {
      if (this.suffix) {
        this.suffix.textContent = suffixText;
      }
    },
    enumerable: false,
    configurable: true
  });
  MDCTextField2.prototype.focus = function() {
    this.input.focus();
  };
  MDCTextField2.prototype.layout = function() {
    var openNotch = this.foundation.shouldFloat;
    this.foundation.notchOutline(openNotch);
  };
  MDCTextField2.prototype.getDefaultFoundation = function() {
    var adapter = __assign(__assign(__assign(__assign(__assign({}, this.getRootAdapterMethods()), this.getInputAdapterMethods()), this.getLabelAdapterMethods()), this.getLineRippleAdapterMethods()), this.getOutlineAdapterMethods());
    return new MDCTextFieldFoundation(adapter, this.getFoundationMap());
  };
  MDCTextField2.prototype.getRootAdapterMethods = function() {
    var _this = this;
    return {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      registerTextFieldInteractionHandler: function(evtType, handler) {
        _this.listen(evtType, handler);
      },
      deregisterTextFieldInteractionHandler: function(evtType, handler) {
        _this.unlisten(evtType, handler);
      },
      registerValidationAttributeChangeHandler: function(handler) {
        var getAttributesList = function(mutationsList) {
          return mutationsList.map(function(mutation) {
            return mutation.attributeName;
          }).filter(function(attributeName) {
            return attributeName;
          });
        };
        var observer = new MutationObserver(function(mutationsList) {
          return handler(getAttributesList(mutationsList));
        });
        var config = { attributes: true };
        observer.observe(_this.input, config);
        return observer;
      },
      deregisterValidationAttributeChangeHandler: function(observer) {
        observer.disconnect();
      }
    };
  };
  MDCTextField2.prototype.getInputAdapterMethods = function() {
    var _this = this;
    return {
      getNativeInput: function() {
        return _this.input;
      },
      setInputAttr: function(attr, value) {
        _this.input.setAttribute(attr, value);
      },
      removeInputAttr: function(attr) {
        _this.input.removeAttribute(attr);
      },
      isFocused: function() {
        return document.activeElement === _this.input;
      },
      registerInputInteractionHandler: function(evtType, handler) {
        _this.input.addEventListener(evtType, handler, applyPassive());
      },
      deregisterInputInteractionHandler: function(evtType, handler) {
        _this.input.removeEventListener(evtType, handler, applyPassive());
      }
    };
  };
  MDCTextField2.prototype.getLabelAdapterMethods = function() {
    var _this = this;
    return {
      floatLabel: function(shouldFloat) {
        _this.label && _this.label.float(shouldFloat);
      },
      getLabelWidth: function() {
        return _this.label ? _this.label.getWidth() : 0;
      },
      hasLabel: function() {
        return Boolean(_this.label);
      },
      shakeLabel: function(shouldShake) {
        _this.label && _this.label.shake(shouldShake);
      },
      setLabelRequired: function(isRequired) {
        _this.label && _this.label.setRequired(isRequired);
      }
    };
  };
  MDCTextField2.prototype.getLineRippleAdapterMethods = function() {
    var _this = this;
    return {
      activateLineRipple: function() {
        if (_this.lineRipple) {
          _this.lineRipple.activate();
        }
      },
      deactivateLineRipple: function() {
        if (_this.lineRipple) {
          _this.lineRipple.deactivate();
        }
      },
      setLineRippleTransformOrigin: function(normalizedX) {
        if (_this.lineRipple) {
          _this.lineRipple.setRippleCenter(normalizedX);
        }
      }
    };
  };
  MDCTextField2.prototype.getOutlineAdapterMethods = function() {
    var _this = this;
    return {
      closeOutline: function() {
        _this.outline && _this.outline.closeNotch();
      },
      hasOutline: function() {
        return Boolean(_this.outline);
      },
      notchOutline: function(labelWidth) {
        _this.outline && _this.outline.notch(labelWidth);
      }
    };
  };
  MDCTextField2.prototype.getFoundationMap = function() {
    return {
      characterCounter: this.characterCounter ? this.characterCounter.foundationForTextField : void 0,
      helperText: this.helperText ? this.helperText.foundationForTextField : void 0,
      leadingIcon: this.leadingIcon ? this.leadingIcon.foundationForTextField : void 0,
      trailingIcon: this.trailingIcon ? this.trailingIcon.foundationForTextField : void 0
    };
  };
  MDCTextField2.prototype.createRipple = function(rippleFactory) {
    var _this = this;
    var isTextArea = this.root.classList.contains(cssClasses2.TEXTAREA);
    var isOutlined = this.root.classList.contains(cssClasses2.OUTLINED);
    if (isTextArea || isOutlined) {
      return null;
    }
    var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { isSurfaceActive: function() {
      return matches(_this.input, ":active");
    }, registerInteractionHandler: function(evtType, handler) {
      _this.input.addEventListener(evtType, handler, applyPassive());
    }, deregisterInteractionHandler: function(evtType, handler) {
      _this.input.removeEventListener(evtType, handler, applyPassive());
    } });
    return rippleFactory(this.root, new MDCRippleFoundation(adapter));
  };
  return MDCTextField2;
}(MDCComponent);

// node_modules/@smui/textfield/dist/HelperLine.js
var HelperLine_default = classAdderBuilder({
  class: "mdc-text-field-helper-line",
  tag: "div"
});

// node_modules/@smui/textfield/dist/Prefix.js
var Prefix_default = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  tag: "span"
});

// node_modules/@smui/textfield/dist/Suffix.js
var Suffix_default = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  tag: "span"
});

// node_modules/@smui/textfield/dist/Input.svelte
var file = "node_modules/@smui/textfield/dist/Input.svelte";
function create_fragment(ctx) {
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = classMap({
        [ctx[1]]: true,
        "mdc-text-field__input": true
      })
    },
    { type: ctx[2] },
    { placeholder: ctx[3] },
    ctx[4],
    ctx[6],
    ctx[10]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[26](input);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, input, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, input)),
          listen_dev(input, "input", ctx[27], false, false, false),
          listen_dev(input, "change", ctx[9], false, false, false),
          listen_dev(input, "blur", ctx[24], false, false, false),
          listen_dev(input, "focus", ctx[25], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & 2 && input_class_value !== (input_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-text-field__input": true
        })) && { class: input_class_value },
        dirty & 4 && { type: ctx2[2] },
        dirty & 8 && { placeholder: ctx2[3] },
        dirty & 16 && ctx2[4],
        dirty & 64 && ctx2[6],
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function toNumber(value) {
  if (value === "") {
    const nan = new Number(Number.NaN);
    nan.length = 0;
    return nan;
  }
  return +value;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "type",
    "placeholder",
    "value",
    "files",
    "dirty",
    "invalid",
    "updateInvalid",
    "emptyValueNull",
    "emptyValueUndefined",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = " " } = $$props;
  let { value = uninitializedValue } = $$props;
  const valueUninitialized = isUninitializedValue(value);
  if (valueUninitialized) {
    value = "";
  }
  let { files = null } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { emptyValueNull = value === null } = $$props;
  if (valueUninitialized && emptyValueNull) {
    value = null;
  }
  let { emptyValueUndefined = value === void 0 } = $$props;
  if (valueUninitialized && emptyValueUndefined) {
    value = void 0;
  }
  let element2;
  let internalAttrs = {};
  let valueProp = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  });
  function valueUpdater(e) {
    if (type === "file") {
      $$invalidate(12, files = e.currentTarget.files);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueNull) {
      $$invalidate(11, value = null);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueUndefined) {
      $$invalidate(11, value = void 0);
      return;
    }
    switch (type) {
      case "number":
      case "range":
        $$invalidate(11, value = toNumber(e.currentTarget.value));
        break;
      default:
        $$invalidate(11, value = e.currentTarget.value);
        break;
    }
  }
  function changeHandler(e) {
    if (type === "file" || type === "range") {
      valueUpdater(e);
    }
    $$invalidate(13, dirty = true);
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const input_handler = (e) => type !== "file" && valueUpdater(e);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(11, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(12, files = $$new_props.files);
    if ("dirty" in $$new_props)
      $$invalidate(13, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    if ("emptyValueNull" in $$new_props)
      $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    if ("emptyValueUndefined" in $$new_props)
      $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
  };
  $$self.$capture_state = () => ({
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    type,
    placeholder,
    value,
    valueUninitialized,
    files,
    dirty,
    invalid,
    updateInvalid,
    emptyValueNull,
    emptyValueUndefined,
    element: element2,
    internalAttrs,
    valueProp,
    toNumber,
    valueUpdater,
    changeHandler,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$props)
      $$invalidate(11, value = $$new_props.value);
    if ("files" in $$props)
      $$invalidate(12, files = $$new_props.files);
    if ("dirty" in $$props)
      $$invalidate(13, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    if ("emptyValueNull" in $$props)
      $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    if ("emptyValueUndefined" in $$props)
      $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("internalAttrs" in $$props)
      $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    if ("valueProp" in $$props)
      $$invalidate(4, valueProp = $$new_props.valueProp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2068) {
      $:
        if (type === "file") {
          delete valueProp.value;
          $$invalidate(4, valueProp), $$invalidate(2, type), $$invalidate(11, value);
        } else {
          $$invalidate(4, valueProp.value = value == null ? "" : value, valueProp);
        }
    }
  };
  return [
    use,
    className,
    type,
    placeholder,
    valueProp,
    element2,
    internalAttrs,
    forwardEvents,
    valueUpdater,
    changeHandler,
    $$restProps,
    value,
    files,
    dirty,
    invalid,
    updateInvalid,
    emptyValueNull,
    emptyValueUndefined,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    input_binding,
    input_handler
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      use: 0,
      class: 1,
      type: 2,
      placeholder: 3,
      value: 11,
      files: 12,
      dirty: 13,
      invalid: 14,
      updateInvalid: 15,
      emptyValueNull: 16,
      emptyValueUndefined: 17,
      getAttr: 18,
      addAttr: 19,
      removeAttr: 20,
      focus: 21,
      blur: 22,
      getElement: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyValueNull() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyValueNull(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyValueUndefined() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyValueUndefined(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getAttr() {
    return this.$$.ctx[18];
  }
  set getAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addAttr() {
    return this.$$.ctx[19];
  }
  set addAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeAttr() {
    return this.$$.ctx[20];
  }
  set removeAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[21];
  }
  set focus(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[22];
  }
  set blur(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[23];
  }
  set getElement(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@smui/textfield/dist/Textarea.svelte
var file2 = "node_modules/@smui/textfield/dist/Textarea.svelte";
function create_fragment2(ctx) {
  let textarea;
  let textarea_class_value;
  let textarea_style_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = classMap({
        [ctx[2]]: true,
        "mdc-text-field__input": true
      })
    },
    {
      style: textarea_style_value = `${ctx[4] ? "" : "resize: none; "}${ctx[3]}`
    },
    ctx[6],
    ctx[9]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      ctx[21](textarea);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, textarea, ctx[1])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, textarea)),
          listen_dev(textarea, "change", ctx[8], false, false, false),
          listen_dev(textarea, "blur", ctx[19], false, false, false),
          listen_dev(textarea, "focus", ctx[20], false, false, false),
          listen_dev(textarea, "input", ctx[22])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 4 && textarea_class_value !== (textarea_class_value = classMap({
          [ctx2[2]]: true,
          "mdc-text-field__input": true
        })) && { class: textarea_class_value },
        dirty & 24 && textarea_style_value !== (textarea_style_value = `${ctx2[4] ? "" : "resize: none; "}${ctx2[3]}`) && { style: textarea_style_value },
        dirty & 64 && ctx2[6],
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 2)
        useActions_action.update.call(null, ctx2[1]);
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "value",
    "dirty",
    "invalid",
    "updateInvalid",
    "resizable",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { value = "" } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { resizable = true } = $$props;
  let element2;
  let internalAttrs = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  });
  function changeHandler() {
    $$invalidate(10, dirty = true);
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("dirty" in $$new_props)
      $$invalidate(10, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    if ("resizable" in $$new_props)
      $$invalidate(4, resizable = $$new_props.resizable);
  };
  $$self.$capture_state = () => ({
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    style,
    value,
    dirty,
    invalid,
    updateInvalid,
    resizable,
    element: element2,
    internalAttrs,
    changeHandler,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(3, style = $$new_props.style);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("dirty" in $$props)
      $$invalidate(10, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    if ("resizable" in $$props)
      $$invalidate(4, resizable = $$new_props.resizable);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("internalAttrs" in $$props)
      $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    use,
    className,
    style,
    resizable,
    element2,
    internalAttrs,
    forwardEvents,
    changeHandler,
    $$restProps,
    dirty,
    invalid,
    updateInvalid,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    textarea_binding,
    textarea_input_handler
  ];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      value: 0,
      dirty: 10,
      invalid: 11,
      updateInvalid: 12,
      resizable: 4,
      getAttr: 13,
      addAttr: 14,
      removeAttr: 15,
      focus: 16,
      blur: 17,
      getElement: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getAttr() {
    return this.$$.ctx[13];
  }
  set getAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addAttr() {
    return this.$$.ctx[14];
  }
  set addAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeAttr() {
    return this.$$.ctx[15];
  }
  set removeAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[16];
  }
  set focus(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[17];
  }
  set blur(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[18];
  }
  set getElement(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/@smui/textfield/dist/Textfield.svelte
var { Error: Error_1 } = globals;
var file3 = "node_modules/@smui/textfield/dist/Textfield.svelte";
var get_helper_slot_changes = (dirty) => ({});
var get_helper_slot_context = (ctx) => ({});
var get_ripple_slot_changes = (dirty) => ({});
var get_ripple_slot_context = (ctx) => ({});
var get_trailingIcon_slot_changes_1 = (dirty) => ({});
var get_trailingIcon_slot_context_1 = (ctx) => ({});
var get_leadingIcon_slot_changes_1 = (dirty) => ({});
var get_leadingIcon_slot_context_1 = (ctx) => ({});
var get_label_slot_changes_2 = (dirty) => ({});
var get_label_slot_context_2 = (ctx) => ({});
var get_trailingIcon_slot_changes = (dirty) => ({});
var get_trailingIcon_slot_context = (ctx) => ({});
var get_suffix_slot_changes = (dirty) => ({});
var get_suffix_slot_context = (ctx) => ({});
var get_prefix_slot_changes = (dirty) => ({});
var get_prefix_slot_context = (ctx) => ({});
var get_internalCounter_slot_changes = (dirty) => ({});
var get_internalCounter_slot_context = (ctx) => ({});
var get_leadingIcon_slot_changes = (dirty) => ({});
var get_leadingIcon_slot_context = (ctx) => ({});
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let div;
  let t0;
  let contextfragment0;
  let t1;
  let t2;
  let contextfragment1;
  let t3;
  let div_class_value;
  let div_style_value;
  let Ripple_action;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_2);
  contextfragment0 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  contextfragment1 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const ripple_slot_template = ctx[51].ripple;
  const ripple_slot = create_slot(ripple_slot_template, ctx, ctx[90], get_ripple_slot_context);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || !ctx[42].label,
        "mdc-text-field--with-leading-icon": ctx[42].leadingIcon,
        "mdc-text-field--with-trailing-icon": ctx[42].trailingIcon,
        "mdc-text-field--invalid": ctx[1],
        ...ctx[25]
      })
    },
    {
      style: div_style_value = Object.entries(ctx[26]).map(func_1).concat([ctx[10]]).join(" ")
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      create_component(contextfragment0.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(contextfragment1.$$.fragment);
      t3 = space();
      if (ripple_slot)
        ripple_slot.c();
      set_attributes(div, div_data);
      add_location(div, file3, 163, 2, 5417);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (label_slot) {
        label_slot.m(div, null);
      }
      append_dev(div, t0);
      mount_component(contextfragment0, div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t2);
      mount_component(contextfragment1, div, null);
      append_dev(div, t3);
      if (ripple_slot) {
        ripple_slot.m(div, null);
      }
      ctx[80](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = dist_default.call(null, div, {
            ripple: ctx[11],
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40]
          })),
          action_destroyer(useActions_action = useActions.call(null, div, ctx[8])),
          action_destroyer(forwardEvents_action = ctx[34].call(null, div)),
          listen_dev(div, "SMUITextfieldLeadingIcon:mount", ctx[81], false, false, false),
          listen_dev(div, "SMUITextfieldLeadingIcon:unmount", ctx[82], false, false, false),
          listen_dev(div, "SMUITextfieldTrailingIcon:mount", ctx[83], false, false, false),
          listen_dev(div, "SMUITextfieldTrailingIcon:unmount", ctx[84], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_2),
            get_label_slot_context_2
          );
        }
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null),
            null
          );
        }
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (ripple_slot) {
        if (ripple_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            ripple_slot,
            ripple_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(ripple_slot_template, ctx2[90], dirty, get_ripple_slot_changes),
            get_ripple_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & 33673730 | dirty[1] & 2048 && div_class_value !== (div_class_value = classMap({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || !ctx2[42].label,
          "mdc-text-field--with-leading-icon": ctx2[42].leadingIcon,
          "mdc-text-field--with-trailing-icon": ctx2[42].trailingIcon,
          "mdc-text-field--invalid": ctx2[1],
          ...ctx2[25]
        }))) && { class: div_class_value },
        (!current || dirty[0] & 67109888 && div_style_value !== (div_style_value = Object.entries(ctx2[26]).map(func_1).concat([ctx2[10]]).join(" "))) && { style: div_style_value },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 2048)
        Ripple_action.update.call(null, {
          ripple: ctx2[11],
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(ripple_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(ripple_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (label_slot)
        label_slot.d(detaching);
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(contextfragment1);
      if (ripple_slot)
        ripple_slot.d(detaching);
      ctx[80](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(163:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let label_1;
  let t0;
  let t1;
  let contextfragment0;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let contextfragment1;
  let t5;
  let label_1_class_value;
  let label_1_style_value;
  let Ripple_action;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[14] && ctx[15] !== "outlined" && create_if_block_8(ctx);
  let if_block1 = (ctx[14] || ctx[15] === "outlined") && create_if_block_6(ctx);
  contextfragment0 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  const if_block_creators = [create_if_block_3, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[14] && typeof ctx2[0] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  contextfragment1 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block3 = !ctx[14] && ctx[15] !== "outlined" && ctx[11] && create_if_block_2(ctx);
  let label_1_levels = [
    {
      class: label_1_class_value = classMap({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || ctx[17] == null && !ctx[42].label,
        "mdc-text-field--label-floating": ctx[28] || ctx[0] != null && ctx[0] !== "",
        "mdc-text-field--with-leading-icon": ctx[35](ctx[22]) ? ctx[42].leadingIcon : ctx[22],
        "mdc-text-field--with-trailing-icon": ctx[35](ctx[23]) ? ctx[42].trailingIcon : ctx[23],
        "mdc-text-field--with-internal-counter": ctx[14] && ctx[42].internalCounter,
        "mdc-text-field--invalid": ctx[1],
        ...ctx[25]
      })
    },
    {
      style: label_1_style_value = Object.entries(ctx[26]).map(func).concat([ctx[10]]).join(" ")
    },
    {
      for: void 0
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let label_1_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_1_data = assign(label_1_data, label_1_levels[i]);
  }
  const block = {
    c: function create() {
      label_1 = element("label");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(contextfragment0.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      create_component(contextfragment1.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      set_attributes(label_1, label_1_data);
      add_location(label_1, file3, 1, 2, 15);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (if_block0)
        if_block0.m(label_1, null);
      append_dev(label_1, t0);
      if (if_block1)
        if_block1.m(label_1, null);
      append_dev(label_1, t1);
      mount_component(contextfragment0, label_1, null);
      append_dev(label_1, t2);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      append_dev(label_1, t3);
      if_blocks[current_block_type_index].m(label_1, null);
      append_dev(label_1, t4);
      mount_component(contextfragment1, label_1, null);
      append_dev(label_1, t5);
      if (if_block3)
        if_block3.m(label_1, null);
      ctx[73](label_1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = dist_default.call(null, label_1, {
            ripple: !ctx[14] && ctx[15] === "filled",
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40],
            eventTarget: ctx[33],
            activeTarget: ctx[33],
            initPromise: ctx[37]
          })),
          action_destroyer(useActions_action = useActions.call(null, label_1, ctx[8])),
          action_destroyer(forwardEvents_action = ctx[34].call(null, label_1)),
          listen_dev(label_1, "SMUITextfieldLeadingIcon:mount", ctx[74], false, false, false),
          listen_dev(label_1, "SMUITextfieldLeadingIcon:unmount", ctx[75], false, false, false),
          listen_dev(label_1, "SMUITextfieldTrailingIcon:mount", ctx[76], false, false, false),
          listen_dev(label_1, "SMUITextfieldTrailingIcon:unmount", ctx[77], false, false, false),
          listen_dev(label_1, "SMUITextfieldCharacterCounter:mount", ctx[78], false, false, false),
          listen_dev(label_1, "SMUITextfieldCharacterCounter:unmount", ctx[79], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[14] && ctx2[15] !== "outlined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label_1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[14] || ctx2[15] === "outlined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label_1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null),
            null
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(label_1, t4);
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (!ctx2[14] && ctx2[15] !== "outlined" && ctx2[11]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 51200) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(label_1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
        (!current || dirty[0] & 314823171 | dirty[1] & 2048 && label_1_class_value !== (label_1_class_value = classMap({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || ctx2[17] == null && !ctx2[42].label,
          "mdc-text-field--label-floating": ctx2[28] || ctx2[0] != null && ctx2[0] !== "",
          "mdc-text-field--with-leading-icon": ctx2[35](ctx2[22]) ? ctx2[42].leadingIcon : ctx2[22],
          "mdc-text-field--with-trailing-icon": ctx2[35](ctx2[23]) ? ctx2[42].trailingIcon : ctx2[23],
          "mdc-text-field--with-internal-counter": ctx2[14] && ctx2[42].internalCounter,
          "mdc-text-field--invalid": ctx2[1],
          ...ctx2[25]
        }))) && { class: label_1_class_value },
        (!current || dirty[0] & 67109888 && label_1_style_value !== (label_1_style_value = Object.entries(ctx2[26]).map(func).concat([ctx2[10]]).join(" "))) && { style: label_1_style_value },
        {
          for: void 0
        },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 49152 | dirty[1] & 4)
        Ripple_action.update.call(null, {
          ripple: !ctx2[14] && ctx2[15] === "filled",
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40],
          eventTarget: ctx2[33],
          activeTarget: ctx2[33],
          initPromise: ctx2[37]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(contextfragment1);
      if (if_block3)
        if_block3.d();
      ctx[73](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(1:0) {#if valued}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context_1);
  const block = {
    c: function create() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    m: function mount(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes_1),
            get_leadingIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: '(207:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context_1);
  const block = {
    c: function create() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    m: function mount(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            trailingIcon_slot,
            trailingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes_1),
            get_trailingIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: '(211:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[15] === "filled" && create_if_block_10(ctx);
  let if_block1 = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_9(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[15] === "filled") {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(62:4) {#if !textarea && variant !== 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "mdc-text-field__ripple");
      add_location(span, file3, 63, 8, 2241);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(63:6) {#if variant === 'filled'}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default2({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[52](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[52](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(66:6) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(67:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let notchedoutline;
  let current;
  const notchedoutline_spread_levels = [
    {
      noLabel: ctx[16] || ctx[17] == null && !ctx[42].label
    },
    prefixFilter(ctx[41], "outline$")
  ];
  let notchedoutline_props = {
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
  }
  notchedoutline = new dist_default4({
    props: notchedoutline_props,
    $$inline: true
  });
  ctx[54](notchedoutline);
  const block = {
    c: function create() {
      create_component(notchedoutline.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notchedoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notchedoutline_changes = dirty[0] & 196608 | dirty[1] & 3072 ? get_spread_update(notchedoutline_spread_levels, [
        dirty[0] & 196608 | dirty[1] & 2048 && {
          noLabel: ctx2[16] || ctx2[17] == null && !ctx2[42].label
        },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "outline$"))
      ]) : {};
      if (dirty[0] & 268640289 | dirty[1] & 3072 | dirty[2] & 268435456) {
        notchedoutline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notchedoutline.$set(notchedoutline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notchedoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notchedoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[54](null);
      destroy_component(notchedoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(77:4) {#if textarea || variant === 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default2({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[53](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[53](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(83:8) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_1);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(84:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_7(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(78:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context);
  const block = {
    c: function create() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    m: function mount(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes),
            get_leadingIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(95:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let t0;
  let t1;
  let input_1;
  let updating_value;
  let updating_files;
  let updating_dirty;
  let updating_invalid;
  let t2;
  let t3;
  let current;
  const prefix_slot_template = ctx[51].prefix;
  const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[90], get_prefix_slot_context);
  let if_block0 = ctx[20] != null && create_if_block_5(ctx);
  const input_1_spread_levels = [
    { type: ctx[18] },
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    ctx[16] && ctx[17] != null ? { placeholder: ctx[17] } : {},
    prefixFilter(ctx[41], "input$")
  ];
  function input_1_value_binding(value) {
    ctx[64](value);
  }
  function input_1_files_binding(value) {
    ctx[65](value);
  }
  function input_1_dirty_binding(value) {
    ctx[66](value);
  }
  function input_1_invalid_binding(value) {
    ctx[67](value);
  }
  let input_1_props = {};
  for (let i = 0; i < input_1_spread_levels.length; i += 1) {
    input_1_props = assign(input_1_props, input_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    input_1_props.value = ctx[0];
  }
  if (ctx[3] !== void 0) {
    input_1_props.files = ctx[3];
  }
  if (ctx[4] !== void 0) {
    input_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    input_1_props.invalid = ctx[1];
  }
  input_1 = new Input_default({ props: input_1_props, $$inline: true });
  ctx[63](input_1);
  binding_callbacks.push(() => bind(input_1, "value", input_1_value_binding));
  binding_callbacks.push(() => bind(input_1, "files", input_1_files_binding));
  binding_callbacks.push(() => bind(input_1, "dirty", input_1_dirty_binding));
  binding_callbacks.push(() => bind(input_1, "invalid", input_1_invalid_binding));
  input_1.$on("blur", ctx[68]);
  input_1.$on("focus", ctx[69]);
  input_1.$on("blur", ctx[70]);
  input_1.$on("focus", ctx[71]);
  let if_block1 = ctx[21] != null && create_if_block_4(ctx);
  const suffix_slot_template = ctx[51].suffix;
  const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[90], get_suffix_slot_context);
  const block = {
    c: function create() {
      if (prefix_slot)
        prefix_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(input_1.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (suffix_slot)
        suffix_slot.c();
    },
    m: function mount(target, anchor) {
      if (prefix_slot) {
        prefix_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(input_1, target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t3, anchor);
      if (suffix_slot) {
        suffix_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (prefix_slot) {
        if (prefix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            prefix_slot,
            prefix_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(prefix_slot_template, ctx2[90], dirty, get_prefix_slot_changes),
            get_prefix_slot_context
          );
        }
      }
      if (ctx2[20] != null) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1048576) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const input_1_changes = dirty[0] & 135213056 | dirty[1] & 1024 ? get_spread_update(input_1_spread_levels, [
        dirty[0] & 262144 && { type: ctx2[18] },
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[0] & 196608 && get_spread_object(ctx2[16] && ctx2[17] != null ? { placeholder: ctx2[17] } : {}),
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        input_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_files && dirty[0] & 8) {
        updating_files = true;
        input_1_changes.files = ctx2[3];
        add_flush_callback(() => updating_files = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        input_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        input_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      input_1.$set(input_1_changes);
      if (ctx2[21] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2097152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (suffix_slot) {
        if (suffix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            suffix_slot,
            suffix_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(suffix_slot_template, ctx2[90], dirty, get_suffix_slot_changes),
            get_suffix_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prefix_slot, local);
      transition_in(if_block0);
      transition_in(input_1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(suffix_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prefix_slot, local);
      transition_out(if_block0);
      transition_out(input_1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(suffix_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (prefix_slot)
        prefix_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      ctx[63](null);
      destroy_component(input_1, detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (suffix_slot)
        suffix_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(124:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let textarea_1;
  let updating_value;
  let updating_dirty;
  let updating_invalid;
  let t;
  let span_class_value;
  let current;
  const textarea_1_spread_levels = [
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    prefixFilter(ctx[41], "input$")
  ];
  function textarea_1_value_binding(value) {
    ctx[56](value);
  }
  function textarea_1_dirty_binding(value) {
    ctx[57](value);
  }
  function textarea_1_invalid_binding(value) {
    ctx[58](value);
  }
  let textarea_1_props = {};
  for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
    textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    textarea_1_props.value = ctx[0];
  }
  if (ctx[4] !== void 0) {
    textarea_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    textarea_1_props.invalid = ctx[1];
  }
  textarea_1 = new Textarea_default({ props: textarea_1_props, $$inline: true });
  ctx[55](textarea_1);
  binding_callbacks.push(() => bind(textarea_1, "value", textarea_1_value_binding));
  binding_callbacks.push(() => bind(textarea_1, "dirty", textarea_1_dirty_binding));
  binding_callbacks.push(() => bind(textarea_1, "invalid", textarea_1_invalid_binding));
  textarea_1.$on("blur", ctx[59]);
  textarea_1.$on("focus", ctx[60]);
  textarea_1.$on("blur", ctx[61]);
  textarea_1.$on("focus", ctx[62]);
  const internalCounter_slot_template = ctx[51].internalCounter;
  const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, ctx[90], get_internalCounter_slot_context);
  const block = {
    c: function create() {
      span = element("span");
      create_component(textarea_1.$$.fragment);
      t = space();
      if (internalCounter_slot)
        internalCounter_slot.c();
      attr_dev(span, "class", span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx[41]) || ctx[41].input$resizable
      }));
      add_location(span, file3, 99, 6, 3514);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      mount_component(textarea_1, span, null);
      append_dev(span, t);
      if (internalCounter_slot) {
        internalCounter_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textarea_1_changes = dirty[0] & 134754304 | dirty[1] & 1024 ? get_spread_update(textarea_1_spread_levels, [
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        textarea_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        textarea_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        textarea_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      textarea_1.$set(textarea_1_changes);
      if (internalCounter_slot) {
        if (internalCounter_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            internalCounter_slot,
            internalCounter_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(internalCounter_slot_template, ctx2[90], dirty, get_internalCounter_slot_changes),
            get_internalCounter_slot_context
          );
        }
      }
      if (!current || dirty[1] & 1024 && span_class_value !== (span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx2[41]) || ctx2[41].input$resizable
      }))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textarea_1.$$.fragment, local);
      transition_in(internalCounter_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textarea_1.$$.fragment, local);
      transition_out(internalCounter_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      ctx[55](null);
      destroy_component(textarea_1);
      if (internalCounter_slot)
        internalCounter_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(99:4) {#if textarea && typeof value === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let prefix_1;
  let current;
  prefix_1 = new Prefix_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prefix_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(prefix_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prefix_1_changes = {};
      if (dirty[0] & 1048576 | dirty[2] & 268435456) {
        prefix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      prefix_1.$set(prefix_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prefix_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prefix_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prefix_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(126:6) {#if prefix != null}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[20]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1048576)
        set_data_dev(t, ctx2[20]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(127:8) <Prefix>",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let suffix_1;
  let current;
  suffix_1 = new Suffix_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(suffix_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(suffix_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const suffix_1_changes = {};
      if (dirty[0] & 2097152 | dirty[2] & 268435456) {
        suffix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suffix_1.$set(suffix_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(suffix_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(suffix_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(suffix_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(148:6) {#if suffix != null}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[21]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2097152)
        set_data_dev(t, ctx2[21]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(149:8) <Suffix>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context);
  const block = {
    c: function create() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    m: function mount(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            trailingIcon_slot,
            trailingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes),
            get_trailingIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(153:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let lineripple;
  let current;
  const lineripple_spread_levels = [prefixFilter(ctx[41], "ripple$")];
  let lineripple_props = {};
  for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
  }
  lineripple = new dist_default3({ props: lineripple_props, $$inline: true });
  ctx[72](lineripple);
  const block = {
    c: function create() {
      create_component(lineripple.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(lineripple, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineripple_changes = dirty[1] & 1024 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "ripple$"))]) : {};
      lineripple.$set(lineripple_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineripple.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineripple.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[72](null);
      destroy_component(lineripple, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(156:4) {#if !textarea && variant !== 'outlined' && ripple}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let helperline;
  let current;
  const helperline_spread_levels = [prefixFilter(ctx[41], "helperLine$")];
  let helperline_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < helperline_spread_levels.length; i += 1) {
    helperline_props = assign(helperline_props, helperline_spread_levels[i]);
  }
  helperline = new HelperLine_default({ props: helperline_props, $$inline: true });
  helperline.$on("SMUITextfieldHelperText:id", ctx[85]);
  helperline.$on("SMUITextfieldHelperText:mount", ctx[86]);
  helperline.$on("SMUITextfieldHelperText:unmount", ctx[87]);
  helperline.$on("SMUITextfieldCharacterCounter:mount", ctx[88]);
  helperline.$on("SMUITextfieldCharacterCounter:unmount", ctx[89]);
  const block = {
    c: function create() {
      create_component(helperline.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(helperline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const helperline_changes = dirty[1] & 1024 ? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "helperLine$"))]) : {};
      if (dirty[2] & 268435456) {
        helperline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helperline.$set(helperline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helperline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helperline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(helperline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(217:0) {#if $$slots.helper}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const helper_slot_template = ctx[51].helper;
  const helper_slot = create_slot(helper_slot_template, ctx, ctx[90], get_helper_slot_context);
  const block = {
    c: function create() {
      if (helper_slot)
        helper_slot.c();
    },
    m: function mount(target, anchor) {
      if (helper_slot) {
        helper_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (helper_slot) {
        if (helper_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            helper_slot,
            helper_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(helper_slot_template, ctx2[90], dirty, get_helper_slot_changes),
            get_helper_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helper_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helper_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (helper_slot)
        helper_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(218:2) <HelperLine     on:SMUITextfieldHelperText:id={(event) => (helperId = event.detail)}     on:SMUITextfieldHelperText:mount={(event) => (helperText = event.detail)}     on:SMUITextfieldHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUITextfieldCharacterCounter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUITextfieldCharacterCounter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[36])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[42].helper && create_if_block(ctx);
  const block = {
    c: function create() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[42].helper) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  let inputElement;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "required",
    "textarea",
    "variant",
    "noLabel",
    "label",
    "type",
    "value",
    "files",
    "invalid",
    "updateInvalid",
    "dirty",
    "prefix",
    "suffix",
    "validateOnValueChange",
    "useNativeValidation",
    "withLeadingIcon",
    "withTrailingIcon",
    "input",
    "floatingLabel",
    "lineRipple",
    "notchedOutline",
    "focus",
    "blur",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textfield", slots, [
    "label",
    "leadingIcon",
    "default",
    "internalCounter",
    "prefix",
    "suffix",
    "trailingIcon",
    "ripple",
    "helper"
  ]);
  const $$slots = compute_slots(slots);
  const { applyPassive: applyPassive2 } = events_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { textarea = false } = $$props;
  let { variant = textarea ? "outlined" : "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { value = $$restProps.input$emptyValueUndefined ? void 0 : uninitializedValue } = $$props;
  let { files = uninitializedValue } = $$props;
  const valued = !isUninitializedValue(value) || !isUninitializedValue(files);
  if (isUninitializedValue(value)) {
    value = void 0;
  }
  if (isUninitializedValue(files)) {
    files = null;
  }
  let { invalid = uninitializedValue } = $$props;
  let { updateInvalid = isUninitializedValue(invalid) } = $$props;
  if (isUninitializedValue(invalid)) {
    invalid = false;
  }
  let { dirty = false } = $$props;
  let { prefix = void 0 } = $$props;
  let { suffix = void 0 } = $$props;
  let { validateOnValueChange = updateInvalid } = $$props;
  let { useNativeValidation = updateInvalid } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { withTrailingIcon = uninitializedValue } = $$props;
  let { input = void 0 } = $$props;
  let { floatingLabel = void 0 } = $$props;
  let { lineRipple = void 0 } = $$props;
  let { notchedOutline = void 0 } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let internalStyles = {};
  let helperId = void 0;
  let focused = false;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let initPromiseResolve;
  let initPromise = new Promise((resolve) => initPromiseResolve = resolve);
  let leadingIcon = void 0;
  let trailingIcon = void 0;
  let helperText = void 0;
  let characterCounter = void 0;
  let previousValue = value;
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(49, instance3 = new MDCTextFieldFoundation(
      {
        addClass,
        removeClass,
        hasClass,
        registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
        registerValidationAttributeChangeHandler: (handler) => {
          const getAttributesList = (mutationsList) => {
            return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
          };
          const observer = new MutationObserver((mutationsList) => {
            if (useNativeValidation) {
              handler(getAttributesList(mutationsList));
            }
          });
          const config = { attributes: true };
          if (input) {
            observer.observe(input.getElement(), config);
          }
          return observer;
        },
        deregisterValidationAttributeChangeHandler: (observer) => {
          observer.disconnect();
        },
        getNativeInput: () => {
          var _a;
          return (_a = input === null || input === void 0 ? void 0 : input.getElement()) !== null && _a !== void 0 ? _a : null;
        },
        setInputAttr: (name, value2) => {
          input === null || input === void 0 ? void 0 : input.addAttr(name, value2);
        },
        removeInputAttr: (name) => {
          input === null || input === void 0 ? void 0 : input.removeAttr(name);
        },
        isFocused: () => document.activeElement === (input === null || input === void 0 ? void 0 : input.getElement()),
        registerInputInteractionHandler: (evtType, handler) => {
          input === null || input === void 0 ? void 0 : input.getElement().addEventListener(evtType, handler, applyPassive2());
        },
        deregisterInputInteractionHandler: (evtType, handler) => {
          input === null || input === void 0 ? void 0 : input.getElement().removeEventListener(evtType, handler, applyPassive2());
        },
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        hasLabel: () => !!floatingLabel,
        shakeLabel: (shouldShake) => floatingLabel && floatingLabel.shake(shouldShake),
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired),
        activateLineRipple: () => lineRipple && lineRipple.activate(),
        deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
        setLineRippleTransformOrigin: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth)
      },
      {
        get helperText() {
          return helperText;
        },
        get characterCounter() {
          return characterCounter;
        },
        get leadingIcon() {
          return leadingIcon;
        },
        get trailingIcon() {
          return trailingIcon;
        }
      }
    ));
    if (valued) {
      if (input == null) {
        throw new Error("SMUI Textfield initialized without Input component.");
      }
      instance3.init();
    } else {
      tick().then(() => {
        if (input == null) {
          throw new Error("SMUI Textfield initialized without Input component.");
        }
        instance3.init();
      });
    }
    initPromiseResolve();
    return () => {
      instance3.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    var _a;
    return className2 in internalClasses ? (_a = internalClasses[className2]) !== null && _a !== void 0 ? _a : null : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(26, internalStyles);
      } else {
        $$invalidate(26, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function focus() {
    input === null || input === void 0 ? void 0 : input.focus();
  }
  function blur() {
    input === null || input === void 0 ? void 0 : input.blur();
  }
  function layout() {
    if (instance3) {
      const openNotch = instance3.shouldFloat;
      instance3.notchOutline(openNotch);
    }
  }
  function getElement() {
    return element2;
  }
  function floatinglabel_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function floatinglabel_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function notchedoutline_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      notchedOutline = $$value;
      $$invalidate(7, notchedOutline);
    });
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function textarea_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textarea_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function textarea_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance3), $$invalidate(19, updateInvalid);
  }
  const blur_handler = () => $$invalidate(28, focused = false);
  const focus_handler = () => $$invalidate(28, focused = true);
  const blur_handler_1 = (event) => dispatch(element2, "blur", event);
  const focus_handler_1 = (event) => dispatch(element2, "focus", event);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function input_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function input_1_files_binding(value2) {
    files = value2;
    $$invalidate(3, files);
  }
  function input_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function input_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance3), $$invalidate(19, updateInvalid);
  }
  const blur_handler_2 = () => $$invalidate(28, focused = false);
  const focus_handler_2 = () => $$invalidate(28, focused = true);
  const blur_handler_3 = (event) => dispatch(element2, "blur", event);
  const focus_handler_3 = (event) => dispatch(element2, "focus", event);
  function lineripple_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      lineRipple = $$value;
      $$invalidate(6, lineRipple);
    });
  }
  function label_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldCharacterCounter_mount_handler = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler = () => $$invalidate(32, characterCounter = void 0);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler_1 = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler_1 = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler_1 = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler_1 = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldHelperText_id_handler = (event) => $$invalidate(27, helperId = event.detail);
  const SMUITextfieldHelperText_mount_handler = (event) => $$invalidate(31, helperText = event.detail);
  const SMUITextfieldHelperText_unmount_handler = () => {
    $$invalidate(27, helperId = void 0);
    $$invalidate(31, helperText = void 0);
  };
  const SMUITextfieldCharacterCounter_mount_handler_1 = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler_1 = () => $$invalidate(32, characterCounter = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(41, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(8, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(10, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(11, ripple = $$new_props.ripple);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(13, required = $$new_props.required);
    if ("textarea" in $$new_props)
      $$invalidate(14, textarea = $$new_props.textarea);
    if ("variant" in $$new_props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("noLabel" in $$new_props)
      $$invalidate(16, noLabel = $$new_props.noLabel);
    if ("label" in $$new_props)
      $$invalidate(17, label = $$new_props.label);
    if ("type" in $$new_props)
      $$invalidate(18, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    if ("dirty" in $$new_props)
      $$invalidate(4, dirty = $$new_props.dirty);
    if ("prefix" in $$new_props)
      $$invalidate(20, prefix = $$new_props.prefix);
    if ("suffix" in $$new_props)
      $$invalidate(21, suffix = $$new_props.suffix);
    if ("validateOnValueChange" in $$new_props)
      $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    if ("useNativeValidation" in $$new_props)
      $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    if ("withLeadingIcon" in $$new_props)
      $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("withTrailingIcon" in $$new_props)
      $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    if ("input" in $$new_props)
      $$invalidate(2, input = $$new_props.input);
    if ("floatingLabel" in $$new_props)
      $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$new_props)
      $$invalidate(6, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$new_props)
      $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    if ("$$scope" in $$new_props)
      $$invalidate(90, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTextFieldFoundation,
    events: events_exports,
    onMount,
    onDestroy,
    getContext,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    ContextFragment: ContextFragment_default,
    Ripple: dist_default,
    FloatingLabel: dist_default2,
    LineRipple: dist_default3,
    NotchedOutline: dist_default4,
    HelperLine: HelperLine_default,
    Prefix: Prefix_default,
    Suffix: Suffix_default,
    Input: Input_default,
    Textarea: Textarea_default,
    applyPassive: applyPassive2,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    ripple,
    disabled,
    required,
    textarea,
    variant,
    noLabel,
    label,
    type,
    value,
    files,
    valued,
    invalid,
    updateInvalid,
    dirty,
    prefix,
    suffix,
    validateOnValueChange,
    useNativeValidation,
    withLeadingIcon,
    withTrailingIcon,
    input,
    floatingLabel,
    lineRipple,
    notchedOutline,
    element: element2,
    instance: instance3,
    internalClasses,
    internalStyles,
    helperId,
    focused,
    addLayoutListener,
    removeLayoutListener,
    initPromiseResolve,
    initPromise,
    leadingIcon,
    trailingIcon,
    helperText,
    characterCounter,
    previousValue,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    focus,
    blur,
    layout,
    getElement,
    inputElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(8, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(10, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(11, ripple = $$new_props.ripple);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(13, required = $$new_props.required);
    if ("textarea" in $$props)
      $$invalidate(14, textarea = $$new_props.textarea);
    if ("variant" in $$props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("noLabel" in $$props)
      $$invalidate(16, noLabel = $$new_props.noLabel);
    if ("label" in $$props)
      $$invalidate(17, label = $$new_props.label);
    if ("type" in $$props)
      $$invalidate(18, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("files" in $$props)
      $$invalidate(3, files = $$new_props.files);
    if ("invalid" in $$props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    if ("dirty" in $$props)
      $$invalidate(4, dirty = $$new_props.dirty);
    if ("prefix" in $$props)
      $$invalidate(20, prefix = $$new_props.prefix);
    if ("suffix" in $$props)
      $$invalidate(21, suffix = $$new_props.suffix);
    if ("validateOnValueChange" in $$props)
      $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    if ("useNativeValidation" in $$props)
      $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    if ("withLeadingIcon" in $$props)
      $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("withTrailingIcon" in $$props)
      $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    if ("input" in $$props)
      $$invalidate(2, input = $$new_props.input);
    if ("floatingLabel" in $$props)
      $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$props)
      $$invalidate(6, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$props)
      $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    if ("element" in $$props)
      $$invalidate(24, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(49, instance3 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(25, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(26, internalStyles = $$new_props.internalStyles);
    if ("helperId" in $$props)
      $$invalidate(27, helperId = $$new_props.helperId);
    if ("focused" in $$props)
      $$invalidate(28, focused = $$new_props.focused);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("initPromiseResolve" in $$props)
      initPromiseResolve = $$new_props.initPromiseResolve;
    if ("initPromise" in $$props)
      $$invalidate(37, initPromise = $$new_props.initPromise);
    if ("leadingIcon" in $$props)
      $$invalidate(29, leadingIcon = $$new_props.leadingIcon);
    if ("trailingIcon" in $$props)
      $$invalidate(30, trailingIcon = $$new_props.trailingIcon);
    if ("helperText" in $$props)
      $$invalidate(31, helperText = $$new_props.helperText);
    if ("characterCounter" in $$props)
      $$invalidate(32, characterCounter = $$new_props.characterCounter);
    if ("previousValue" in $$props)
      $$invalidate(50, previousValue = $$new_props.previousValue);
    if ("inputElement" in $$props)
      $$invalidate(33, inputElement = $$new_props.inputElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4) {
      $:
        $$invalidate(33, inputElement = input && input.getElement());
    }
    if ($$self.$$.dirty[0] & 524290 | $$self.$$.dirty[1] & 262144) {
      $:
        if (instance3 && instance3.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance3.isValid());
          } else {
            instance3.setValid(!invalid);
          }
        }
    }
    if ($$self.$$.dirty[1] & 266240) {
      $:
        if (instance3 && instance3.getValidateOnValueChange() !== validateOnValueChange) {
          instance3.setValidateOnValueChange(isUninitializedValue(validateOnValueChange) ? false : validateOnValueChange);
        }
    }
    if ($$self.$$.dirty[1] & 270336) {
      $:
        if (instance3) {
          instance3.setUseNativeValidation(isUninitializedValue(useNativeValidation) ? true : useNativeValidation);
        }
    }
    if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 262144) {
      $:
        if (instance3) {
          instance3.setDisabled(disabled);
        }
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 786432) {
      $:
        if (instance3 && valued && previousValue !== value) {
          $$invalidate(50, previousValue = value);
          const stringValue = `${value}`;
          if (instance3.getValue() !== stringValue) {
            instance3.setValue(stringValue);
          }
        }
    }
  };
  return [
    value,
    invalid,
    input,
    files,
    dirty,
    floatingLabel,
    lineRipple,
    notchedOutline,
    use,
    className,
    style,
    ripple,
    disabled,
    required,
    textarea,
    variant,
    noLabel,
    label,
    type,
    updateInvalid,
    prefix,
    suffix,
    withLeadingIcon,
    withTrailingIcon,
    element2,
    internalClasses,
    internalStyles,
    helperId,
    focused,
    leadingIcon,
    trailingIcon,
    helperText,
    characterCounter,
    inputElement,
    forwardEvents,
    isUninitializedValue,
    valued,
    initPromise,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    $$slots,
    validateOnValueChange,
    useNativeValidation,
    focus,
    blur,
    layout,
    getElement,
    instance3,
    previousValue,
    slots,
    floatinglabel_binding,
    floatinglabel_binding_1,
    notchedoutline_binding,
    textarea_1_binding,
    textarea_1_value_binding,
    textarea_1_dirty_binding,
    textarea_1_invalid_binding,
    blur_handler,
    focus_handler,
    blur_handler_1,
    focus_handler_1,
    input_1_binding,
    input_1_value_binding,
    input_1_files_binding,
    input_1_dirty_binding,
    input_1_invalid_binding,
    blur_handler_2,
    focus_handler_2,
    blur_handler_3,
    focus_handler_3,
    lineripple_binding,
    label_1_binding,
    SMUITextfieldLeadingIcon_mount_handler,
    SMUITextfieldLeadingIcon_unmount_handler,
    SMUITextfieldTrailingIcon_mount_handler,
    SMUITextfieldTrailingIcon_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler,
    SMUITextfieldCharacterCounter_unmount_handler,
    div_binding,
    SMUITextfieldLeadingIcon_mount_handler_1,
    SMUITextfieldLeadingIcon_unmount_handler_1,
    SMUITextfieldTrailingIcon_mount_handler_1,
    SMUITextfieldTrailingIcon_unmount_handler_1,
    SMUITextfieldHelperText_id_handler,
    SMUITextfieldHelperText_mount_handler,
    SMUITextfieldHelperText_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler_1,
    SMUITextfieldCharacterCounter_unmount_handler_1,
    $$scope
  ];
}
var Textfield = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment3,
      safe_not_equal,
      {
        use: 8,
        class: 9,
        style: 10,
        ripple: 11,
        disabled: 12,
        required: 13,
        textarea: 14,
        variant: 15,
        noLabel: 16,
        label: 17,
        type: 18,
        value: 0,
        files: 3,
        invalid: 1,
        updateInvalid: 19,
        dirty: 4,
        prefix: 20,
        suffix: 21,
        validateOnValueChange: 43,
        useNativeValidation: 44,
        withLeadingIcon: 22,
        withTrailingIcon: 23,
        input: 2,
        floatingLabel: 5,
        lineRipple: 6,
        notchedOutline: 7,
        focus: 45,
        blur: 46,
        layout: 47,
        getElement: 48
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textfield",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textarea() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textarea(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get suffix() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set suffix(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateOnValueChange() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateOnValueChange(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useNativeValidation() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useNativeValidation(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withLeadingIcon() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withLeadingIcon(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withTrailingIcon() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withTrailingIcon(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingLabel() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingLabel(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineRipple() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineRipple(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notchedOutline() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notchedOutline(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[45];
  }
  set focus(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[46];
  }
  set blur(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[47];
  }
  set layout(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[48];
  }
  set getElement(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textfield_default = Textfield;

// node_modules/@smui/textfield/dist/index.js
var dist_default5 = Textfield_default;
export {
  HelperLine_default as HelperLine,
  Input_default as Input,
  Prefix_default as Prefix,
  Suffix_default as Suffix,
  Textarea_default as Textarea,
  dist_default5 as default
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@smui_textfield.js.map
