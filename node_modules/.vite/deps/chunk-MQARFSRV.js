import {
  classAdderBuilder
} from "./chunk-HQIZ4DBT.js";
import {
  SmuiElement_default
} from "./chunk-ZSIG2HMK.js";
import {
  MDCComponent,
  MDCFoundation,
  classMap,
  closest,
  dispatch,
  dist_default,
  forwardEventsBuilder,
  matches,
  normalizeKey,
  ponyfill_exports,
  useActions
} from "./chunk-QH7DRB7N.js";
import {
  __assign,
  __extends,
  __read,
  __spreadArray
} from "./chunk-3L2CPHNC.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  is_function,
  mount_component,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-NLMIYH64.js";

// node_modules/@material/list/constants.js
var _a;
var _b;
var cssClasses = {
  LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
  LIST_ITEM_CLASS: "mdc-list-item",
  LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
  LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
  LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
  LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
  ROOT: "mdc-list"
};
var evolutionClassNameMap = (_a = {}, _a["" + cssClasses.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses.ROOT] = "mdc-list", _a);
var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b["" + cssClasses.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b["" + cssClasses.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b["" + cssClasses.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b["" + cssClasses.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b["" + cssClasses.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b["" + cssClasses.ROOT] = "mdc-deprecated-list", _b);
var strings = {
  ACTION_EVENT: "MDCList:action",
  SELECTION_CHANGE_EVENT: "MDCList:selectionChange",
  ARIA_CHECKED: "aria-checked",
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_CURRENT: "aria-current",
  ARIA_DISABLED: "aria-disabled",
  ARIA_ORIENTATION: "aria-orientation",
  ARIA_ORIENTATION_HORIZONTAL: "horizontal",
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_SELECTED: "aria-selected",
  ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
  ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + " a\n  ",
  DEPRECATED_SELECTOR: ".mdc-deprecated-list",
  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses.LIST_ITEM_CLASS + " a,\n    ." + cssClasses.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
  RADIO_SELECTOR: 'input[type="radio"]',
  SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
};
var numbers = {
  UNSET_INDEX: -1,
  TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
};
var evolutionAttribute = "evolution";

// node_modules/@material/list/events.js
var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
var preventDefaultEvent = function(evt) {
  var target = evt.target;
  if (!target) {
    return;
  }
  var tagName = ("" + target.tagName).toLowerCase();
  if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
    evt.preventDefault();
  }
};

// node_modules/@material/list/typeahead.js
function initState() {
  var state = {
    bufferClearTimeout: 0,
    currentFirstChar: "",
    sortedIndexCursor: 0,
    typeaheadBuffer: ""
  };
  return state;
}
function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
  var sortedIndexByFirstChar = /* @__PURE__ */ new Map();
  for (var i = 0; i < listItemCount; i++) {
    var primaryText = getPrimaryTextByItemIndex(i).trim();
    if (!primaryText) {
      continue;
    }
    var firstChar = primaryText[0].toLowerCase();
    if (!sortedIndexByFirstChar.has(firstChar)) {
      sortedIndexByFirstChar.set(firstChar, []);
    }
    sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i });
  }
  sortedIndexByFirstChar.forEach(function(values) {
    values.sort(function(first, second) {
      return first.index - second.index;
    });
  });
  return sortedIndexByFirstChar;
}
function matchItem(opts, state) {
  var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  clearTimeout(state.bufferClearTimeout);
  state.bufferClearTimeout = setTimeout(function() {
    clearBuffer(state);
  }, numbers.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
  state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
  var index;
  if (state.typeaheadBuffer.length === 1) {
    index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
  } else {
    index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
  }
  if (index !== -1 && !skipFocus) {
    focusItemAtIndex(index);
  }
  return index;
}
function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
    state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
    if (!isItemAtIndexDisabled(newIndex)) {
      return newIndex;
    }
  }
  state.currentFirstChar = firstChar;
  var newCursorPosition = -1;
  var cursorPosition;
  for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  if (newCursorPosition !== -1) {
    state.sortedIndexCursor = newCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
  if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
    return startingItem.index;
  }
  var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
  var nextCursorPosition = -1;
  while (cursorPosition !== state.sortedIndexCursor) {
    var currentItem = itemsMatchingFirstChar[cursorPosition];
    var matches2 = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
    var isEnabled = !isItemAtIndexDisabled(currentItem.index);
    if (matches2 && isEnabled) {
      nextCursorPosition = cursorPosition;
      break;
    }
    cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
  }
  if (nextCursorPosition !== -1) {
    state.sortedIndexCursor = nextCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function isTypingInProgress(state) {
  return state.typeaheadBuffer.length > 0;
}
function clearBuffer(state) {
  state.typeaheadBuffer = "";
}
function handleKeydown(opts, state) {
  var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  var isArrowLeft = normalizeKey(event) === "ArrowLeft";
  var isArrowUp = normalizeKey(event) === "ArrowUp";
  var isArrowRight = normalizeKey(event) === "ArrowRight";
  var isArrowDown = normalizeKey(event) === "ArrowDown";
  var isHome = normalizeKey(event) === "Home";
  var isEnd = normalizeKey(event) === "End";
  var isEnter = normalizeKey(event) === "Enter";
  var isSpace = normalizeKey(event) === "Spacebar";
  if (event.altKey || event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
    return -1;
  }
  var isCharacterKey = !isSpace && event.key.length === 1;
  if (isCharacterKey) {
    preventDefaultEvent(event);
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: event.key.toLowerCase(),
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  if (!isSpace) {
    return -1;
  }
  if (isTargetListItem) {
    preventDefaultEvent(event);
  }
  var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
  if (typeaheadOnListItem) {
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: " ",
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  return -1;
}

// node_modules/@material/list/foundation.js
function isNumberArray(selectedIndex) {
  return selectedIndex instanceof Array;
}
var handledModifierKeys = ["Alt", "Control", "Meta", "Shift"];
function createModifierChecker(event) {
  var eventModifiers = new Set(event ? handledModifierKeys.filter(function(m) {
    return event.getModifierState(m);
  }) : []);
  return function(modifiers) {
    return modifiers.every(function(m) {
      return eventModifiers.has(m);
    }) && modifiers.length === eventModifiers.size;
  };
}
var MDCListFoundation = function(_super) {
  __extends(MDCListFoundation2, _super);
  function MDCListFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
    _this.wrapFocus = false;
    _this.isVertical = true;
    _this.isSingleSelectionList = false;
    _this.areDisabledItemsFocusable = true;
    _this.selectedIndex = numbers.UNSET_INDEX;
    _this.focusedItemIndex = numbers.UNSET_INDEX;
    _this.useActivatedClass = false;
    _this.useSelectedAttr = false;
    _this.ariaCurrentAttrValue = null;
    _this.isCheckboxList = false;
    _this.isRadioList = false;
    _this.lastSelectedIndex = null;
    _this.hasTypeahead = false;
    _this.typeaheadState = initState();
    _this.sortedIndexByFirstChar = /* @__PURE__ */ new Map();
    return _this;
  }
  Object.defineProperty(MDCListFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClassForElementIndex: function() {
          return void 0;
        },
        focusItemAtIndex: function() {
          return void 0;
        },
        getAttributeForElementIndex: function() {
          return null;
        },
        getFocusedElementIndex: function() {
          return 0;
        },
        getListItemCount: function() {
          return 0;
        },
        hasCheckboxAtIndex: function() {
          return false;
        },
        hasRadioAtIndex: function() {
          return false;
        },
        isCheckboxCheckedAtIndex: function() {
          return false;
        },
        isFocusInsideList: function() {
          return false;
        },
        isRootFocused: function() {
          return false;
        },
        listItemAtIndexHasClass: function() {
          return false;
        },
        notifyAction: function() {
          return void 0;
        },
        notifySelectionChange: function() {
        },
        removeClassForElementIndex: function() {
          return void 0;
        },
        setAttributeForElementIndex: function() {
          return void 0;
        },
        setCheckedCheckboxOrRadioAtIndex: function() {
          return void 0;
        },
        setTabIndexForListItemChildren: function() {
          return void 0;
        },
        getPrimaryTextAtIndex: function() {
          return "";
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCListFoundation2.prototype.layout = function() {
    if (this.adapter.getListItemCount() === 0) {
      return;
    }
    if (this.adapter.hasCheckboxAtIndex(0)) {
      this.isCheckboxList = true;
    } else if (this.adapter.hasRadioAtIndex(0)) {
      this.isRadioList = true;
    } else {
      this.maybeInitializeSingleSelection();
    }
    if (this.hasTypeahead) {
      this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
    }
  };
  MDCListFoundation2.prototype.getFocusedItemIndex = function() {
    return this.focusedItemIndex;
  };
  MDCListFoundation2.prototype.setWrapFocus = function(value) {
    this.wrapFocus = value;
  };
  MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
    this.isVertical = value;
  };
  MDCListFoundation2.prototype.setSingleSelection = function(value) {
    this.isSingleSelectionList = value;
    if (value) {
      this.maybeInitializeSingleSelection();
      this.selectedIndex = this.getSelectedIndexFromDOM();
    }
  };
  MDCListFoundation2.prototype.setDisabledItemsFocusable = function(value) {
    this.areDisabledItemsFocusable = value;
  };
  MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
    var selectedItemIndex = this.getSelectedIndexFromDOM();
    if (selectedItemIndex === numbers.UNSET_INDEX)
      return;
    var hasActivatedClass = this.adapter.listItemAtIndexHasClass(selectedItemIndex, cssClasses.LIST_ITEM_ACTIVATED_CLASS);
    if (hasActivatedClass) {
      this.setUseActivatedClass(true);
    }
    this.isSingleSelectionList = true;
    this.selectedIndex = selectedItemIndex;
  };
  MDCListFoundation2.prototype.getSelectedIndexFromDOM = function() {
    var selectedIndex = numbers.UNSET_INDEX;
    var listItemsCount = this.adapter.getListItemCount();
    for (var i = 0; i < listItemsCount; i++) {
      var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses.LIST_ITEM_SELECTED_CLASS);
      var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i, cssClasses.LIST_ITEM_ACTIVATED_CLASS);
      if (!(hasSelectedClass || hasActivatedClass)) {
        continue;
      }
      selectedIndex = i;
      break;
    }
    return selectedIndex;
  };
  MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
    this.hasTypeahead = hasTypeahead;
    if (hasTypeahead) {
      this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
    }
  };
  MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
    return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
  };
  MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
    this.useActivatedClass = useActivated;
  };
  MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
    this.useSelectedAttr = useSelected;
  };
  MDCListFoundation2.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  };
  MDCListFoundation2.prototype.setSelectedIndex = function(index, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this.isIndexValid(index)) {
      return;
    }
    if (this.isCheckboxList) {
      this.setCheckboxAtIndex(index, options);
    } else if (this.isRadioList) {
      this.setRadioAtIndex(index, options);
    } else {
      this.setSingleSelectionAtIndex(index, options);
    }
  };
  MDCListFoundation2.prototype.handleFocusIn = function(listItemIndex) {
    if (listItemIndex >= 0) {
      this.focusedItemIndex = listItemIndex;
      this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
      this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
    }
  };
  MDCListFoundation2.prototype.handleFocusOut = function(listItemIndex) {
    var _this = this;
    if (listItemIndex >= 0) {
      this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
      this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
    }
    setTimeout(function() {
      if (!_this.adapter.isFocusInsideList()) {
        _this.setTabindexToFirstSelectedOrFocusedItem();
      }
    }, 0);
  };
  MDCListFoundation2.prototype.isIndexDisabled = function(index) {
    return this.adapter.listItemAtIndexHasClass(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
  };
  MDCListFoundation2.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
    var _this = this;
    var _a2;
    var isArrowLeft = normalizeKey(event) === "ArrowLeft";
    var isArrowUp = normalizeKey(event) === "ArrowUp";
    var isArrowRight = normalizeKey(event) === "ArrowRight";
    var isArrowDown = normalizeKey(event) === "ArrowDown";
    var isHome = normalizeKey(event) === "Home";
    var isEnd = normalizeKey(event) === "End";
    var isEnter = normalizeKey(event) === "Enter";
    var isSpace = normalizeKey(event) === "Spacebar";
    var isForward = this.isVertical && isArrowDown || !this.isVertical && isArrowRight;
    var isBack = this.isVertical && isArrowUp || !this.isVertical && isArrowLeft;
    var isLetterA = event.key === "A" || event.key === "a";
    var eventHasModifiers = createModifierChecker(event);
    if (this.adapter.isRootFocused()) {
      if ((isBack || isEnd) && eventHasModifiers([])) {
        event.preventDefault();
        this.focusLastElement();
      } else if ((isForward || isHome) && eventHasModifiers([])) {
        event.preventDefault();
        this.focusFirstElement();
      } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        event.preventDefault();
        var focusedIndex = this.focusLastElement();
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        event.preventDefault();
        var focusedIndex = this.focusFirstElement();
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event,
          focusItemAtIndex: function(index) {
            _this.focusItemAtIndex(index);
          },
          focusedItemIndex: -1,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index) {
            return _this.isIndexDisabled(index);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
      return;
    }
    var currentIndex = this.adapter.getFocusedElementIndex();
    if (currentIndex === -1) {
      currentIndex = listItemIndex;
      if (currentIndex < 0) {
        return;
      }
    }
    if (isForward && eventHasModifiers([])) {
      preventDefaultEvent(event);
      this.focusNextElement(currentIndex);
    } else if (isBack && eventHasModifiers([])) {
      preventDefaultEvent(event);
      this.focusPrevElement(currentIndex);
    } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
      preventDefaultEvent(event);
      var focusedIndex = this.focusNextElement(currentIndex);
      if (focusedIndex !== -1) {
        this.setSelectedIndexOnAction(focusedIndex, false);
      }
    } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
      preventDefaultEvent(event);
      var focusedIndex = this.focusPrevElement(currentIndex);
      if (focusedIndex !== -1) {
        this.setSelectedIndexOnAction(focusedIndex, false);
      }
    } else if (isHome && eventHasModifiers([])) {
      preventDefaultEvent(event);
      this.focusFirstElement();
    } else if (isEnd && eventHasModifiers([])) {
      preventDefaultEvent(event);
      this.focusLastElement();
    } else if (isHome && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
      preventDefaultEvent(event);
      if (this.isIndexDisabled(currentIndex)) {
        return;
      }
      this.focusFirstElement();
      this.toggleCheckboxRange(0, currentIndex, currentIndex);
    } else if (isEnd && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
      preventDefaultEvent(event);
      if (this.isIndexDisabled(currentIndex)) {
        return;
      }
      this.focusLastElement();
      this.toggleCheckboxRange(currentIndex, this.adapter.getListItemCount() - 1, currentIndex);
    } else if (isLetterA && eventHasModifiers(["Control"]) && this.isCheckboxList) {
      event.preventDefault();
      this.checkboxListToggleAll(this.selectedIndex === numbers.UNSET_INDEX ? [] : this.selectedIndex, true);
    } else if ((isEnter || isSpace) && eventHasModifiers([])) {
      if (isRootListItem) {
        var target = event.target;
        if (target && target.tagName === "A" && isEnter) {
          return;
        }
        preventDefaultEvent(event);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        if (!this.isTypeaheadInProgress()) {
          if (this.isSelectableList()) {
            this.setSelectedIndexOnAction(currentIndex, false);
          }
          this.adapter.notifyAction(currentIndex);
        }
      }
    } else if ((isEnter || isSpace) && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
      var target = event.target;
      if (target && target.tagName === "A" && isEnter) {
        return;
      }
      preventDefaultEvent(event);
      if (this.isIndexDisabled(currentIndex)) {
        return;
      }
      if (!this.isTypeaheadInProgress()) {
        this.toggleCheckboxRange((_a2 = this.lastSelectedIndex) !== null && _a2 !== void 0 ? _a2 : currentIndex, currentIndex, currentIndex);
        this.adapter.notifyAction(currentIndex);
      }
    }
    if (this.hasTypeahead) {
      var handleKeydownOpts = {
        event,
        focusItemAtIndex: function(index) {
          _this.focusItemAtIndex(index);
        },
        focusedItemIndex: this.focusedItemIndex,
        isTargetListItem: isRootListItem,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        isItemAtIndexDisabled: function(index) {
          return _this.isIndexDisabled(index);
        }
      };
      handleKeydown(handleKeydownOpts, this.typeaheadState);
    }
  };
  MDCListFoundation2.prototype.handleClick = function(index, isCheckboxAlreadyUpdatedInAdapter, event) {
    var _a2;
    var eventHasModifiers = createModifierChecker(event);
    if (index === numbers.UNSET_INDEX) {
      return;
    }
    if (this.isIndexDisabled(index)) {
      return;
    }
    if (eventHasModifiers([])) {
      if (this.isSelectableList()) {
        this.setSelectedIndexOnAction(index, isCheckboxAlreadyUpdatedInAdapter);
      }
      this.adapter.notifyAction(index);
    } else if (this.isCheckboxList && eventHasModifiers(["Shift"])) {
      this.toggleCheckboxRange((_a2 = this.lastSelectedIndex) !== null && _a2 !== void 0 ? _a2 : index, index, index);
      this.adapter.notifyAction(index);
    }
  };
  MDCListFoundation2.prototype.focusNextElement = function(index) {
    var count = this.adapter.getListItemCount();
    var nextIndex = index;
    var firstChecked = null;
    do {
      nextIndex++;
      if (nextIndex >= count) {
        if (this.wrapFocus) {
          nextIndex = 0;
        } else {
          return index;
        }
      }
      if (nextIndex === firstChecked) {
        return -1;
      }
      firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : nextIndex;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(nextIndex));
    this.focusItemAtIndex(nextIndex);
    return nextIndex;
  };
  MDCListFoundation2.prototype.focusPrevElement = function(index) {
    var count = this.adapter.getListItemCount();
    var prevIndex = index;
    var firstChecked = null;
    do {
      prevIndex--;
      if (prevIndex < 0) {
        if (this.wrapFocus) {
          prevIndex = count - 1;
        } else {
          return index;
        }
      }
      if (prevIndex === firstChecked) {
        return -1;
      }
      firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : prevIndex;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(prevIndex));
    this.focusItemAtIndex(prevIndex);
    return prevIndex;
  };
  MDCListFoundation2.prototype.focusFirstElement = function() {
    return this.focusNextElement(-1);
  };
  MDCListFoundation2.prototype.focusLastElement = function() {
    return this.focusPrevElement(this.adapter.getListItemCount());
  };
  MDCListFoundation2.prototype.focusInitialElement = function() {
    var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
    this.focusItemAtIndex(initialIndex);
    return initialIndex;
  };
  MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
    if (!this.isIndexValid(itemIndex, false)) {
      return;
    }
    if (isEnabled) {
      this.adapter.removeClassForElementIndex(itemIndex, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.setAttributeForElementIndex(itemIndex, strings.ARIA_DISABLED, "false");
    } else {
      this.adapter.addClassForElementIndex(itemIndex, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.setAttributeForElementIndex(itemIndex, strings.ARIA_DISABLED, "true");
    }
  };
  MDCListFoundation2.prototype.setSingleSelectionAtIndex = function(index, options) {
    if (options === void 0) {
      options = {};
    }
    if (this.selectedIndex === index && !options.forceUpdate) {
      return;
    }
    var selectedClassName = cssClasses.LIST_ITEM_SELECTED_CLASS;
    if (this.useActivatedClass) {
      selectedClassName = cssClasses.LIST_ITEM_ACTIVATED_CLASS;
    }
    if (this.selectedIndex !== numbers.UNSET_INDEX) {
      this.adapter.removeClassForElementIndex(this.selectedIndex, selectedClassName);
    }
    this.setAriaForSingleSelectionAtIndex(index);
    this.setTabindexAtIndex(index);
    if (index !== numbers.UNSET_INDEX) {
      this.adapter.addClassForElementIndex(index, selectedClassName);
    }
    this.selectedIndex = index;
    if (options.isUserInteraction && !options.forceUpdate) {
      this.adapter.notifySelectionChange([index]);
    }
  };
  MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex = function(index) {
    if (this.selectedIndex === numbers.UNSET_INDEX) {
      this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(index, strings.ARIA_CURRENT);
    }
    var isAriaCurrent = this.ariaCurrentAttrValue !== null;
    var ariaAttribute = isAriaCurrent ? strings.ARIA_CURRENT : strings.ARIA_SELECTED;
    if (this.selectedIndex !== numbers.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, ariaAttribute, "false");
    }
    if (index !== numbers.UNSET_INDEX) {
      var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue : "true";
      this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
    }
  };
  MDCListFoundation2.prototype.getSelectionAttribute = function() {
    return this.useSelectedAttr ? strings.ARIA_SELECTED : strings.ARIA_CHECKED;
  };
  MDCListFoundation2.prototype.setRadioAtIndex = function(index, options) {
    if (options === void 0) {
      options = {};
    }
    var selectionAttribute = this.getSelectionAttribute();
    this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
    if (this.selectedIndex === index && !options.forceUpdate) {
      return;
    }
    if (this.selectedIndex !== numbers.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, selectionAttribute, "false");
    }
    this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
    this.selectedIndex = index;
    if (options.isUserInteraction && !options.forceUpdate) {
      this.adapter.notifySelectionChange([index]);
    }
  };
  MDCListFoundation2.prototype.setCheckboxAtIndex = function(index, options) {
    if (options === void 0) {
      options = {};
    }
    var currentIndex = this.selectedIndex;
    var currentlySelected = options.isUserInteraction ? new Set(currentIndex === numbers.UNSET_INDEX ? [] : currentIndex) : null;
    var selectionAttribute = this.getSelectionAttribute();
    var changedIndices = [];
    for (var i = 0; i < this.adapter.getListItemCount(); i++) {
      var previousIsChecked = currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(i);
      var newIsChecked = index.indexOf(i) >= 0;
      if (newIsChecked !== previousIsChecked) {
        changedIndices.push(i);
      }
      this.adapter.setCheckedCheckboxOrRadioAtIndex(i, newIsChecked);
      this.adapter.setAttributeForElementIndex(i, selectionAttribute, newIsChecked ? "true" : "false");
    }
    this.selectedIndex = index;
    if (options.isUserInteraction && changedIndices.length) {
      this.adapter.notifySelectionChange(changedIndices);
    }
  };
  MDCListFoundation2.prototype.toggleCheckboxRange = function(fromIndex, toIndex, toggleIndex) {
    this.lastSelectedIndex = toggleIndex;
    var currentlySelected = new Set(this.selectedIndex === numbers.UNSET_INDEX ? [] : this.selectedIndex);
    var newIsChecked = !(currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(toggleIndex));
    var _a2 = __read([fromIndex, toIndex].sort(), 2), startIndex = _a2[0], endIndex = _a2[1];
    var selectionAttribute = this.getSelectionAttribute();
    var changedIndices = [];
    for (var i = startIndex; i <= endIndex; i++) {
      if (this.isIndexDisabled(i)) {
        continue;
      }
      var previousIsChecked = currentlySelected.has(i);
      if (newIsChecked !== previousIsChecked) {
        changedIndices.push(i);
        this.adapter.setCheckedCheckboxOrRadioAtIndex(i, newIsChecked);
        this.adapter.setAttributeForElementIndex(i, selectionAttribute, "" + newIsChecked);
        if (newIsChecked) {
          currentlySelected.add(i);
        } else {
          currentlySelected.delete(i);
        }
      }
    }
    if (changedIndices.length) {
      this.selectedIndex = __spreadArray([], __read(currentlySelected));
      this.adapter.notifySelectionChange(changedIndices);
    }
  };
  MDCListFoundation2.prototype.setTabindexAtIndex = function(index) {
    if (this.focusedItemIndex === numbers.UNSET_INDEX && index !== 0) {
      this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
    } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
      this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
    }
    if (!(this.selectedIndex instanceof Array) && this.selectedIndex !== index) {
      this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1");
    }
    if (index !== numbers.UNSET_INDEX) {
      this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
    }
  };
  MDCListFoundation2.prototype.isSelectableList = function() {
    return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
  };
  MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
    var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
    this.setTabindexAtIndex(targetIndex);
  };
  MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
    if (!this.isSelectableList()) {
      return Math.max(this.focusedItemIndex, 0);
    }
    if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers.UNSET_INDEX) {
      return this.selectedIndex;
    }
    if (isNumberArray(this.selectedIndex) && this.selectedIndex.length > 0) {
      return this.selectedIndex.reduce(function(minIndex, currentIndex) {
        return Math.min(minIndex, currentIndex);
      });
    }
    return 0;
  };
  MDCListFoundation2.prototype.isIndexValid = function(index, validateListType) {
    var _this = this;
    if (validateListType === void 0) {
      validateListType = true;
    }
    if (index instanceof Array) {
      if (!this.isCheckboxList && validateListType) {
        throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
      }
      if (index.length === 0) {
        return true;
      } else {
        return index.some(function(i) {
          return _this.isIndexInRange(i);
        });
      }
    } else if (typeof index === "number") {
      if (this.isCheckboxList && validateListType) {
        throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
      }
      return this.isIndexInRange(index) || this.isSingleSelectionList && index === numbers.UNSET_INDEX;
    } else {
      return false;
    }
  };
  MDCListFoundation2.prototype.isIndexInRange = function(index) {
    var listSize = this.adapter.getListItemCount();
    return index >= 0 && index < listSize;
  };
  MDCListFoundation2.prototype.setSelectedIndexOnAction = function(index, isCheckboxAlreadyUpdatedInAdapter) {
    this.lastSelectedIndex = index;
    if (this.isCheckboxList) {
      this.toggleCheckboxAtIndex(index, isCheckboxAlreadyUpdatedInAdapter);
      this.adapter.notifySelectionChange([index]);
    } else {
      this.setSelectedIndex(index, { isUserInteraction: true });
    }
  };
  MDCListFoundation2.prototype.toggleCheckboxAtIndex = function(index, isCheckboxAlreadyUpdatedInAdapter) {
    var selectionAttribute = this.getSelectionAttribute();
    var adapterIsChecked = this.adapter.isCheckboxCheckedAtIndex(index);
    var newCheckedValue;
    if (isCheckboxAlreadyUpdatedInAdapter) {
      newCheckedValue = adapterIsChecked;
    } else {
      newCheckedValue = !adapterIsChecked;
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index, newCheckedValue);
    }
    this.adapter.setAttributeForElementIndex(index, selectionAttribute, newCheckedValue ? "true" : "false");
    var selectedIndexes = this.selectedIndex === numbers.UNSET_INDEX ? [] : this.selectedIndex.slice();
    if (newCheckedValue) {
      selectedIndexes.push(index);
    } else {
      selectedIndexes = selectedIndexes.filter(function(i) {
        return i !== index;
      });
    }
    this.selectedIndex = selectedIndexes;
  };
  MDCListFoundation2.prototype.focusItemAtIndex = function(index) {
    this.adapter.focusItemAtIndex(index);
    this.focusedItemIndex = index;
  };
  MDCListFoundation2.prototype.checkboxListToggleAll = function(currentlySelectedIndexes, isUserInteraction) {
    var count = this.adapter.getListItemCount();
    if (currentlySelectedIndexes.length === count) {
      this.setCheckboxAtIndex([], { isUserInteraction });
    } else {
      var allIndexes = [];
      for (var i = 0; i < count; i++) {
        if (!this.isIndexDisabled(i) || currentlySelectedIndexes.indexOf(i) > -1) {
          allIndexes.push(i);
        }
      }
      this.setCheckboxAtIndex(allIndexes, { isUserInteraction });
    }
  };
  MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
    var _this = this;
    if (skipFocus === void 0) {
      skipFocus = false;
    }
    var opts = {
      focusItemAtIndex: function(index) {
        _this.focusItemAtIndex(index);
      },
      focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
      nextChar,
      sortedIndexByFirstChar: this.sortedIndexByFirstChar,
      skipFocus,
      isItemAtIndexDisabled: function(index) {
        return _this.isIndexDisabled(index);
      }
    };
    return matchItem(opts, this.typeaheadState);
  };
  MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
    return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
  };
  MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
    clearBuffer(this.typeaheadState);
  };
  return MDCListFoundation2;
}(MDCFoundation);

// node_modules/@material/list/component.js
var MDCList = function(_super) {
  __extends(MDCList2, _super);
  function MDCList2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MDCList2.prototype, "vertical", {
    set: function(value) {
      this.foundation.setVerticalOrientation(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "listElements", {
    get: function() {
      return Array.from(this.root.querySelectorAll("." + this.classNameMap[cssClasses.LIST_ITEM_CLASS]));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "wrapFocus", {
    set: function(value) {
      this.foundation.setWrapFocus(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "typeaheadInProgress", {
    get: function() {
      return this.foundation.isTypeaheadInProgress();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "hasTypeahead", {
    set: function(hasTypeahead) {
      this.foundation.setHasTypeahead(hasTypeahead);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "singleSelection", {
    set: function(isSingleSelectionList) {
      this.foundation.setSingleSelection(isSingleSelectionList);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "disabledItemsFocusable", {
    set: function(areDisabledItemsFocusable) {
      this.foundation.setDisabledItemsFocusable(areDisabledItemsFocusable);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCList2.prototype, "selectedIndex", {
    get: function() {
      return this.foundation.getSelectedIndex();
    },
    set: function(index) {
      this.foundation.setSelectedIndex(index);
    },
    enumerable: false,
    configurable: true
  });
  MDCList2.attachTo = function(root) {
    return new MDCList2(root);
  };
  MDCList2.prototype.initialSyncWithDOM = function() {
    this.isEvolutionEnabled = evolutionAttribute in this.root.dataset;
    if (this.isEvolutionEnabled) {
      this.classNameMap = evolutionClassNameMap;
    } else if (matches(this.root, strings.DEPRECATED_SELECTOR)) {
      this.classNameMap = deprecatedClassNameMap;
    } else {
      this.classNameMap = Object.values(cssClasses).reduce(function(obj, className) {
        obj[className] = className;
        return obj;
      }, {});
    }
    this.handleClick = this.handleClickEvent.bind(this);
    this.handleKeydown = this.handleKeydownEvent.bind(this);
    this.focusInEventListener = this.handleFocusInEvent.bind(this);
    this.focusOutEventListener = this.handleFocusOutEvent.bind(this);
    this.listen("keydown", this.handleKeydown);
    this.listen("click", this.handleClick);
    this.listen("focusin", this.focusInEventListener);
    this.listen("focusout", this.focusOutEventListener);
    this.layout();
    this.initializeListType();
    this.ensureFocusable();
  };
  MDCList2.prototype.destroy = function() {
    this.unlisten("keydown", this.handleKeydown);
    this.unlisten("click", this.handleClick);
    this.unlisten("focusin", this.focusInEventListener);
    this.unlisten("focusout", this.focusOutEventListener);
  };
  MDCList2.prototype.layout = function() {
    var direction = this.root.getAttribute(strings.ARIA_ORIENTATION);
    this.vertical = direction !== strings.ARIA_ORIENTATION_HORIZONTAL;
    var itemSelector = "." + this.classNameMap[cssClasses.LIST_ITEM_CLASS] + ":not([tabindex])";
    var childSelector = strings.FOCUSABLE_CHILD_ELEMENTS;
    var itemEls = this.root.querySelectorAll(itemSelector);
    if (itemEls.length) {
      Array.prototype.forEach.call(itemEls, function(el) {
        el.setAttribute("tabindex", "-1");
      });
    }
    var focusableChildEls = this.root.querySelectorAll(childSelector);
    if (focusableChildEls.length) {
      Array.prototype.forEach.call(focusableChildEls, function(el) {
        el.setAttribute("tabindex", "-1");
      });
    }
    if (this.isEvolutionEnabled) {
      this.foundation.setUseSelectedAttribute(true);
    }
    this.foundation.layout();
  };
  MDCList2.prototype.getPrimaryText = function(item) {
    var _a2;
    var primaryText = item.querySelector("." + this.classNameMap[cssClasses.LIST_ITEM_PRIMARY_TEXT_CLASS]);
    if (this.isEvolutionEnabled || primaryText) {
      return (_a2 = primaryText === null || primaryText === void 0 ? void 0 : primaryText.textContent) !== null && _a2 !== void 0 ? _a2 : "";
    }
    var singleLineText = item.querySelector("." + this.classNameMap[cssClasses.LIST_ITEM_TEXT_CLASS]);
    return singleLineText && singleLineText.textContent || "";
  };
  MDCList2.prototype.initializeListType = function() {
    var _this = this;
    this.isInteractive = matches(this.root, strings.ARIA_INTERACTIVE_ROLES_SELECTOR);
    if (this.isEvolutionEnabled && this.isInteractive) {
      var selection = Array.from(this.root.querySelectorAll(strings.SELECTED_ITEM_SELECTOR), function(listItem) {
        return _this.listElements.indexOf(listItem);
      });
      if (matches(this.root, strings.ARIA_MULTI_SELECTABLE_SELECTOR)) {
        this.selectedIndex = selection;
      } else if (selection.length > 0) {
        this.selectedIndex = selection[0];
      }
      return;
    }
    var checkboxListItems = this.root.querySelectorAll(strings.ARIA_ROLE_CHECKBOX_SELECTOR);
    var radioSelectedListItem = this.root.querySelector(strings.ARIA_CHECKED_RADIO_SELECTOR);
    if (checkboxListItems.length) {
      var preselectedItems = this.root.querySelectorAll(strings.ARIA_CHECKED_CHECKBOX_SELECTOR);
      this.selectedIndex = Array.from(preselectedItems, function(listItem) {
        return _this.listElements.indexOf(listItem);
      });
    } else if (radioSelectedListItem) {
      this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
    }
  };
  MDCList2.prototype.setEnabled = function(itemIndex, isEnabled) {
    this.foundation.setEnabled(itemIndex, isEnabled);
  };
  MDCList2.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
    return this.foundation.typeaheadMatchItem(nextChar, startingIndex, true);
  };
  MDCList2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClassForElementIndex: function(index, className) {
        var element2 = _this.listElements[index];
        if (element2) {
          element2.classList.add(_this.classNameMap[className]);
        }
      },
      focusItemAtIndex: function(index) {
        var element2 = _this.listElements[index];
        if (element2) {
          element2.focus();
        }
      },
      getAttributeForElementIndex: function(index, attr) {
        return _this.listElements[index].getAttribute(attr);
      },
      getFocusedElementIndex: function() {
        return _this.listElements.indexOf(document.activeElement);
      },
      getListItemCount: function() {
        return _this.listElements.length;
      },
      getPrimaryTextAtIndex: function(index) {
        return _this.getPrimaryText(_this.listElements[index]);
      },
      hasCheckboxAtIndex: function(index) {
        var listItem = _this.listElements[index];
        return !!listItem.querySelector(strings.CHECKBOX_SELECTOR);
      },
      hasRadioAtIndex: function(index) {
        var listItem = _this.listElements[index];
        return !!listItem.querySelector(strings.RADIO_SELECTOR);
      },
      isCheckboxCheckedAtIndex: function(index) {
        var listItem = _this.listElements[index];
        var toggleEl = listItem.querySelector(strings.CHECKBOX_SELECTOR);
        return toggleEl.checked;
      },
      isFocusInsideList: function() {
        return _this.root !== document.activeElement && _this.root.contains(document.activeElement);
      },
      isRootFocused: function() {
        return document.activeElement === _this.root;
      },
      listItemAtIndexHasClass: function(index, className) {
        return _this.listElements[index].classList.contains(_this.classNameMap[className]);
      },
      notifyAction: function(index) {
        _this.emit(strings.ACTION_EVENT, { index }, true);
      },
      notifySelectionChange: function(changedIndices) {
        _this.emit(strings.SELECTION_CHANGE_EVENT, { changedIndices }, true);
      },
      removeClassForElementIndex: function(index, className) {
        var element2 = _this.listElements[index];
        if (element2) {
          element2.classList.remove(_this.classNameMap[className]);
        }
      },
      setAttributeForElementIndex: function(index, attr, value) {
        var element2 = _this.listElements[index];
        if (element2) {
          element2.setAttribute(attr, value);
        }
      },
      setCheckedCheckboxOrRadioAtIndex: function(index, isChecked) {
        var listItem = _this.listElements[index];
        var toggleEl = listItem.querySelector(strings.CHECKBOX_RADIO_SELECTOR);
        toggleEl.checked = isChecked;
        var event = document.createEvent("Event");
        event.initEvent("change", true, true);
        toggleEl.dispatchEvent(event);
      },
      setTabIndexForListItemChildren: function(listItemIndex, tabIndexValue) {
        var element2 = _this.listElements[listItemIndex];
        var selector = strings.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX;
        Array.prototype.forEach.call(element2.querySelectorAll(selector), function(el) {
          el.setAttribute("tabindex", tabIndexValue);
        });
      }
    };
    return new MDCListFoundation(adapter);
  };
  MDCList2.prototype.ensureFocusable = function() {
    if (this.isEvolutionEnabled && this.isInteractive) {
      if (!this.root.querySelector("." + this.classNameMap[cssClasses.LIST_ITEM_CLASS] + '[tabindex="0"]')) {
        var index = this.initialFocusIndex();
        if (index !== -1) {
          this.listElements[index].tabIndex = 0;
        }
      }
    }
  };
  MDCList2.prototype.initialFocusIndex = function() {
    if (this.selectedIndex instanceof Array && this.selectedIndex.length > 0) {
      return this.selectedIndex[0];
    }
    if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers.UNSET_INDEX) {
      return this.selectedIndex;
    }
    var el = this.root.querySelector("." + this.classNameMap[cssClasses.LIST_ITEM_CLASS] + ":not(." + this.classNameMap[cssClasses.LIST_ITEM_DISABLED_CLASS] + ")");
    if (el === null) {
      return -1;
    }
    return this.getListItemIndex(el);
  };
  MDCList2.prototype.getListItemIndex = function(el) {
    var nearestParent = closest(el, "." + this.classNameMap[cssClasses.LIST_ITEM_CLASS] + ", ." + this.classNameMap[cssClasses.ROOT]);
    if (nearestParent && matches(nearestParent, "." + this.classNameMap[cssClasses.LIST_ITEM_CLASS])) {
      return this.listElements.indexOf(nearestParent);
    }
    return -1;
  };
  MDCList2.prototype.handleFocusInEvent = function(evt) {
    var index = this.getListItemIndex(evt.target);
    this.foundation.handleFocusIn(index);
  };
  MDCList2.prototype.handleFocusOutEvent = function(evt) {
    var index = this.getListItemIndex(evt.target);
    this.foundation.handleFocusOut(index);
  };
  MDCList2.prototype.handleKeydownEvent = function(evt) {
    var index = this.getListItemIndex(evt.target);
    var target = evt.target;
    this.foundation.handleKeydown(evt, target.classList.contains(this.classNameMap[cssClasses.LIST_ITEM_CLASS]), index);
  };
  MDCList2.prototype.handleClickEvent = function(evt) {
    var index = this.getListItemIndex(evt.target);
    var target = evt.target;
    var toggleCheckbox = !matches(target, strings.CHECKBOX_RADIO_SELECTOR);
    this.foundation.handleClick(index, toggleCheckbox, evt);
  };
  return MDCList2;
}(MDCComponent);

// node_modules/@smui/list/dist/List.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[41].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[43], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[43],
            !current ? get_all_dirty_from_scope(ctx2[43]) : get_slot_changes(default_slot_template, ctx2[43], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-deprecated-list': true,     'mdc-deprecated-list--non-interactive': nonInteractive,     'mdc-deprecated-list--dense': dense,     'mdc-deprecated-list--textual-list': textualList,     'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,     'mdc-deprecated-list--icon-list': iconList,     'mdc-deprecated-list--image-list': imageList,     'mdc-deprecated-list--thumbnail-list': thumbnailList,     'mdc-deprecated-list--video-list': videoList,     'mdc-deprecated-list--two-line': twoLine,     'smui-list--three-line': threeLine && !twoLine,   })}   {role}   on:keydown={handleKeydown}   on:focusin={handleFocusin}   on:focusout={handleFocusout}   on:click={handleClick}   on:SMUIListItem:mount={handleItemMount}   on:SMUIListItem:unmount={handleItemUnmount}   on:SMUI:action={handleAction}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: ctx[13] },
    {
      use: [ctx[16], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list": true,
        "mdc-deprecated-list--non-interactive": ctx[2],
        "mdc-deprecated-list--dense": ctx[3],
        "mdc-deprecated-list--textual-list": ctx[4],
        "mdc-deprecated-list--avatar-list": ctx[5] || ctx[17],
        "mdc-deprecated-list--icon-list": ctx[6],
        "mdc-deprecated-list--image-list": ctx[7],
        "mdc-deprecated-list--thumbnail-list": ctx[8],
        "mdc-deprecated-list--video-list": ctx[9],
        "mdc-deprecated-list--two-line": ctx[10],
        "smui-list--three-line": ctx[11] && !ctx[10]
      })
    },
    { role: ctx[15] },
    ctx[25]
  ];
  var switch_value = ctx[12];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[42](switch_instance);
    switch_instance.$on("keydown", ctx[20]);
    switch_instance.$on("focusin", ctx[21]);
    switch_instance.$on("focusout", ctx[22]);
    switch_instance.$on("click", ctx[23]);
    switch_instance.$on("SMUIListItem:mount", ctx[18]);
    switch_instance.$on("SMUIListItem:unmount", ctx[19]);
    switch_instance.$on("SMUI:action", ctx[24]);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 33796095 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & 8192 && { tag: ctx2[13] },
        dirty[0] & 65537 && {
          use: [ctx2[16], ...ctx2[0]]
        },
        dirty[0] & 135166 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-deprecated-list": true,
            "mdc-deprecated-list--non-interactive": ctx2[2],
            "mdc-deprecated-list--dense": ctx2[3],
            "mdc-deprecated-list--textual-list": ctx2[4],
            "mdc-deprecated-list--avatar-list": ctx2[5] || ctx2[17],
            "mdc-deprecated-list--icon-list": ctx2[6],
            "mdc-deprecated-list--image-list": ctx2[7],
            "mdc-deprecated-list--thumbnail-list": ctx2[8],
            "mdc-deprecated-list--video-list": ctx2[9],
            "mdc-deprecated-list--two-line": ctx2[10],
            "smui-list--three-line": ctx2[11] && !ctx2[10]
          })
        },
        dirty[0] & 32768 && { role: ctx2[15] },
        dirty[0] & 33554432 && get_spread_object(ctx2[25])
      ]) : {};
      if (dirty[1] & 4096) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[42](switch_instance);
          switch_instance.$on("keydown", ctx2[20]);
          switch_instance.$on("focusin", ctx2[21]);
          switch_instance.$on("focusout", ctx2[22]);
          switch_instance.$on("click", ctx2[23]);
          switch_instance.$on("SMUIListItem:mount", ctx2[18]);
          switch_instance.$on("SMUIListItem:unmount", ctx2[19]);
          switch_instance.$on("SMUI:action", ctx2[24]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[42](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "disabledItemsFocusable",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "component",
    "tag",
    "layout",
    "setEnabled",
    "getTypeaheadInProgress",
    "getSelectedIndex",
    "getFocusedItemIndex",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  var _a2;
  const { closest: closest2, matches: matches2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { nonInteractive = false } = $$props;
  let { dense = false } = $$props;
  let { textualList = false } = $$props;
  let { avatarList = false } = $$props;
  let { iconList = false } = $$props;
  let { imageList = false } = $$props;
  let { thumbnailList = false } = $$props;
  let { videoList = false } = $$props;
  let { twoLine = false } = $$props;
  let { threeLine = false } = $$props;
  let { vertical = true } = $$props;
  let { wrapFocus = (_a2 = getContext("SMUI:list:wrapFocus")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
  let { singleSelection = false } = $$props;
  let { disabledItemsFocusable = false } = $$props;
  let { selectedIndex = -1 } = $$props;
  let { radioList = false } = $$props;
  let { checkList = false } = $$props;
  let { hasTypeahead = false } = $$props;
  let element2;
  let instance5;
  let items = [];
  let role = getContext("SMUI:list:role");
  let nav = getContext("SMUI:list:nav");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav ? "nav" : "ul" : void 0 } = $$props;
  setContext("SMUI:list:nonInteractive", nonInteractive);
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(40, instance5 = new MDCListFoundation({
      addClassForElementIndex,
      focusItemAtIndex,
      getAttributeForElementIndex: (index, name) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.getAttr(name)) !== null && _b2 !== void 0 ? _b2 : null;
      },
      getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
      getListItemCount: () => items.length,
      getPrimaryTextAtIndex,
      hasCheckboxAtIndex: (index) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.hasCheckbox) !== null && _b2 !== void 0 ? _b2 : false;
      },
      hasRadioAtIndex: (index) => {
        var _a3, _b2;
        return (_b2 = (_a3 = getOrderedList()[index]) === null || _a3 === void 0 ? void 0 : _a3.hasRadio) !== null && _b2 !== void 0 ? _b2 : false;
      },
      isCheckboxCheckedAtIndex: (index) => {
        var _a3;
        const listItem = getOrderedList()[index];
        return (_a3 = (listItem === null || listItem === void 0 ? void 0 : listItem.hasCheckbox) && listItem.checked) !== null && _a3 !== void 0 ? _a3 : false;
      },
      isFocusInsideList: () => element2 != null && getElement() !== document.activeElement && getElement().contains(document.activeElement),
      isRootFocused: () => element2 != null && document.activeElement === getElement(),
      listItemAtIndexHasClass,
      notifyAction: (index) => {
        $$invalidate(26, selectedIndex = index);
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:action", { index }, void 0, true);
        }
      },
      notifySelectionChange: (changedIndices) => {
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:selectionChange", { changedIndices });
        }
      },
      removeClassForElementIndex,
      setAttributeForElementIndex,
      setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
        getOrderedList()[index].checked = isChecked;
      },
      setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
        const listItem = getOrderedList()[listItemIndex];
        const selector = "button:not(:disabled), a";
        Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
          el.setAttribute("tabindex", tabIndexValue);
        });
      }
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        return instance5.isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        return instance5.typeaheadMatchItem(
          nextChar,
          startingIndex,
          true
        );
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    dispatch(getElement(), "SMUIList:mount", accessor);
    instance5.init();
    instance5.layout();
    return () => {
      instance5.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleItemMount(event) {
    items.push(event.detail);
    itemAccessorMap.set(event.detail.element, event.detail);
    if (singleSelection && event.detail.selected) {
      $$invalidate(26, selectedIndex = getListItemIndex(event.detail.element));
    }
    event.stopPropagation();
  }
  function handleItemUnmount(event) {
    var _a3;
    const idx = (_a3 = event.detail && items.indexOf(event.detail)) !== null && _a3 !== void 0 ? _a3 : -1;
    if (idx !== -1) {
      items.splice(idx, 1);
      items = items;
      itemAccessorMap.delete(event.detail.element);
    }
    event.stopPropagation();
  }
  function handleKeydown2(event) {
    if (instance5 && event.target) {
      instance5.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
    }
  }
  function handleFocusin(event) {
    if (instance5 && event.target) {
      instance5.handleFocusIn(getListItemIndex(event.target));
    }
  }
  function handleFocusout(event) {
    if (instance5 && event.target) {
      instance5.handleFocusOut(getListItemIndex(event.target));
    }
  }
  function handleClick(event) {
    if (instance5 && event.target) {
      instance5.handleClick(getListItemIndex(event.target), !matches2(event.target, 'input[type="checkbox"], input[type="radio"]'), event);
    }
  }
  function handleAction(event) {
    if (radioList || checkList) {
      const index = getListItemIndex(event.target);
      if (index !== -1) {
        const item = getOrderedList()[index];
        if (item && (radioList && !item.checked || checkList)) {
          if (!matches2(event.detail.target, 'input[type="checkbox"], input[type="radio"]')) {
            item.checked = !item.checked;
          }
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (element2 == null) {
      return [];
    }
    return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor && "focus" in accessor.element && accessor.element.focus();
  }
  function listItemAtIndexHasClass(index, className2) {
    var _a3;
    const accessor = getOrderedList()[index];
    return (_a3 = accessor && accessor.hasClass(className2)) !== null && _a3 !== void 0 ? _a3 : false;
  }
  function addClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className2);
  }
  function removeClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index) {
    var _a3;
    const accessor = getOrderedList()[index];
    return (_a3 = accessor && accessor.getPrimaryText()) !== null && _a3 !== void 0 ? _a3 : "";
  }
  function getListItemIndex(element3) {
    const nearestParent = closest2(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches2(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item === null || item === void 0 ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    return instance5.layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    return instance5.setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    return instance5.isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    return instance5.getSelectedIndex();
  }
  function getFocusedItemIndex() {
    return instance5.getFocusedItemIndex();
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(14, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("nonInteractive" in $$new_props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$new_props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$new_props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$new_props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$new_props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$new_props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$new_props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$new_props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$new_props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$new_props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$new_props)
      $$invalidate(27, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$new_props)
      $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$new_props)
      $$invalidate(29, singleSelection = $$new_props.singleSelection);
    if ("disabledItemsFocusable" in $$new_props)
      $$invalidate(30, disabledItemsFocusable = $$new_props.disabledItemsFocusable);
    if ("selectedIndex" in $$new_props)
      $$invalidate(26, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$new_props)
      $$invalidate(31, radioList = $$new_props.radioList);
    if ("checkList" in $$new_props)
      $$invalidate(32, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$new_props)
      $$invalidate(33, hasTypeahead = $$new_props.hasTypeahead);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(13, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a: _a2,
    MDCListFoundation,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    SmuiElement: SmuiElement_default,
    closest: closest2,
    matches: matches2,
    forwardEvents,
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    vertical,
    wrapFocus,
    singleSelection,
    disabledItemsFocusable,
    selectedIndex,
    radioList,
    checkList,
    hasTypeahead,
    element: element2,
    instance: instance5,
    items,
    role,
    nav,
    itemAccessorMap,
    selectionDialog,
    addLayoutListener,
    removeLayoutListener,
    component,
    tag,
    handleItemMount,
    handleItemUnmount,
    handleKeydown: handleKeydown2,
    handleFocusin,
    handleFocusout,
    handleClick,
    handleAction,
    getOrderedList,
    focusItemAtIndex,
    listItemAtIndexHasClass,
    addClassForElementIndex,
    removeClassForElementIndex,
    setAttributeForElementIndex,
    removeAttributeForElementIndex,
    getAttributeFromElementIndex,
    getPrimaryTextAtIndex,
    getListItemIndex,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a2 = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("nonInteractive" in $$props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$props)
      $$invalidate(27, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$props)
      $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$props)
      $$invalidate(29, singleSelection = $$new_props.singleSelection);
    if ("disabledItemsFocusable" in $$props)
      $$invalidate(30, disabledItemsFocusable = $$new_props.disabledItemsFocusable);
    if ("selectedIndex" in $$props)
      $$invalidate(26, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$props)
      $$invalidate(31, radioList = $$new_props.radioList);
    if ("checkList" in $$props)
      $$invalidate(32, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$props)
      $$invalidate(33, hasTypeahead = $$new_props.hasTypeahead);
    if ("element" in $$props)
      $$invalidate(14, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(40, instance5 = $$new_props.instance);
    if ("items" in $$props)
      items = $$new_props.items;
    if ("role" in $$props)
      $$invalidate(15, role = $$new_props.role);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("selectionDialog" in $$props)
      $$invalidate(17, selectionDialog = $$new_props.selectionDialog);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("component" in $$props)
      $$invalidate(12, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(13, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 134217728 | $$self.$$.dirty[1] & 512) {
      $:
        if (instance5) {
          instance5.setVerticalOrientation(vertical);
        }
    }
    if ($$self.$$.dirty[0] & 268435456 | $$self.$$.dirty[1] & 512) {
      $:
        if (instance5) {
          instance5.setWrapFocus(wrapFocus);
        }
    }
    if ($$self.$$.dirty[1] & 516) {
      $:
        if (instance5) {
          instance5.setHasTypeahead(hasTypeahead);
        }
    }
    if ($$self.$$.dirty[0] & 536870912 | $$self.$$.dirty[1] & 512) {
      $:
        if (instance5) {
          instance5.setSingleSelection(singleSelection);
        }
    }
    if ($$self.$$.dirty[0] & 1073741824 | $$self.$$.dirty[1] & 512) {
      $:
        if (instance5) {
          instance5.setDisabledItemsFocusable(disabledItemsFocusable);
        }
    }
    if ($$self.$$.dirty[0] & 603979776 | $$self.$$.dirty[1] & 512) {
      $:
        if (instance5 && singleSelection && getSelectedIndex() !== selectedIndex) {
          instance5.setSelectedIndex(selectedIndex);
        }
    }
  };
  return [
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    component,
    tag,
    element2,
    role,
    forwardEvents,
    selectionDialog,
    handleItemMount,
    handleItemUnmount,
    handleKeydown2,
    handleFocusin,
    handleFocusout,
    handleClick,
    handleAction,
    $$restProps,
    selectedIndex,
    vertical,
    wrapFocus,
    singleSelection,
    disabledItemsFocusable,
    radioList,
    checkList,
    hasTypeahead,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    getElement,
    instance5,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        nonInteractive: 2,
        dense: 3,
        textualList: 4,
        avatarList: 5,
        iconList: 6,
        imageList: 7,
        thumbnailList: 8,
        videoList: 9,
        twoLine: 10,
        threeLine: 11,
        vertical: 27,
        wrapFocus: 28,
        singleSelection: 29,
        disabledItemsFocusable: 30,
        selectedIndex: 26,
        radioList: 31,
        checkList: 32,
        hasTypeahead: 33,
        component: 12,
        tag: 13,
        layout: 34,
        setEnabled: 35,
        getTypeaheadInProgress: 36,
        getSelectedIndex: 37,
        getFocusedItemIndex: 38,
        getElement: 39
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dense() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dense(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avatarList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avatarList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnailList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnailList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get videoList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set videoList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get twoLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set twoLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get threeLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threeLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapFocus() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapFocus(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get singleSelection() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set singleSelection(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabledItemsFocusable() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabledItemsFocusable(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radioList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radioList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasTypeahead() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasTypeahead(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[34];
  }
  set layout(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setEnabled() {
    return this.$$.ctx[35];
  }
  set setEnabled(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTypeaheadInProgress() {
    return this.$$.ctx[36];
  }
  set getTypeaheadInProgress(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectedIndex() {
    return this.$$.ctx[37];
  }
  set getSelectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFocusedItemIndex() {
    return this.$$.ctx[38];
  }
  set getFocusedItemIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[39];
  }
  set getElement(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/@smui/list/dist/Item.svelte
var file = "node_modules/@smui/list/dist/Item.svelte";
function create_if_block(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "mdc-deprecated-list-item__ripple");
      add_location(span, file, 58, 15, 1774);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(59:3) {#if ripple}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[7] && create_if_block(ctx);
  const default_slot_template = ctx[34].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[37], null);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[37],
            !current ? get_all_dirty_from_scope(ctx2[37]) : get_slot_changes(default_slot_template, ctx2[37], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[     ...(nonInteractive       ? []       : [           [             Ripple,             {               ripple: !input,               unbounded: false,               color:                 (activated || selected) && color == null ? 'primary' : color,               disabled,               addClass,               removeClass,               addStyle,             },           ],         ]),     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-deprecated-list-item': !wrapper,     'mdc-deprecated-list-item__wrapper': wrapper,     'mdc-deprecated-list-item--activated': activated,     'mdc-deprecated-list-item--selected': selected,     'mdc-deprecated-list-item--disabled': disabled,     'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,     'smui-menu-item--non-interactive': nonInteractive,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...nav && activated ? { 'aria-current': 'page' } : {}}   {...!nav || wrapper ? { role } : {}}   {...!nav && role === 'option'     ? { 'aria-selected': selected ? 'true' : 'false' }     : {}}   {...!nav && (role === 'radio' || role === 'checkbox')     ? { 'aria-checked': input && input.checked ? 'true' : 'false' }     : {}}   {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}   data-menu-item-skip-restore-focus={skipRestoreFocus || undefined}   {tabindex}   on:click={action}   on:keydown={handleKeydown}   on:SMUIGenericInput:mount={handleInputMount}   on:SMUIGenericInput:unmount={() => (input = undefined)}   {href}   {...internalAttrs}   {...$$restProps}   >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: ctx[14] },
    {
      use: [
        ...ctx[6] ? [] : [
          [
            dist_default,
            {
              ripple: !ctx[16],
              unbounded: false,
              color: (ctx[1] || ctx[0]) && ctx[5] == null ? "primary" : ctx[5],
              disabled: ctx[10],
              addClass: ctx[24],
              removeClass: ctx[25],
              addStyle: ctx[26]
            }
          ]
        ],
        ctx[22],
        ...ctx[2]
      ]
    },
    {
      class: classMap({
        [ctx[3]]: true,
        "mdc-deprecated-list-item": !ctx[8],
        "mdc-deprecated-list-item__wrapper": ctx[8],
        "mdc-deprecated-list-item--activated": ctx[1],
        "mdc-deprecated-list-item--selected": ctx[0],
        "mdc-deprecated-list-item--disabled": ctx[10],
        "mdc-menu-item--selected": !ctx[23] && ctx[9] === "menuitem" && ctx[0],
        "smui-menu-item--non-interactive": ctx[6],
        ...ctx[18]
      })
    },
    {
      style: Object.entries(ctx[19]).map(func).concat([ctx[4]]).join(" ")
    },
    ctx[23] && ctx[1] ? { "aria-current": "page" } : {},
    !ctx[23] || ctx[8] ? { role: ctx[9] } : {},
    !ctx[23] && ctx[9] === "option" ? {
      "aria-selected": ctx[0] ? "true" : "false"
    } : {},
    !ctx[23] && (ctx[9] === "radio" || ctx[9] === "checkbox") ? {
      "aria-checked": ctx[16] && ctx[16].checked ? "true" : "false"
    } : {},
    !ctx[23] ? {
      "aria-disabled": ctx[10] ? "true" : "false"
    } : {},
    {
      "data-menu-item-skip-restore-focus": ctx[11] || void 0
    },
    { tabindex: ctx[21] },
    { href: ctx[12] },
    ctx[20],
    ctx[29]
  ];
  var switch_value = ctx[13];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[35](switch_instance);
    switch_instance.$on("click", ctx[15]);
    switch_instance.$on("keydown", ctx[27]);
    switch_instance.$on("SMUIGenericInput:mount", ctx[28]);
    switch_instance.$on("SMUIGenericInput:unmount", ctx[36]);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 670916479 ? get_spread_update(switch_instance_spread_levels, [
        dirty[0] & 16384 && { tag: ctx2[14] },
        dirty[0] & 121701479 && {
          use: [
            ...ctx2[6] ? [] : [
              [
                dist_default,
                {
                  ripple: !ctx2[16],
                  unbounded: false,
                  color: (ctx2[1] || ctx2[0]) && ctx2[5] == null ? "primary" : ctx2[5],
                  disabled: ctx2[10],
                  addClass: ctx2[24],
                  removeClass: ctx2[25],
                  addStyle: ctx2[26]
                }
              ]
            ],
            ctx2[22],
            ...ctx2[2]
          ]
        },
        dirty[0] & 8652619 && {
          class: classMap({
            [ctx2[3]]: true,
            "mdc-deprecated-list-item": !ctx2[8],
            "mdc-deprecated-list-item__wrapper": ctx2[8],
            "mdc-deprecated-list-item--activated": ctx2[1],
            "mdc-deprecated-list-item--selected": ctx2[0],
            "mdc-deprecated-list-item--disabled": ctx2[10],
            "mdc-menu-item--selected": !ctx2[23] && ctx2[9] === "menuitem" && ctx2[0],
            "smui-menu-item--non-interactive": ctx2[6],
            ...ctx2[18]
          })
        },
        dirty[0] & 524304 && {
          style: Object.entries(ctx2[19]).map(func).concat([ctx2[4]]).join(" ")
        },
        dirty[0] & 8388610 && get_spread_object(ctx2[23] && ctx2[1] ? { "aria-current": "page" } : {}),
        dirty[0] & 8389376 && get_spread_object(!ctx2[23] || ctx2[8] ? { role: ctx2[9] } : {}),
        dirty[0] & 8389121 && get_spread_object(!ctx2[23] && ctx2[9] === "option" ? {
          "aria-selected": ctx2[0] ? "true" : "false"
        } : {}),
        dirty[0] & 8454656 && get_spread_object(!ctx2[23] && (ctx2[9] === "radio" || ctx2[9] === "checkbox") ? {
          "aria-checked": ctx2[16] && ctx2[16].checked ? "true" : "false"
        } : {}),
        dirty[0] & 8389632 && get_spread_object(!ctx2[23] ? {
          "aria-disabled": ctx2[10] ? "true" : "false"
        } : {}),
        dirty[0] & 2048 && {
          "data-menu-item-skip-restore-focus": ctx2[11] || void 0
        },
        dirty[0] & 2097152 && { tabindex: ctx2[21] },
        dirty[0] & 4096 && { href: ctx2[12] },
        dirty[0] & 1048576 && get_spread_object(ctx2[20]),
        dirty[0] & 536870912 && get_spread_object(ctx2[29])
      ]) : {};
      if (dirty[0] & 128 | dirty[1] & 64) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[35](switch_instance);
          switch_instance.$on("click", ctx2[15]);
          switch_instance.$on("keydown", ctx2[27]);
          switch_instance.$on("SMUIGenericInput:mount", ctx2[28]);
          switch_instance.$on("SMUIGenericInput:unmount", ctx2[36]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[35](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
var func = ([name, value]) => `${name}: ${value};`;
function instance($$self, $$props, $$invalidate) {
  let tabindex;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "color",
    "nonInteractive",
    "ripple",
    "wrapper",
    "activated",
    "role",
    "selected",
    "disabled",
    "skipRestoreFocus",
    "tabindex",
    "inputId",
    "href",
    "component",
    "tag",
    "action",
    "getPrimaryText",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  var _a2;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { color = void 0 } = $$props;
  let { nonInteractive = (_a2 = getContext("SMUI:list:nonInteractive")) !== null && _a2 !== void 0 ? _a2 : false } = $$props;
  setContext("SMUI:list:nonInteractive", void 0);
  let { ripple = !nonInteractive } = $$props;
  let { wrapper = false } = $$props;
  let { activated = false } = $$props;
  let { role = wrapper ? "presentation" : getContext("SMUI:list:item:role") } = $$props;
  setContext("SMUI:list:item:role", void 0);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { skipRestoreFocus = false } = $$props;
  let { tabindex: tabindexProp = uninitializedValue } = $$props;
  let { inputId = "SMUI-form-field-list-" + counter++ } = $$props;
  let { href = void 0 } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let input;
  let addTabindexIfNoItemsSelectedRaf;
  let nav = getContext("SMUI:list:item:nav");
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav ? href ? "a" : "span" : "li" : void 0 } = $$props;
  setContext("SMUI:generic:input:props", { id: inputId });
  setContext("SMUI:separator:context", void 0);
  onMount(() => {
    if (!selected && !nonInteractive) {
      let first = true;
      let el = element2;
      while (el.previousSibling) {
        el = el.previousSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected;
      },
      set selected(value) {
        $$invalidate(0, selected = value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      get checked() {
        var _a3;
        return (_a3 = input && input.checked) !== null && _a3 !== void 0 ? _a3 : false;
      },
      set checked(value) {
        if (input) {
          $$invalidate(16, input.checked = !!value, input);
        }
      },
      get hasCheckbox() {
        return !!(input && "_smui_checkbox_accessor" in input);
      },
      get hasRadio() {
        return !!(input && "_smui_radio_accessor" in input);
      },
      activateRipple() {
        if (input) {
          input.activateRipple();
        }
      },
      deactivateRipple() {
        if (input) {
          input.deactivateRipple();
        }
      },
      getValue() {
        return $$restProps.value;
      },
      action,
      get tabindex() {
        return tabindex;
      },
      set tabindex(value) {
        $$invalidate(30, tabindexProp = value);
      },
      get disabled() {
        return disabled;
      },
      get activated() {
        return activated;
      },
      set activated(value) {
        $$invalidate(1, activated = value);
      }
    };
    dispatch(getElement(), "SMUIListItem:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIListItem:unmount", accessor);
    };
  });
  onDestroy(() => {
    if (addTabindexIfNoItemsSelectedRaf) {
      window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(18, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(18, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(19, internalStyles);
      } else {
        $$invalidate(19, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a3;
    return name in internalAttrs ? (_a3 = internalAttrs[name]) !== null && _a3 !== void 0 ? _a3 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(20, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(20, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function addTabindexIfNoItemsSelected() {
    let noneSelected = true;
    let el = element2.getElement();
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && tabindexAttr.value === "0") {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      $$invalidate(21, tabindex = 0);
    }
  }
  function handleKeydown2(e) {
    const isEnter = e.key === "Enter";
    const isSpace = e.key === "Space";
    if (isEnter || isSpace) {
      action(e);
    }
  }
  function handleInputMount(e) {
    if ("_smui_checkbox_accessor" in e.detail || "_smui_radio_accessor" in e.detail) {
      $$invalidate(16, input = e.detail);
    }
  }
  function action(e) {
    if (!disabled) {
      dispatch(getElement(), "SMUI:action", e);
    }
  }
  function getPrimaryText() {
    var _a3, _b2, _c;
    const element3 = getElement();
    const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return (_a3 = primaryText.textContent) !== null && _a3 !== void 0 ? _a3 : "";
    }
    const text = element3.querySelector(".mdc-deprecated-list-item__text");
    if (text) {
      return (_b2 = text.textContent) !== null && _b2 !== void 0 ? _b2 : "";
    }
    return (_c = element3.textContent) !== null && _c !== void 0 ? _c : "";
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(17, element2);
    });
  }
  const SMUIGenericInput_unmount_handler = () => $$invalidate(16, input = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$new_props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$new_props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("wrapper" in $$new_props)
      $$invalidate(8, wrapper = $$new_props.wrapper);
    if ("activated" in $$new_props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$new_props)
      $$invalidate(9, role = $$new_props.role);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$new_props)
      $$invalidate(11, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindex" in $$new_props)
      $$invalidate(30, tabindexProp = $$new_props.tabindex);
    if ("inputId" in $$new_props)
      $$invalidate(31, inputId = $$new_props.inputId);
    if ("href" in $$new_props)
      $$invalidate(12, href = $$new_props.href);
    if ("component" in $$new_props)
      $$invalidate(13, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(14, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    _a: _a2,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ripple: dist_default,
    SmuiElement: SmuiElement_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    wrapper,
    activated,
    role,
    selected,
    disabled,
    skipRestoreFocus,
    tabindexProp,
    inputId,
    href,
    element: element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    input,
    addTabindexIfNoItemsSelectedRaf,
    nav,
    component,
    tag,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    getAttr,
    addAttr,
    removeAttr,
    addTabindexIfNoItemsSelected,
    handleKeydown: handleKeydown2,
    handleInputMount,
    action,
    getPrimaryText,
    getElement,
    tabindex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a2 = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("wrapper" in $$props)
      $$invalidate(8, wrapper = $$new_props.wrapper);
    if ("activated" in $$props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$props)
      $$invalidate(9, role = $$new_props.role);
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$props)
      $$invalidate(11, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindexProp" in $$props)
      $$invalidate(30, tabindexProp = $$new_props.tabindexProp);
    if ("inputId" in $$props)
      $$invalidate(31, inputId = $$new_props.inputId);
    if ("href" in $$props)
      $$invalidate(12, href = $$new_props.href);
    if ("element" in $$props)
      $$invalidate(17, element2 = $$new_props.element);
    if ("internalClasses" in $$props)
      $$invalidate(18, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(19, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(20, internalAttrs = $$new_props.internalAttrs);
    if ("input" in $$props)
      $$invalidate(16, input = $$new_props.input);
    if ("addTabindexIfNoItemsSelectedRaf" in $$props)
      addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
    if ("nav" in $$props)
      $$invalidate(23, nav = $$new_props.nav);
    if ("component" in $$props)
      $$invalidate(13, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(14, tag = $$new_props.tag);
    if ("tabindex" in $$props)
      $$invalidate(21, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1073808449) {
      $:
        $$invalidate(21, tabindex = isUninitializedValue(tabindexProp) ? !nonInteractive && !disabled && (selected || input && input.checked) ? 0 : -1 : tabindexProp);
    }
  };
  return [
    selected,
    activated,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    wrapper,
    role,
    disabled,
    skipRestoreFocus,
    href,
    component,
    tag,
    action,
    input,
    element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    tabindex,
    forwardEvents,
    nav,
    addClass,
    removeClass,
    addStyle,
    handleKeydown2,
    handleInputMount,
    $$restProps,
    tabindexProp,
    inputId,
    getPrimaryText,
    getElement,
    slots,
    switch_instance_binding,
    SMUIGenericInput_unmount_handler,
    $$scope
  ];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment2,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        color: 5,
        nonInteractive: 6,
        ripple: 7,
        wrapper: 8,
        activated: 1,
        role: 9,
        selected: 0,
        disabled: 10,
        skipRestoreFocus: 11,
        tabindex: 30,
        inputId: 31,
        href: 12,
        component: 13,
        tag: 14,
        action: 15,
        getPrimaryText: 32,
        getElement: 33
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapper() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapper(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activated() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activated(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipRestoreFocus() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipRestoreFocus(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    return this.$$.ctx[15];
  }
  set action(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getPrimaryText() {
    return this.$$.ctx[32];
  }
  set getPrimaryText(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[33];
  }
  set getElement(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Item_default = Item;

// node_modules/@smui/list/dist/Text.js
var Text_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  tag: "span"
});

// node_modules/@smui/list/dist/PrimaryText.js
var PrimaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/SecondaryText.js
var SecondaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/Graphic.svelte
var file2 = "node_modules/@smui/list/dist/Graphic.svelte";
function create_fragment3(ctx) {
  let span;
  let span_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let span_levels = [
    {
      class: span_class_value = classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list-item__graphic": true,
        "mdc-menu__selection-group-icon": ctx[4]
      })
    },
    ctx[5]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[9](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[3].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & 2 && span_class_value !== (span_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-deprecated-list-item__graphic": true,
          "mdc-menu__selection-group-icon": ctx2[4]
        }))) && { class: span_class_value },
        dirty & 32 && ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Graphic", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    menuSelectionGroup,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("menuSelectionGroup" in $$props)
      $$invalidate(4, menuSelectionGroup = $$new_props.menuSelectionGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    menuSelectionGroup,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
var Graphic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Graphic",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Graphic_default = Graphic;

// node_modules/@smui/list/dist/Meta.js
var Meta_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  tag: "span"
});

// node_modules/@smui/list/dist/Label.svelte
var file3 = "node_modules/@smui/list/dist/Label.svelte";
function create_fragment4(ctx) {
  let label;
  let label_class_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let label_levels = [
    {
      class: label_class_value = classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list-item__text": true
      })
    },
    {
      for: label_for_value = ctx[4] ? ctx[4].id : void 0
    },
    ctx[5]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
      add_location(label, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[9](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, label, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[3].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 2 && label_class_value !== (label_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-deprecated-list-item__text": true
        }))) && { class: label_class_value },
        { for: label_for_value },
        dirty & 32 && ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  var _a2;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let inputProps = (_a2 = getContext("SMUI:generic:input:props")) !== null && _a2 !== void 0 ? _a2 : {};
  function getElement() {
    return element2;
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a: _a2,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    inputProps,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a2 = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("inputProps" in $$props)
      $$invalidate(4, inputProps = $$new_props.inputProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    inputProps,
    $$restProps,
    getElement,
    $$scope,
    slots,
    label_binding
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment4, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@smui/list/dist/Group.js
var Group_default = classAdderBuilder({
  class: "mdc-deprecated-list-group",
  tag: "div"
});

// node_modules/@smui/list/dist/Subheader.js
var Subheader_default = classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  tag: "h3"
});

// node_modules/@smui/list/dist/Separator.svelte
function create_fragment5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: ctx[8] },
    {
      use: [ctx[10], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-deprecated-list-divider": true,
        "mdc-deprecated-list-divider--padded": ctx[2],
        "mdc-deprecated-list-divider--inset": ctx[3],
        "mdc-deprecated-list-divider--inset-leading": ctx[4],
        "mdc-deprecated-list-divider--inset-trailing": ctx[5],
        "mdc-deprecated-list-divider--inset-padding": ctx[6]
      })
    },
    { role: "separator" },
    ctx[11]
  ];
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[13](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 3455 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 256 && { tag: ctx2[8] },
        dirty & 1025 && {
          use: [ctx2[10], ...ctx2[0]]
        },
        dirty & 126 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": ctx2[2],
            "mdc-deprecated-list-divider--inset": ctx2[3],
            "mdc-deprecated-list-divider--inset-leading": ctx2[4],
            "mdc-deprecated-list-divider--inset-trailing": ctx2[5],
            "mdc-deprecated-list-divider--inset-padding": ctx2[6]
          })
        },
        switch_instance_spread_levels[3],
        dirty & 2048 && get_spread_object(ctx2[11])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[13](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[13](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "padded",
    "inset",
    "insetLeading",
    "insetTrailing",
    "insetPadding",
    "component",
    "tag",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Separator", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { padded = false } = $$props;
  let { inset = false } = $$props;
  let { insetLeading = false } = $$props;
  let { insetTrailing = false } = $$props;
  let { insetPadding = false } = $$props;
  let element2;
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav || context !== "list" ? "hr" : "li" : void 0 } = $$props;
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("padded" in $$new_props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$new_props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$new_props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$new_props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$new_props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("component" in $$new_props)
      $$invalidate(7, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(8, tag = $$new_props.tag);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    SmuiElement: SmuiElement_default,
    forwardEvents,
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    element: element2,
    nav,
    context,
    component,
    tag,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("padded" in $$props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("context" in $$props)
      context = $$new_props.context;
    if ("component" in $$props)
      $$invalidate(7, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(8, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    component,
    tag,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    switch_instance_binding
  ];
}
var Separator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment5, safe_not_equal, {
      use: 0,
      class: 1,
      padded: 2,
      inset: 3,
      insetLeading: 4,
      insetTrailing: 5,
      insetPadding: 6,
      component: 7,
      tag: 8,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Separator",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padded() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padded(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetLeading() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetLeading(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetTrailing() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetTrailing(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetPadding() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetPadding(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Separator_default = Separator;

// node_modules/@smui/list/dist/index.js
var dist_default2 = List_default;

export {
  cssClasses,
  numbers,
  MDCListFoundation,
  MDCList,
  Item_default,
  Text_default,
  PrimaryText_default,
  SecondaryText_default,
  Graphic_default,
  Meta_default,
  Label_default,
  Group_default,
  Subheader_default,
  Separator_default,
  dist_default2 as dist_default
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=chunk-MQARFSRV.js.map
