import {
  classAdderBuilder
} from "./chunk-HQIZ4DBT.js";
import "./chunk-ZSIG2HMK.js";
import {
  classMap,
  dispatch,
  dist_default,
  forwardEventsBuilder,
  useActions
} from "./chunk-QH7DRB7N.js";
import "./chunk-3L2CPHNC.js";
import {
  writable
} from "./chunk-RAXL67E4.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-NLMIYH64.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@smui-extra/accordion/dist/Accordion.svelte
var file = "node_modules/@smui-extra/accordion/dist/Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "smui-accordion": true,
        "smui-accordion--multiple": ctx[2],
        "smui-accordion--with-open-dialog": ctx[4]
      })
    },
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[14](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[5].call(null, div)),
          listen_dev(div, "SMUIAccordionPanel:mount", ctx[6], false, false, false),
          listen_dev(div, "SMUIAccordionPanel:unmount", ctx[7], false, false, false),
          listen_dev(div, "SMUIAccordionPanel:activate", ctx[8], false, false, false),
          listen_dev(div, "SMUIAccordionPanel:opening", ctx[9], false, false, false),
          listen_dev(div, "SMUIDialog:opening", ctx[15], true, false, false),
          listen_dev(div, "SMUIDialog:closed", ctx[16], true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 22 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "smui-accordion": true,
          "smui-accordion--multiple": ctx2[2],
          "smui-accordion--with-open-dialog": ctx2[4]
        }))) && { class: div_class_value },
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "multiple", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { multiple = false } = $$props;
  let element2;
  let panelAccessorSet = /* @__PURE__ */ new Set();
  let withOpenDialog = false;
  function handlePanelMount(event) {
    const accessor = event.detail;
    event.stopPropagation();
    if (!multiple && accessor.open) {
      const currentOpen = Array.from(panelAccessorSet).find((accessor2) => accessor2.open);
      if (currentOpen) {
        currentOpen.setOpen(false);
      }
    }
    panelAccessorSet.add(accessor);
  }
  function handlePanelUnmount(event) {
    const accessor = event.detail;
    if (!panelAccessorSet.has(accessor)) {
      return;
    }
    event.stopPropagation();
    panelAccessorSet.delete(accessor);
  }
  function handlePanelActivate(event) {
    const { accessor } = event.detail;
    if (!panelAccessorSet.has(accessor)) {
      return;
    }
    if (!multiple && !accessor.open) {
      const currentOpen = Array.from(panelAccessorSet).find((accessor2) => accessor2.open);
      if (currentOpen) {
        currentOpen.setOpen(false);
      }
    }
    accessor.setOpen(!accessor.open);
  }
  function handlePanelOpening(event) {
    const { accessor } = event.detail;
    if (!panelAccessorSet.has(accessor)) {
      return;
    }
    if (!multiple) {
      const otherOpen = Array.from(panelAccessorSet).filter((checkAccessor) => checkAccessor !== accessor && checkAccessor.open);
      otherOpen.forEach((accessor2) => accessor2.setOpen(false));
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(3, element2);
    });
  }
  const SMUIDialog_opening_handler = () => $$invalidate(4, withOpenDialog = true);
  const SMUIDialog_closed_handler = () => $$invalidate(4, withOpenDialog = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("multiple" in $$new_props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    multiple,
    element: element2,
    panelAccessorSet,
    withOpenDialog,
    handlePanelMount,
    handlePanelUnmount,
    handlePanelActivate,
    handlePanelOpening,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("multiple" in $$props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("element" in $$props)
      $$invalidate(3, element2 = $$new_props.element);
    if ("panelAccessorSet" in $$props)
      panelAccessorSet = $$new_props.panelAccessorSet;
    if ("withOpenDialog" in $$props)
      $$invalidate(4, withOpenDialog = $$new_props.withOpenDialog);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    multiple,
    element2,
    withOpenDialog,
    forwardEvents,
    handlePanelMount,
    handlePanelUnmount,
    handlePanelActivate,
    handlePanelOpening,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding,
    SMUIDialog_opening_handler,
    SMUIDialog_closed_handler
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      use: 0,
      class: 1,
      multiple: 2,
      getElement: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/@smui/paper/dist/Paper.svelte
var file2 = "node_modules/@smui/paper/dist/Paper.svelte";
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "smui-paper": true,
        "smui-paper--raised": ctx[2] === "raised",
        "smui-paper--unelevated": ctx[2] === "unelevated",
        "smui-paper--outlined": ctx[2] === "outlined",
        ["smui-paper--elevation-z" + ctx[5]]: ctx[5] !== 0 && ctx[2] === "raised",
        "smui-paper--rounded": !ctx[3],
        ["smui-paper--color-" + ctx[4]]: ctx[4] !== "default",
        "smui-paper-transition": ctx[6]
      })
    },
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[13](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[8].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 126 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "smui-paper": true,
          "smui-paper--raised": ctx2[2] === "raised",
          "smui-paper--unelevated": ctx2[2] === "unelevated",
          "smui-paper--outlined": ctx2[2] === "outlined",
          ["smui-paper--elevation-z" + ctx2[5]]: ctx2[5] !== 0 && ctx2[2] === "raised",
          "smui-paper--rounded": !ctx2[3],
          ["smui-paper--color-" + ctx2[4]]: ctx2[4] !== "default",
          "smui-paper-transition": ctx2[6]
        }))) && { class: div_class_value },
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "variant", "square", "color", "elevation", "transition", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paper", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = "raised" } = $$props;
  let { square = false } = $$props;
  let { color = "default" } = $$props;
  let { elevation = 1 } = $$props;
  let { transition = false } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("variant" in $$new_props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("square" in $$new_props)
      $$invalidate(3, square = $$new_props.square);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("elevation" in $$new_props)
      $$invalidate(5, elevation = $$new_props.elevation);
    if ("transition" in $$new_props)
      $$invalidate(6, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    variant,
    square,
    color,
    elevation,
    transition,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("variant" in $$props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("square" in $$props)
      $$invalidate(3, square = $$new_props.square);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("elevation" in $$props)
      $$invalidate(5, elevation = $$new_props.elevation);
    if ("transition" in $$props)
      $$invalidate(6, transition = $$new_props.transition);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    variant,
    square,
    color,
    elevation,
    transition,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
var Paper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      use: 0,
      class: 1,
      variant: 2,
      square: 3,
      color: 4,
      elevation: 5,
      transition: 6,
      getElement: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paper",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get square() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set square(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elevation() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elevation(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[10];
  }
  set getElement(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paper_default = Paper;

// node_modules/@smui/paper/dist/Content.js
var Content_default = classAdderBuilder({
  class: "smui-paper__content",
  tag: "div"
});

// node_modules/@smui/paper/dist/Title.js
var Title_default = classAdderBuilder({
  class: "smui-paper__title",
  tag: "h5"
});

// node_modules/@smui/paper/dist/Subtitle.js
var Subtitle_default = classAdderBuilder({
  class: "smui-paper__subtitle",
  tag: "h6"
});

// node_modules/@smui/paper/dist/index.js
var dist_default2 = Paper_default;

// node_modules/@smui-extra/accordion/dist/Panel.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[23].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <Paper   bind:this={element}   use={usePass}   class={classMap({     [className]: true,     'smui-accordion__panel': true,     'smui-accordion__panel--open': open,     'smui-accordion__panel--opened': opened,     'smui-accordion__panel--disabled': disabled,     'smui-accordion__panel--non-interactive': nonInteractive,     'smui-accordion__panel--raised': variant === 'raised',     'smui-accordion__panel--extend': extend,     ['smui-accordion__panel--elevation-z' +     (extend && open ? extendedElevation : elevation)]:       (elevation !== 0 && variant === 'raised') ||       (extendedElevation !== 0 && variant === 'raised' && extend && open),   })}   {color}   variant={variant === 'raised' ? 'unelevated' : variant}   on:SMUIAccordionHeader:activate={handleHeaderActivate}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let paper;
  let current;
  const paper_spread_levels = [
    { use: ctx[11] },
    {
      class: classMap({
        [ctx[1]]: true,
        "smui-accordion__panel": true,
        "smui-accordion__panel--open": ctx[0],
        "smui-accordion__panel--opened": ctx[10],
        "smui-accordion__panel--disabled": ctx[5],
        "smui-accordion__panel--non-interactive": ctx[6],
        "smui-accordion__panel--raised": ctx[2] === "raised",
        "smui-accordion__panel--extend": ctx[7],
        ["smui-accordion__panel--elevation-z" + (ctx[7] && ctx[0] ? ctx[8] : ctx[4])]: ctx[4] !== 0 && ctx[2] === "raised" || ctx[8] !== 0 && ctx[2] === "raised" && ctx[7] && ctx[0]
      })
    },
    { color: ctx[3] },
    {
      variant: ctx[2] === "raised" ? "unelevated" : ctx[2]
    },
    ctx[16]
  ];
  let paper_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < paper_spread_levels.length; i += 1) {
    paper_props = assign(paper_props, paper_spread_levels[i]);
  }
  paper = new dist_default2({ props: paper_props, $$inline: true });
  ctx[24](paper);
  paper.$on("SMUIAccordionHeader:activate", ctx[15]);
  const block = {
    c: function create() {
      create_component(paper.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(paper, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const paper_changes = dirty & 69119 ? get_spread_update(paper_spread_levels, [
        dirty & 2048 && { use: ctx2[11] },
        dirty & 1527 && {
          class: classMap({
            [ctx2[1]]: true,
            "smui-accordion__panel": true,
            "smui-accordion__panel--open": ctx2[0],
            "smui-accordion__panel--opened": ctx2[10],
            "smui-accordion__panel--disabled": ctx2[5],
            "smui-accordion__panel--non-interactive": ctx2[6],
            "smui-accordion__panel--raised": ctx2[2] === "raised",
            "smui-accordion__panel--extend": ctx2[7],
            ["smui-accordion__panel--elevation-z" + (ctx2[7] && ctx2[0] ? ctx2[8] : ctx2[4])]: ctx2[4] !== 0 && ctx2[2] === "raised" || ctx2[8] !== 0 && ctx2[2] === "raised" && ctx2[7] && ctx2[0]
          })
        },
        dirty & 8 && { color: ctx2[3] },
        dirty & 4 && {
          variant: ctx2[2] === "raised" ? "unelevated" : ctx2[2]
        },
        dirty & 65536 && get_spread_object(ctx2[16])
      ]) : {};
      if (dirty & 33554432) {
        paper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paper.$set(paper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[24](null);
      destroy_component(paper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let usePass;
  const omit_props_names = [
    "use",
    "class",
    "variant",
    "color",
    "elevation",
    "open",
    "disabled",
    "nonInteractive",
    "extend",
    "extendedElevation",
    "isOpen",
    "setOpen",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openStore;
  let $nonInteractiveStore;
  let $disabledStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Panel", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { variant = "raised" } = $$props;
  let { color = "default" } = $$props;
  let { elevation = 1 } = $$props;
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { nonInteractive = false } = $$props;
  let { extend = false } = $$props;
  let { extendedElevation = 3 } = $$props;
  let element2;
  let accessor;
  let opened = open;
  const disabledStore = writable(disabled);
  validate_store(disabledStore, "disabledStore");
  component_subscribe($$self, disabledStore, (value) => $$invalidate(28, $disabledStore = value));
  setContext("SMUI:accordion:panel:disabled", disabledStore);
  const nonInteractiveStore = writable(nonInteractive);
  validate_store(nonInteractiveStore, "nonInteractiveStore");
  component_subscribe($$self, nonInteractiveStore, (value) => $$invalidate(27, $nonInteractiveStore = value));
  setContext("SMUI:accordion:panel:nonInteractive", nonInteractiveStore);
  const openStore = writable(open);
  validate_store(openStore, "openStore");
  component_subscribe($$self, openStore, (value) => $$invalidate(26, $openStore = value));
  setContext("SMUI:accordion:panel:open", openStore);
  let previousOpen = open;
  onMount(() => {
    $$invalidate(21, accessor = {
      get open() {
        return open;
      },
      setOpen
    });
    Array.from(getElement().children).forEach((child) => {
      if (child.classList.contains("smui-paper__content")) {
        const content = child;
        content.setAttribute("aria-hidden", open ? "false" : "true");
      }
    });
    dispatch(getElement(), "SMUIAccordionPanel:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIAccordionPanel:unmount", accessor);
    };
  });
  function handleHeaderActivate(event) {
    event.stopPropagation();
    if (disabled || nonInteractive) {
      return;
    }
    dispatch(getElement(), "SMUIAccordionPanel:activate", { accessor, event });
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function getElement() {
    return element2.getElement();
  }
  function paper_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(17, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("variant" in $$new_props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("color" in $$new_props)
      $$invalidate(3, color = $$new_props.color);
    if ("elevation" in $$new_props)
      $$invalidate(4, elevation = $$new_props.elevation);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("nonInteractive" in $$new_props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("extend" in $$new_props)
      $$invalidate(7, extend = $$new_props.extend);
    if ("extendedElevation" in $$new_props)
      $$invalidate(8, extendedElevation = $$new_props.extendedElevation);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Paper: dist_default2,
    forwardEvents,
    use,
    className,
    variant,
    color,
    elevation,
    open,
    disabled,
    nonInteractive,
    extend,
    extendedElevation,
    element: element2,
    accessor,
    opened,
    disabledStore,
    nonInteractiveStore,
    openStore,
    previousOpen,
    handleHeaderActivate,
    isOpen,
    setOpen,
    getElement,
    usePass,
    $openStore,
    $nonInteractiveStore,
    $disabledStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(17, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("variant" in $$props)
      $$invalidate(2, variant = $$new_props.variant);
    if ("color" in $$props)
      $$invalidate(3, color = $$new_props.color);
    if ("elevation" in $$props)
      $$invalidate(4, elevation = $$new_props.elevation);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("nonInteractive" in $$props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("extend" in $$props)
      $$invalidate(7, extend = $$new_props.extend);
    if ("extendedElevation" in $$props)
      $$invalidate(8, extendedElevation = $$new_props.extendedElevation);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("accessor" in $$props)
      $$invalidate(21, accessor = $$new_props.accessor);
    if ("opened" in $$props)
      $$invalidate(10, opened = $$new_props.opened);
    if ("previousOpen" in $$props)
      $$invalidate(22, previousOpen = $$new_props.previousOpen);
    if ("usePass" in $$props)
      $$invalidate(11, usePass = $$new_props.usePass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 131072) {
      $:
        $$invalidate(11, usePass = [forwardEvents, ...use]);
    }
    if ($$self.$$.dirty & 32) {
      $:
        set_store_value(disabledStore, $disabledStore = disabled, $disabledStore);
    }
    if ($$self.$$.dirty & 64) {
      $:
        set_store_value(nonInteractiveStore, $nonInteractiveStore = nonInteractive, $nonInteractiveStore);
    }
    if ($$self.$$.dirty & 1) {
      $:
        set_store_value(openStore, $openStore = open, $openStore);
    }
    if ($$self.$$.dirty & 6291457) {
      $:
        if (previousOpen !== open) {
          $$invalidate(22, previousOpen = open);
          Array.from(getElement().children).forEach((child) => {
            if (child.classList.contains("smui-paper__content")) {
              const content = child;
              if (open) {
                content.classList.add("smui-accordion__content--no-transition");
                content.classList.add("smui-accordion__content--force-open");
                const { height } = content.getBoundingClientRect();
                content.classList.remove("smui-accordion__content--force-open");
                content.getBoundingClientRect();
                content.classList.remove("smui-accordion__content--no-transition");
                content.style.height = height + "px";
                content.addEventListener(
                  "transitionend",
                  () => {
                    if (content) {
                      content.style.height = "";
                    }
                    $$invalidate(10, opened = open);
                    dispatch(getElement(), "SMUIAccordionPanel:opened", { accessor });
                  },
                  { once: true }
                );
              } else {
                content.style.height = content.getBoundingClientRect().height + "px";
                content.getBoundingClientRect();
                requestAnimationFrame(() => {
                  if (content) {
                    content.style.height = "";
                  }
                  dispatch(getElement(), "SMUIAccordionPanel:closed", { accessor });
                });
                $$invalidate(10, opened = false);
              }
              content.setAttribute("aria-hidden", open ? "false" : "true");
            }
          });
          dispatch(
            getElement(),
            open ? "SMUIAccordionPanel:opening" : "SMUIAccordionPanel:closing",
            { accessor }
          );
        }
    }
  };
  return [
    open,
    className,
    variant,
    color,
    elevation,
    disabled,
    nonInteractive,
    extend,
    extendedElevation,
    element2,
    opened,
    usePass,
    disabledStore,
    nonInteractiveStore,
    openStore,
    handleHeaderActivate,
    $$restProps,
    use,
    isOpen,
    setOpen,
    getElement,
    accessor,
    previousOpen,
    slots,
    paper_binding,
    $$scope
  ];
}
var Panel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      use: 17,
      class: 1,
      variant: 2,
      color: 3,
      elevation: 4,
      open: 0,
      disabled: 5,
      nonInteractive: 6,
      extend: 7,
      extendedElevation: 8,
      isOpen: 18,
      setOpen: 19,
      getElement: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Panel",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get elevation() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elevation(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extend() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extend(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extendedElevation() {
    throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extendedElevation(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[18];
  }
  set isOpen(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[19];
  }
  set setOpen(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[20];
  }
  set getElement(value) {
    throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Panel_default = Panel;

// node_modules/@smui-extra/accordion/dist/Header.svelte
var file3 = "node_modules/@smui-extra/accordion/dist/Header.svelte";
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
var get_description_slot_changes = (dirty) => ({});
var get_description_slot_context = (ctx) => ({});
function create_if_block_2(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "smui-accordion__header__ripple");
      add_location(div, file3, 30, 4, 672);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(30:2) {#if ripple}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current;
  const description_slot_template = ctx[23].description;
  const description_slot = create_slot(description_slot_template, ctx, ctx[22], get_description_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (description_slot)
        description_slot.c();
      attr_dev(div, "class", "smui-accordion__header__description");
      add_location(div, file3, 41, 4, 945);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (description_slot) {
        description_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (description_slot) {
        if (description_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(description_slot_template, ctx2[22], dirty, get_description_slot_changes),
            get_description_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(description_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(description_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (description_slot)
        description_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(41:2) {#if $$slots.description}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[23].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[22], get_icon_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      attr_dev(div, "class", "smui-accordion__header__icon");
      add_location(div, file3, 46, 4, 1073);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(icon_slot_template, ctx2[22], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(46:2) {#if $$slots.icon}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let t2;
  let div1_class_value;
  let div1_style_value;
  let div1_tabindex_value;
  let div1_aria_expanded_value;
  let useActions_action;
  let forwardEvents_action;
  let Ripple_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_2(ctx);
  const default_slot_template = ctx[23].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[22], null);
  let if_block1 = ctx[20].description && create_if_block_1(ctx);
  let if_block2 = ctx[20].icon && create_if_block(ctx);
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [ctx[1]]: true,
        "smui-accordion__header": true,
        ...ctx[5]
      })
    },
    {
      style: div1_style_value = Object.entries(ctx[6]).map(func).concat([ctx[2]]).join(" ")
    },
    { role: "button" },
    {
      tabindex: div1_tabindex_value = ctx[7] ? -1 : 0
    },
    {
      "aria-expanded": div1_aria_expanded_value = ctx[9] ? "true" : "false"
    },
    ctx[19]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr_dev(div0, "class", div0_class_value = classMap({
        "smui-accordion__header__title": true,
        "smui-accordion__header__title--with-description": ctx[20].description
      }));
      add_location(div0, file3, 32, 2, 729);
      set_attributes(div1, div1_data);
      add_location(div1, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      ctx[24](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div1, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, div1)),
          action_destroyer(Ripple_action = dist_default.call(null, div1, {
            ripple: ctx[3],
            unbounded: false,
            surface: !ctx[7],
            disabled: ctx[8] || ctx[7],
            addClass: ctx[16],
            removeClass: ctx[17],
            addStyle: ctx[18]
          })),
          listen_dev(div1, "click", ctx[14], false, false, false),
          listen_dev(div1, "keydown", ctx[15], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(default_slot_template, ctx2[22], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1048576 && div0_class_value !== (div0_class_value = classMap({
        "smui-accordion__header__title": true,
        "smui-accordion__header__title--with-description": ctx2[20].description
      }))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (ctx2[20].description) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1048576) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[20].icon) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 1048576) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty & 34 && div1_class_value !== (div1_class_value = classMap({
          [ctx2[1]]: true,
          "smui-accordion__header": true,
          ...ctx2[5]
        }))) && { class: div1_class_value },
        (!current || dirty & 68 && div1_style_value !== (div1_style_value = Object.entries(ctx2[6]).map(func).concat([ctx2[2]]).join(" "))) && { style: div1_style_value },
        { role: "button" },
        (!current || dirty & 128 && div1_tabindex_value !== (div1_tabindex_value = ctx2[7] ? -1 : 0)) && { tabindex: div1_tabindex_value },
        (!current || dirty & 512 && div1_aria_expanded_value !== (div1_aria_expanded_value = ctx2[9] ? "true" : "false")) && {
          "aria-expanded": div1_aria_expanded_value
        },
        dirty & 524288 && ctx2[19]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
      if (Ripple_action && is_function(Ripple_action.update) && dirty & 392)
        Ripple_action.update.call(null, {
          ripple: ctx2[3],
          unbounded: false,
          surface: !ctx2[7],
          disabled: ctx2[8] || ctx2[7],
          addClass: ctx2[16],
          removeClass: ctx2[17],
          addStyle: ctx2[18]
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "style", "ripple", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $nonInteractive;
  let $disabled;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["default", "description", "icon"]);
  const $$slots = compute_slots(slots);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  const disabled = getContext("SMUI:accordion:panel:disabled");
  validate_store(disabled, "disabled");
  component_subscribe($$self, disabled, (value) => $$invalidate(8, $disabled = value));
  const nonInteractive = getContext("SMUI:accordion:panel:nonInteractive");
  validate_store(nonInteractive, "nonInteractive");
  component_subscribe($$self, nonInteractive, (value) => $$invalidate(7, $nonInteractive = value));
  const open = getContext("SMUI:accordion:panel:open");
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(9, $open = value));
  function handleClick(event) {
    event = event;
    if (event.button === 0) {
      dispatch(getElement(), "SMUIAccordionHeader:activate", { event });
    }
  }
  function handleKeyDown(event) {
    event = event;
    if (event.key === "Enter") {
      dispatch(getElement(), "SMUIAccordionHeader:activate", { event });
    }
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(6, internalStyles);
      } else {
        $$invalidate(6, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getElement() {
    return element2;
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    Ripple: dist_default,
    forwardEvents,
    use,
    className,
    style,
    ripple,
    element: element2,
    internalClasses,
    internalStyles,
    disabled,
    nonInteractive,
    open,
    handleClick,
    handleKeyDown,
    addClass,
    removeClass,
    addStyle,
    getElement,
    $nonInteractive,
    $disabled,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("internalClasses" in $$props)
      $$invalidate(5, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(6, internalStyles = $$new_props.internalStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    ripple,
    element2,
    internalClasses,
    internalStyles,
    $nonInteractive,
    $disabled,
    $open,
    forwardEvents,
    disabled,
    nonInteractive,
    open,
    handleClick,
    handleKeyDown,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    $$slots,
    getElement,
    $$scope,
    slots,
    div1_binding
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      ripple: 3,
      getElement: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[21];
  }
  set getElement(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/@smui-extra/accordion/dist/index.js
var dist_default3 = Accordion_default;
export {
  Content_default as Content,
  Header_default as Header,
  Panel_default as Panel,
  dist_default3 as default
};
//# sourceMappingURL=@smui-extra_accordion.js.map
