import {
  Graphic_default,
  Item_default,
  MDCList,
  MDCListFoundation,
  cssClasses,
  dist_default as dist_default2,
  numbers
} from "./chunk-MQARFSRV.js";
import {
  MDCFloatingLabel,
  MDCLineRipple,
  MDCNotchedOutline,
  dist_default as dist_default3,
  dist_default2 as dist_default4,
  dist_default3 as dist_default5
} from "./chunk-PYNMXI5K.js";
import {
  classAdderBuilder
} from "./chunk-HQIZ4DBT.js";
import "./chunk-ZSIG2HMK.js";
import {
  KEY,
  MDCComponent,
  MDCFoundation,
  MDCRipple,
  MDCRippleFoundation,
  classMap,
  closest,
  dispatch,
  dist_default,
  exclude,
  forwardEventsBuilder,
  normalizeKey,
  ponyfill_exports,
  prefixFilter,
  useActions
} from "./chunk-QH7DRB7N.js";
import {
  __assign,
  __extends,
  __values
} from "./chunk-3L2CPHNC.js";
import {
  writable
} from "./chunk-RAXL67E4.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-NLMIYH64.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@material/menu-surface/constants.js
var cssClasses2 = {
  ANCHOR: "mdc-menu-surface--anchor",
  ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
  ANIMATING_OPEN: "mdc-menu-surface--animating-open",
  FIXED: "mdc-menu-surface--fixed",
  IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
  OPEN: "mdc-menu-surface--open",
  ROOT: "mdc-menu-surface"
};
var strings = {
  CLOSED_EVENT: "MDCMenuSurface:closed",
  CLOSING_EVENT: "MDCMenuSurface:closing",
  OPENED_EVENT: "MDCMenuSurface:opened",
  OPENING_EVENT: "MDCMenuSurface:opening",
  FOCUSABLE_ELEMENTS: [
    "button:not(:disabled)",
    '[href]:not([aria-disabled="true"])',
    "input:not(:disabled)",
    "select:not(:disabled)",
    "textarea:not(:disabled)",
    '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  ].join(", ")
};
var numbers2 = {
  TRANSITION_OPEN_DURATION: 120,
  TRANSITION_CLOSE_DURATION: 75,
  MARGIN_TO_EDGE: 32,
  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
  TOUCH_EVENT_WAIT_MS: 30
};
var CornerBit;
(function(CornerBit2) {
  CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
  CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
  CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
  CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
var Corner;
(function(Corner2) {
  Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
  Corner2[Corner2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
  Corner2[Corner2["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
  Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
  Corner2[Corner2["TOP_START"] = 8] = "TOP_START";
  Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
  Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
  Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));

// node_modules/@material/menu-surface/foundation.js
var MDCMenuSurfaceFoundation = function(_super) {
  __extends(MDCMenuSurfaceFoundation2, _super);
  function MDCMenuSurfaceFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation2.defaultAdapter), adapter)) || this;
    _this.isSurfaceOpen = false;
    _this.isQuickOpen = false;
    _this.isHoistedElement = false;
    _this.isFixedPosition = false;
    _this.isHorizontallyCenteredOnViewport = false;
    _this.maxHeight = 0;
    _this.openBottomBias = 0;
    _this.openAnimationEndTimerId = 0;
    _this.closeAnimationEndTimerId = 0;
    _this.animationRequestId = 0;
    _this.anchorCorner = Corner.TOP_START;
    _this.originCorner = Corner.TOP_START;
    _this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };
    _this.position = { x: 0, y: 0 };
    return _this;
  }
  Object.defineProperty(MDCMenuSurfaceFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "numbers", {
    get: function() {
      return numbers2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "Corner", {
    get: function() {
      return Corner;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        hasAnchor: function() {
          return false;
        },
        isElementInContainer: function() {
          return false;
        },
        isFocused: function() {
          return false;
        },
        isRtl: function() {
          return false;
        },
        getInnerDimensions: function() {
          return { height: 0, width: 0 };
        },
        getAnchorDimensions: function() {
          return null;
        },
        getWindowDimensions: function() {
          return { height: 0, width: 0 };
        },
        getBodyDimensions: function() {
          return { height: 0, width: 0 };
        },
        getWindowScroll: function() {
          return { x: 0, y: 0 };
        },
        setPosition: function() {
          return void 0;
        },
        setMaxHeight: function() {
          return void 0;
        },
        setTransformOrigin: function() {
          return void 0;
        },
        saveFocus: function() {
          return void 0;
        },
        restoreFocus: function() {
          return void 0;
        },
        notifyClose: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        },
        notifyOpen: function() {
          return void 0;
        },
        notifyOpening: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuSurfaceFoundation2.prototype.init = function() {
    var _a = MDCMenuSurfaceFoundation2.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
    if (!this.adapter.hasClass(ROOT)) {
      throw new Error(ROOT + " class required in root element.");
    }
    if (this.adapter.hasClass(OPEN)) {
      this.isSurfaceOpen = true;
    }
  };
  MDCMenuSurfaceFoundation2.prototype.destroy = function() {
    clearTimeout(this.openAnimationEndTimerId);
    clearTimeout(this.closeAnimationEndTimerId);
    cancelAnimationFrame(this.animationRequestId);
  };
  MDCMenuSurfaceFoundation2.prototype.setAnchorCorner = function(corner) {
    this.anchorCorner = corner;
  };
  MDCMenuSurfaceFoundation2.prototype.flipCornerHorizontally = function() {
    this.originCorner = this.originCorner ^ CornerBit.RIGHT;
  };
  MDCMenuSurfaceFoundation2.prototype.setAnchorMargin = function(margin) {
    this.anchorMargin.top = margin.top || 0;
    this.anchorMargin.right = margin.right || 0;
    this.anchorMargin.bottom = margin.bottom || 0;
    this.anchorMargin.left = margin.left || 0;
  };
  MDCMenuSurfaceFoundation2.prototype.setIsHoisted = function(isHoisted) {
    this.isHoistedElement = isHoisted;
  };
  MDCMenuSurfaceFoundation2.prototype.setFixedPosition = function(isFixedPosition) {
    this.isFixedPosition = isFixedPosition;
  };
  MDCMenuSurfaceFoundation2.prototype.isFixed = function() {
    return this.isFixedPosition;
  };
  MDCMenuSurfaceFoundation2.prototype.setAbsolutePosition = function(x, y) {
    this.position.x = this.isFinite(x) ? x : 0;
    this.position.y = this.isFinite(y) ? y : 0;
  };
  MDCMenuSurfaceFoundation2.prototype.setIsHorizontallyCenteredOnViewport = function(isCentered) {
    this.isHorizontallyCenteredOnViewport = isCentered;
  };
  MDCMenuSurfaceFoundation2.prototype.setQuickOpen = function(quickOpen) {
    this.isQuickOpen = quickOpen;
  };
  MDCMenuSurfaceFoundation2.prototype.setMaxHeight = function(maxHeight) {
    this.maxHeight = maxHeight;
  };
  MDCMenuSurfaceFoundation2.prototype.setOpenBottomBias = function(bias) {
    this.openBottomBias = bias;
  };
  MDCMenuSurfaceFoundation2.prototype.isOpen = function() {
    return this.isSurfaceOpen;
  };
  MDCMenuSurfaceFoundation2.prototype.open = function() {
    var _this = this;
    if (this.isSurfaceOpen) {
      return;
    }
    this.adapter.notifyOpening();
    this.adapter.saveFocus();
    if (this.isQuickOpen) {
      this.isSurfaceOpen = true;
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      this.dimensions = this.adapter.getInnerDimensions();
      this.autoposition();
      this.adapter.notifyOpen();
    } else {
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
      this.animationRequestId = requestAnimationFrame(function() {
        _this.dimensions = _this.adapter.getInnerDimensions();
        _this.autoposition();
        _this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        _this.openAnimationEndTimerId = setTimeout(function() {
          _this.openAnimationEndTimerId = 0;
          _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
          _this.adapter.notifyOpen();
        }, numbers2.TRANSITION_OPEN_DURATION);
      });
      this.isSurfaceOpen = true;
    }
  };
  MDCMenuSurfaceFoundation2.prototype.close = function(skipRestoreFocus) {
    var _this = this;
    if (skipRestoreFocus === void 0) {
      skipRestoreFocus = false;
    }
    if (!this.isSurfaceOpen) {
      return;
    }
    this.adapter.notifyClosing();
    if (this.isQuickOpen) {
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
      this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      this.adapter.notifyClose();
      return;
    }
    this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
    requestAnimationFrame(function() {
      _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      _this.closeAnimationEndTimerId = setTimeout(function() {
        _this.closeAnimationEndTimerId = 0;
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
        _this.adapter.notifyClose();
      }, numbers2.TRANSITION_CLOSE_DURATION);
    });
    this.isSurfaceOpen = false;
    if (!skipRestoreFocus) {
      this.maybeRestoreFocus();
    }
  };
  MDCMenuSurfaceFoundation2.prototype.handleBodyClick = function(evt) {
    var el = evt.target;
    if (this.adapter.isElementInContainer(el)) {
      return;
    }
    this.close();
  };
  MDCMenuSurfaceFoundation2.prototype.handleKeydown = function(evt) {
    var keyCode = evt.keyCode, key = evt.key;
    var isEscape = key === "Escape" || keyCode === 27;
    if (isEscape) {
      this.close();
    }
  };
  MDCMenuSurfaceFoundation2.prototype.autoposition = function() {
    var _a;
    this.measurements = this.getAutoLayoutmeasurements();
    var corner = this.getoriginCorner();
    var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
    var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
    var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
    var horizontalOffset = this.getHorizontalOriginOffset(corner);
    var verticalOffset = this.getVerticalOriginOffset(corner);
    var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
    var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a);
    if (anchorSize.width / surfaceSize.width > numbers2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
      horizontalAlignment = "center";
    }
    if (this.isHoistedElement || this.isFixedPosition) {
      this.adjustPositionForHoistedElement(position);
    }
    this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
    this.adapter.setPosition(position);
    this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
    if (!this.hasBit(corner, CornerBit.BOTTOM)) {
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
    }
  };
  MDCMenuSurfaceFoundation2.prototype.getAutoLayoutmeasurements = function() {
    var anchorRect = this.adapter.getAnchorDimensions();
    var bodySize = this.adapter.getBodyDimensions();
    var viewportSize = this.adapter.getWindowDimensions();
    var windowScroll = this.adapter.getWindowScroll();
    if (!anchorRect) {
      anchorRect = {
        top: this.position.y,
        right: this.position.x,
        bottom: this.position.y,
        left: this.position.x,
        width: 0,
        height: 0
      };
    }
    return {
      anchorSize: anchorRect,
      bodySize,
      surfaceSize: this.dimensions,
      viewportDistance: {
        top: anchorRect.top,
        right: viewportSize.width - anchorRect.right,
        bottom: viewportSize.height - anchorRect.bottom,
        left: anchorRect.left
      },
      viewportSize,
      windowScroll
    };
  };
  MDCMenuSurfaceFoundation2.prototype.getoriginCorner = function() {
    var corner = this.originCorner;
    var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
    var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var availableTop;
    var availableBottom;
    if (isAnchoredToBottom) {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
    } else {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
    }
    var isAvailableBottom = availableBottom - surfaceSize.height > 0;
    if (!isAvailableBottom && availableTop > availableBottom + this.openBottomBias) {
      corner = this.setBit(corner, CornerBit.BOTTOM);
    }
    var isRtl = this.adapter.isRtl();
    var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
    var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
    var isAnchoredToRight = false;
    if (isRtl && isFlipRtl) {
      isAnchoredToRight = !hasRightBit;
    } else {
      isAnchoredToRight = hasRightBit;
    }
    var availableLeft;
    var availableRight;
    if (isAnchoredToRight) {
      availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
      availableRight = viewportDistance.right - this.anchorMargin.right;
    } else {
      availableLeft = viewportDistance.left + this.anchorMargin.left;
      availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
    }
    var isAvailableLeft = availableLeft - surfaceSize.width > 0;
    var isAvailableRight = availableRight - surfaceSize.width > 0;
    var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
      corner = this.unsetBit(corner, CornerBit.RIGHT);
    } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
      corner = this.setBit(corner, CornerBit.RIGHT);
    }
    return corner;
  };
  MDCMenuSurfaceFoundation2.prototype.getMenuSurfaceMaxHeight = function(corner) {
    if (this.maxHeight > 0) {
      return this.maxHeight;
    }
    var viewportDistance = this.measurements.viewportDistance;
    var maxHeight = 0;
    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
    if (isBottomAligned) {
      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
      if (!isBottomAnchored) {
        maxHeight += this.measurements.anchorSize.height;
      }
    } else {
      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
      if (isBottomAnchored) {
        maxHeight -= this.measurements.anchorSize.height;
      }
    }
    return maxHeight;
  };
  MDCMenuSurfaceFoundation2.prototype.getHorizontalOriginOffset = function(corner) {
    var anchorSize = this.measurements.anchorSize;
    var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
    var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
    if (isRightAligned) {
      var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
      if (this.isHoistedElement || this.isFixedPosition) {
        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
      }
      return rightOffset;
    }
    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
  };
  MDCMenuSurfaceFoundation2.prototype.getVerticalOriginOffset = function(corner) {
    var anchorSize = this.measurements.anchorSize;
    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var y = 0;
    if (isBottomAligned) {
      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
    } else {
      y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
    }
    return y;
  };
  MDCMenuSurfaceFoundation2.prototype.adjustPositionForHoistedElement = function(position) {
    var e_1, _a;
    var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance, surfaceSize = _b.surfaceSize, viewportSize = _b.viewportSize;
    var props = Object.keys(position);
    try {
      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        var value = position[prop] || 0;
        if (this.isHorizontallyCenteredOnViewport && (prop === "left" || prop === "right")) {
          position[prop] = (viewportSize.width - surfaceSize.width) / 2;
          continue;
        }
        value += viewportDistance[prop];
        if (!this.isFixedPosition) {
          if (prop === "top") {
            value += windowScroll.y;
          } else if (prop === "bottom") {
            value -= windowScroll.y;
          } else if (prop === "left") {
            value += windowScroll.x;
          } else {
            value -= windowScroll.x;
          }
        }
        position[prop] = value;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return))
          _a.call(props_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCMenuSurfaceFoundation2.prototype.maybeRestoreFocus = function() {
    var _this = this;
    var isRootFocused = this.adapter.isFocused();
    var ownerDocument = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document;
    var childHasFocus = ownerDocument.activeElement && this.adapter.isElementInContainer(ownerDocument.activeElement);
    if (isRootFocused || childHasFocus) {
      setTimeout(function() {
        _this.adapter.restoreFocus();
      }, numbers2.TOUCH_EVENT_WAIT_MS);
    }
  };
  MDCMenuSurfaceFoundation2.prototype.hasBit = function(corner, bit) {
    return Boolean(corner & bit);
  };
  MDCMenuSurfaceFoundation2.prototype.setBit = function(corner, bit) {
    return corner | bit;
  };
  MDCMenuSurfaceFoundation2.prototype.unsetBit = function(corner, bit) {
    return corner ^ bit;
  };
  MDCMenuSurfaceFoundation2.prototype.isFinite = function(num) {
    return typeof num === "number" && isFinite(num);
  };
  return MDCMenuSurfaceFoundation2;
}(MDCFoundation);

// node_modules/@material/animation/util.js
var cssPropertyNameMap = {
  animation: {
    prefixed: "-webkit-animation",
    standard: "animation"
  },
  transform: {
    prefixed: "-webkit-transform",
    standard: "transform"
  },
  transition: {
    prefixed: "-webkit-transition",
    standard: "transition"
  }
};
function isWindow(windowObj) {
  return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
}
function getCorrectPropertyName(windowObj, cssProperty) {
  if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
    var el = windowObj.document.createElement("div");
    var _a = cssPropertyNameMap[cssProperty], standard = _a.standard, prefixed = _a.prefixed;
    var isStandard = standard in el.style;
    return isStandard ? standard : prefixed;
  }
  return cssProperty;
}

// node_modules/@material/menu-surface/component.js
var MDCMenuSurface = function(_super) {
  __extends(MDCMenuSurface2, _super);
  function MDCMenuSurface2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCMenuSurface2.attachTo = function(root) {
    return new MDCMenuSurface2(root);
  };
  MDCMenuSurface2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    var parentEl = this.root.parentElement;
    this.anchorElement = parentEl && parentEl.classList.contains(cssClasses2.ANCHOR) ? parentEl : null;
    if (this.root.classList.contains(cssClasses2.FIXED)) {
      this.setFixedPosition(true);
    }
    this.handleKeydown = function(event) {
      _this.foundation.handleKeydown(event);
    };
    this.handleBodyClick = function(event) {
      _this.foundation.handleBodyClick(event);
    };
    this.registerBodyClickListener = function() {
      document.body.addEventListener("click", _this.handleBodyClick, { capture: true });
    };
    this.deregisterBodyClickListener = function() {
      document.body.removeEventListener("click", _this.handleBodyClick, { capture: true });
    };
    this.listen("keydown", this.handleKeydown);
    this.listen(strings.OPENED_EVENT, this.registerBodyClickListener);
    this.listen(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
  };
  MDCMenuSurface2.prototype.destroy = function() {
    this.unlisten("keydown", this.handleKeydown);
    this.unlisten(strings.OPENED_EVENT, this.registerBodyClickListener);
    this.unlisten(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
    _super.prototype.destroy.call(this);
  };
  MDCMenuSurface2.prototype.isOpen = function() {
    return this.foundation.isOpen();
  };
  MDCMenuSurface2.prototype.open = function() {
    this.foundation.open();
  };
  MDCMenuSurface2.prototype.close = function(skipRestoreFocus) {
    if (skipRestoreFocus === void 0) {
      skipRestoreFocus = false;
    }
    this.foundation.close(skipRestoreFocus);
  };
  Object.defineProperty(MDCMenuSurface2.prototype, "quickOpen", {
    set: function(quickOpen) {
      this.foundation.setQuickOpen(quickOpen);
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuSurface2.prototype.setIsHoisted = function(isHoisted) {
    this.foundation.setIsHoisted(isHoisted);
  };
  MDCMenuSurface2.prototype.setMenuSurfaceAnchorElement = function(element2) {
    this.anchorElement = element2;
  };
  MDCMenuSurface2.prototype.setFixedPosition = function(isFixed) {
    if (isFixed) {
      this.root.classList.add(cssClasses2.FIXED);
    } else {
      this.root.classList.remove(cssClasses2.FIXED);
    }
    this.foundation.setFixedPosition(isFixed);
  };
  MDCMenuSurface2.prototype.setAbsolutePosition = function(x, y) {
    this.foundation.setAbsolutePosition(x, y);
    this.setIsHoisted(true);
  };
  MDCMenuSurface2.prototype.setAnchorCorner = function(corner) {
    this.foundation.setAnchorCorner(corner);
  };
  MDCMenuSurface2.prototype.setAnchorMargin = function(margin) {
    this.foundation.setAnchorMargin(margin);
  };
  MDCMenuSurface2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      hasAnchor: function() {
        return !!_this.anchorElement;
      },
      notifyClose: function() {
        return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
      },
      notifyClosing: function() {
        _this.emit(MDCMenuSurfaceFoundation.strings.CLOSING_EVENT, {});
      },
      notifyOpen: function() {
        return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
      },
      notifyOpening: function() {
        return _this.emit(MDCMenuSurfaceFoundation.strings.OPENING_EVENT, {});
      },
      isElementInContainer: function(el) {
        return _this.root.contains(el);
      },
      isRtl: function() {
        return getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
      },
      setTransformOrigin: function(origin) {
        var propertyName = getCorrectPropertyName(window, "transform") + "-origin";
        _this.root.style.setProperty(propertyName, origin);
      },
      isFocused: function() {
        return document.activeElement === _this.root;
      },
      saveFocus: function() {
        _this.previousFocus = document.activeElement;
      },
      restoreFocus: function() {
        if (_this.root.contains(document.activeElement)) {
          if (_this.previousFocus && _this.previousFocus.focus) {
            _this.previousFocus.focus();
          }
        }
      },
      getInnerDimensions: function() {
        return {
          width: _this.root.offsetWidth,
          height: _this.root.offsetHeight
        };
      },
      getAnchorDimensions: function() {
        return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null;
      },
      getWindowDimensions: function() {
        return { width: window.innerWidth, height: window.innerHeight };
      },
      getBodyDimensions: function() {
        return { width: document.body.clientWidth, height: document.body.clientHeight };
      },
      getWindowScroll: function() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      },
      setPosition: function(position) {
        var rootHTML = _this.root;
        rootHTML.style.left = "left" in position ? position.left + "px" : "";
        rootHTML.style.right = "right" in position ? position.right + "px" : "";
        rootHTML.style.top = "top" in position ? position.top + "px" : "";
        rootHTML.style.bottom = "bottom" in position ? position.bottom + "px" : "";
      },
      setMaxHeight: function(height) {
        _this.root.style.maxHeight = height;
      }
    };
    return new MDCMenuSurfaceFoundation(adapter);
  };
  return MDCMenuSurface2;
}(MDCComponent);

// node_modules/@material/menu/constants.js
var cssClasses3 = {
  MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
  MENU_SELECTION_GROUP: "mdc-menu__selection-group",
  ROOT: "mdc-menu"
};
var strings2 = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_DISABLED_ATTR: "aria-disabled",
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  SELECTED_EVENT: "MDCMenu:selected",
  SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
};
var numbers3 = {
  FOCUS_ROOT_INDEX: -1
};
var DefaultFocusState;
(function(DefaultFocusState2) {
  DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
  DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
  DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
  DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));

// node_modules/@material/menu/foundation.js
var MDCMenuFoundation = function(_super) {
  __extends(MDCMenuFoundation2, _super);
  function MDCMenuFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
    _this.closeAnimationEndTimerId = 0;
    _this.defaultFocusState = DefaultFocusState.LIST_ROOT;
    _this.selectedIndex = -1;
    return _this;
  }
  Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
    get: function() {
      return cssClasses3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "strings", {
    get: function() {
      return strings2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "numbers", {
    get: function() {
      return numbers3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClassToElementAtIndex: function() {
          return void 0;
        },
        removeClassFromElementAtIndex: function() {
          return void 0;
        },
        addAttributeToElementAtIndex: function() {
          return void 0;
        },
        removeAttributeFromElementAtIndex: function() {
          return void 0;
        },
        getAttributeFromElementAtIndex: function() {
          return null;
        },
        elementContainsClass: function() {
          return false;
        },
        closeSurface: function() {
          return void 0;
        },
        getElementIndex: function() {
          return -1;
        },
        notifySelected: function() {
          return void 0;
        },
        getMenuItemCount: function() {
          return 0;
        },
        focusItemAtIndex: function() {
          return void 0;
        },
        focusListRoot: function() {
          return void 0;
        },
        getSelectedSiblingOfItemAtIndex: function() {
          return -1;
        },
        isSelectableItemAtIndex: function() {
          return false;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuFoundation2.prototype.destroy = function() {
    if (this.closeAnimationEndTimerId) {
      clearTimeout(this.closeAnimationEndTimerId);
    }
    this.adapter.closeSurface();
  };
  MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
    var key = evt.key, keyCode = evt.keyCode;
    var isTab = key === "Tab" || keyCode === 9;
    if (isTab) {
      this.adapter.closeSurface(true);
    }
  };
  MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
    var _this = this;
    var index = this.adapter.getElementIndex(listItem);
    if (index < 0) {
      return;
    }
    this.adapter.notifySelected({ index });
    var skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(index, strings2.SKIP_RESTORE_FOCUS) === "true";
    this.adapter.closeSurface(skipRestoreFocus);
    this.closeAnimationEndTimerId = setTimeout(function() {
      var recomputedIndex = _this.adapter.getElementIndex(listItem);
      if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
        _this.setSelectedIndex(recomputedIndex);
      }
    }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
  };
  MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
    switch (this.defaultFocusState) {
      case DefaultFocusState.FIRST_ITEM:
        this.adapter.focusItemAtIndex(0);
        break;
      case DefaultFocusState.LAST_ITEM:
        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
        break;
      case DefaultFocusState.NONE:
        break;
      default:
        this.adapter.focusListRoot();
        break;
    }
  };
  MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
    this.defaultFocusState = focusState;
  };
  MDCMenuFoundation2.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  };
  MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
    this.validatedIndex(index);
    if (!this.adapter.isSelectableItemAtIndex(index)) {
      throw new Error("MDCMenuFoundation: No selection group at specified index.");
    }
    var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
    if (prevSelectedIndex >= 0) {
      this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings2.ARIA_CHECKED_ATTR);
      this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses3.MENU_SELECTED_LIST_ITEM);
    }
    this.adapter.addClassToElementAtIndex(index, cssClasses3.MENU_SELECTED_LIST_ITEM);
    this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_CHECKED_ATTR, "true");
    this.selectedIndex = index;
  };
  MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
    this.validatedIndex(index);
    if (isEnabled) {
      this.adapter.removeClassFromElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "false");
    } else {
      this.adapter.addClassToElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "true");
    }
  };
  MDCMenuFoundation2.prototype.validatedIndex = function(index) {
    var menuSize = this.adapter.getMenuItemCount();
    var isIndexInRange = index >= 0 && index < menuSize;
    if (!isIndexInRange) {
      throw new Error("MDCMenuFoundation: No list item at specified index.");
    }
  };
  return MDCMenuFoundation2;
}(MDCFoundation);

// node_modules/@material/menu/component.js
var MDCMenu = function(_super) {
  __extends(MDCMenu2, _super);
  function MDCMenu2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCMenu2.attachTo = function(root) {
    return new MDCMenu2(root);
  };
  MDCMenu2.prototype.initialize = function(menuSurfaceFactory, listFactory) {
    if (menuSurfaceFactory === void 0) {
      menuSurfaceFactory = function(el) {
        return new MDCMenuSurface(el);
      };
    }
    if (listFactory === void 0) {
      listFactory = function(el) {
        return new MDCList(el);
      };
    }
    this.menuSurfaceFactory = menuSurfaceFactory;
    this.listFactory = listFactory;
  };
  MDCMenu2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.menuSurface = this.menuSurfaceFactory(this.root);
    var list = this.root.querySelector(strings2.LIST_SELECTOR);
    if (list) {
      this.list = this.listFactory(list);
      this.list.wrapFocus = true;
    } else {
      this.list = null;
    }
    this.handleKeydown = function(evt) {
      _this.foundation.handleKeydown(evt);
    };
    this.handleItemAction = function(evt) {
      _this.foundation.handleItemAction(_this.items[evt.detail.index]);
    };
    this.handleMenuSurfaceOpened = function() {
      _this.foundation.handleMenuSurfaceOpened();
    };
    this.menuSurface.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
    this.listen("keydown", this.handleKeydown);
    this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
  };
  MDCMenu2.prototype.destroy = function() {
    if (this.list) {
      this.list.destroy();
    }
    this.menuSurface.destroy();
    this.menuSurface.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
    this.unlisten("keydown", this.handleKeydown);
    this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
    _super.prototype.destroy.call(this);
  };
  Object.defineProperty(MDCMenu2.prototype, "open", {
    get: function() {
      return this.menuSurface.isOpen();
    },
    set: function(value) {
      if (value) {
        this.menuSurface.open();
      } else {
        this.menuSurface.close();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "wrapFocus", {
    get: function() {
      return this.list ? this.list.wrapFocus : false;
    },
    set: function(value) {
      if (this.list) {
        this.list.wrapFocus = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "hasTypeahead", {
    set: function(value) {
      if (this.list) {
        this.list.hasTypeahead = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "typeaheadInProgress", {
    get: function() {
      return this.list ? this.list.typeaheadInProgress : false;
    },
    enumerable: false,
    configurable: true
  });
  MDCMenu2.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
    if (this.list) {
      return this.list.typeaheadMatchItem(nextChar, startingIndex);
    }
    return -1;
  };
  MDCMenu2.prototype.layout = function() {
    if (this.list) {
      this.list.layout();
    }
  };
  Object.defineProperty(MDCMenu2.prototype, "items", {
    get: function() {
      return this.list ? this.list.listElements : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "singleSelection", {
    set: function(singleSelection) {
      if (this.list) {
        this.list.singleSelection = singleSelection;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "selectedIndex", {
    get: function() {
      return this.list ? this.list.selectedIndex : numbers.UNSET_INDEX;
    },
    set: function(index) {
      if (this.list) {
        this.list.selectedIndex = index;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "quickOpen", {
    set: function(quickOpen) {
      this.menuSurface.quickOpen = quickOpen;
    },
    enumerable: false,
    configurable: true
  });
  MDCMenu2.prototype.setDefaultFocusState = function(focusState) {
    this.foundation.setDefaultFocusState(focusState);
  };
  MDCMenu2.prototype.setAnchorCorner = function(corner) {
    this.menuSurface.setAnchorCorner(corner);
  };
  MDCMenu2.prototype.setAnchorMargin = function(margin) {
    this.menuSurface.setAnchorMargin(margin);
  };
  MDCMenu2.prototype.setSelectedIndex = function(index) {
    this.foundation.setSelectedIndex(index);
  };
  MDCMenu2.prototype.setEnabled = function(index, isEnabled) {
    this.foundation.setEnabled(index, isEnabled);
  };
  MDCMenu2.prototype.getOptionByIndex = function(index) {
    var items = this.items;
    if (index < items.length) {
      return this.items[index];
    } else {
      return null;
    }
  };
  MDCMenu2.prototype.getPrimaryTextAtIndex = function(index) {
    var item = this.getOptionByIndex(index);
    if (item && this.list) {
      return this.list.getPrimaryText(item) || "";
    }
    return "";
  };
  MDCMenu2.prototype.setFixedPosition = function(isFixed) {
    this.menuSurface.setFixedPosition(isFixed);
  };
  MDCMenu2.prototype.setIsHoisted = function(isHoisted) {
    this.menuSurface.setIsHoisted(isHoisted);
  };
  MDCMenu2.prototype.setAbsolutePosition = function(x, y) {
    this.menuSurface.setAbsolutePosition(x, y);
  };
  MDCMenu2.prototype.setAnchorElement = function(element2) {
    this.menuSurface.anchorElement = element2;
  };
  MDCMenu2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClassToElementAtIndex: function(index, className) {
        var list = _this.items;
        list[index].classList.add(className);
      },
      removeClassFromElementAtIndex: function(index, className) {
        var list = _this.items;
        list[index].classList.remove(className);
      },
      addAttributeToElementAtIndex: function(index, attr, value) {
        var list = _this.items;
        list[index].setAttribute(attr, value);
      },
      removeAttributeFromElementAtIndex: function(index, attr) {
        var list = _this.items;
        list[index].removeAttribute(attr);
      },
      getAttributeFromElementAtIndex: function(index, attr) {
        var list = _this.items;
        return list[index].getAttribute(attr);
      },
      elementContainsClass: function(element2, className) {
        return element2.classList.contains(className);
      },
      closeSurface: function(skipRestoreFocus) {
        _this.menuSurface.close(skipRestoreFocus);
      },
      getElementIndex: function(element2) {
        return _this.items.indexOf(element2);
      },
      notifySelected: function(evtData) {
        _this.emit(strings2.SELECTED_EVENT, {
          index: evtData.index,
          item: _this.items[evtData.index]
        });
      },
      getMenuItemCount: function() {
        return _this.items.length;
      },
      focusItemAtIndex: function(index) {
        _this.items[index].focus();
      },
      focusListRoot: function() {
        _this.root.querySelector(strings2.LIST_SELECTOR).focus();
      },
      isSelectableItemAtIndex: function(index) {
        return !!closest(_this.items[index], "." + cssClasses3.MENU_SELECTION_GROUP);
      },
      getSelectedSiblingOfItemAtIndex: function(index) {
        var selectionGroupEl = closest(_this.items[index], "." + cssClasses3.MENU_SELECTION_GROUP);
        var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses3.MENU_SELECTED_LIST_ITEM);
        return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
      }
    };
    return new MDCMenuFoundation(adapter);
  };
  return MDCMenu2;
}(MDCComponent);

// node_modules/@material/select/constants.js
var cssClasses4 = {
  ACTIVATED: "mdc-select--activated",
  DISABLED: "mdc-select--disabled",
  FOCUSED: "mdc-select--focused",
  INVALID: "mdc-select--invalid",
  MENU_INVALID: "mdc-select__menu--invalid",
  OUTLINED: "mdc-select--outlined",
  REQUIRED: "mdc-select--required",
  ROOT: "mdc-select",
  WITH_LEADING_ICON: "mdc-select--with-leading-icon"
};
var strings3 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  ARIA_SELECTED_ATTR: "aria-selected",
  CHANGE_EVENT: "MDCSelect:change",
  HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-select__icon",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  MENU_SELECTOR: ".mdc-select__menu",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  SELECTED_TEXT_SELECTOR: ".mdc-select__selected-text",
  SELECT_ANCHOR_SELECTOR: ".mdc-select__anchor",
  VALUE_ATTR: "data-value"
};
var numbers4 = {
  LABEL_SCALE: 0.75,
  UNSET_INDEX: -1,
  CLICK_DEBOUNCE_TIMEOUT_MS: 330
};

// node_modules/@material/select/foundation.js
var MDCSelectFoundation = function(_super) {
  __extends(MDCSelectFoundation2, _super);
  function MDCSelectFoundation2(adapter, foundationMap) {
    if (foundationMap === void 0) {
      foundationMap = {};
    }
    var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation2.defaultAdapter), adapter)) || this;
    _this.disabled = false;
    _this.isMenuOpen = false;
    _this.useDefaultValidation = true;
    _this.customValidity = true;
    _this.lastSelectedIndex = numbers4.UNSET_INDEX;
    _this.clickDebounceTimeout = 0;
    _this.recentlyClicked = false;
    _this.leadingIcon = foundationMap.leadingIcon;
    _this.helperText = foundationMap.helperText;
    return _this;
  }
  Object.defineProperty(MDCSelectFoundation2, "cssClasses", {
    get: function() {
      return cssClasses4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectFoundation2, "numbers", {
    get: function() {
      return numbers4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectFoundation2, "strings", {
    get: function() {
      return strings3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        activateBottomLine: function() {
          return void 0;
        },
        deactivateBottomLine: function() {
          return void 0;
        },
        getSelectedIndex: function() {
          return -1;
        },
        setSelectedIndex: function() {
          return void 0;
        },
        hasLabel: function() {
          return false;
        },
        floatLabel: function() {
          return void 0;
        },
        getLabelWidth: function() {
          return 0;
        },
        setLabelRequired: function() {
          return void 0;
        },
        hasOutline: function() {
          return false;
        },
        notchOutline: function() {
          return void 0;
        },
        closeOutline: function() {
          return void 0;
        },
        setRippleCenter: function() {
          return void 0;
        },
        notifyChange: function() {
          return void 0;
        },
        setSelectedText: function() {
          return void 0;
        },
        isSelectAnchorFocused: function() {
          return false;
        },
        getSelectAnchorAttr: function() {
          return "";
        },
        setSelectAnchorAttr: function() {
          return void 0;
        },
        removeSelectAnchorAttr: function() {
          return void 0;
        },
        addMenuClass: function() {
          return void 0;
        },
        removeMenuClass: function() {
          return void 0;
        },
        openMenu: function() {
          return void 0;
        },
        closeMenu: function() {
          return void 0;
        },
        getAnchorElement: function() {
          return null;
        },
        setMenuAnchorElement: function() {
          return void 0;
        },
        setMenuAnchorCorner: function() {
          return void 0;
        },
        setMenuWrapFocus: function() {
          return void 0;
        },
        focusMenuItemAtIndex: function() {
          return void 0;
        },
        getMenuItemCount: function() {
          return 0;
        },
        getMenuItemValues: function() {
          return [];
        },
        getMenuItemTextAtIndex: function() {
          return "";
        },
        isTypeaheadInProgress: function() {
          return false;
        },
        typeaheadMatchItem: function() {
          return -1;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSelectFoundation2.prototype.getSelectedIndex = function() {
    return this.adapter.getSelectedIndex();
  };
  MDCSelectFoundation2.prototype.setSelectedIndex = function(index, closeMenu, skipNotify) {
    if (closeMenu === void 0) {
      closeMenu = false;
    }
    if (skipNotify === void 0) {
      skipNotify = false;
    }
    if (index >= this.adapter.getMenuItemCount()) {
      return;
    }
    if (index === numbers4.UNSET_INDEX) {
      this.adapter.setSelectedText("");
    } else {
      this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
    }
    this.adapter.setSelectedIndex(index);
    if (closeMenu) {
      this.adapter.closeMenu();
    }
    if (!skipNotify && this.lastSelectedIndex !== index) {
      this.handleChange();
    }
    this.lastSelectedIndex = index;
  };
  MDCSelectFoundation2.prototype.setValue = function(value, skipNotify) {
    if (skipNotify === void 0) {
      skipNotify = false;
    }
    var index = this.adapter.getMenuItemValues().indexOf(value);
    this.setSelectedIndex(index, false, skipNotify);
  };
  MDCSelectFoundation2.prototype.getValue = function() {
    var index = this.adapter.getSelectedIndex();
    var menuItemValues = this.adapter.getMenuItemValues();
    return index !== numbers4.UNSET_INDEX ? menuItemValues[index] : "";
  };
  MDCSelectFoundation2.prototype.getDisabled = function() {
    return this.disabled;
  };
  MDCSelectFoundation2.prototype.setDisabled = function(isDisabled) {
    this.disabled = isDisabled;
    if (this.disabled) {
      this.adapter.addClass(cssClasses4.DISABLED);
      this.adapter.closeMenu();
    } else {
      this.adapter.removeClass(cssClasses4.DISABLED);
    }
    if (this.leadingIcon) {
      this.leadingIcon.setDisabled(this.disabled);
    }
    if (this.disabled) {
      this.adapter.removeSelectAnchorAttr("tabindex");
    } else {
      this.adapter.setSelectAnchorAttr("tabindex", "0");
    }
    this.adapter.setSelectAnchorAttr("aria-disabled", this.disabled.toString());
  };
  MDCSelectFoundation2.prototype.openMenu = function() {
    this.adapter.addClass(cssClasses4.ACTIVATED);
    this.adapter.openMenu();
    this.isMenuOpen = true;
    this.adapter.setSelectAnchorAttr("aria-expanded", "true");
  };
  MDCSelectFoundation2.prototype.setHelperTextContent = function(content) {
    if (this.helperText) {
      this.helperText.setContent(content);
    }
  };
  MDCSelectFoundation2.prototype.layout = function() {
    if (this.adapter.hasLabel()) {
      var optionHasValue = this.getValue().length > 0;
      var isFocused = this.adapter.hasClass(cssClasses4.FOCUSED);
      var shouldFloatAndNotch = optionHasValue || isFocused;
      var isRequired = this.adapter.hasClass(cssClasses4.REQUIRED);
      this.notchOutline(shouldFloatAndNotch);
      this.adapter.floatLabel(shouldFloatAndNotch);
      this.adapter.setLabelRequired(isRequired);
    }
  };
  MDCSelectFoundation2.prototype.layoutOptions = function() {
    var menuItemValues = this.adapter.getMenuItemValues();
    var selectedIndex = menuItemValues.indexOf(this.getValue());
    this.setSelectedIndex(selectedIndex, false, true);
  };
  MDCSelectFoundation2.prototype.handleMenuOpened = function() {
    if (this.adapter.getMenuItemValues().length === 0) {
      return;
    }
    var selectedIndex = this.getSelectedIndex();
    var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
    this.adapter.focusMenuItemAtIndex(focusItemIndex);
  };
  MDCSelectFoundation2.prototype.handleMenuClosing = function() {
    this.adapter.setSelectAnchorAttr("aria-expanded", "false");
  };
  MDCSelectFoundation2.prototype.handleMenuClosed = function() {
    this.adapter.removeClass(cssClasses4.ACTIVATED);
    this.isMenuOpen = false;
    if (!this.adapter.isSelectAnchorFocused()) {
      this.blur();
    }
  };
  MDCSelectFoundation2.prototype.handleChange = function() {
    this.layout();
    this.adapter.notifyChange(this.getValue());
    var isRequired = this.adapter.hasClass(cssClasses4.REQUIRED);
    if (isRequired && this.useDefaultValidation) {
      this.setValid(this.isValid());
    }
  };
  MDCSelectFoundation2.prototype.handleMenuItemAction = function(index) {
    this.setSelectedIndex(index, true);
  };
  MDCSelectFoundation2.prototype.handleFocus = function() {
    this.adapter.addClass(cssClasses4.FOCUSED);
    this.layout();
    this.adapter.activateBottomLine();
  };
  MDCSelectFoundation2.prototype.handleBlur = function() {
    if (this.isMenuOpen) {
      return;
    }
    this.blur();
  };
  MDCSelectFoundation2.prototype.handleClick = function(normalizedX) {
    if (this.disabled || this.recentlyClicked) {
      return;
    }
    this.setClickDebounceTimeout();
    if (this.isMenuOpen) {
      this.adapter.closeMenu();
      return;
    }
    this.adapter.setRippleCenter(normalizedX);
    this.openMenu();
  };
  MDCSelectFoundation2.prototype.handleKeydown = function(event) {
    if (this.isMenuOpen || !this.adapter.hasClass(cssClasses4.FOCUSED)) {
      return;
    }
    var isEnter = normalizeKey(event) === KEY.ENTER;
    var isSpace = normalizeKey(event) === KEY.SPACEBAR;
    var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
    var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
    var isModifier = event.ctrlKey || event.metaKey;
    if (!isModifier && (!isSpace && event.key && event.key.length === 1 || isSpace && this.adapter.isTypeaheadInProgress())) {
      var key = isSpace ? " " : event.key;
      var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
      if (typeaheadNextIndex >= 0) {
        this.setSelectedIndex(typeaheadNextIndex);
      }
      event.preventDefault();
      return;
    }
    if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
      return;
    }
    this.openMenu();
    event.preventDefault();
  };
  MDCSelectFoundation2.prototype.notchOutline = function(openNotch) {
    if (!this.adapter.hasOutline()) {
      return;
    }
    var isFocused = this.adapter.hasClass(cssClasses4.FOCUSED);
    if (openNotch) {
      var labelScale = numbers4.LABEL_SCALE;
      var labelWidth = this.adapter.getLabelWidth() * labelScale;
      this.adapter.notchOutline(labelWidth);
    } else if (!isFocused) {
      this.adapter.closeOutline();
    }
  };
  MDCSelectFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
    if (this.leadingIcon) {
      this.leadingIcon.setAriaLabel(label);
    }
  };
  MDCSelectFoundation2.prototype.setLeadingIconContent = function(content) {
    if (this.leadingIcon) {
      this.leadingIcon.setContent(content);
    }
  };
  MDCSelectFoundation2.prototype.getUseDefaultValidation = function() {
    return this.useDefaultValidation;
  };
  MDCSelectFoundation2.prototype.setUseDefaultValidation = function(useDefaultValidation) {
    this.useDefaultValidation = useDefaultValidation;
  };
  MDCSelectFoundation2.prototype.setValid = function(isValid) {
    if (!this.useDefaultValidation) {
      this.customValidity = isValid;
    }
    this.adapter.setSelectAnchorAttr("aria-invalid", (!isValid).toString());
    if (isValid) {
      this.adapter.removeClass(cssClasses4.INVALID);
      this.adapter.removeMenuClass(cssClasses4.MENU_INVALID);
    } else {
      this.adapter.addClass(cssClasses4.INVALID);
      this.adapter.addMenuClass(cssClasses4.MENU_INVALID);
    }
    this.syncHelperTextValidity(isValid);
  };
  MDCSelectFoundation2.prototype.isValid = function() {
    if (this.useDefaultValidation && this.adapter.hasClass(cssClasses4.REQUIRED) && !this.adapter.hasClass(cssClasses4.DISABLED)) {
      return this.getSelectedIndex() !== numbers4.UNSET_INDEX && (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
    }
    return this.customValidity;
  };
  MDCSelectFoundation2.prototype.setRequired = function(isRequired) {
    if (isRequired) {
      this.adapter.addClass(cssClasses4.REQUIRED);
    } else {
      this.adapter.removeClass(cssClasses4.REQUIRED);
    }
    this.adapter.setSelectAnchorAttr("aria-required", isRequired.toString());
    this.adapter.setLabelRequired(isRequired);
  };
  MDCSelectFoundation2.prototype.getRequired = function() {
    return this.adapter.getSelectAnchorAttr("aria-required") === "true";
  };
  MDCSelectFoundation2.prototype.init = function() {
    var anchorEl = this.adapter.getAnchorElement();
    if (anchorEl) {
      this.adapter.setMenuAnchorElement(anchorEl);
      this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
    }
    this.adapter.setMenuWrapFocus(false);
    this.setDisabled(this.adapter.hasClass(cssClasses4.DISABLED));
    this.syncHelperTextValidity(!this.adapter.hasClass(cssClasses4.INVALID));
    this.layout();
    this.layoutOptions();
  };
  MDCSelectFoundation2.prototype.blur = function() {
    this.adapter.removeClass(cssClasses4.FOCUSED);
    this.layout();
    this.adapter.deactivateBottomLine();
    var isRequired = this.adapter.hasClass(cssClasses4.REQUIRED);
    if (isRequired && this.useDefaultValidation) {
      this.setValid(this.isValid());
    }
  };
  MDCSelectFoundation2.prototype.syncHelperTextValidity = function(isValid) {
    if (!this.helperText) {
      return;
    }
    this.helperText.setValidity(isValid);
    var helperTextVisible = this.helperText.isVisible();
    var helperTextId = this.helperText.getId();
    if (helperTextVisible && helperTextId) {
      this.adapter.setSelectAnchorAttr(strings3.ARIA_DESCRIBEDBY, helperTextId);
    } else {
      this.adapter.removeSelectAnchorAttr(strings3.ARIA_DESCRIBEDBY);
    }
  };
  MDCSelectFoundation2.prototype.setClickDebounceTimeout = function() {
    var _this = this;
    clearTimeout(this.clickDebounceTimeout);
    this.clickDebounceTimeout = setTimeout(function() {
      _this.recentlyClicked = false;
    }, numbers4.CLICK_DEBOUNCE_TIMEOUT_MS);
    this.recentlyClicked = true;
  };
  return MDCSelectFoundation2;
}(MDCFoundation);

// node_modules/@material/select/helper-text/constants.js
var strings4 = {
  ARIA_HIDDEN: "aria-hidden",
  ROLE: "role"
};
var cssClasses5 = {
  HELPER_TEXT_VALIDATION_MSG: "mdc-select-helper-text--validation-msg",
  HELPER_TEXT_VALIDATION_MSG_PERSISTENT: "mdc-select-helper-text--validation-msg-persistent"
};

// node_modules/@material/select/helper-text/foundation.js
var MDCSelectHelperTextFoundation = function(_super) {
  __extends(MDCSelectHelperTextFoundation2, _super);
  function MDCSelectHelperTextFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCSelectHelperTextFoundation2, "cssClasses", {
    get: function() {
      return cssClasses5;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectHelperTextFoundation2, "strings", {
    get: function() {
      return strings4;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectHelperTextFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        setAttr: function() {
          return void 0;
        },
        getAttr: function() {
          return null;
        },
        removeAttr: function() {
          return void 0;
        },
        setContent: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSelectHelperTextFoundation2.prototype.getId = function() {
    return this.adapter.getAttr("id");
  };
  MDCSelectHelperTextFoundation2.prototype.isVisible = function() {
    return this.adapter.getAttr(strings4.ARIA_HIDDEN) !== "true";
  };
  MDCSelectHelperTextFoundation2.prototype.setContent = function(content) {
    this.adapter.setContent(content);
  };
  MDCSelectHelperTextFoundation2.prototype.setValidation = function(isValidation) {
    if (isValidation) {
      this.adapter.addClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG);
    } else {
      this.adapter.removeClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG);
    }
  };
  MDCSelectHelperTextFoundation2.prototype.setValidationMsgPersistent = function(isPersistent) {
    if (isPersistent) {
      this.adapter.addClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
    } else {
      this.adapter.removeClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
    }
  };
  MDCSelectHelperTextFoundation2.prototype.getIsValidation = function() {
    return this.adapter.hasClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG);
  };
  MDCSelectHelperTextFoundation2.prototype.getIsValidationMsgPersistent = function() {
    return this.adapter.hasClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
  };
  MDCSelectHelperTextFoundation2.prototype.setValidity = function(selectIsValid) {
    var isValidationMsg = this.adapter.hasClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG);
    if (!isValidationMsg) {
      return;
    }
    var isPersistentValidationMsg = this.adapter.hasClass(cssClasses5.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
    var msgShouldDisplay = !selectIsValid || isPersistentValidationMsg;
    if (msgShouldDisplay) {
      this.showToScreenReader();
      if (!selectIsValid) {
        this.adapter.setAttr(strings4.ROLE, "alert");
      } else {
        this.adapter.removeAttr(strings4.ROLE);
      }
      return;
    }
    this.adapter.removeAttr(strings4.ROLE);
    this.hide();
  };
  MDCSelectHelperTextFoundation2.prototype.showToScreenReader = function() {
    this.adapter.removeAttr(strings4.ARIA_HIDDEN);
  };
  MDCSelectHelperTextFoundation2.prototype.hide = function() {
    this.adapter.setAttr(strings4.ARIA_HIDDEN, "true");
  };
  return MDCSelectHelperTextFoundation2;
}(MDCFoundation);

// node_modules/@material/select/helper-text/component.js
var MDCSelectHelperText = function(_super) {
  __extends(MDCSelectHelperText2, _super);
  function MDCSelectHelperText2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSelectHelperText2.attachTo = function(root) {
    return new MDCSelectHelperText2(root);
  };
  Object.defineProperty(MDCSelectHelperText2.prototype, "foundationForSelect", {
    get: function() {
      return this.foundation;
    },
    enumerable: false,
    configurable: true
  });
  MDCSelectHelperText2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      getAttr: function(attr) {
        return _this.root.getAttribute(attr);
      },
      setAttr: function(attr, value) {
        return _this.root.setAttribute(attr, value);
      },
      removeAttr: function(attr) {
        return _this.root.removeAttribute(attr);
      },
      setContent: function(content) {
        _this.root.textContent = content;
      }
    };
    return new MDCSelectHelperTextFoundation(adapter);
  };
  return MDCSelectHelperText2;
}(MDCComponent);

// node_modules/@material/select/icon/constants.js
var strings5 = {
  ICON_EVENT: "MDCSelect:icon",
  ICON_ROLE: "button"
};

// node_modules/@material/select/icon/foundation.js
var INTERACTION_EVENTS = ["click", "keydown"];
var MDCSelectIconFoundation = function(_super) {
  __extends(MDCSelectIconFoundation2, _super);
  function MDCSelectIconFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCSelectIconFoundation2.defaultAdapter), adapter)) || this;
    _this.savedTabIndex = null;
    _this.interactionHandler = function(evt) {
      _this.handleInteraction(evt);
    };
    return _this;
  }
  Object.defineProperty(MDCSelectIconFoundation2, "strings", {
    get: function() {
      return strings5;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelectIconFoundation2, "defaultAdapter", {
    get: function() {
      return {
        getAttr: function() {
          return null;
        },
        setAttr: function() {
          return void 0;
        },
        removeAttr: function() {
          return void 0;
        },
        setContent: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        notifyIconAction: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSelectIconFoundation2.prototype.init = function() {
    var e_1, _a;
    this.savedTabIndex = this.adapter.getAttr("tabindex");
    try {
      for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
        var evtType = INTERACTION_EVENTS_1_1.value;
        this.adapter.registerInteractionHandler(evtType, this.interactionHandler);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_a = INTERACTION_EVENTS_1.return))
          _a.call(INTERACTION_EVENTS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCSelectIconFoundation2.prototype.destroy = function() {
    var e_2, _a;
    try {
      for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
        var evtType = INTERACTION_EVENTS_2_1.value;
        this.adapter.deregisterInteractionHandler(evtType, this.interactionHandler);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_a = INTERACTION_EVENTS_2.return))
          _a.call(INTERACTION_EVENTS_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  MDCSelectIconFoundation2.prototype.setDisabled = function(disabled) {
    if (!this.savedTabIndex) {
      return;
    }
    if (disabled) {
      this.adapter.setAttr("tabindex", "-1");
      this.adapter.removeAttr("role");
    } else {
      this.adapter.setAttr("tabindex", this.savedTabIndex);
      this.adapter.setAttr("role", strings5.ICON_ROLE);
    }
  };
  MDCSelectIconFoundation2.prototype.setAriaLabel = function(label) {
    this.adapter.setAttr("aria-label", label);
  };
  MDCSelectIconFoundation2.prototype.setContent = function(content) {
    this.adapter.setContent(content);
  };
  MDCSelectIconFoundation2.prototype.handleInteraction = function(evt) {
    var isEnterKey = evt.key === "Enter" || evt.keyCode === 13;
    if (evt.type === "click" || isEnterKey) {
      this.adapter.notifyIconAction();
    }
  };
  return MDCSelectIconFoundation2;
}(MDCFoundation);

// node_modules/@material/select/icon/component.js
var MDCSelectIcon = function(_super) {
  __extends(MDCSelectIcon2, _super);
  function MDCSelectIcon2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSelectIcon2.attachTo = function(root) {
    return new MDCSelectIcon2(root);
  };
  Object.defineProperty(MDCSelectIcon2.prototype, "foundationForSelect", {
    get: function() {
      return this.foundation;
    },
    enumerable: false,
    configurable: true
  });
  MDCSelectIcon2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      getAttr: function(attr) {
        return _this.root.getAttribute(attr);
      },
      setAttr: function(attr, value) {
        return _this.root.setAttribute(attr, value);
      },
      removeAttr: function(attr) {
        return _this.root.removeAttribute(attr);
      },
      setContent: function(content) {
        _this.root.textContent = content;
      },
      registerInteractionHandler: function(evtType, handler) {
        return _this.listen(evtType, handler);
      },
      deregisterInteractionHandler: function(evtType, handler) {
        return _this.unlisten(evtType, handler);
      },
      notifyIconAction: function() {
        return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {}, true);
      }
    };
    return new MDCSelectIconFoundation(adapter);
  };
  return MDCSelectIcon2;
}(MDCComponent);

// node_modules/@material/select/component.js
var MDCSelect = function(_super) {
  __extends(MDCSelect2, _super);
  function MDCSelect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSelect2.attachTo = function(root) {
    return new MDCSelect2(root);
  };
  MDCSelect2.prototype.initialize = function(labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
    if (labelFactory === void 0) {
      labelFactory = function(el) {
        return new MDCFloatingLabel(el);
      };
    }
    if (lineRippleFactory === void 0) {
      lineRippleFactory = function(el) {
        return new MDCLineRipple(el);
      };
    }
    if (outlineFactory === void 0) {
      outlineFactory = function(el) {
        return new MDCNotchedOutline(el);
      };
    }
    if (menuFactory === void 0) {
      menuFactory = function(el) {
        return new MDCMenu(el);
      };
    }
    if (iconFactory === void 0) {
      iconFactory = function(el) {
        return new MDCSelectIcon(el);
      };
    }
    if (helperTextFactory === void 0) {
      helperTextFactory = function(el) {
        return new MDCSelectHelperText(el);
      };
    }
    this.selectAnchor = this.root.querySelector(strings3.SELECT_ANCHOR_SELECTOR);
    this.selectedText = this.root.querySelector(strings3.SELECTED_TEXT_SELECTOR);
    this.hiddenInput = this.root.querySelector(strings3.HIDDEN_INPUT_SELECTOR);
    if (!this.selectedText) {
      throw new Error("MDCSelect: Missing required element: The following selector must be present: " + ("'" + strings3.SELECTED_TEXT_SELECTOR + "'"));
    }
    if (this.selectAnchor.hasAttribute(strings3.ARIA_CONTROLS)) {
      var helperTextElement = document.getElementById(this.selectAnchor.getAttribute(strings3.ARIA_CONTROLS));
      if (helperTextElement) {
        this.helperText = helperTextFactory(helperTextElement);
      }
    }
    this.menuSetup(menuFactory);
    var labelElement = this.root.querySelector(strings3.LABEL_SELECTOR);
    this.label = labelElement ? labelFactory(labelElement) : null;
    var lineRippleElement = this.root.querySelector(strings3.LINE_RIPPLE_SELECTOR);
    this.lineRipple = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
    var outlineElement = this.root.querySelector(strings3.OUTLINE_SELECTOR);
    this.outline = outlineElement ? outlineFactory(outlineElement) : null;
    var leadingIcon = this.root.querySelector(strings3.LEADING_ICON_SELECTOR);
    if (leadingIcon) {
      this.leadingIcon = iconFactory(leadingIcon);
    }
    if (!this.root.classList.contains(cssClasses4.OUTLINED)) {
      this.ripple = this.createRipple();
    }
  };
  MDCSelect2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleFocus = function() {
      _this.foundation.handleFocus();
    };
    this.handleBlur = function() {
      _this.foundation.handleBlur();
    };
    this.handleClick = function(evt) {
      _this.selectAnchor.focus();
      _this.foundation.handleClick(_this.getNormalizedXCoordinate(evt));
    };
    this.handleKeydown = function(evt) {
      _this.foundation.handleKeydown(evt);
    };
    this.handleMenuItemAction = function(evt) {
      _this.foundation.handleMenuItemAction(evt.detail.index);
    };
    this.handleMenuOpened = function() {
      _this.foundation.handleMenuOpened();
    };
    this.handleMenuClosed = function() {
      _this.foundation.handleMenuClosed();
    };
    this.handleMenuClosing = function() {
      _this.foundation.handleMenuClosing();
    };
    this.selectAnchor.addEventListener("focus", this.handleFocus);
    this.selectAnchor.addEventListener("blur", this.handleBlur);
    this.selectAnchor.addEventListener("click", this.handleClick);
    this.selectAnchor.addEventListener("keydown", this.handleKeydown);
    this.menu.listen(strings.CLOSED_EVENT, this.handleMenuClosed);
    this.menu.listen(strings.CLOSING_EVENT, this.handleMenuClosing);
    this.menu.listen(strings.OPENED_EVENT, this.handleMenuOpened);
    this.menu.listen(strings2.SELECTED_EVENT, this.handleMenuItemAction);
    if (this.hiddenInput) {
      if (this.hiddenInput.value) {
        this.foundation.setValue(this.hiddenInput.value, true);
        this.foundation.layout();
        return;
      }
      this.hiddenInput.value = this.value;
    }
  };
  MDCSelect2.prototype.destroy = function() {
    this.selectAnchor.removeEventListener("focus", this.handleFocus);
    this.selectAnchor.removeEventListener("blur", this.handleBlur);
    this.selectAnchor.removeEventListener("keydown", this.handleKeydown);
    this.selectAnchor.removeEventListener("click", this.handleClick);
    this.menu.unlisten(strings.CLOSED_EVENT, this.handleMenuClosed);
    this.menu.unlisten(strings.OPENED_EVENT, this.handleMenuOpened);
    this.menu.unlisten(strings2.SELECTED_EVENT, this.handleMenuItemAction);
    this.menu.destroy();
    if (this.ripple) {
      this.ripple.destroy();
    }
    if (this.outline) {
      this.outline.destroy();
    }
    if (this.leadingIcon) {
      this.leadingIcon.destroy();
    }
    if (this.helperText) {
      this.helperText.destroy();
    }
    _super.prototype.destroy.call(this);
  };
  Object.defineProperty(MDCSelect2.prototype, "value", {
    get: function() {
      return this.foundation.getValue();
    },
    set: function(value) {
      this.foundation.setValue(value);
    },
    enumerable: false,
    configurable: true
  });
  MDCSelect2.prototype.setValue = function(value, skipNotify) {
    if (skipNotify === void 0) {
      skipNotify = false;
    }
    this.foundation.setValue(value, skipNotify);
  };
  Object.defineProperty(MDCSelect2.prototype, "selectedIndex", {
    get: function() {
      return this.foundation.getSelectedIndex();
    },
    set: function(selectedIndex) {
      this.foundation.setSelectedIndex(selectedIndex, true);
    },
    enumerable: false,
    configurable: true
  });
  MDCSelect2.prototype.setSelectedIndex = function(selectedIndex, skipNotify) {
    if (skipNotify === void 0) {
      skipNotify = false;
    }
    this.foundation.setSelectedIndex(selectedIndex, true, skipNotify);
  };
  Object.defineProperty(MDCSelect2.prototype, "disabled", {
    get: function() {
      return this.foundation.getDisabled();
    },
    set: function(disabled) {
      this.foundation.setDisabled(disabled);
      if (this.hiddenInput) {
        this.hiddenInput.disabled = disabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "leadingIconAriaLabel", {
    set: function(label) {
      this.foundation.setLeadingIconAriaLabel(label);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "leadingIconContent", {
    set: function(content) {
      this.foundation.setLeadingIconContent(content);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "helperTextContent", {
    set: function(content) {
      this.foundation.setHelperTextContent(content);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "useDefaultValidation", {
    set: function(useDefaultValidation) {
      this.foundation.setUseDefaultValidation(useDefaultValidation);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "valid", {
    get: function() {
      return this.foundation.isValid();
    },
    set: function(isValid) {
      this.foundation.setValid(isValid);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSelect2.prototype, "required", {
    get: function() {
      return this.foundation.getRequired();
    },
    set: function(isRequired) {
      this.foundation.setRequired(isRequired);
    },
    enumerable: false,
    configurable: true
  });
  MDCSelect2.prototype.layout = function() {
    this.foundation.layout();
  };
  MDCSelect2.prototype.layoutOptions = function() {
    this.foundation.layoutOptions();
    this.menu.layout();
    this.menuItemValues = this.menu.items.map(function(el) {
      return el.getAttribute(strings3.VALUE_ATTR) || "";
    });
    if (this.hiddenInput) {
      this.hiddenInput.value = this.value;
    }
  };
  MDCSelect2.prototype.getDefaultFoundation = function() {
    var adapter = __assign(__assign(__assign(__assign({}, this.getSelectAdapterMethods()), this.getCommonAdapterMethods()), this.getOutlineAdapterMethods()), this.getLabelAdapterMethods());
    return new MDCSelectFoundation(adapter, this.getFoundationMap());
  };
  MDCSelect2.prototype.menuSetup = function(menuFactory) {
    this.menuElement = this.root.querySelector(strings3.MENU_SELECTOR);
    this.menu = menuFactory(this.menuElement);
    this.menu.hasTypeahead = true;
    this.menu.singleSelection = true;
    this.menuItemValues = this.menu.items.map(function(el) {
      return el.getAttribute(strings3.VALUE_ATTR) || "";
    });
  };
  MDCSelect2.prototype.createRipple = function() {
    var _this = this;
    var adapter = __assign(__assign({}, MDCRipple.createAdapter({ root: this.selectAnchor })), { registerInteractionHandler: function(evtType, handler) {
      _this.selectAnchor.addEventListener(evtType, handler);
    }, deregisterInteractionHandler: function(evtType, handler) {
      _this.selectAnchor.removeEventListener(evtType, handler);
    } });
    return new MDCRipple(this.selectAnchor, new MDCRippleFoundation(adapter));
  };
  MDCSelect2.prototype.getSelectAdapterMethods = function() {
    var _this = this;
    return {
      getMenuItemAttr: function(menuItem, attr) {
        return menuItem.getAttribute(attr);
      },
      setSelectedText: function(text2) {
        _this.selectedText.textContent = text2;
      },
      isSelectAnchorFocused: function() {
        return document.activeElement === _this.selectAnchor;
      },
      getSelectAnchorAttr: function(attr) {
        return _this.selectAnchor.getAttribute(attr);
      },
      setSelectAnchorAttr: function(attr, value) {
        _this.selectAnchor.setAttribute(attr, value);
      },
      removeSelectAnchorAttr: function(attr) {
        _this.selectAnchor.removeAttribute(attr);
      },
      addMenuClass: function(className) {
        _this.menuElement.classList.add(className);
      },
      removeMenuClass: function(className) {
        _this.menuElement.classList.remove(className);
      },
      openMenu: function() {
        _this.menu.open = true;
      },
      closeMenu: function() {
        _this.menu.open = false;
      },
      getAnchorElement: function() {
        return _this.root.querySelector(strings3.SELECT_ANCHOR_SELECTOR);
      },
      setMenuAnchorElement: function(anchorEl) {
        _this.menu.setAnchorElement(anchorEl);
      },
      setMenuAnchorCorner: function(anchorCorner) {
        _this.menu.setAnchorCorner(anchorCorner);
      },
      setMenuWrapFocus: function(wrapFocus) {
        _this.menu.wrapFocus = wrapFocus;
      },
      getSelectedIndex: function() {
        var index = _this.menu.selectedIndex;
        return index instanceof Array ? index[0] : index;
      },
      setSelectedIndex: function(index) {
        _this.menu.selectedIndex = index;
      },
      focusMenuItemAtIndex: function(index) {
        _this.menu.items[index].focus();
      },
      getMenuItemCount: function() {
        return _this.menu.items.length;
      },
      getMenuItemValues: function() {
        return _this.menuItemValues;
      },
      getMenuItemTextAtIndex: function(index) {
        return _this.menu.getPrimaryTextAtIndex(index);
      },
      isTypeaheadInProgress: function() {
        return _this.menu.typeaheadInProgress;
      },
      typeaheadMatchItem: function(nextChar, startingIndex) {
        return _this.menu.typeaheadMatchItem(nextChar, startingIndex);
      }
    };
  };
  MDCSelect2.prototype.getCommonAdapterMethods = function() {
    var _this = this;
    return {
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      setRippleCenter: function(normalizedX) {
        _this.lineRipple && _this.lineRipple.setRippleCenter(normalizedX);
      },
      activateBottomLine: function() {
        _this.lineRipple && _this.lineRipple.activate();
      },
      deactivateBottomLine: function() {
        _this.lineRipple && _this.lineRipple.deactivate();
      },
      notifyChange: function(value) {
        if (_this.hiddenInput) {
          _this.hiddenInput.value = value;
        }
        var index = _this.selectedIndex;
        _this.emit(strings3.CHANGE_EVENT, { value, index }, true);
      }
    };
  };
  MDCSelect2.prototype.getOutlineAdapterMethods = function() {
    var _this = this;
    return {
      hasOutline: function() {
        return Boolean(_this.outline);
      },
      notchOutline: function(labelWidth) {
        _this.outline && _this.outline.notch(labelWidth);
      },
      closeOutline: function() {
        _this.outline && _this.outline.closeNotch();
      }
    };
  };
  MDCSelect2.prototype.getLabelAdapterMethods = function() {
    var _this = this;
    return {
      hasLabel: function() {
        return !!_this.label;
      },
      floatLabel: function(shouldFloat) {
        _this.label && _this.label.float(shouldFloat);
      },
      getLabelWidth: function() {
        return _this.label ? _this.label.getWidth() : 0;
      },
      setLabelRequired: function(isRequired) {
        _this.label && _this.label.setRequired(isRequired);
      }
    };
  };
  MDCSelect2.prototype.getNormalizedXCoordinate = function(evt) {
    var targetClientRect = evt.target.getBoundingClientRect();
    var xCoordinate = this.isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
    return xCoordinate - targetClientRect.left;
  };
  MDCSelect2.prototype.isTouchEvent = function(evt) {
    return Boolean(evt.touches);
  };
  MDCSelect2.prototype.getFoundationMap = function() {
    return {
      helperText: this.helperText ? this.helperText.foundationForSelect : void 0,
      leadingIcon: this.leadingIcon ? this.leadingIcon.foundationForSelect : void 0
    };
  };
  return MDCSelect2;
}(MDCComponent);

// node_modules/@smui/menu-surface/dist/MenuSurface.svelte
var { document: document_1 } = globals;
var file = "node_modules/@smui/menu-surface/dist/MenuSurface.svelte";
function create_fragment(ctx) {
  let t;
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[33].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[32], null);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-menu-surface": true,
        "mdc-menu-surface--fixed": ctx[4],
        "mdc-menu-surface--open": ctx[3],
        "smui-menu-surface--static": ctx[3],
        "mdc-menu-surface--fullwidth": ctx[5],
        ...ctx[8]
      })
    },
    {
      style: div_style_value = Object.entries(ctx[9]).map(func).concat([ctx[2]]).join(" ")
    },
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 2, 0, 52);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[34](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(document_1.body, "click", ctx[11], true, false, false),
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, div)),
          listen_dev(
            div,
            "keydown",
            function() {
              if (is_function(ctx[7] && ctx[7].handleKeydown.bind(ctx[7])))
                (ctx[7] && ctx[7].handleKeydown.bind(ctx[7])).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[32],
            !current ? get_all_dirty_from_scope(ctx[32]) : get_slot_changes(default_slot_template, ctx[32], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & 314 && div_class_value !== (div_class_value = classMap({
          [ctx[1]]: true,
          "mdc-menu-surface": true,
          "mdc-menu-surface--fixed": ctx[4],
          "mdc-menu-surface--open": ctx[3],
          "smui-menu-surface--static": ctx[3],
          "mdc-menu-surface--fullwidth": ctx[5],
          ...ctx[8]
        }))) && { class: div_class_value },
        (!current || dirty[0] & 516 && div_style_value !== (div_style_value = Object.entries(ctx[9]).map(func).concat([ctx[2]]).join(" "))) && { style: div_style_value },
        dirty[0] & 4096 && ctx[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 1)
        useActions_action.update.call(null, ctx[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[34](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "static",
    "anchor",
    "fixed",
    "open",
    "managed",
    "fullWidth",
    "quickOpen",
    "anchorElement",
    "anchorCorner",
    "anchorMargin",
    "maxHeight",
    "horizontallyCenteredOnViewport",
    "openBottomBias",
    "isOpen",
    "setOpen",
    "setAbsolutePosition",
    "setIsHoisted",
    "isFixed",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuSurface", slots, ["default"]);
  var _a, _b, _c;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { static: isStatic = false } = $$props;
  let { anchor = true } = $$props;
  let { fixed = false } = $$props;
  let { open = isStatic } = $$props;
  let { managed = false } = $$props;
  let { fullWidth = false } = $$props;
  let { quickOpen = false } = $$props;
  let { anchorElement = void 0 } = $$props;
  let { anchorCorner = void 0 } = $$props;
  let { anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 } } = $$props;
  let { maxHeight = 0 } = $$props;
  let { horizontallyCenteredOnViewport = false } = $$props;
  let { openBottomBias = 0 } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let previousFocus = void 0;
  setContext("SMUI:list:role", "menu");
  setContext("SMUI:list:item:role", "menuitem");
  const iCorner = Corner;
  onMount(() => {
    $$invalidate(7, instance2 = new MDCMenuSurfaceFoundation({
      addClass,
      removeClass,
      hasClass,
      hasAnchor: () => !!anchorElement,
      notifyClose: () => {
        if (!managed) {
          $$invalidate(13, open = isStatic);
        }
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:closed", void 0, void 0, true);
        }
      },
      notifyClosing: () => {
        if (!managed) {
          $$invalidate(13, open = isStatic);
        }
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:closing", void 0, void 0, true);
        }
      },
      notifyOpen: () => {
        if (!managed) {
          $$invalidate(13, open = true);
        }
        if (open) {
          dispatch(element2, "SMUIMenuSurface:opened", void 0, void 0, true);
        }
      },
      notifyOpening: () => {
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:opening", void 0, void 0, true);
        }
      },
      isElementInContainer: (el) => element2.contains(el),
      isRtl: () => getComputedStyle(element2).getPropertyValue("direction") === "rtl",
      setTransformOrigin: (origin) => {
        $$invalidate(9, internalStyles["transform-origin"] = origin, internalStyles);
      },
      isFocused: () => document.activeElement === element2,
      saveFocus: () => {
        var _a2;
        previousFocus = (_a2 = document.activeElement) !== null && _a2 !== void 0 ? _a2 : void 0;
      },
      restoreFocus: () => {
        if ((!element2 || element2.contains(document.activeElement)) && previousFocus && document.contains(previousFocus) && "focus" in previousFocus) {
          previousFocus.focus();
        }
      },
      getInnerDimensions: () => {
        return {
          width: element2.offsetWidth,
          height: element2.offsetHeight
        };
      },
      getAnchorDimensions: () => anchorElement ? anchorElement.getBoundingClientRect() : null,
      getWindowDimensions: () => {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      },
      getBodyDimensions: () => {
        return {
          width: document.body.clientWidth,
          height: document.body.clientHeight
        };
      },
      getWindowScroll: () => {
        return {
          x: window.pageXOffset,
          y: window.pageYOffset
        };
      },
      setPosition: (position) => {
        $$invalidate(9, internalStyles.left = "left" in position ? `${position.left}px` : "", internalStyles);
        $$invalidate(9, internalStyles.right = "right" in position ? `${position.right}px` : "", internalStyles);
        $$invalidate(9, internalStyles.top = "top" in position ? `${position.top}px` : "", internalStyles);
        $$invalidate(9, internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "", internalStyles);
      },
      setMaxHeight: (height) => {
        $$invalidate(9, internalStyles["max-height"] = height, internalStyles);
      }
    }));
    const accessor = {
      get open() {
        return open;
      },
      set open(value) {
        $$invalidate(13, open = value);
      },
      closeProgrammatic
    };
    dispatch(element2, "SMUIMenuSurface:mount", accessor);
    instance2.init();
    return () => {
      var _a2;
      const isHoisted = instance2.isHoistedElement;
      instance2.destroy();
      if (isHoisted) {
        (_a2 = element2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(element2);
      }
    };
  });
  onDestroy(() => {
    var _a2;
    if (anchor) {
      element2 && ((_a2 = element2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.classList.remove("mdc-menu-surface--anchor"));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function closeProgrammatic(skipRestoreFocus) {
    instance2.close(skipRestoreFocus);
    $$invalidate(13, open = false);
  }
  function handleBodyClick(event) {
    if (instance2 && open && !managed) {
      instance2.handleBodyClick(event);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(13, open = value);
  }
  function setAbsolutePosition(x, y) {
    return instance2.setAbsolutePosition(x, y);
  }
  function setIsHoisted(isHoisted) {
    return instance2.setIsHoisted(isHoisted);
  }
  function isFixed() {
    return instance2.isFixed();
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("static" in $$new_props)
      $$invalidate(3, isStatic = $$new_props.static);
    if ("anchor" in $$new_props)
      $$invalidate(15, anchor = $$new_props.anchor);
    if ("fixed" in $$new_props)
      $$invalidate(4, fixed = $$new_props.fixed);
    if ("open" in $$new_props)
      $$invalidate(13, open = $$new_props.open);
    if ("managed" in $$new_props)
      $$invalidate(16, managed = $$new_props.managed);
    if ("fullWidth" in $$new_props)
      $$invalidate(5, fullWidth = $$new_props.fullWidth);
    if ("quickOpen" in $$new_props)
      $$invalidate(17, quickOpen = $$new_props.quickOpen);
    if ("anchorElement" in $$new_props)
      $$invalidate(14, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$new_props)
      $$invalidate(18, anchorCorner = $$new_props.anchorCorner);
    if ("anchorMargin" in $$new_props)
      $$invalidate(19, anchorMargin = $$new_props.anchorMargin);
    if ("maxHeight" in $$new_props)
      $$invalidate(20, maxHeight = $$new_props.maxHeight);
    if ("horizontallyCenteredOnViewport" in $$new_props)
      $$invalidate(21, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
    if ("openBottomBias" in $$new_props)
      $$invalidate(22, openBottomBias = $$new_props.openBottomBias);
    if ("$$scope" in $$new_props)
      $$invalidate(32, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    _b,
    _c,
    MDCMenuSurfaceFoundation,
    onMount,
    onDestroy,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    Corner,
    forwardEvents,
    use,
    className,
    style,
    isStatic,
    anchor,
    fixed,
    open,
    managed,
    fullWidth,
    quickOpen,
    anchorElement,
    anchorCorner,
    anchorMargin,
    maxHeight,
    horizontallyCenteredOnViewport,
    openBottomBias,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    previousFocus,
    iCorner,
    hasClass,
    addClass,
    removeClass,
    closeProgrammatic,
    handleBodyClick,
    isOpen,
    setOpen,
    setAbsolutePosition,
    setIsHoisted,
    isFixed,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      $$invalidate(29, _a = $$new_props._a);
    if ("_b" in $$props)
      $$invalidate(30, _b = $$new_props._b);
    if ("_c" in $$props)
      $$invalidate(31, _c = $$new_props._c);
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("isStatic" in $$props)
      $$invalidate(3, isStatic = $$new_props.isStatic);
    if ("anchor" in $$props)
      $$invalidate(15, anchor = $$new_props.anchor);
    if ("fixed" in $$props)
      $$invalidate(4, fixed = $$new_props.fixed);
    if ("open" in $$props)
      $$invalidate(13, open = $$new_props.open);
    if ("managed" in $$props)
      $$invalidate(16, managed = $$new_props.managed);
    if ("fullWidth" in $$props)
      $$invalidate(5, fullWidth = $$new_props.fullWidth);
    if ("quickOpen" in $$props)
      $$invalidate(17, quickOpen = $$new_props.quickOpen);
    if ("anchorElement" in $$props)
      $$invalidate(14, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$props)
      $$invalidate(18, anchorCorner = $$new_props.anchorCorner);
    if ("anchorMargin" in $$props)
      $$invalidate(19, anchorMargin = $$new_props.anchorMargin);
    if ("maxHeight" in $$props)
      $$invalidate(20, maxHeight = $$new_props.maxHeight);
    if ("horizontallyCenteredOnViewport" in $$props)
      $$invalidate(21, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
    if ("openBottomBias" in $$props)
      $$invalidate(22, openBottomBias = $$new_props.openBottomBias);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(7, instance2 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(9, internalStyles = $$new_props.internalStyles);
    if ("previousFocus" in $$props)
      previousFocus = $$new_props.previousFocus;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1610645568 | $$self.$$.dirty[1] & 1) {
      $:
        if (element2 && anchor && !($$invalidate(29, _a = element2.parentElement) === null || _a === void 0 ? void 0 : _a.classList.contains("mdc-menu-surface--anchor"))) {
          $$invalidate(30, _b = element2.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add("mdc-menu-surface--anchor");
          $$invalidate(14, anchorElement = $$invalidate(31, _c = element2.parentElement) !== null && _c !== void 0 ? _c : void 0);
        }
    }
    if ($$self.$$.dirty[0] & 8320) {
      $:
        if (instance2 && instance2.isOpen() !== open) {
          if (open) {
            instance2.open();
          } else {
            instance2.close();
          }
        }
    }
    if ($$self.$$.dirty[0] & 131200) {
      $:
        if (instance2) {
          instance2.setQuickOpen(quickOpen);
        }
    }
    if ($$self.$$.dirty[0] & 144) {
      $:
        if (instance2) {
          instance2.setFixedPosition(fixed);
        }
    }
    if ($$self.$$.dirty[0] & 1048704) {
      $:
        if (instance2) {
          instance2.setMaxHeight(maxHeight);
        }
    }
    if ($$self.$$.dirty[0] & 2097280) {
      $:
        if (instance2) {
          instance2.setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport);
        }
    }
    if ($$self.$$.dirty[0] & 262272) {
      $:
        if (instance2 && anchorCorner != null) {
          if (typeof anchorCorner === "string") {
            instance2.setAnchorCorner(iCorner[anchorCorner]);
          } else {
            instance2.setAnchorCorner(anchorCorner);
          }
        }
    }
    if ($$self.$$.dirty[0] & 524416) {
      $:
        if (instance2) {
          instance2.setAnchorMargin(anchorMargin);
        }
    }
    if ($$self.$$.dirty[0] & 4194432) {
      $:
        if (instance2) {
          instance2.setOpenBottomBias(openBottomBias);
        }
    }
  };
  return [
    use,
    className,
    style,
    isStatic,
    fixed,
    fullWidth,
    element2,
    instance2,
    internalClasses,
    internalStyles,
    forwardEvents,
    handleBodyClick,
    $$restProps,
    open,
    anchorElement,
    anchor,
    managed,
    quickOpen,
    anchorCorner,
    anchorMargin,
    maxHeight,
    horizontallyCenteredOnViewport,
    openBottomBias,
    isOpen,
    setOpen,
    setAbsolutePosition,
    setIsHoisted,
    isFixed,
    getElement,
    _a,
    _b,
    _c,
    $$scope,
    slots,
    div_binding
  ];
}
var MenuSurface = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        static: 3,
        anchor: 15,
        fixed: 4,
        open: 13,
        managed: 16,
        fullWidth: 5,
        quickOpen: 17,
        anchorElement: 14,
        anchorCorner: 18,
        anchorMargin: 19,
        maxHeight: 20,
        horizontallyCenteredOnViewport: 21,
        openBottomBias: 22,
        isOpen: 23,
        setOpen: 24,
        setAbsolutePosition: 25,
        setIsHoisted: 26,
        isFixed: 27,
        getElement: 28
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuSurface",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get managed() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set managed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get quickOpen() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set quickOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorCorner() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorCorner(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorMargin() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorMargin(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontallyCenteredOnViewport() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontallyCenteredOnViewport(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openBottomBias() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openBottomBias(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[23];
  }
  set isOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[24];
  }
  set setOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setAbsolutePosition() {
    return this.$$.ctx[25];
  }
  set setAbsolutePosition(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setIsHoisted() {
    return this.$$.ctx[26];
  }
  set setIsHoisted(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFixed() {
    return this.$$.ctx[27];
  }
  set isFixed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[28];
  }
  set getElement(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuSurface_default = MenuSurface;

// node_modules/@smui/menu-surface/dist/Anchor.js
function Anchor(node, { addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className) } = {}) {
  addClass("mdc-menu-surface--anchor");
  return {
    destroy() {
      removeClass("mdc-menu-surface--anchor");
    }
  };
}

// node_modules/@smui/menu-surface/dist/index.js
var dist_default6 = MenuSurface_default;

// node_modules/@smui/menu/dist/Menu.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[22], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(default_slot_template, ctx2[22], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <MenuSurface   bind:this={element}   use={usePass}   class={classMap({     [className]: true,     'mdc-menu': true,   })}   bind:open   on:SMUIMenuSurface:mount={handleMenuSurfaceAccessor}   on:SMUIList:mount={handleListAccessor}   on:SMUIMenuSurface:opened={() =>     instance && instance.handleMenuSurfaceOpened()}   on:keydown={handleKeydown}   on:SMUIList:action={(event) =>     instance &&     instance.handleItemAction(       listAccessor.getOrderedList()[event.detail.index].element     )}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let menusurface;
  let updating_open;
  let current;
  const menusurface_spread_levels = [
    { use: ctx[5] },
    {
      class: classMap({
        [ctx[1]]: true,
        "mdc-menu": true
      })
    },
    ctx[9]
  ];
  function menusurface_open_binding(value) {
    ctx[19](value);
  }
  let menusurface_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
    menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    menusurface_props.open = ctx[0];
  }
  menusurface = new dist_default6({ props: menusurface_props, $$inline: true });
  ctx[18](menusurface);
  binding_callbacks.push(() => bind(menusurface, "open", menusurface_open_binding));
  menusurface.$on("SMUIMenuSurface:mount", ctx[7]);
  menusurface.$on("SMUIList:mount", ctx[8]);
  menusurface.$on("SMUIMenuSurface:opened", ctx[20]);
  menusurface.$on("keydown", ctx[6]);
  menusurface.$on("SMUIList:action", ctx[21]);
  const block = {
    c: function create() {
      create_component(menusurface.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(menusurface, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const menusurface_changes = dirty & 546 ? get_spread_update(menusurface_spread_levels, [
        dirty & 32 && { use: ctx2[5] },
        dirty & 2 && {
          class: classMap({
            [ctx2[1]]: true,
            "mdc-menu": true
          })
        },
        dirty & 512 && get_spread_object(ctx2[9])
      ]) : {};
      if (dirty & 4194304) {
        menusurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & 1) {
        updating_open = true;
        menusurface_changes.open = ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      menusurface.$set(menusurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menusurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menusurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(menusurface, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_12($$self, $$props, $$invalidate) {
  let usePass;
  const omit_props_names = [
    "use",
    "class",
    "open",
    "isOpen",
    "setOpen",
    "setDefaultFocusState",
    "getSelectedIndex",
    "getMenuSurface",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["default"]);
  const { closest: closest2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let element2;
  let instance2;
  let menuSurfaceAccessor;
  let listAccessor;
  onMount(() => {
    $$invalidate(3, instance2 = new MDCMenuFoundation({
      addClassToElementAtIndex: (index, className2) => {
        listAccessor.addClassForElementIndex(index, className2);
      },
      removeClassFromElementAtIndex: (index, className2) => {
        listAccessor.removeClassForElementIndex(index, className2);
      },
      addAttributeToElementAtIndex: (index, attr, value) => {
        listAccessor.setAttributeForElementIndex(index, attr, value);
      },
      removeAttributeFromElementAtIndex: (index, attr) => {
        listAccessor.removeAttributeForElementIndex(index, attr);
      },
      getAttributeFromElementAtIndex: (index, attr) => listAccessor.getAttributeFromElementIndex(index, attr),
      elementContainsClass: (element3, className2) => element3.classList.contains(className2),
      closeSurface: (skipRestoreFocus) => menuSurfaceAccessor.closeProgrammatic(skipRestoreFocus),
      getElementIndex: (element3) => listAccessor.getOrderedList().map((accessor) => accessor.element).indexOf(element3),
      notifySelected: (evtData) => dispatch(
        getElement(),
        "SMUIMenu:selected",
        {
          index: evtData.index,
          item: listAccessor.getOrderedList()[evtData.index].element
        },
        void 0,
        true
      ),
      getMenuItemCount: () => listAccessor.items.length,
      focusItemAtIndex: (index) => listAccessor.focusItemAtIndex(index),
      focusListRoot: () => "focus" in listAccessor.element && listAccessor.element.focus(),
      isSelectableItemAtIndex: (index) => !!closest2(listAccessor.getOrderedList()[index].element, `.${cssClasses3.MENU_SELECTION_GROUP}`),
      getSelectedSiblingOfItemAtIndex: (index) => {
        const orderedList = listAccessor.getOrderedList();
        const selectionGroupEl = closest2(orderedList[index].element, `.${cssClasses3.MENU_SELECTION_GROUP}`);
        const selectedItemEl = selectionGroupEl === null || selectionGroupEl === void 0 ? void 0 : selectionGroupEl.querySelector(`.${cssClasses3.MENU_SELECTED_LIST_ITEM}`);
        return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
      }
    }));
    dispatch(getElement(), "SMUIMenu:mount", instance2);
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function handleKeydown(event) {
    instance2 && instance2.handleKeydown(event);
  }
  function handleMenuSurfaceAccessor(event) {
    if (!menuSurfaceAccessor) {
      menuSurfaceAccessor = event.detail;
    }
  }
  function handleListAccessor(event) {
    if (!listAccessor) {
      $$invalidate(4, listAccessor = event.detail);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function setDefaultFocusState(focusState) {
    instance2.setDefaultFocusState(focusState);
  }
  function getSelectedIndex() {
    return instance2.getSelectedIndex();
  }
  function getMenuSurface() {
    return element2;
  }
  function getElement() {
    return element2.getElement();
  }
  function menusurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function menusurface_open_binding(value) {
    open = value;
    $$invalidate(0, open);
  }
  const SMUIMenuSurface_opened_handler = () => instance2 && instance2.handleMenuSurfaceOpened();
  const SMUIList_action_handler = (event) => instance2 && instance2.handleItemAction(listAccessor.getOrderedList()[event.detail.index].element);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(10, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCMenuFoundation,
    cssClasses: cssClasses3,
    ponyfill: ponyfill_exports,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    MenuSurface: dist_default6,
    closest: closest2,
    forwardEvents,
    use,
    className,
    open,
    element: element2,
    instance: instance2,
    menuSurfaceAccessor,
    listAccessor,
    handleKeydown,
    handleMenuSurfaceAccessor,
    handleListAccessor,
    isOpen,
    setOpen,
    setDefaultFocusState,
    getSelectedIndex,
    getMenuSurface,
    getElement,
    usePass
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(10, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(3, instance2 = $$new_props.instance);
    if ("menuSurfaceAccessor" in $$props)
      menuSurfaceAccessor = $$new_props.menuSurfaceAccessor;
    if ("listAccessor" in $$props)
      $$invalidate(4, listAccessor = $$new_props.listAccessor);
    if ("usePass" in $$props)
      $$invalidate(5, usePass = $$new_props.usePass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(5, usePass = [forwardEvents, ...use]);
    }
  };
  return [
    open,
    className,
    element2,
    instance2,
    listAccessor,
    usePass,
    handleKeydown,
    handleMenuSurfaceAccessor,
    handleListAccessor,
    $$restProps,
    use,
    isOpen,
    setOpen,
    setDefaultFocusState,
    getSelectedIndex,
    getMenuSurface,
    getElement,
    slots,
    menusurface_binding,
    menusurface_open_binding,
    SMUIMenuSurface_opened_handler,
    SMUIList_action_handler,
    $$scope
  ];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      use: 10,
      class: 1,
      open: 0,
      isOpen: 11,
      setOpen: 12,
      setDefaultFocusState: 13,
      getSelectedIndex: 14,
      getMenuSurface: 15,
      getElement: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[11];
  }
  set isOpen(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[12];
  }
  set setOpen(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setDefaultFocusState() {
    return this.$$.ctx[13];
  }
  set setDefaultFocusState(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectedIndex() {
    return this.$$.ctx[14];
  }
  set getSelectedIndex(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getMenuSurface() {
    return this.$$.ctx[15];
  }
  set getMenuSurface(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[16];
  }
  set getElement(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/@smui/menu/dist/SelectionGroupIcon.js
var SelectionGroupIcon_default = classAdderBuilder({
  class: "mdc-menu__selection-group-icon",
  component: Graphic_default
});

// node_modules/@smui/menu/dist/index.js
var dist_default7 = Menu_default;

// node_modules/@smui/select/dist/helper-text/HelperText.svelte
var file2 = "node_modules/@smui/select/dist/helper-text/HelperText.svelte";
function create_else_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[8]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256)
        set_data_dev(t, ctx2[8]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(17:31) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(17:2) {#if content == null}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_aria_hidden_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8] == null)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-select-helper-text": true,
        "mdc-select-helper-text--validation-msg": ctx[4],
        "mdc-select-helper-text--validation-msg-persistent": ctx[3],
        ...ctx[6]
      })
    },
    {
      "aria-hidden": div_aria_hidden_value = ctx[3] ? void 0 : "true"
    },
    { id: ctx[2] },
    ctx[7],
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[14](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[9].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 90 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-select-helper-text": true,
          "mdc-select-helper-text--validation-msg": ctx2[4],
          "mdc-select-helper-text--validation-msg-persistent": ctx2[3],
          ...ctx2[6]
        }))) && { class: div_class_value },
        (!current || dirty & 8 && div_aria_hidden_value !== (div_aria_hidden_value = ctx2[3] ? void 0 : "true")) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & 4) && { id: ctx2[2] },
        dirty & 128 && ctx2[7],
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HelperText", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { id = "SMUI-select-helper-text-" + counter++ } = $$props;
  let { persistent = false } = $$props;
  let { validationMsg = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalAttrs = {};
  let content = void 0;
  onMount(() => {
    instance2 = new MDCSelectHelperTextFoundation({
      addClass,
      removeClass,
      hasClass,
      getAttr,
      setAttr: addAttr,
      removeAttr,
      setContent: (value) => {
        $$invalidate(8, content = value);
      }
    });
    if (id.startsWith("SMUI-select-helper-text-")) {
      dispatch(getElement(), "SMUISelectHelperText:id", id);
    }
    dispatch(getElement(), "SMUISelectHelperText:mount", instance2);
    instance2.init();
    return () => {
      dispatch(getElement(), "SMUISelectHelperText:unmount", instance2);
      instance2.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(7, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(7, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("persistent" in $$new_props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("validationMsg" in $$new_props)
      $$invalidate(4, validationMsg = $$new_props.validationMsg);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    MDCSelectHelperTextFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    id,
    persistent,
    validationMsg,
    element: element2,
    instance: instance2,
    internalClasses,
    internalAttrs,
    content,
    hasClass,
    addClass,
    removeClass,
    getAttr,
    addAttr,
    removeAttr,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("persistent" in $$props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("validationMsg" in $$props)
      $$invalidate(4, validationMsg = $$new_props.validationMsg);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance2 = $$new_props.instance;
    if ("internalClasses" in $$props)
      $$invalidate(6, internalClasses = $$new_props.internalClasses);
    if ("internalAttrs" in $$props)
      $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
    if ("content" in $$props)
      $$invalidate(8, content = $$new_props.content);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    id,
    persistent,
    validationMsg,
    element2,
    internalClasses,
    internalAttrs,
    content,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
var HelperText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment3, safe_not_equal, {
      use: 0,
      class: 1,
      id: 2,
      persistent: 3,
      validationMsg: 4,
      getElement: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HelperText",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationMsg() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationMsg(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HelperText_default = HelperText;

// node_modules/@smui/select/dist/Select.svelte
var file3 = "node_modules/@smui/select/dist/Select.svelte";
var get_helperText_slot_changes = (dirty) => ({});
var get_helperText_slot_context = (ctx) => ({});
var get_leadingIcon_slot_changes = (dirty) => ({});
var get_leadingIcon_slot_context = (ctx) => ({});
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block_6(ctx) {
  let input;
  let input_levels = [
    { type: "hidden" },
    { required: ctx[10] },
    { disabled: ctx[6] },
    { value: ctx[0] },
    prefixFilter(ctx[52], "input$")
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file3, 51, 4, 1457);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "hidden" },
        dirty[0] & 1024 && { required: ctx2[10] },
        dirty[0] & 64 && { disabled: ctx2[6] },
        dirty[0] & 1 && { value: ctx2[0] },
        dirty[1] & 2097152 && prefixFilter(ctx2[52], "input$")
      ]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(51:2) {#if hiddenInput}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "mdc-select__ripple");
      add_location(span, file3, 85, 6, 2386);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(85:4) {#if variant === 'filled'}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    { id: ctx[11] + "-smui-label" },
    {
      floatAbove: ctx[42] !== ""
    },
    { required: ctx[10] },
    prefixFilter(ctx[52], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default3({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[65](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 2099200 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 2048 && { id: ctx2[11] + "-smui-label" },
        dirty[1] & 2048 && {
          floatAbove: ctx2[42] !== ""
        },
        dirty[0] & 1024 && { required: ctx2[10] },
        dirty[1] & 2097152 && get_spread_object(prefixFilter(ctx2[52], "label$"))
      ]) : {};
      if (dirty[0] & 512 | dirty[2] & 16777216) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[65](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(88:4) {#if variant !== 'outlined' && !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
  let t;
  let current;
  const label_slot_template = ctx[62].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[86], get_label_slot_context);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 16777216)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[86],
            !current ? get_all_dirty_from_scope(ctx2[86]) : get_slot_changes(label_slot_template, ctx2[86], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(89:6) <FloatingLabel         bind:this={floatingLabel}         id={inputId + '-smui-label'}         floatAbove={$selectedTextStore !== ''}         {required}         {...prefixFilter($$restProps, 'label$')}         >",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let notchedoutline;
  let current;
  const notchedoutline_spread_levels = [
    {
      noLabel: ctx[8] || ctx[9] == null && !ctx[51].label
    },
    prefixFilter(ctx[52], "outline$")
  ];
  let notchedoutline_props = {
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
  }
  notchedoutline = new dist_default5({
    props: notchedoutline_props,
    $$inline: true
  });
  ctx[67](notchedoutline);
  const block = {
    c: function create() {
      create_component(notchedoutline.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notchedoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notchedoutline_changes = dirty[0] & 768 | dirty[1] & 3145728 ? get_spread_update(notchedoutline_spread_levels, [
        dirty[0] & 768 | dirty[1] & 1048576 && {
          noLabel: ctx2[8] || ctx2[9] == null && !ctx2[51].label
        },
        dirty[1] & 2097152 && get_spread_object(prefixFilter(ctx2[52], "outline$"))
      ]) : {};
      if (dirty[0] & 3840 | dirty[1] & 3148032 | dirty[2] & 16777216) {
        notchedoutline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notchedoutline.$set(notchedoutline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notchedoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notchedoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[67](null);
      destroy_component(notchedoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(98:4) {#if variant === 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    { id: ctx[11] + "-smui-label" },
    {
      floatAbove: ctx[42] !== ""
    },
    { required: ctx[10] },
    prefixFilter(ctx[52], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default3({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[66](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 3072 | dirty[1] & 2099200 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 2048 && { id: ctx2[11] + "-smui-label" },
        dirty[1] & 2048 && {
          floatAbove: ctx2[42] !== ""
        },
        dirty[0] & 1024 && { required: ctx2[10] },
        dirty[1] & 2097152 && get_spread_object(prefixFilter(ctx2[52], "label$"))
      ]) : {};
      if (dirty[0] & 512 | dirty[2] & 16777216) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[66](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(104:8) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t_value = (ctx[9] == null ? "" : ctx[9]) + "";
  let t;
  let current;
  const label_slot_template = ctx[62].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[86], get_label_slot_context_1);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 512) && t_value !== (t_value = (ctx2[9] == null ? "" : ctx2[9]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 16777216)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[86],
            !current ? get_all_dirty_from_scope(ctx2[86]) : get_slot_changes(label_slot_template, ctx2[86], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(105:10) <FloatingLabel             bind:this={floatingLabel}             id={inputId + '-smui-label'}             floatAbove={$selectedTextStore !== ''}             {required}             {...prefixFilter($$restProps, 'label$')}             >",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[8] && (ctx[9] != null || ctx[51].label) && create_if_block_3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[8] && (ctx2[9] != null || ctx2[51].label)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 768 | dirty[1] & 1048576) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(99:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let lineripple;
  let current;
  const lineripple_spread_levels = [prefixFilter(ctx[52], "ripple$")];
  let lineripple_props = {};
  for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
  }
  lineripple = new dist_default4({ props: lineripple_props, $$inline: true });
  ctx[68](lineripple);
  const block = {
    c: function create() {
      create_component(lineripple.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(lineripple, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineripple_changes = dirty[1] & 2097152 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(ctx2[52], "ripple$"))]) : {};
      lineripple.$set(lineripple_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineripple.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineripple.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[68](null);
      destroy_component(lineripple, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(167:4) {#if variant !== 'outlined' && ripple}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = ctx[62].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[86], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[86],
            !current ? get_all_dirty_from_scope(ctx2[86]) : get_slot_changes(default_slot_template, ctx2[86], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: `(193:4) <List       role=\\"listbox\\"       {wrapFocus}       bind:selectedIndex       on:SMUIList:mount={(event) => (list = event.detail)}       {...prefixFilter($$restProps, 'list$')}>`,
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let list_1;
  let updating_selectedIndex;
  let current;
  const list_1_spread_levels = [
    { role: "listbox" },
    { wrapFocus: ctx[35] },
    prefixFilter(ctx[52], "list$")
  ];
  function list_1_selectedIndex_binding(value) {
    ctx[73](value);
  }
  let list_1_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < list_1_spread_levels.length; i += 1) {
    list_1_props = assign(list_1_props, list_1_spread_levels[i]);
  }
  if (ctx[24] !== void 0) {
    list_1_props.selectedIndex = ctx[24];
  }
  list_1 = new dist_default2({ props: list_1_props, $$inline: true });
  binding_callbacks.push(() => bind(list_1, "selectedIndex", list_1_selectedIndex_binding));
  list_1.$on("SMUIList:mount", ctx[74]);
  const block = {
    c: function create() {
      create_component(list_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(list_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const list_1_changes = dirty[1] & 2097168 ? get_spread_update(list_1_spread_levels, [
        list_1_spread_levels[0],
        dirty[1] & 16 && { wrapFocus: ctx2[35] },
        dirty[1] & 2097152 && get_spread_object(prefixFilter(ctx2[52], "list$"))
      ]) : {};
      if (dirty[2] & 16777216) {
        list_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedIndex && dirty[0] & 16777216) {
        updating_selectedIndex = true;
        list_1_changes.selectedIndex = ctx2[24];
        add_flush_callback(() => updating_selectedIndex = false);
      }
      list_1.$set(list_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(list_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(175:2) <Menu     class={classMap({       [menu$class]: true,       'mdc-select__menu': true,       ...menuClasses,     })}     fullWidth     anchor={false}     {anchorElement}     {anchorCorner}     bind:open={menuOpen}     on:SMUIMenu:selected={(event) =>       instance && instance.handleMenuItemAction(event.detail.index)}     on:SMUIMenuSurface:closing={() => instance && instance.handleMenuClosing()}     on:SMUIMenuSurface:closed={() => instance && instance.handleMenuClosed()}     on:SMUIMenuSurface:opened={() => instance && instance.handleMenuOpened()}     {...prefixFilter($$restProps, 'menu$')}   >",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let helpertext;
  let current;
  const helpertext_spread_levels = [prefixFilter(ctx[52], "helperText$")];
  let helpertext_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < helpertext_spread_levels.length; i += 1) {
    helpertext_props = assign(helpertext_props, helpertext_spread_levels[i]);
  }
  helpertext = new HelperText_default({ props: helpertext_props, $$inline: true });
  helpertext.$on("SMUISelectHelperText:id", ctx[83]);
  helpertext.$on("SMUISelectHelperText:mount", ctx[84]);
  helpertext.$on("SMUISelectHelperText:unmount", ctx[85]);
  const block = {
    c: function create() {
      create_component(helpertext.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(helpertext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const helpertext_changes = dirty[1] & 2097152 ? get_spread_update(helpertext_spread_levels, [get_spread_object(prefixFilter(ctx2[52], "helperText$"))]) : {};
      if (dirty[2] & 16777216) {
        helpertext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpertext.$set(helpertext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helpertext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helpertext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(helpertext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(202:0) {#if $$slots.helperText}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const helperText_slot_template = ctx[62].helperText;
  const helperText_slot = create_slot(helperText_slot_template, ctx, ctx[86], get_helperText_slot_context);
  const block = {
    c: function create() {
      if (helperText_slot)
        helperText_slot.c();
    },
    m: function mount(target, anchor) {
      if (helperText_slot) {
        helperText_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (helperText_slot) {
        if (helperText_slot.p && (!current || dirty[2] & 16777216)) {
          update_slot_base(
            helperText_slot,
            helperText_slot_template,
            ctx2,
            ctx2[86],
            !current ? get_all_dirty_from_scope(ctx2[86]) : get_slot_changes(helperText_slot_template, ctx2[86], dirty, get_helperText_slot_changes),
            get_helperText_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helperText_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helperText_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (helperText_slot)
        helperText_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(203:2) <HelperText     on:SMUISelectHelperText:id={(event) => (helperId = event.detail)}     on:SMUISelectHelperText:mount={(event) => (helperText = event.detail)}     on:SMUISelectHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     {...prefixFilter($$restProps, 'helperText$')}     >",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let t3;
  let t4;
  let span1;
  let span0;
  let t5;
  let span0_id_value;
  let span0_class_value;
  let span0_aria_labelledby_value;
  let useActions_action;
  let span1_class_value;
  let useActions_action_1;
  let t6;
  let span2;
  let svg;
  let polygon0;
  let polygon1;
  let span2_class_value;
  let useActions_action_2;
  let t7;
  let div0_class_value;
  let div0_aria_required_value;
  let div0_aria_disabled_value;
  let useActions_action_3;
  let t8;
  let menu;
  let updating_open;
  let div1_class_value;
  let div1_style_value;
  let Ripple_action;
  let Anchor_action;
  let useActions_action_4;
  let forwardEvents_action;
  let t9;
  let if_block5_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[12] && create_if_block_6(ctx);
  let if_block1 = ctx[7] === "filled" && create_if_block_5(ctx);
  let if_block2 = ctx[7] !== "outlined" && !ctx[8] && (ctx[9] != null || ctx[51].label) && create_if_block_4(ctx);
  let if_block3 = ctx[7] === "outlined" && create_if_block_2(ctx);
  const leadingIcon_slot_template = ctx[62].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[86], get_leadingIcon_slot_context);
  let span0_levels = [
    {
      id: span0_id_value = ctx[11] + "-smui-selected-text"
    },
    {
      class: span0_class_value = classMap({
        [ctx[19]]: true,
        "mdc-select__selected-text": true
      })
    },
    { role: "button" },
    { "aria-haspopup": "listbox" },
    {
      "aria-labelledby": span0_aria_labelledby_value = ctx[11] + "-smui-label"
    },
    prefixFilter(ctx[52], "selectedText$")
  ];
  let span0_data = {};
  for (let i = 0; i < span0_levels.length; i += 1) {
    span0_data = assign(span0_data, span0_levels[i]);
  }
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [ctx[17]]: true,
        "mdc-select__selected-text-container": true
      })
    },
    prefixFilter(ctx[52], "selectedTextContainer$")
  ];
  let span1_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span1_data = assign(span1_data, span1_levels[i]);
  }
  let span2_levels = [
    {
      class: span2_class_value = classMap({
        [ctx[21]]: true,
        "mdc-select__dropdown-icon": true
      })
    },
    prefixFilter(ctx[52], "dropdownIcon$")
  ];
  let span2_data = {};
  for (let i = 0; i < span2_levels.length; i += 1) {
    span2_data = assign(span2_data, span2_levels[i]);
  }
  let if_block4 = ctx[7] !== "outlined" && ctx[5] && create_if_block_1(ctx);
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [ctx[15]]: true,
        "mdc-select__anchor": true
      })
    },
    {
      "aria-required": div0_aria_required_value = ctx[10] ? "true" : void 0
    },
    {
      "aria-disabled": div0_aria_disabled_value = ctx[6] ? "true" : void 0
    },
    { "aria-controls": ctx[30] },
    { "aria-describedby": ctx[30] },
    ctx[29],
    prefixFilter(ctx[52], "anchor$")
  ];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  const menu_spread_levels = [
    {
      class: classMap({
        [ctx[22]]: true,
        "mdc-select__menu": true,
        ...ctx[32]
      })
    },
    { fullWidth: true },
    { anchor: false },
    { anchorElement: ctx[33] },
    { anchorCorner: ctx[34] },
    prefixFilter(ctx[52], "menu$")
  ];
  function menu_open_binding(value) {
    ctx[75](value);
  }
  let menu_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menu_spread_levels.length; i += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i]);
  }
  if (ctx[31] !== void 0) {
    menu_props.open = ctx[31];
  }
  menu = new dist_default7({ props: menu_props, $$inline: true });
  binding_callbacks.push(() => bind(menu, "open", menu_open_binding));
  menu.$on("SMUIMenu:selected", ctx[76]);
  menu.$on("SMUIMenuSurface:closing", ctx[77]);
  menu.$on("SMUIMenuSurface:closed", ctx[78]);
  menu.$on("SMUIMenuSurface:opened", ctx[79]);
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [ctx[3]]: true,
        "mdc-select": true,
        "mdc-select--required": ctx[10],
        "mdc-select--disabled": ctx[6],
        "mdc-select--filled": ctx[7] === "filled",
        "mdc-select--outlined": ctx[7] === "outlined",
        "smui-select--standard": ctx[7] === "standard",
        "mdc-select--with-leading-icon": ctx[44](ctx[13]) ? ctx[51].leadingIcon : ctx[13],
        "mdc-select--no-label": ctx[8] || ctx[9] == null && !ctx[51].label,
        "mdc-select--invalid": ctx[1],
        "mdc-select--activated": ctx[31],
        "mdc-data-table__pagination-rows-per-page-select": ctx[45] === "data-table:pagination",
        ...ctx[26]
      })
    },
    {
      style: div1_style_value = Object.entries(ctx[27]).map(func2).concat([ctx[4]]).join(" ")
    },
    exclude(ctx[52], [
      "input$",
      "anchor$",
      "label$",
      "outline$",
      "selectedTextContainer$",
      "selectedText$",
      "dropdownIcon$",
      "ripple$",
      "menu$",
      "list$",
      "helperText$"
    ])
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  let if_block5 = ctx[51].helperText && create_if_block2(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (leadingIcon_slot)
        leadingIcon_slot.c();
      t4 = space();
      span1 = element("span");
      span0 = element("span");
      t5 = text(ctx[42]);
      t6 = space();
      span2 = element("span");
      svg = svg_element("svg");
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      t7 = space();
      if (if_block4)
        if_block4.c();
      t8 = space();
      create_component(menu.$$.fragment);
      t9 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      set_attributes(span0, span0_data);
      add_location(span0, file3, 124, 6, 3750);
      set_attributes(span1, span1_data);
      add_location(span1, file3, 116, 4, 3488);
      attr_dev(polygon0, "class", "mdc-select__dropdown-icon-inactive");
      attr_dev(polygon0, "stroke", "none");
      attr_dev(polygon0, "fill-rule", "evenodd");
      attr_dev(polygon0, "points", "7 10 12 15 17 10");
      add_location(polygon0, file3, 152, 8, 4541);
      attr_dev(polygon1, "class", "mdc-select__dropdown-icon-active");
      attr_dev(polygon1, "stroke", "none");
      attr_dev(polygon1, "fill-rule", "evenodd");
      attr_dev(polygon1, "points", "7 15 12 10 17 15");
      add_location(polygon1, file3, 158, 8, 4712);
      attr_dev(svg, "class", "mdc-select__dropdown-icon-graphic");
      attr_dev(svg, "viewBox", "7 10 10 5");
      attr_dev(svg, "focusable", "false");
      add_location(svg, file3, 147, 6, 4416);
      set_attributes(span2, span2_data);
      add_location(span2, file3, 139, 4, 4191);
      set_attributes(div0, div0_data);
      add_location(div0, file3, 59, 2, 1596);
      set_attributes(div1, div1_data);
      add_location(div1, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t3);
      if (leadingIcon_slot) {
        leadingIcon_slot.m(div0, null);
      }
      append_dev(div0, t4);
      append_dev(div0, span1);
      append_dev(span1, span0);
      append_dev(span0, t5);
      append_dev(div0, t6);
      append_dev(div0, span2);
      append_dev(span2, svg);
      append_dev(svg, polygon0);
      append_dev(svg, polygon1);
      append_dev(div0, t7);
      if (if_block4)
        if_block4.m(div0, null);
      ctx[69](div0);
      append_dev(div1, t8);
      mount_component(menu, div1, null);
      ctx[80](div1);
      insert_dev(target, t9, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_dev(target, if_block5_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span0, ctx[18])),
          action_destroyer(useActions_action_1 = useActions.call(null, span1, ctx[16])),
          action_destroyer(useActions_action_2 = useActions.call(null, span2, ctx[20])),
          action_destroyer(useActions_action_3 = useActions.call(null, div0, ctx[14])),
          listen_dev(div0, "focus", ctx[70], false, false, false),
          listen_dev(div0, "blur", ctx[71], false, false, false),
          listen_dev(div0, "click", ctx[72], false, false, false),
          listen_dev(
            div0,
            "keydown",
            function() {
              if (is_function(ctx[23] && ctx[23].handleKeydown.bind(ctx[23])))
                (ctx[23] && ctx[23].handleKeydown.bind(ctx[23])).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(div0, "focus", ctx[63], false, false, false),
          listen_dev(div0, "blur", ctx[64], false, false, false),
          action_destroyer(Ripple_action = dist_default.call(null, div1, {
            ripple: ctx[7] === "filled",
            unbounded: false,
            addClass: ctx[48],
            removeClass: ctx[49],
            addStyle: ctx[50]
          })),
          action_destroyer(Anchor_action = Anchor.call(null, div1, {
            addClass: ctx[48],
            removeClass: ctx[49]
          })),
          action_destroyer(useActions_action_4 = useActions.call(null, div1, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[43].call(null, div1)),
          listen_dev(div1, "SMUISelectLeadingIcon:mount", ctx[81], false, false, false),
          listen_dev(div1, "SMUISelectLeadingIcon:unmount", ctx[82], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[12]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_6(ctx);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[7] === "filled") {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_5(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx[7] !== "outlined" && !ctx[8] && (ctx[9] != null || ctx[51].label)) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty[0] & 896 | dirty[1] & 1048576) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx[7] === "outlined") {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 16777216)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx,
            ctx[86],
            !current ? get_all_dirty_from_scope(ctx[86]) : get_slot_changes(leadingIcon_slot_template, ctx[86], dirty, get_leadingIcon_slot_changes),
            get_leadingIcon_slot_context
          );
        }
      }
      if (!current || dirty[1] & 2048)
        set_data_dev(t5, ctx[42]);
      set_attributes(span0, span0_data = get_spread_update(span0_levels, [
        (!current || dirty[0] & 2048 && span0_id_value !== (span0_id_value = ctx[11] + "-smui-selected-text")) && { id: span0_id_value },
        (!current || dirty[0] & 524288 && span0_class_value !== (span0_class_value = classMap({
          [ctx[19]]: true,
          "mdc-select__selected-text": true
        }))) && { class: span0_class_value },
        { role: "button" },
        { "aria-haspopup": "listbox" },
        (!current || dirty[0] & 2048 && span0_aria_labelledby_value !== (span0_aria_labelledby_value = ctx[11] + "-smui-label")) && {
          "aria-labelledby": span0_aria_labelledby_value
        },
        dirty[1] & 2097152 && prefixFilter(ctx[52], "selectedText$")
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 262144)
        useActions_action.update.call(null, ctx[18]);
      set_attributes(span1, span1_data = get_spread_update(span1_levels, [
        (!current || dirty[0] & 131072 && span1_class_value !== (span1_class_value = classMap({
          [ctx[17]]: true,
          "mdc-select__selected-text-container": true
        }))) && { class: span1_class_value },
        dirty[1] & 2097152 && prefixFilter(ctx[52], "selectedTextContainer$")
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & 65536)
        useActions_action_1.update.call(null, ctx[16]);
      set_attributes(span2, span2_data = get_spread_update(span2_levels, [
        (!current || dirty[0] & 2097152 && span2_class_value !== (span2_class_value = classMap({
          [ctx[21]]: true,
          "mdc-select__dropdown-icon": true
        }))) && { class: span2_class_value },
        dirty[1] & 2097152 && prefixFilter(ctx[52], "dropdownIcon$")
      ]));
      if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & 1048576)
        useActions_action_2.update.call(null, ctx[20]);
      if (ctx[7] !== "outlined" && ctx[5]) {
        if (if_block4) {
          if_block4.p(ctx, dirty);
          if (dirty[0] & 160) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1(ctx);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & 32768 && div0_class_value !== (div0_class_value = classMap({
          [ctx[15]]: true,
          "mdc-select__anchor": true
        }))) && { class: div0_class_value },
        (!current || dirty[0] & 1024 && div0_aria_required_value !== (div0_aria_required_value = ctx[10] ? "true" : void 0)) && {
          "aria-required": div0_aria_required_value
        },
        (!current || dirty[0] & 64 && div0_aria_disabled_value !== (div0_aria_disabled_value = ctx[6] ? "true" : void 0)) && {
          "aria-disabled": div0_aria_disabled_value
        },
        (!current || dirty[0] & 1073741824) && { "aria-controls": ctx[30] },
        (!current || dirty[0] & 1073741824) && { "aria-describedby": ctx[30] },
        dirty[0] & 536870912 && ctx[29],
        dirty[1] & 2097152 && prefixFilter(ctx[52], "anchor$")
      ]));
      if (useActions_action_3 && is_function(useActions_action_3.update) && dirty[0] & 16384)
        useActions_action_3.update.call(null, ctx[14]);
      const menu_changes = dirty[0] & 4194304 | dirty[1] & 2097166 ? get_spread_update(menu_spread_levels, [
        dirty[0] & 4194304 | dirty[1] & 2 && {
          class: classMap({
            [ctx[22]]: true,
            "mdc-select__menu": true,
            ...ctx[32]
          })
        },
        menu_spread_levels[1],
        menu_spread_levels[2],
        dirty[1] & 4 && { anchorElement: ctx[33] },
        dirty[1] & 8 && { anchorCorner: ctx[34] },
        dirty[1] & 2097152 && get_spread_object(prefixFilter(ctx[52], "menu$"))
      ]) : {};
      if (dirty[0] & 16777216 | dirty[1] & 2097200 | dirty[2] & 16777216) {
        menu_changes.$$scope = { dirty, ctx };
      }
      if (!updating_open && dirty[1] & 1) {
        updating_open = true;
        menu_changes.open = ctx[31];
        add_flush_callback(() => updating_open = false);
      }
      menu.$set(menu_changes);
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        (!current || dirty[0] & 67119050 | dirty[1] & 1048577 && div1_class_value !== (div1_class_value = classMap({
          [ctx[3]]: true,
          "mdc-select": true,
          "mdc-select--required": ctx[10],
          "mdc-select--disabled": ctx[6],
          "mdc-select--filled": ctx[7] === "filled",
          "mdc-select--outlined": ctx[7] === "outlined",
          "smui-select--standard": ctx[7] === "standard",
          "mdc-select--with-leading-icon": ctx[44](ctx[13]) ? ctx[51].leadingIcon : ctx[13],
          "mdc-select--no-label": ctx[8] || ctx[9] == null && !ctx[51].label,
          "mdc-select--invalid": ctx[1],
          "mdc-select--activated": ctx[31],
          "mdc-data-table__pagination-rows-per-page-select": ctx[45] === "data-table:pagination",
          ...ctx[26]
        }))) && { class: div1_class_value },
        (!current || dirty[0] & 134217744 && div1_style_value !== (div1_style_value = Object.entries(ctx[27]).map(func2).concat([ctx[4]]).join(" "))) && { style: div1_style_value },
        dirty[1] & 2097152 && exclude(ctx[52], [
          "input$",
          "anchor$",
          "label$",
          "outline$",
          "selectedTextContainer$",
          "selectedText$",
          "dropdownIcon$",
          "ripple$",
          "menu$",
          "list$",
          "helperText$"
        ])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 128)
        Ripple_action.update.call(null, {
          ripple: ctx[7] === "filled",
          unbounded: false,
          addClass: ctx[48],
          removeClass: ctx[49],
          addStyle: ctx[50]
        });
      if (useActions_action_4 && is_function(useActions_action_4.update) && dirty[0] & 4)
        useActions_action_4.update.call(null, ctx[2]);
      if (ctx[51].helperText) {
        if (if_block5) {
          if_block5.p(ctx, dirty);
          if (dirty[1] & 1048576) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block2(ctx);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(leadingIcon_slot, local);
      transition_in(if_block4);
      transition_in(menu.$$.fragment, local);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(leadingIcon_slot, local);
      transition_out(if_block4);
      transition_out(menu.$$.fragment, local);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
      if (if_block4)
        if_block4.d();
      ctx[69](null);
      destroy_component(menu);
      ctx[80](null);
      if (detaching)
        detach_dev(t9);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach_dev(if_block5_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter2 = 0;
function getNormalizedXCoordinate(evt) {
  const targetClientRect = evt.currentTarget.getBoundingClientRect();
  const xCoordinate = isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
  return xCoordinate - targetClientRect.left;
}
function isTouchEvent(evt) {
  return "touches" in evt;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_14($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "variant",
    "noLabel",
    "label",
    "value",
    "key",
    "dirty",
    "invalid",
    "updateInvalid",
    "required",
    "inputId",
    "hiddenInput",
    "withLeadingIcon",
    "anchor$use",
    "anchor$class",
    "selectedTextContainer$use",
    "selectedTextContainer$class",
    "selectedText$use",
    "selectedText$class",
    "dropdownIcon$use",
    "dropdownIcon$class",
    "menu$class",
    "getUseDefaultValidation",
    "setUseDefaultValidation",
    "focus",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTextStore;
  let $valueStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["label", "leadingIcon", "default", "helperText"]);
  const $$slots = compute_slots(slots);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { variant = "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = void 0 } = $$props;
  let { value = "" } = $$props;
  let { key = (item) => item } = $$props;
  let { dirty = false } = $$props;
  let { invalid = uninitializedValue } = $$props;
  let { updateInvalid = isUninitializedValue(invalid) } = $$props;
  const useDefaultValidation = isUninitializedValue(invalid);
  if (isUninitializedValue(invalid)) {
    invalid = false;
  }
  let { required = false } = $$props;
  let { inputId = "SMUI-select-" + counter2++ } = $$props;
  let { hiddenInput = false } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { anchor$use = [] } = $$props;
  let { anchor$class = "" } = $$props;
  let { selectedTextContainer$use = [] } = $$props;
  let { selectedTextContainer$class = "" } = $$props;
  let { selectedText$use = [] } = $$props;
  let { selectedText$class = "" } = $$props;
  let { dropdownIcon$use = [] } = $$props;
  let { dropdownIcon$class = "" } = $$props;
  let { menu$class = "" } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let selectAnchor;
  let selectAnchorAttrs = {};
  let selectedIndex = -1;
  let helperId = void 0;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let menuOpen = false;
  let menuClasses = {};
  let anchorElement = void 0;
  let anchorCorner = void 0;
  let wrapFocus = false;
  let list;
  let context = getContext("SMUI:select:context");
  let leadingIcon = void 0;
  let helperText = void 0;
  let floatingLabel = void 0;
  let lineRipple = void 0;
  let notchedOutline = void 0;
  setContext("SMUI:list:role", "");
  setContext("SMUI:list:nav", false);
  const selectedTextStore = writable("");
  validate_store(selectedTextStore, "selectedTextStore");
  component_subscribe($$self, selectedTextStore, (value2) => $$invalidate(42, $selectedTextStore = value2));
  setContext("SMUI:select:selectedText", selectedTextStore);
  const valueStore = writable(value);
  validate_store(valueStore, "valueStore");
  component_subscribe($$self, valueStore, (value2) => $$invalidate(88, $valueStore = value2));
  setContext("SMUI:select:value", valueStore);
  let previousSelectedIndex = selectedIndex;
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(23, instance2 = new MDCSelectFoundation(
      {
        setSelectedText: (text2) => {
          set_store_value(selectedTextStore, $selectedTextStore = text2, $selectedTextStore);
        },
        isSelectAnchorFocused: () => document.activeElement === selectAnchor,
        getSelectAnchorAttr,
        setSelectAnchorAttr: addSelectAnchorAttr,
        removeSelectAnchorAttr,
        addMenuClass,
        removeMenuClass,
        openMenu: () => {
          $$invalidate(31, menuOpen = true);
        },
        closeMenu: () => {
          $$invalidate(31, menuOpen = false);
        },
        getAnchorElement: () => selectAnchor,
        setMenuAnchorElement: (value2) => {
          $$invalidate(33, anchorElement = value2);
        },
        setMenuAnchorCorner: (value2) => {
          $$invalidate(34, anchorCorner = value2);
        },
        setMenuWrapFocus: (value2) => {
          $$invalidate(35, wrapFocus = value2);
        },
        getSelectedIndex: () => selectedIndex,
        setSelectedIndex: (index) => {
          $$invalidate(61, previousSelectedIndex = index);
          $$invalidate(24, selectedIndex = index);
          $$invalidate(0, value = getMenuItemValues()[selectedIndex]);
        },
        focusMenuItemAtIndex: (index) => {
          list.focusItemAtIndex(index);
        },
        getMenuItemCount: () => list.items.length,
        getMenuItemValues: () => getMenuItemValues().map(key),
        getMenuItemTextAtIndex: (index) => list.getPrimaryTextAtIndex(index),
        isTypeaheadInProgress: () => list.typeaheadInProgress,
        typeaheadMatchItem: (nextChar, startingIndex) => list.typeaheadMatchItem(nextChar, startingIndex),
        addClass,
        removeClass,
        hasClass,
        setRippleCenter: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        activateBottomLine: () => lineRipple && lineRipple.activate(),
        deactivateBottomLine: () => lineRipple && lineRipple.deactivate(),
        notifyChange: (_selectedValue) => {
          $$invalidate(53, dirty = true);
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance2.isValid());
          }
          dispatch(getElement(), "SMUISelect:change", { value, index: selectedIndex }, void 0, true);
        },
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        hasLabel: () => !!floatingLabel,
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired)
      },
      {
        get helperText() {
          return helperText;
        },
        get leadingIcon() {
          return leadingIcon;
        }
      }
    ));
    $$invalidate(24, selectedIndex = getMenuItemValues().indexOf(value));
    instance2.init();
    setUseDefaultValidation(useDefaultValidation);
    return () => {
      instance2.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(26, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(26, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(27, internalStyles);
      } else {
        $$invalidate(27, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function addMenuClass(className2) {
    if (!menuClasses[className2]) {
      $$invalidate(32, menuClasses[className2] = true, menuClasses);
    }
  }
  function removeMenuClass(className2) {
    if (!(className2 in menuClasses) || menuClasses[className2]) {
      $$invalidate(32, menuClasses[className2] = false, menuClasses);
    }
  }
  function getSelectAnchorAttr(name) {
    var _a;
    return name in selectAnchorAttrs ? (_a = selectAnchorAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addSelectAnchorAttr(name, value2) {
    if (selectAnchorAttrs[name] !== value2) {
      $$invalidate(29, selectAnchorAttrs[name] = value2, selectAnchorAttrs);
    }
  }
  function removeSelectAnchorAttr(name) {
    if (!(name in selectAnchorAttrs) || selectAnchorAttrs[name] != null) {
      $$invalidate(29, selectAnchorAttrs[name] = void 0, selectAnchorAttrs);
    }
  }
  function getMenuItemValues() {
    return list.getOrderedList().map((accessor) => accessor.getValue());
  }
  function getUseDefaultValidation() {
    return instance2.getUseDefaultValidation();
  }
  function setUseDefaultValidation(useDefaultValidation2) {
    instance2.setUseDefaultValidation(useDefaultValidation2);
  }
  function focus() {
    selectAnchor.focus();
  }
  function layout() {
    instance2.layout();
  }
  function getElement() {
    return element2;
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function floatinglabel_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(39, floatingLabel);
    });
  }
  function floatinglabel_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(39, floatingLabel);
    });
  }
  function notchedoutline_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      notchedOutline = $$value;
      $$invalidate(41, notchedOutline);
    });
  }
  function lineripple_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      lineRipple = $$value;
      $$invalidate(40, lineRipple);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectAnchor = $$value;
      $$invalidate(28, selectAnchor);
    });
  }
  const focus_handler_1 = () => instance2 && instance2.handleFocus();
  const blur_handler_1 = () => instance2 && instance2.handleBlur();
  const click_handler = (event) => {
    selectAnchor.focus();
    if (instance2) {
      instance2.handleClick(getNormalizedXCoordinate(event));
    }
  };
  function list_1_selectedIndex_binding(value2) {
    selectedIndex = value2;
    $$invalidate(24, selectedIndex);
  }
  const SMUIList_mount_handler = (event) => $$invalidate(36, list = event.detail);
  function menu_open_binding(value2) {
    menuOpen = value2;
    $$invalidate(31, menuOpen);
  }
  const SMUIMenu_selected_handler = (event) => instance2 && instance2.handleMenuItemAction(event.detail.index);
  const SMUIMenuSurface_closing_handler = () => instance2 && instance2.handleMenuClosing();
  const SMUIMenuSurface_closed_handler = () => instance2 && instance2.handleMenuClosed();
  const SMUIMenuSurface_opened_handler = () => instance2 && instance2.handleMenuOpened();
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(25, element2);
    });
  }
  const SMUISelectLeadingIcon_mount_handler = (event) => $$invalidate(37, leadingIcon = event.detail);
  const SMUISelectLeadingIcon_unmount_handler = () => $$invalidate(37, leadingIcon = void 0);
  const SMUISelectHelperText_id_handler = (event) => $$invalidate(30, helperId = event.detail);
  const SMUISelectHelperText_mount_handler = (event) => $$invalidate(38, helperText = event.detail);
  const SMUISelectHelperText_unmount_handler = () => {
    $$invalidate(30, helperId = void 0);
    $$invalidate(38, helperText = void 0);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(52, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(5, ripple = $$new_props.ripple);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("variant" in $$new_props)
      $$invalidate(7, variant = $$new_props.variant);
    if ("noLabel" in $$new_props)
      $$invalidate(8, noLabel = $$new_props.noLabel);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("key" in $$new_props)
      $$invalidate(54, key = $$new_props.key);
    if ("dirty" in $$new_props)
      $$invalidate(53, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(55, updateInvalid = $$new_props.updateInvalid);
    if ("required" in $$new_props)
      $$invalidate(10, required = $$new_props.required);
    if ("inputId" in $$new_props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("hiddenInput" in $$new_props)
      $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
    if ("withLeadingIcon" in $$new_props)
      $$invalidate(13, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("anchor$use" in $$new_props)
      $$invalidate(14, anchor$use = $$new_props.anchor$use);
    if ("anchor$class" in $$new_props)
      $$invalidate(15, anchor$class = $$new_props.anchor$class);
    if ("selectedTextContainer$use" in $$new_props)
      $$invalidate(16, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
    if ("selectedTextContainer$class" in $$new_props)
      $$invalidate(17, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
    if ("selectedText$use" in $$new_props)
      $$invalidate(18, selectedText$use = $$new_props.selectedText$use);
    if ("selectedText$class" in $$new_props)
      $$invalidate(19, selectedText$class = $$new_props.selectedText$class);
    if ("dropdownIcon$use" in $$new_props)
      $$invalidate(20, dropdownIcon$use = $$new_props.dropdownIcon$use);
    if ("dropdownIcon$class" in $$new_props)
      $$invalidate(21, dropdownIcon$class = $$new_props.dropdownIcon$class);
    if ("menu$class" in $$new_props)
      $$invalidate(22, menu$class = $$new_props.menu$class);
    if ("$$scope" in $$new_props)
      $$invalidate(86, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter: counter2,
    MDCSelectFoundation,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    Anchor,
    Menu: dist_default7,
    List: dist_default2,
    FloatingLabel: dist_default3,
    LineRipple: dist_default4,
    NotchedOutline: dist_default5,
    HelperText: HelperText_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    ripple,
    disabled,
    variant,
    noLabel,
    label,
    value,
    key,
    dirty,
    invalid,
    updateInvalid,
    useDefaultValidation,
    required,
    inputId,
    hiddenInput,
    withLeadingIcon,
    anchor$use,
    anchor$class,
    selectedTextContainer$use,
    selectedTextContainer$class,
    selectedText$use,
    selectedText$class,
    dropdownIcon$use,
    dropdownIcon$class,
    menu$class,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    selectAnchor,
    selectAnchorAttrs,
    selectedIndex,
    helperId,
    addLayoutListener,
    removeLayoutListener,
    menuOpen,
    menuClasses,
    anchorElement,
    anchorCorner,
    wrapFocus,
    list,
    context,
    leadingIcon,
    helperText,
    floatingLabel,
    lineRipple,
    notchedOutline,
    selectedTextStore,
    valueStore,
    previousSelectedIndex,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    addMenuClass,
    removeMenuClass,
    getSelectAnchorAttr,
    addSelectAnchorAttr,
    removeSelectAnchorAttr,
    getMenuItemValues,
    getNormalizedXCoordinate,
    isTouchEvent,
    getUseDefaultValidation,
    setUseDefaultValidation,
    focus,
    layout,
    getElement,
    $selectedTextStore,
    $valueStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(5, ripple = $$new_props.ripple);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("variant" in $$props)
      $$invalidate(7, variant = $$new_props.variant);
    if ("noLabel" in $$props)
      $$invalidate(8, noLabel = $$new_props.noLabel);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("key" in $$props)
      $$invalidate(54, key = $$new_props.key);
    if ("dirty" in $$props)
      $$invalidate(53, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(55, updateInvalid = $$new_props.updateInvalid);
    if ("required" in $$props)
      $$invalidate(10, required = $$new_props.required);
    if ("inputId" in $$props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("hiddenInput" in $$props)
      $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
    if ("withLeadingIcon" in $$props)
      $$invalidate(13, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("anchor$use" in $$props)
      $$invalidate(14, anchor$use = $$new_props.anchor$use);
    if ("anchor$class" in $$props)
      $$invalidate(15, anchor$class = $$new_props.anchor$class);
    if ("selectedTextContainer$use" in $$props)
      $$invalidate(16, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
    if ("selectedTextContainer$class" in $$props)
      $$invalidate(17, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
    if ("selectedText$use" in $$props)
      $$invalidate(18, selectedText$use = $$new_props.selectedText$use);
    if ("selectedText$class" in $$props)
      $$invalidate(19, selectedText$class = $$new_props.selectedText$class);
    if ("dropdownIcon$use" in $$props)
      $$invalidate(20, dropdownIcon$use = $$new_props.dropdownIcon$use);
    if ("dropdownIcon$class" in $$props)
      $$invalidate(21, dropdownIcon$class = $$new_props.dropdownIcon$class);
    if ("menu$class" in $$props)
      $$invalidate(22, menu$class = $$new_props.menu$class);
    if ("element" in $$props)
      $$invalidate(25, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(23, instance2 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(26, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(27, internalStyles = $$new_props.internalStyles);
    if ("selectAnchor" in $$props)
      $$invalidate(28, selectAnchor = $$new_props.selectAnchor);
    if ("selectAnchorAttrs" in $$props)
      $$invalidate(29, selectAnchorAttrs = $$new_props.selectAnchorAttrs);
    if ("selectedIndex" in $$props)
      $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
    if ("helperId" in $$props)
      $$invalidate(30, helperId = $$new_props.helperId);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("menuOpen" in $$props)
      $$invalidate(31, menuOpen = $$new_props.menuOpen);
    if ("menuClasses" in $$props)
      $$invalidate(32, menuClasses = $$new_props.menuClasses);
    if ("anchorElement" in $$props)
      $$invalidate(33, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$props)
      $$invalidate(34, anchorCorner = $$new_props.anchorCorner);
    if ("wrapFocus" in $$props)
      $$invalidate(35, wrapFocus = $$new_props.wrapFocus);
    if ("list" in $$props)
      $$invalidate(36, list = $$new_props.list);
    if ("context" in $$props)
      $$invalidate(45, context = $$new_props.context);
    if ("leadingIcon" in $$props)
      $$invalidate(37, leadingIcon = $$new_props.leadingIcon);
    if ("helperText" in $$props)
      $$invalidate(38, helperText = $$new_props.helperText);
    if ("floatingLabel" in $$props)
      $$invalidate(39, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$props)
      $$invalidate(40, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$props)
      $$invalidate(41, notchedOutline = $$new_props.notchedOutline);
    if ("previousSelectedIndex" in $$props)
      $$invalidate(61, previousSelectedIndex = $$new_props.previousSelectedIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 25165825 | $$self.$$.dirty[1] & 1073741824) {
      $:
        if (previousSelectedIndex !== selectedIndex) {
          $$invalidate(61, previousSelectedIndex = selectedIndex);
          if (instance2) {
            instance2.setSelectedIndex(
              selectedIndex,
              false,
              true
            );
          } else {
            const values = getMenuItemValues();
            if (value !== values[selectedIndex]) {
              $$invalidate(0, value = values[selectedIndex]);
            }
          }
        }
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        set_store_value(valueStore, $valueStore = value, $valueStore);
    }
    if ($$self.$$.dirty[0] & 8388609 | $$self.$$.dirty[1] & 8388608) {
      $:
        if (instance2 && instance2.getValue() !== key(value)) {
          instance2.setValue(key(value));
        }
    }
    if ($$self.$$.dirty[0] & 8388672) {
      $:
        if (instance2 && instance2.getDisabled() !== disabled) {
          instance2.setDisabled(disabled);
        }
    }
    if ($$self.$$.dirty[0] & 8388610 | $$self.$$.dirty[1] & 20971520) {
      $:
        if (instance2 && dirty && instance2.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance2.isValid());
          } else {
            instance2.setValid(!invalid);
          }
        }
    }
    if ($$self.$$.dirty[0] & 8389632) {
      $:
        if (instance2 && instance2.getRequired() !== required) {
          instance2.setRequired(required);
        }
    }
  };
  return [
    value,
    invalid,
    use,
    className,
    style,
    ripple,
    disabled,
    variant,
    noLabel,
    label,
    required,
    inputId,
    hiddenInput,
    withLeadingIcon,
    anchor$use,
    anchor$class,
    selectedTextContainer$use,
    selectedTextContainer$class,
    selectedText$use,
    selectedText$class,
    dropdownIcon$use,
    dropdownIcon$class,
    menu$class,
    instance2,
    selectedIndex,
    element2,
    internalClasses,
    internalStyles,
    selectAnchor,
    selectAnchorAttrs,
    helperId,
    menuOpen,
    menuClasses,
    anchorElement,
    anchorCorner,
    wrapFocus,
    list,
    leadingIcon,
    helperText,
    floatingLabel,
    lineRipple,
    notchedOutline,
    $selectedTextStore,
    forwardEvents,
    isUninitializedValue,
    context,
    selectedTextStore,
    valueStore,
    addClass,
    removeClass,
    addStyle,
    $$slots,
    $$restProps,
    dirty,
    key,
    updateInvalid,
    getUseDefaultValidation,
    setUseDefaultValidation,
    focus,
    layout,
    getElement,
    previousSelectedIndex,
    slots,
    focus_handler,
    blur_handler,
    floatinglabel_binding,
    floatinglabel_binding_1,
    notchedoutline_binding,
    lineripple_binding,
    div0_binding,
    focus_handler_1,
    blur_handler_1,
    click_handler,
    list_1_selectedIndex_binding,
    SMUIList_mount_handler,
    menu_open_binding,
    SMUIMenu_selected_handler,
    SMUIMenuSurface_closing_handler,
    SMUIMenuSurface_closed_handler,
    SMUIMenuSurface_opened_handler,
    div1_binding,
    SMUISelectLeadingIcon_mount_handler,
    SMUISelectLeadingIcon_unmount_handler,
    SMUISelectHelperText_id_handler,
    SMUISelectHelperText_mount_handler,
    SMUISelectHelperText_unmount_handler,
    $$scope
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_14,
      create_fragment4,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        ripple: 5,
        disabled: 6,
        variant: 7,
        noLabel: 8,
        label: 9,
        value: 0,
        key: 54,
        dirty: 53,
        invalid: 1,
        updateInvalid: 55,
        required: 10,
        inputId: 11,
        hiddenInput: 12,
        withLeadingIcon: 13,
        anchor$use: 14,
        anchor$class: 15,
        selectedTextContainer$use: 16,
        selectedTextContainer$class: 17,
        selectedText$use: 18,
        selectedText$class: 19,
        dropdownIcon$use: 20,
        dropdownIcon$class: 21,
        menu$class: 22,
        getUseDefaultValidation: 56,
        setUseDefaultValidation: 57,
        focus: 58,
        layout: 59,
        getElement: 60
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hiddenInput() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hiddenInput(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withLeadingIcon() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withLeadingIcon(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedTextContainer$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedTextContainer$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedTextContainer$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedTextContainer$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedText$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedText$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedText$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedText$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownIcon$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownIcon$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownIcon$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownIcon$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menu$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menu$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getUseDefaultValidation() {
    return this.$$.ctx[56];
  }
  set getUseDefaultValidation(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setUseDefaultValidation() {
    return this.$$.ctx[57];
  }
  set setUseDefaultValidation(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[58];
  }
  set focus(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[59];
  }
  set layout(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[60];
  }
  set getElement(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/@smui/select/dist/Option.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(1:0) <Item   bind:this={element}   use={usePass}   data-value={value}   {value}   {selected}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let item;
  let current;
  const item_spread_levels = [
    { use: ctx[3] },
    { "data-value": ctx[0] },
    { value: ctx[0] },
    { selected: ctx[2] },
    ctx[6]
  ];
  let item_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < item_spread_levels.length; i += 1) {
    item_props = assign(item_props, item_spread_levels[i]);
  }
  item = new Item_default({ props: item_props, $$inline: true });
  ctx[12](item);
  const block = {
    c: function create() {
      create_component(item.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(item, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const item_changes = dirty & 77 ? get_spread_update(item_spread_levels, [
        dirty & 8 && { use: ctx2[3] },
        dirty & 1 && { "data-value": ctx2[0] },
        dirty & 1 && { value: ctx2[0] },
        dirty & 4 && { selected: ctx2[2] },
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 8192) {
        item_changes.$$scope = { dirty, ctx: ctx2 };
      }
      item.$set(item_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[12](null);
      destroy_component(item, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let usePass;
  let selected;
  const omit_props_names = ["use", "class", "value", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedText;
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Option", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  const className = "";
  let { value = "" } = $$props;
  let element2;
  const selectedText = getContext("SMUI:select:selectedText");
  validate_store(selectedText, "selectedText");
  component_subscribe($$self, selectedText, (value2) => $$invalidate(14, $selectedText = value2));
  const selectedValue = getContext("SMUI:select:value");
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
  setContext("SMUI:list:item:role", "option");
  onMount(setSelectedText);
  onDestroy(setSelectedText);
  function setSelectedText() {
    if (selected && element2) {
      set_store_value(selectedText, $selectedText = element2.getPrimaryText(), $selectedText);
    }
  }
  function getElement() {
    return element2.getElement();
  }
  function item_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(7, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    Item: Item_default,
    forwardEvents,
    use,
    className,
    value,
    element: element2,
    selectedText,
    selectedValue,
    setSelectedText,
    getElement,
    selected,
    usePass,
    $selectedText,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(7, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("usePass" in $$props)
      $$invalidate(3, usePass = $$new_props.usePass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, usePass = [forwardEvents, ...use]);
    }
    if ($$self.$$.dirty & 1025) {
      $:
        $$invalidate(2, selected = value != null && value !== "" && $selectedValue === value);
    }
  };
  return [
    value,
    element2,
    selected,
    usePass,
    selectedText,
    selectedValue,
    $$restProps,
    use,
    className,
    getElement,
    $selectedValue,
    slots,
    item_binding,
    $$scope
  ];
}
var Option = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment5, safe_not_equal, {
      use: 7,
      class: 8,
      value: 0,
      getElement: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Option",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    return this.$$.ctx[8];
  }
  set class(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[9];
  }
  set getElement(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Option_default = Option;

// node_modules/@smui/select/dist/index.js
var dist_default8 = Select_default;
export {
  DefaultFocusState,
  Option_default as Option,
  dist_default8 as default
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@smui_select.js.map
