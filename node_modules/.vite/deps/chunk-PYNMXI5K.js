import {
  MDCComponent,
  MDCFoundation,
  classMap,
  dispatch,
  estimateScrollWidth,
  forwardEventsBuilder,
  useActions
} from "./chunk-QH7DRB7N.js";
import {
  __assign,
  __extends
} from "./chunk-3L2CPHNC.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-NLMIYH64.js";

// node_modules/@material/floating-label/constants.js
var cssClasses = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};

// node_modules/@material/floating-label/foundation.js
var MDCFloatingLabelFoundation = function(_super) {
  __extends(MDCFloatingLabelFoundation2, _super);
  function MDCFloatingLabelFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
    _this.shakeAnimationEndHandler = function() {
      _this.handleShakeAnimationEnd();
    };
    return _this;
  }
  Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        getWidth: function() {
          return 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCFloatingLabelFoundation2.prototype.init = function() {
    this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.destroy = function() {
    this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
  };
  MDCFloatingLabelFoundation2.prototype.getWidth = function() {
    return this.adapter.getWidth();
  };
  MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    if (shouldShake) {
      this.adapter.addClass(LABEL_SHAKE);
    } else {
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
    var _a = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
    if (shouldFloat) {
      this.adapter.addClass(LABEL_FLOAT_ABOVE);
    } else {
      this.adapter.removeClass(LABEL_FLOAT_ABOVE);
      this.adapter.removeClass(LABEL_SHAKE);
    }
  };
  MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
    var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
    if (isRequired) {
      this.adapter.addClass(LABEL_REQUIRED);
    } else {
      this.adapter.removeClass(LABEL_REQUIRED);
    }
  };
  MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd = function() {
    var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
    this.adapter.removeClass(LABEL_SHAKE);
  };
  return MDCFloatingLabelFoundation2;
}(MDCFoundation);

// node_modules/@material/floating-label/component.js
var MDCFloatingLabel = function(_super) {
  __extends(MDCFloatingLabel2, _super);
  function MDCFloatingLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCFloatingLabel2.attachTo = function(root) {
    return new MDCFloatingLabel2(root);
  };
  MDCFloatingLabel2.prototype.shake = function(shouldShake) {
    this.foundation.shake(shouldShake);
  };
  MDCFloatingLabel2.prototype.float = function(shouldFloat) {
    this.foundation.float(shouldFloat);
  };
  MDCFloatingLabel2.prototype.setRequired = function(isRequired) {
    this.foundation.setRequired(isRequired);
  };
  MDCFloatingLabel2.prototype.getWidth = function() {
    return this.foundation.getWidth();
  };
  MDCFloatingLabel2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      getWidth: function() {
        return estimateScrollWidth(_this.root);
      },
      registerInteractionHandler: function(evtType, handler) {
        return _this.listen(evtType, handler);
      },
      deregisterInteractionHandler: function(evtType, handler) {
        return _this.unlisten(evtType, handler);
      }
    };
    return new MDCFloatingLabelFoundation(adapter);
  };
  return MDCFloatingLabel2;
}(MDCComponent);

// node_modules/@smui/floating-label/dist/FloatingLabel.svelte
var file = "node_modules/@smui/floating-label/dist/FloatingLabel.svelte";
function create_else_block(ctx) {
  let label;
  let label_class_value;
  let label_style_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let label_levels = [
    {
      class: label_class_value = classMap({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1],
        ...ctx[8]
      })
    },
    {
      style: label_style_value = Object.entries(ctx[9]).map(func_1).concat([ctx[4]]).join(" ")
    },
    {
      for: label_for_value = ctx[5] || (ctx[11] ? ctx[11].id : void 0)
    },
    ctx[12]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
      add_location(label, file, 19, 2, 494);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[24](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, label, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 267 && label_class_value !== (label_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1],
          ...ctx2[8]
        }))) && { class: label_class_value },
        (!current || dirty & 528 && label_style_value !== (label_style_value = Object.entries(ctx2[9]).map(func_1).concat([ctx2[4]]).join(" "))) && { style: label_style_value },
        (!current || dirty & 32 && label_for_value !== (label_for_value = ctx2[5] || (ctx2[11] ? ctx2[11].id : void 0))) && { for: label_for_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let span_levels = [
    {
      class: span_class_value = classMap({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1],
        ...ctx[8]
      })
    },
    {
      style: span_style_value = Object.entries(ctx[9]).map(func).concat([ctx[4]]).join(" ")
    },
    ctx[12]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file, 1, 2, 16);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[23](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & 267 && span_class_value !== (span_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1],
          ...ctx2[8]
        }))) && { class: span_class_value },
        (!current || dirty & 528 && span_style_value !== (span_style_value = Object.entries(ctx2[9]).map(func).concat([ctx2[4]]).join(" "))) && { style: span_style_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(1:0) {#if wrapped}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FloatingLabel", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { for: forId = void 0 } = $$props;
  let { floatAbove = false } = $$props;
  let { required = false } = $$props;
  let { wrapped = false } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let internalStyles = {};
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let previousFloatAbove = floatAbove;
  let previousRequired = required;
  onMount(() => {
    $$invalidate(18, instance = new MDCFloatingLabelFoundation({
      addClass,
      removeClass,
      getWidth: () => {
        var _a2, _b;
        const el = getElement();
        const clone = el.cloneNode(true);
        (_a2 = el.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(clone);
        clone.classList.add("smui-floating-label--remove-transition");
        clone.classList.add("smui-floating-label--force-size");
        clone.classList.remove("mdc-floating-label--float-above");
        const scrollWidth = clone.scrollWidth;
        (_b = el.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(clone);
        return scrollWidth;
      },
      registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      addStyle,
      removeStyle
    };
    dispatch(element2, "SMUIFloatingLabel:mount", accessor);
    instance.init();
    return () => {
      dispatch(element2, "SMUIFloatingLabel:unmount", accessor);
      instance.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(9, internalStyles);
      } else {
        $$invalidate(9, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function removeStyle(name) {
    if (name in internalStyles) {
      delete internalStyles[name];
      $$invalidate(9, internalStyles);
    }
  }
  function shake(shouldShake) {
    instance.shake(shouldShake);
  }
  function float(shouldFloat) {
    $$invalidate(0, floatAbove = shouldFloat);
  }
  function setRequired(isRequired) {
    $$invalidate(1, required = isRequired);
  }
  function getWidth() {
    return instance.getWidth();
  }
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("for" in $$new_props)
      $$invalidate(5, forId = $$new_props.for);
    if ("floatAbove" in $$new_props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$new_props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$new_props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCFloatingLabelFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    style,
    forId,
    floatAbove,
    required,
    wrapped,
    element: element2,
    instance,
    internalClasses,
    internalStyles,
    inputProps,
    previousFloatAbove,
    previousRequired,
    addClass,
    removeClass,
    addStyle,
    removeStyle,
    shake,
    float,
    setRequired,
    getWidth,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("forId" in $$props)
      $$invalidate(5, forId = $$new_props.forId);
    if ("floatAbove" in $$props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(18, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(9, internalStyles = $$new_props.internalStyles);
    if ("inputProps" in $$props)
      $$invalidate(11, inputProps = $$new_props.inputProps);
    if ("previousFloatAbove" in $$props)
      $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
    if ("previousRequired" in $$props)
      $$invalidate(20, previousRequired = $$new_props.previousRequired);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 786433) {
      $:
        if (instance && previousFloatAbove !== floatAbove) {
          $$invalidate(19, previousFloatAbove = floatAbove);
          instance.float(floatAbove);
        }
    }
    if ($$self.$$.dirty & 1310722) {
      $:
        if (instance && previousRequired !== required) {
          $$invalidate(20, previousRequired = required);
          instance.setRequired(required);
        }
    }
  };
  return [
    floatAbove,
    required,
    use,
    className,
    style,
    forId,
    wrapped,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    inputProps,
    $$restProps,
    shake,
    float,
    setRequired,
    getWidth,
    getElement,
    instance,
    previousFloatAbove,
    previousRequired,
    $$scope,
    slots,
    span_binding,
    label_binding
  ];
}
var FloatingLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FloatingLabel",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatAbove() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatAbove(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapped() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapped(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shake() {
    return this.$$.ctx[13];
  }
  set shake(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get float() {
    return this.$$.ctx[14];
  }
  set float(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  set setRequired(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  set getWidth(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[17];
  }
  set getElement(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FloatingLabel_default = FloatingLabel;

// node_modules/@smui/floating-label/dist/index.js
var dist_default = FloatingLabel_default;

// node_modules/@material/line-ripple/constants.js
var cssClasses2 = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};

// node_modules/@material/line-ripple/foundation.js
var MDCLineRippleFoundation = function(_super) {
  __extends(MDCLineRippleFoundation2, _super);
  function MDCLineRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.transitionEndHandler = function(evt) {
      _this.handleTransitionEnd(evt);
    };
    return _this;
  }
  Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        setStyle: function() {
          return void 0;
        },
        registerEventHandler: function() {
          return void 0;
        },
        deregisterEventHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCLineRippleFoundation2.prototype.init = function() {
    this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.destroy = function() {
    this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
  };
  MDCLineRippleFoundation2.prototype.activate = function() {
    this.adapter.removeClass(cssClasses2.LINE_RIPPLE_DEACTIVATING);
    this.adapter.addClass(cssClasses2.LINE_RIPPLE_ACTIVE);
  };
  MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
    this.adapter.setStyle("transform-origin", xCoordinate + "px center");
  };
  MDCLineRippleFoundation2.prototype.deactivate = function() {
    this.adapter.addClass(cssClasses2.LINE_RIPPLE_DEACTIVATING);
  };
  MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
    var isDeactivating = this.adapter.hasClass(cssClasses2.LINE_RIPPLE_DEACTIVATING);
    if (evt.propertyName === "opacity") {
      if (isDeactivating) {
        this.adapter.removeClass(cssClasses2.LINE_RIPPLE_ACTIVE);
        this.adapter.removeClass(cssClasses2.LINE_RIPPLE_DEACTIVATING);
      }
    }
  };
  return MDCLineRippleFoundation2;
}(MDCFoundation);

// node_modules/@material/line-ripple/component.js
var MDCLineRipple = function(_super) {
  __extends(MDCLineRipple2, _super);
  function MDCLineRipple2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCLineRipple2.attachTo = function(root) {
    return new MDCLineRipple2(root);
  };
  MDCLineRipple2.prototype.activate = function() {
    this.foundation.activate();
  };
  MDCLineRipple2.prototype.deactivate = function() {
    this.foundation.deactivate();
  };
  MDCLineRipple2.prototype.setRippleCenter = function(xCoordinate) {
    this.foundation.setRippleCenter(xCoordinate);
  };
  MDCLineRipple2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      setStyle: function(propertyName, value) {
        return _this.root.style.setProperty(propertyName, value);
      },
      registerEventHandler: function(evtType, handler) {
        return _this.listen(evtType, handler);
      },
      deregisterEventHandler: function(evtType, handler) {
        return _this.unlisten(evtType, handler);
      }
    };
    return new MDCLineRippleFoundation(adapter);
  };
  return MDCLineRipple2;
}(MDCComponent);

// node_modules/@smui/line-ripple/dist/LineRipple.svelte
var file2 = "node_modules/@smui/line-ripple/dist/LineRipple.svelte";
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-line-ripple": true,
        "mdc-line-ripple--active": ctx[3],
        ...ctx[5]
      })
    },
    {
      style: div_style_value = Object.entries(ctx[6]).map(func2).concat([ctx[2]]).join(" ")
    },
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[13](div);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 42 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": ctx2[3],
          ...ctx2[5]
        })) && { class: div_class_value },
        dirty & 68 && div_style_value !== (div_style_value = Object.entries(ctx2[6]).map(func2).concat([ctx2[2]]).join(" ")) && { style: div_style_value },
        dirty & 256 && ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineRipple", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { active = false } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let internalStyles = {};
  onMount(() => {
    instance = new MDCLineRippleFoundation({
      addClass,
      removeClass,
      hasClass,
      setStyle: addStyle,
      registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    });
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(6, internalStyles);
      } else {
        $$invalidate(6, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function activate() {
    instance.activate();
  }
  function deactivate() {
    instance.deactivate();
  }
  function setRippleCenter(xCoordinate) {
    instance.setRippleCenter(xCoordinate);
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
  };
  $$self.$capture_state = () => ({
    MDCLineRippleFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    style,
    active,
    element: element2,
    instance,
    internalClasses,
    internalStyles,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    activate,
    deactivate,
    setRippleCenter,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance = $$new_props.instance;
    if ("internalClasses" in $$props)
      $$invalidate(5, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(6, internalStyles = $$new_props.internalStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    active,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    $$restProps,
    activate,
    deactivate,
    setRippleCenter,
    getElement,
    div_binding
  ];
}
var LineRipple = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineRipple",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activate() {
    return this.$$.ctx[9];
  }
  set activate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  set deactivate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  set setRippleCenter(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineRipple_default = LineRipple;

// node_modules/@smui/line-ripple/dist/index.js
var dist_default2 = LineRipple_default;

// node_modules/@material/notched-outline/constants.js
var strings = {
  NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
};
var numbers = {
  NOTCH_ELEMENT_PADDING: 8
};
var cssClasses3 = {
  NO_LABEL: "mdc-notched-outline--no-label",
  OUTLINE_NOTCHED: "mdc-notched-outline--notched",
  OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
};

// node_modules/@material/notched-outline/foundation.js
var MDCNotchedOutlineFoundation = function(_super) {
  __extends(MDCNotchedOutlineFoundation2, _super);
  function MDCNotchedOutlineFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
    get: function() {
      return cssClasses3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        setNotchWidthProperty: function() {
          return void 0;
        },
        removeNotchWidthProperty: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    if (notchWidth > 0) {
      notchWidth += numbers.NOTCH_ELEMENT_PADDING;
    }
    this.adapter.setNotchWidthProperty(notchWidth);
    this.adapter.addClass(OUTLINE_NOTCHED);
  };
  MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
    this.adapter.removeClass(OUTLINE_NOTCHED);
    this.adapter.removeNotchWidthProperty();
  };
  return MDCNotchedOutlineFoundation2;
}(MDCFoundation);

// node_modules/@material/notched-outline/component.js
var MDCNotchedOutline = function(_super) {
  __extends(MDCNotchedOutline2, _super);
  function MDCNotchedOutline2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCNotchedOutline2.attachTo = function(root) {
    return new MDCNotchedOutline2(root);
  };
  MDCNotchedOutline2.prototype.initialSyncWithDOM = function() {
    this.notchElement = this.root.querySelector(strings.NOTCH_ELEMENT_SELECTOR);
    var label = this.root.querySelector("." + MDCFloatingLabelFoundation.cssClasses.ROOT);
    if (label) {
      label.style.transitionDuration = "0s";
      this.root.classList.add(cssClasses3.OUTLINE_UPGRADED);
      requestAnimationFrame(function() {
        label.style.transitionDuration = "";
      });
    } else {
      this.root.classList.add(cssClasses3.NO_LABEL);
    }
  };
  MDCNotchedOutline2.prototype.notch = function(notchWidth) {
    this.foundation.notch(notchWidth);
  };
  MDCNotchedOutline2.prototype.closeNotch = function() {
    this.foundation.closeNotch();
  };
  MDCNotchedOutline2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      setNotchWidthProperty: function(width) {
        _this.notchElement.style.setProperty("width", width + "px");
      },
      removeNotchWidthProperty: function() {
        _this.notchElement.style.removeProperty("width");
      }
    };
    return new MDCNotchedOutlineFoundation(adapter);
  };
  return MDCNotchedOutline2;
}(MDCComponent);

// node_modules/@smui/notched-outline/dist/NotchedOutline.svelte
var file3 = "node_modules/@smui/notched-outline/dist/NotchedOutline.svelte";
function create_if_block2(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "mdc-notched-outline__notch");
      attr_dev(div, "style", div_style_value = Object.entries(ctx[7]).map(func3).join(" "));
      add_location(div, file3, 17, 4, 496);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 128 && div_style_value !== (div_style_value = Object.entries(ctx2[7]).map(func3).join(" "))) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:2) {#if !noLabel}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let div2_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[3] && create_if_block2(ctx);
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [ctx[1]]: true,
        "mdc-notched-outline": true,
        "mdc-notched-outline--notched": ctx[2],
        "mdc-notched-outline--no-label": ctx[3],
        ...ctx[6]
      })
    },
    ctx[9]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      attr_dev(div0, "class", "mdc-notched-outline__leading");
      add_location(div0, file3, 15, 2, 430);
      attr_dev(div1, "class", "mdc-notched-outline__trailing");
      add_location(div1, file3, 26, 2, 699);
      set_attributes(div2, div2_data);
      add_location(div2, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      ctx[15](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div2, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[8].call(null, div2)),
          listen_dev(div2, "SMUIFloatingLabel:mount", ctx[16], false, false, false),
          listen_dev(div2, "SMUIFloatingLabel:unmount", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & 78 && div2_class_value !== (div2_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": ctx2[2],
          "mdc-notched-outline--no-label": ctx2[3],
          ...ctx2[6]
        }))) && { class: div2_class_value },
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func3 = ([name, value]) => `${name}: ${value};`;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotchedOutline", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { notched = false } = $$props;
  let { noLabel = false } = $$props;
  let element2;
  let instance;
  let floatingLabel;
  let internalClasses = {};
  let notchStyles = {};
  onMount(() => {
    instance = new MDCNotchedOutlineFoundation({
      addClass,
      removeClass,
      setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
      removeNotchWidthProperty: () => removeNotchStyle("width")
    });
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function addNotchStyle(name, value) {
    if (notchStyles[name] != value) {
      if (value === "" || value == null) {
        delete notchStyles[name];
        $$invalidate(7, notchStyles);
      } else {
        $$invalidate(7, notchStyles[name] = value, notchStyles);
      }
    }
  }
  function removeNotchStyle(name) {
    if (name in notchStyles) {
      delete notchStyles[name];
      $$invalidate(7, notchStyles);
    }
  }
  function notch(notchWidth) {
    instance.notch(notchWidth);
  }
  function closeNotch() {
    instance.closeNotch();
  }
  function getElement() {
    return element2;
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const SMUIFloatingLabel_mount_handler = (event) => $$invalidate(4, floatingLabel = event.detail);
  const SMUIFloatingLabel_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("notched" in $$new_props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$new_props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCNotchedOutlineFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    notched,
    noLabel,
    element: element2,
    instance,
    floatingLabel,
    internalClasses,
    notchStyles,
    addClass,
    removeClass,
    addNotchStyle,
    removeNotchStyle,
    notch,
    closeNotch,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("notched" in $$props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance = $$new_props.instance;
    if ("floatingLabel" in $$props)
      $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
    if ("internalClasses" in $$props)
      $$invalidate(6, internalClasses = $$new_props.internalClasses);
    if ("notchStyles" in $$props)
      $$invalidate(7, notchStyles = $$new_props.notchStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        if (floatingLabel) {
          floatingLabel.addStyle("transition-duration", "0s");
          addClass("mdc-notched-outline--upgraded");
          requestAnimationFrame(() => {
            if (floatingLabel) {
              floatingLabel.removeStyle("transition-duration");
            }
          });
        } else {
          removeClass("mdc-notched-outline--upgraded");
        }
    }
  };
  return [
    use,
    className,
    notched,
    noLabel,
    floatingLabel,
    element2,
    internalClasses,
    notchStyles,
    forwardEvents,
    $$restProps,
    notch,
    closeNotch,
    getElement,
    $$scope,
    slots,
    div2_binding,
    SMUIFloatingLabel_mount_handler,
    SMUIFloatingLabel_unmount_handler
  ];
}
var NotchedOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment3, safe_not_equal, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 10,
      closeNotch: 11,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotchedOutline",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notched() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notched(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notch() {
    return this.$$.ctx[10];
  }
  set notch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeNotch() {
    return this.$$.ctx[11];
  }
  set closeNotch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotchedOutline_default = NotchedOutline;

// node_modules/@smui/notched-outline/dist/index.js
var dist_default3 = NotchedOutline_default;

export {
  MDCFloatingLabel,
  MDCLineRipple,
  MDCNotchedOutline,
  dist_default,
  dist_default2,
  dist_default3
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=chunk-PYNMXI5K.js.map
