import {
  fade,
  slide
} from "./chunk-PDA3SY24.js";
import "./chunk-M6MB33T7.js";
import {
  derived,
  writable
} from "./chunk-RAXL67E4.js";
import "./chunk-6A2TAOKG.js";
import {
  HtmlTag,
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  stop_propagation,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-NLMIYH64.js";
import "./chunk-HUBM7RA2.js";

// node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte
var file = "node_modules/carbon-components-svelte/src/icons/ChevronRight.svelte";
function create_if_block(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z");
      add_location(path, file, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronRight", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ChevronRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronRight",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<ChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronRight_default = ChevronRight;

// node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte
var file2 = "node_modules/carbon-components-svelte/src/SkeletonText/SkeletonText.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i].width;
  return child_ctx;
}
function create_else_block(ctx) {
  let p;
  let p_style_value;
  let mounted;
  let dispose;
  let p_levels = [
    ctx[4],
    {
      style: p_style_value = "width: " + ctx[2] + ";" + ctx[4].style
    }
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      set_attributes(p, p_data);
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(p, "bx--skeleton__heading", ctx[0]);
      add_location(p, file2, 40, 2, 1146);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(p, "click", ctx[12], false, false, false),
          listen_dev(p, "mouseover", ctx[13], false, false, false),
          listen_dev(p, "mouseenter", ctx[14], false, false, false),
          listen_dev(p, "mouseleave", ctx[15], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & 16 && ctx2[4],
        dirty & 20 && p_style_value !== (p_style_value = "width: " + ctx2[2] + ";" + ctx2[4].style) && { style: p_style_value }
      ]));
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(p, "bx--skeleton__heading", ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(40:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [ctx[4]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
      add_location(div, file2, 30, 2, 870);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[8], false, false, false),
          listen_dev(div, "mouseover", ctx[9], false, false, false),
          listen_dev(div, "mouseenter", ctx[10], false, false, false),
          listen_dev(div, "mouseleave", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 9) {
        each_value = ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 16 && ctx2[4]]));
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(30:0) {#if paragraph}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let p;
  const block = {
    c: function create() {
      p = element("p");
      set_style(p, "width", ctx[2]);
      toggle_class(p, "bx--skeleton__text", true);
      toggle_class(p, "bx--skeleton__heading", ctx[0]);
      add_location(p, file2, 32, 6, 979);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8) {
        set_style(p, "width", ctx2[2]);
      }
      if (dirty & 1) {
        toggle_class(p, "bx--skeleton__heading", ctx2[0]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(32:4) {#each rows as { width }}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let rows;
  let widthNum;
  let widthPx;
  const omit_props_names = ["lines", "heading", "paragraph", "width"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonText", slots, []);
  let { lines = 3 } = $$props;
  let { heading = false } = $$props;
  let { paragraph = false } = $$props;
  let { width = "100%" } = $$props;
  const RANDOM = [0.973, 0.153, 0.567];
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("lines" in $$new_props)
      $$invalidate(5, lines = $$new_props.lines);
    if ("heading" in $$new_props)
      $$invalidate(0, heading = $$new_props.heading);
    if ("paragraph" in $$new_props)
      $$invalidate(1, paragraph = $$new_props.paragraph);
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
  };
  $$self.$capture_state = () => ({
    lines,
    heading,
    paragraph,
    width,
    RANDOM,
    widthPx,
    rows,
    widthNum
  });
  $$self.$inject_state = ($$new_props) => {
    if ("lines" in $$props)
      $$invalidate(5, lines = $$new_props.lines);
    if ("heading" in $$props)
      $$invalidate(0, heading = $$new_props.heading);
    if ("paragraph" in $$props)
      $$invalidate(1, paragraph = $$new_props.paragraph);
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("widthPx" in $$props)
      $$invalidate(6, widthPx = $$new_props.widthPx);
    if ("rows" in $$props)
      $$invalidate(3, rows = $$new_props.rows);
    if ("widthNum" in $$props)
      $$invalidate(7, widthNum = $$new_props.widthNum);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(7, widthNum = parseInt(width, 10));
    }
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(6, widthPx = width.includes("px"));
    }
    if ($$self.$$.dirty & 238) {
      $:
        if (paragraph) {
          for (let i = 0; i < lines; i++) {
            const min = widthPx ? widthNum - 75 : 0;
            const max = widthPx ? widthNum : 75;
            const rand = Math.floor(RANDOM[i % 3] * (max - min + 1)) + min + "px";
            $$invalidate(3, rows = [
              ...rows,
              {
                width: widthPx ? rand : `calc(${width} - ${rand})`
              }
            ]);
          }
        }
    }
  };
  $:
    $$invalidate(3, rows = []);
  return [
    heading,
    paragraph,
    width,
    rows,
    $$restProps,
    lines,
    widthPx,
    widthNum,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var SkeletonText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      lines: 5,
      heading: 0,
      paragraph: 1,
      width: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonText",
      options,
      id: create_fragment2.name
    });
  }
  get lines() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lines(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heading() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paragraph() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paragraph(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SkeletonText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SkeletonText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkeletonText_default = SkeletonText;

// node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte
var file3 = "node_modules/carbon-components-svelte/src/Accordion/AccordionSkeleton.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_if_block3(ctx) {
  let li;
  let span;
  let chevronright;
  let t0;
  let skeletontext0;
  let t1;
  let div;
  let skeletontext1;
  let t2;
  let skeletontext2;
  let t3;
  let skeletontext3;
  let current;
  chevronright = new ChevronRight_default({
    props: { class: "bx--accordion__arrow" },
    $$inline: true
  });
  skeletontext0 = new SkeletonText_default({
    props: { class: "bx--accordion__title" },
    $$inline: true
  });
  skeletontext1 = new SkeletonText_default({ props: { width: "90%" }, $$inline: true });
  skeletontext2 = new SkeletonText_default({ props: { width: "80%" }, $$inline: true });
  skeletontext3 = new SkeletonText_default({ props: { width: "95%" }, $$inline: true });
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      create_component(chevronright.$$.fragment);
      t0 = space();
      create_component(skeletontext0.$$.fragment);
      t1 = space();
      div = element("div");
      create_component(skeletontext1.$$.fragment);
      t2 = space();
      create_component(skeletontext2.$$.fragment);
      t3 = space();
      create_component(skeletontext3.$$.fragment);
      toggle_class(span, "bx--accordion__heading", true);
      add_location(span, file3, 42, 6, 1054);
      toggle_class(div, "bx--accordion__content", true);
      add_location(div, file3, 46, 6, 1227);
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(li, "bx--accordion__item--active", true);
      add_location(li, file3, 38, 4, 948);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, span);
      mount_component(chevronright, span, null);
      append_dev(span, t0);
      mount_component(skeletontext0, span, null);
      append_dev(li, t1);
      append_dev(li, div);
      mount_component(skeletontext1, div, null);
      append_dev(div, t2);
      mount_component(skeletontext2, div, null);
      append_dev(div, t3);
      mount_component(skeletontext3, div, null);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(skeletontext2.$$.fragment, local);
      transition_in(skeletontext3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(skeletontext2.$$.fragment, local);
      transition_out(skeletontext3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(chevronright);
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(skeletontext2);
      destroy_component(skeletontext3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(38:2) {#if open}",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let li;
  let span;
  let chevronright;
  let t0;
  let skeletontext;
  let t1;
  let current;
  chevronright = new ChevronRight_default({
    props: { class: "bx--accordion__arrow" },
    $$inline: true
  });
  skeletontext = new SkeletonText_default({
    props: { class: "bx--accordion__title" },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      span = element("span");
      create_component(chevronright.$$.fragment);
      t0 = space();
      create_component(skeletontext.$$.fragment);
      t1 = space();
      toggle_class(span, "bx--accordion__heading", true);
      add_location(span, file3, 55, 6, 1550);
      toggle_class(li, "bx--accordion__item", true);
      add_location(li, file3, 54, 4, 1504);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, span);
      mount_component(chevronright, span, null);
      append_dev(span, t0);
      mount_component(skeletontext, span, null);
      append_dev(li, t1);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(skeletontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(skeletontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(chevronright);
      destroy_component(skeletontext);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(54:2) {#each Array.from({ length: open ? count - 1 : count }, (_, i) => i) as item (item)}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let ul;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block3(ctx);
  let each_value = Array.from(
    {
      length: ctx[3] ? ctx[0] - 1 : ctx[0]
    },
    func
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[9];
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  let ul_levels = [ctx[4]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--skeleton", true);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(ul, "bx--accordion--start", ctx[1] === "start");
      toggle_class(ul, "bx--accordion--end", ctx[1] === "end");
      toggle_class(ul, "bx--accordion--sm", ctx[2] === "sm");
      toggle_class(ul, "bx--accordion--xl", ctx[2] === "xl");
      add_location(ul, file3, 24, 0, 601);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (if_block)
        if_block.m(ul, null);
      append_dev(ul, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ul, "click", ctx[5], false, false, false),
          listen_dev(ul, "mouseover", ctx[6], false, false, false),
          listen_dev(ul, "mouseenter", ctx[7], false, false, false),
          listen_dev(ul, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(ul, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 9) {
        each_value = Array.from(
          {
            length: ctx2[3] ? ctx2[0] - 1 : ctx2[0]
          },
          func
        );
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 16 && ctx2[4]]));
      toggle_class(ul, "bx--skeleton", true);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(ul, "bx--accordion--start", ctx2[1] === "start");
      toggle_class(ul, "bx--accordion--end", ctx2[1] === "end");
      toggle_class(ul, "bx--accordion--sm", ctx2[2] === "sm");
      toggle_class(ul, "bx--accordion--xl", ctx2[2] === "xl");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (if_block)
        if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = (_, i) => i;
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["count", "align", "size", "open"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionSkeleton", slots, []);
  let { count = 4 } = $$props;
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { open = true } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("count" in $$new_props)
      $$invalidate(0, count = $$new_props.count);
    if ("align" in $$new_props)
      $$invalidate(1, align = $$new_props.align);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props)
      $$invalidate(3, open = $$new_props.open);
  };
  $$self.$capture_state = () => ({
    count,
    align,
    size,
    open,
    ChevronRight: ChevronRight_default,
    SkeletonText: SkeletonText_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("count" in $$props)
      $$invalidate(0, count = $$new_props.count);
    if ("align" in $$props)
      $$invalidate(1, align = $$new_props.align);
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props)
      $$invalidate(3, open = $$new_props.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    count,
    align,
    size,
    open,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var AccordionSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { count: 0, align: 1, size: 2, open: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionSkeleton",
      options,
      id: create_fragment3.name
    });
  }
  get count() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AccordionSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionSkeleton_default = AccordionSkeleton;

// node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte
var file4 = "node_modules/carbon-components-svelte/src/Accordion/Accordion.svelte";
function create_else_block2(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let ul_levels = [ctx[3]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--accordion", true);
      toggle_class(ul, "bx--accordion--start", ctx[0] === "start");
      toggle_class(ul, "bx--accordion--end", ctx[0] === "end");
      toggle_class(ul, "bx--accordion--sm", ctx[1] === "sm");
      toggle_class(ul, "bx--accordion--xl", ctx[1] === "xl");
      add_location(ul, file4, 44, 2, 991);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ul, "click", ctx[7], false, false, false),
          listen_dev(ul, "mouseover", ctx[8], false, false, false),
          listen_dev(ul, "mouseenter", ctx[9], false, false, false),
          listen_dev(ul, "mouseleave", ctx[10], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 8 && ctx2[3]]));
      toggle_class(ul, "bx--accordion", true);
      toggle_class(ul, "bx--accordion--start", ctx2[0] === "start");
      toggle_class(ul, "bx--accordion--end", ctx2[0] === "end");
      toggle_class(ul, "bx--accordion--sm", ctx2[1] === "sm");
      toggle_class(ul, "bx--accordion--xl", ctx2[1] === "xl");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let accordionskeleton;
  let current;
  const accordionskeleton_spread_levels = [ctx[3], { align: ctx[0] }, { size: ctx[1] }];
  let accordionskeleton_props = {};
  for (let i = 0; i < accordionskeleton_spread_levels.length; i += 1) {
    accordionskeleton_props = assign(accordionskeleton_props, accordionskeleton_spread_levels[i]);
  }
  accordionskeleton = new AccordionSkeleton_default({
    props: accordionskeleton_props,
    $$inline: true
  });
  accordionskeleton.$on("click", ctx[11]);
  accordionskeleton.$on("mouseover", ctx[12]);
  accordionskeleton.$on("mouseenter", ctx[13]);
  accordionskeleton.$on("mouseleave", ctx[14]);
  const block = {
    c: function create() {
      create_component(accordionskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(accordionskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const accordionskeleton_changes = dirty & 11 ? get_spread_update(accordionskeleton_spread_levels, [
        dirty & 8 && get_spread_object(ctx2[3]),
        dirty & 1 && { align: ctx2[0] },
        dirty & 2 && { size: ctx2[1] }
      ]) : {};
      accordionskeleton.$set(accordionskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(accordionskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(accordionskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(accordionskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(34:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["align", "size", "disabled", "skeleton"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { align = "end" } = $$props;
  let { size = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { skeleton = false } = $$props;
  const disableItems = writable(disabled);
  setContext("Accordion", { disableItems });
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("align" in $$new_props)
      $$invalidate(0, align = $$new_props.align);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("skeleton" in $$new_props)
      $$invalidate(2, skeleton = $$new_props.skeleton);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    align,
    size,
    disabled,
    skeleton,
    setContext,
    writable,
    AccordionSkeleton: AccordionSkeleton_default,
    disableItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("align" in $$props)
      $$invalidate(0, align = $$new_props.align);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("skeleton" in $$props)
      $$invalidate(2, skeleton = $$new_props.skeleton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        disableItems.set(disabled);
    }
  };
  return [
    align,
    size,
    skeleton,
    $$restProps,
    disabled,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      align: 0,
      size: 1,
      disabled: 4,
      skeleton: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment4.name
    });
  }
  get align() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte
var file5 = "node_modules/carbon-components-svelte/src/Accordion/AccordionItem.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(73:25) {title}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let li;
  let button;
  let chevronright;
  let t0;
  let div0;
  let t1;
  let div1;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: {
      class: "bx--accordion__arrow",
      "aria-label": ctx[3]
    },
    $$inline: true
  });
  const title_slot_template = ctx[7].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[6], get_title_slot_context);
  const title_slot_or_fallback = title_slot || fallback_block(ctx);
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let li_levels = [ctx[5]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      create_component(chevronright.$$.fragment);
      t0 = space();
      div0 = element("div");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div0, "bx--accordion__title", true);
      add_location(div0, file5, 71, 4, 1867);
      attr_dev(button, "type", "button");
      attr_dev(button, "title", ctx[3]);
      attr_dev(button, "aria-expanded", ctx[0]);
      button.disabled = ctx[1];
      toggle_class(button, "bx--accordion__heading", true);
      add_location(button, file5, 49, 2, 1334);
      toggle_class(div1, "bx--accordion__content", true);
      add_location(div1, file5, 75, 2, 1974);
      set_attributes(li, li_data);
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(li, "bx--accordion__item--active", ctx[0]);
      toggle_class(li, "bx--accordion__item--disabled", ctx[1]);
      toggle_class(li, "bx--accordion__item--expanding", ctx[4] === "expanding");
      toggle_class(li, "bx--accordion__item--collapsing", ctx[4] === "collapsing");
      add_location(li, file5, 37, 0, 955);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, button);
      mount_component(chevronright, button, null);
      append_dev(button, t0);
      append_dev(button, div0);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(div0, null);
      }
      append_dev(li, t1);
      append_dev(li, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[9], false, false, false),
          listen_dev(button, "click", ctx[14], false, false, false),
          listen_dev(button, "mouseover", ctx[10], false, false, false),
          listen_dev(button, "mouseenter", ctx[11], false, false, false),
          listen_dev(button, "mouseleave", ctx[12], false, false, false),
          listen_dev(button, "keydown", ctx[13], false, false, false),
          listen_dev(button, "keydown", ctx[15], false, false, false),
          listen_dev(li, "animationend", ctx[8], false, false, false),
          listen_dev(li, "animationend", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const chevronright_changes = {};
      if (dirty & 8)
        chevronright_changes["aria-label"] = ctx2[3];
      chevronright.$set(chevronright_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(title_slot_template, ctx2[6], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 4)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 8) {
        attr_dev(button, "title", ctx2[3]);
      }
      if (!current || dirty & 1) {
        attr_dev(button, "aria-expanded", ctx2[0]);
      }
      if (!current || dirty & 2) {
        prop_dev(button, "disabled", ctx2[1]);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 32 && ctx2[5]]));
      toggle_class(li, "bx--accordion__item", true);
      toggle_class(li, "bx--accordion__item--active", ctx2[0]);
      toggle_class(li, "bx--accordion__item--disabled", ctx2[1]);
      toggle_class(li, "bx--accordion__item--expanding", ctx2[4] === "expanding");
      toggle_class(li, "bx--accordion__item--collapsing", ctx2[4] === "collapsing");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(chevronright);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "open", "disabled", "iconDescription"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["title", "default"]);
  let { title = "title" } = $$props;
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { iconDescription = "Expand/Collapse" } = $$props;
  let initialDisabled = disabled;
  const ctx = getContext("Accordion");
  const unsubscribe = ctx.disableItems.subscribe((value) => {
    if (!value && initialDisabled)
      return;
    $$invalidate(1, disabled = value);
  });
  let animation = void 0;
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(0, open = !open);
    $$invalidate(4, animation = open ? "expanding" : "collapsing");
  };
  const keydown_handler_12 = ({ key }) => {
    if (open && key === "Escape") {
      $$invalidate(0, open = false);
    }
  };
  const animationend_handler_1 = () => {
    $$invalidate(4, animation = void 0);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("iconDescription" in $$new_props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    open,
    disabled,
    iconDescription,
    onMount,
    getContext,
    ChevronRight: ChevronRight_default,
    initialDisabled,
    ctx,
    unsubscribe,
    animation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("iconDescription" in $$props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("initialDisabled" in $$props)
      initialDisabled = $$new_props.initialDisabled;
    if ("animation" in $$props)
      $$invalidate(4, animation = $$new_props.animation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    disabled,
    title,
    iconDescription,
    animation,
    $$restProps,
    $$scope,
    slots,
    animationend_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12,
    animationend_handler_1
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      title: 2,
      open: 0,
      disabled: 1,
      iconDescription: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment5.name
    });
  }
  get title() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte
var file6 = "node_modules/carbon-components-svelte/src/AspectRatio/AspectRatio.svelte";
function create_fragment6(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div0, "bx--aspect-ratio--object", true);
      add_location(div0, file6, 21, 2, 691);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--aspect-ratio", true);
      toggle_class(div1, "bx--aspect-ratio--2x1", ctx[0] === "2x1");
      toggle_class(div1, "bx--aspect-ratio--2x3", ctx[0] === "2x3");
      toggle_class(div1, "bx--aspect-ratio--16x9", ctx[0] === "16x9");
      toggle_class(div1, "bx--aspect-ratio--4x3", ctx[0] === "4x3");
      toggle_class(div1, "bx--aspect-ratio--1x1", ctx[0] === "1x1");
      toggle_class(div1, "bx--aspect-ratio--3x4", ctx[0] === "3x4");
      toggle_class(div1, "bx--aspect-ratio--3x2", ctx[0] === "3x2");
      toggle_class(div1, "bx--aspect-ratio--9x16", ctx[0] === "9x16");
      toggle_class(div1, "bx--aspect-ratio--1x2", ctx[0] === "1x2");
      add_location(div1, file6, 8, 0, 175);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--aspect-ratio", true);
      toggle_class(div1, "bx--aspect-ratio--2x1", ctx2[0] === "2x1");
      toggle_class(div1, "bx--aspect-ratio--2x3", ctx2[0] === "2x3");
      toggle_class(div1, "bx--aspect-ratio--16x9", ctx2[0] === "16x9");
      toggle_class(div1, "bx--aspect-ratio--4x3", ctx2[0] === "4x3");
      toggle_class(div1, "bx--aspect-ratio--1x1", ctx2[0] === "1x1");
      toggle_class(div1, "bx--aspect-ratio--3x4", ctx2[0] === "3x4");
      toggle_class(div1, "bx--aspect-ratio--3x2", ctx2[0] === "3x2");
      toggle_class(div1, "bx--aspect-ratio--9x16", ctx2[0] === "9x16");
      toggle_class(div1, "bx--aspect-ratio--1x2", ctx2[0] === "1x2");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["ratio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AspectRatio", slots, ["default"]);
  let { ratio = "2x1" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ratio" in $$new_props)
      $$invalidate(0, ratio = $$new_props.ratio);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ratio });
  $$self.$inject_state = ($$new_props) => {
    if ("ratio" in $$props)
      $$invalidate(0, ratio = $$new_props.ratio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ratio, $$restProps, $$scope, slots];
}
var AspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { ratio: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AspectRatio",
      options,
      id: create_fragment6.name
    });
  }
  get ratio() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AspectRatio_default = AspectRatio;

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte
var file7 = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbSkeleton.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let div;
  let span;
  let t1;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      span = element("span");
      span.textContent = "\xA0";
      t1 = space();
      toggle_class(span, "bx--link", true);
      add_location(span, file7, 21, 6, 586);
      toggle_class(div, "bx--breadcrumb-item", true);
      add_location(div, file7, 20, 4, 539);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      append_dev(div, t1);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(20:2) {#each Array.from({ length: count }, (_, i) => i) as item (item)}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[1] }, func2);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[7];
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  let div_levels = [ctx[2]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--breadcrumb", true);
      toggle_class(div, "bx--breadcrumb--no-trailing-slash", ctx[0]);
      add_location(div, file7, 9, 0, 259);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[3], false, false, false),
          listen_dev(div, "mouseover", ctx[4], false, false, false),
          listen_dev(div, "mouseenter", ctx[5], false, false, false),
          listen_dev(div, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = Array.from({ length: ctx2[1] }, func2);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block3, null, get_each_context3);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--breadcrumb", true);
      toggle_class(div, "bx--breadcrumb--no-trailing-slash", ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = (_, i) => i;
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["noTrailingSlash", "count"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbSkeleton", slots, []);
  let { noTrailingSlash = false } = $$props;
  let { count = 3 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noTrailingSlash" in $$new_props)
      $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("count" in $$new_props)
      $$invalidate(1, count = $$new_props.count);
  };
  $$self.$capture_state = () => ({ noTrailingSlash, count });
  $$self.$inject_state = ($$new_props) => {
    if ("noTrailingSlash" in $$props)
      $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("count" in $$props)
      $$invalidate(1, count = $$new_props.count);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noTrailingSlash,
    count,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var BreadcrumbSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { noTrailingSlash: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbSkeleton",
      options,
      id: create_fragment7.name
    });
  }
  get noTrailingSlash() {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noTrailingSlash(value) {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<BreadcrumbSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbSkeleton_default = BreadcrumbSkeleton;

// node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte
var file8 = "node_modules/carbon-components-svelte/src/Breadcrumb/Breadcrumb.svelte";
function create_else_block3(ctx) {
  let nav;
  let ol;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let nav_levels = [{ "aria-label": "Breadcrumb" }, ctx[2]];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      toggle_class(ol, "bx--breadcrumb", true);
      toggle_class(ol, "bx--breadcrumb--no-trailing-slash", ctx[0]);
      add_location(ol, file8, 31, 4, 704);
      set_attributes(nav, nav_data);
      add_location(nav, file8, 23, 2, 576);
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(nav, "click", ctx[5], false, false, false),
          listen_dev(nav, "mouseover", ctx[6], false, false, false),
          listen_dev(nav, "mouseenter", ctx[7], false, false, false),
          listen_dev(nav, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        toggle_class(ol, "bx--breadcrumb--no-trailing-slash", ctx2[0]);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        { "aria-label": "Breadcrumb" },
        dirty & 4 && ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let breadcrumbskeleton;
  let current;
  const breadcrumbskeleton_spread_levels = [
    {
      noTrailingSlash: ctx[0]
    },
    ctx[2]
  ];
  let breadcrumbskeleton_props = {};
  for (let i = 0; i < breadcrumbskeleton_spread_levels.length; i += 1) {
    breadcrumbskeleton_props = assign(breadcrumbskeleton_props, breadcrumbskeleton_spread_levels[i]);
  }
  breadcrumbskeleton = new BreadcrumbSkeleton_default({
    props: breadcrumbskeleton_props,
    $$inline: true
  });
  breadcrumbskeleton.$on("click", ctx[9]);
  breadcrumbskeleton.$on("mouseover", ctx[10]);
  breadcrumbskeleton.$on("mouseenter", ctx[11]);
  breadcrumbskeleton.$on("mouseleave", ctx[12]);
  const block = {
    c: function create() {
      create_component(breadcrumbskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(breadcrumbskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const breadcrumbskeleton_changes = dirty & 5 ? get_spread_update(breadcrumbskeleton_spread_levels, [
        dirty & 1 && {
          noTrailingSlash: ctx2[0]
        },
        dirty & 4 && get_spread_object(ctx2[2])
      ]) : {};
      breadcrumbskeleton.$set(breadcrumbskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(breadcrumbskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(breadcrumbskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(breadcrumbskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(14:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["noTrailingSlash", "skeleton"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { noTrailingSlash = false } = $$props;
  let { skeleton = false } = $$props;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noTrailingSlash" in $$new_props)
      $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("skeleton" in $$new_props)
      $$invalidate(1, skeleton = $$new_props.skeleton);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    noTrailingSlash,
    skeleton,
    BreadcrumbSkeleton: BreadcrumbSkeleton_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("noTrailingSlash" in $$props)
      $$invalidate(0, noTrailingSlash = $$new_props.noTrailingSlash);
    if ("skeleton" in $$props)
      $$invalidate(1, skeleton = $$new_props.skeleton);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noTrailingSlash,
    skeleton,
    $$restProps,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { noTrailingSlash: 0, skeleton: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment8.name
    });
  }
  get noTrailingSlash() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noTrailingSlash(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/carbon-components-svelte/src/Link/Link.svelte
var file9 = "node_modules/carbon-components-svelte/src/Link/Link.svelte";
var get_icon_slot_changes_1 = (dirty) => ({});
var get_icon_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_else_block4(ctx) {
  let a;
  let t;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = !ctx[3] && (ctx[8].icon || ctx[4]) && create_if_block_2(ctx);
  let a_levels = [
    {
      rel: a_rel_value = ctx[7].target === "_blank" ? "noopener noreferrer" : void 0
    },
    { href: ctx[2] },
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--link", true);
      toggle_class(a, "bx--link--disabled", ctx[5]);
      toggle_class(a, "bx--link--inline", ctx[3]);
      toggle_class(a, "bx--link--visited", ctx[6]);
      toggle_class(a, "bx--link--sm", ctx[1] === "sm");
      toggle_class(a, "bx--link--lg", ctx[1] === "lg");
      add_location(a, file9, 59, 2, 1287);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      append_dev(a, t);
      if (if_block)
        if_block.m(a, null);
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[15], false, false, false),
          listen_dev(a, "mouseover", ctx[16], false, false, false),
          listen_dev(a, "mouseenter", ctx[17], false, false, false),
          listen_dev(a, "mouseleave", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!ctx2[3] && (ctx2[8].icon || ctx2[4])) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 280) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 128 && a_rel_value !== (a_rel_value = ctx2[7].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        (!current || dirty & 4) && { href: ctx2[2] },
        dirty & 128 && ctx2[7]
      ]));
      toggle_class(a, "bx--link", true);
      toggle_class(a, "bx--link--disabled", ctx2[5]);
      toggle_class(a, "bx--link--inline", ctx2[3]);
      toggle_class(a, "bx--link--visited", ctx2[6]);
      toggle_class(a, "bx--link--sm", ctx2[1] === "sm");
      toggle_class(a, "bx--link--lg", ctx2[1] === "lg");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(59:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let p;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = !ctx[3] && (ctx[8].icon || ctx[4]) && create_if_block_1(ctx);
  let p_levels = [ctx[7]];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(p, p_data);
      toggle_class(p, "bx--link", true);
      toggle_class(p, "bx--link--disabled", ctx[5]);
      toggle_class(p, "bx--link--inline", ctx[3]);
      toggle_class(p, "bx--link--visited", ctx[6]);
      add_location(p, file9, 37, 2, 796);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      append_dev(p, t);
      if (if_block)
        if_block.m(p, null);
      ctx[19](p);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(p, "click", ctx[11], false, false, false),
          listen_dev(p, "mouseover", ctx[12], false, false, false),
          listen_dev(p, "mouseenter", ctx[13], false, false, false),
          listen_dev(p, "mouseleave", ctx[14], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!ctx2[3] && (ctx2[8].icon || ctx2[4])) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 280) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(p, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [dirty & 128 && ctx2[7]]));
      toggle_class(p, "bx--link", true);
      toggle_class(p, "bx--link--disabled", ctx2[5]);
      toggle_class(p, "bx--link--inline", ctx2[3]);
      toggle_class(p, "bx--link--visited", ctx2[6]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(37:0) {#if disabled}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[9], get_icon_slot_context_1);
  const icon_slot_or_fallback = icon_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--link__icon", true);
      add_location(div, file9, 77, 6, 1794);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(icon_slot_template, ctx2[9], dirty, get_icon_slot_changes_1),
            get_icon_slot_context_1
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(77:4) {#if !inline && ($$slots.icon || icon)}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(79:26)            ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[9], get_icon_slot_context);
  const icon_slot_or_fallback = icon_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--link__icon", true);
      add_location(div, file9, 51, 6, 1123);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(icon_slot_template, ctx2[9], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(51:4) {#if !inline && ($$slots.icon || icon)}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(53:26)            ",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "href", "inline", "icon", "disabled", "visited", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default", "icon"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { inline = false } = $$props;
  let { icon = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { visited = false } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function p_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("icon" in $$new_props)
      $$invalidate(4, icon = $$new_props.icon);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("visited" in $$new_props)
      $$invalidate(6, visited = $$new_props.visited);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    href,
    inline,
    icon,
    disabled,
    visited,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("icon" in $$props)
      $$invalidate(4, icon = $$new_props.icon);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("visited" in $$props)
      $$invalidate(6, visited = $$new_props.visited);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    size,
    href,
    inline,
    icon,
    disabled,
    visited,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    p_binding,
    a_binding
  ];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      size: 1,
      href: 2,
      inline: 3,
      icon: 4,
      disabled: 5,
      visited: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment9.name
    });
  }
  get size() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visited() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visited(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte
var file10 = "node_modules/carbon-components-svelte/src/Breadcrumb/BreadcrumbItem.svelte";
var get_default_slot_changes_1 = (dirty) => ({ props: dirty & 4 });
var get_default_slot_context_1 = (ctx) => ({
  props: {
    "aria-current": ctx[2]["aria-current"],
    class: "bx--link"
  }
});
var get_default_slot_changes = (dirty) => ({ props: dirty & 4 });
var get_default_slot_context = (ctx) => ({
  props: {
    "aria-current": ctx[2]["aria-current"],
    class: "bx--link"
  }
});
function create_else_block5(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], get_default_slot_context_1);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, get_default_slot_changes_1),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(37:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let link;
  let current;
  link = new Link_default({
    props: {
      href: ctx[0],
      "aria-current": ctx[2]["aria-current"],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const link_changes = {};
      if (dirty & 1)
        link_changes.href = ctx2[0];
      if (dirty & 4)
        link_changes["aria-current"] = ctx2[2]["aria-current"];
      if (dirty & 260) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(33:2) {#if href}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], get_default_slot_context);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: `(34:4) <Link href=\\"{href}\\" aria-current=\\"{$$restProps['aria-current']}\\">`,
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block7, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [ctx[2]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      set_attributes(li, li_data);
      toggle_class(li, "bx--breadcrumb-item", true);
      toggle_class(li, "bx--breadcrumb-item--current", ctx[1] && ctx[2]["aria-current"] !== "page");
      add_location(li, file10, 22, 0, 499);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", ctx[4], false, false, false),
          listen_dev(li, "mouseover", ctx[5], false, false, false),
          listen_dev(li, "mouseenter", ctx[6], false, false, false),
          listen_dev(li, "mouseleave", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(li, "bx--breadcrumb-item", true);
      toggle_class(li, "bx--breadcrumb-item--current", ctx2[1] && ctx2[2]["aria-current"] !== "page");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "isCurrentPage"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbItem", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { isCurrentPage = false } = $$props;
  setContext("BreadcrumbItem", {});
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("isCurrentPage" in $$new_props)
      $$invalidate(1, isCurrentPage = $$new_props.isCurrentPage);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, isCurrentPage, Link: Link_default, setContext });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("isCurrentPage" in $$props)
      $$invalidate(1, isCurrentPage = $$new_props.isCurrentPage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    isCurrentPage,
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var BreadcrumbItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { href: 0, isCurrentPage: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbItem",
      options,
      id: create_fragment10.name
    });
  }
  get href() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCurrentPage() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCurrentPage(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/carbon-components-svelte/src/Breakpoint/breakpoints.js
var breakpoints = Object.freeze({
  sm: 320,
  md: 672,
  lg: 1056,
  xlg: 1312,
  max: 1584
});
var breakpoints_default = breakpoints;

// node_modules/carbon-components-svelte/src/Breakpoint/breakpointObserver.js
function breakpointObserver() {
  const store = writable(void 0);
  onMount(() => {
    const match = {
      sm: window.matchMedia(`(max-width: ${breakpoints.md}px)`),
      md: window.matchMedia(
        `(min-width: ${breakpoints.md}px) and (max-width: ${breakpoints.lg}px)`
      ),
      lg: window.matchMedia(
        `(min-width: ${breakpoints.lg}px) and (max-width: ${breakpoints.xlg}px)`
      ),
      xlg: window.matchMedia(
        `(min-width: ${breakpoints.xlg}px) and (max-width: ${breakpoints.max}px)`
      ),
      max: window.matchMedia(`(min-width: ${breakpoints.max}px)`)
    };
    const matchers = Object.entries(match);
    const sizeByMedia = Object.fromEntries(
      matchers.map(([size2, queryList]) => [queryList.media, size2])
    );
    const size = matchers.find(([size2, queryList]) => queryList.matches)[0];
    store.set(size);
    function handleChange({ matches, media }) {
      const size2 = sizeByMedia[media];
      if (matches)
        store.set(size2);
    }
    matchers.forEach(
      ([size2, queryList]) => queryList.addEventListener("change", handleChange)
    );
    return () => {
      matchers.forEach(
        ([size2, queryList]) => queryList.removeEventListener("change", handleChange)
      );
    };
  });
  return {
    subscribe: store.subscribe,
    smallerThan: (size) => {
      checkSizeValid(size);
      return derived(store, ($size) => breakpoints[$size] < breakpoints[size]);
    },
    largerThan: (size) => {
      checkSizeValid(size);
      return derived(store, ($size) => breakpoints[$size] > breakpoints[size]);
    }
  };
}
function checkSizeValid(size) {
  if (size in breakpoints == false)
    throw new Error(`"${size}" is not a valid breakpoint size.`);
}
var breakpointObserver_default = breakpointObserver;

// node_modules/carbon-components-svelte/src/Breakpoint/Breakpoint.svelte
var get_default_slot_changes2 = (dirty) => ({
  size: dirty & 1,
  sizes: dirty & 2
});
var get_default_slot_context2 = (ctx) => ({
  size: ctx[0],
  sizes: ctx[1]
});
function create_fragment11(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], get_default_slot_context2);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 19)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, get_default_slot_changes2),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $observer;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breakpoint", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { sizes = {
    sm: false,
    md: false,
    lg: false,
    xlg: false,
    max: false
  } } = $$props;
  const dispatch = createEventDispatcher();
  const observer = breakpointObserver();
  validate_store(observer, "observer");
  component_subscribe($$self, observer, (value) => $$invalidate(3, $observer = value));
  const writable_props = ["size", "sizes"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Breakpoint> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("sizes" in $$props2)
      $$invalidate(1, sizes = $$props2.sizes);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    sizes,
    createEventDispatcher,
    breakpointObserver,
    breakpoints,
    dispatch,
    observer,
    $observer
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("sizes" in $$props2)
      $$invalidate(1, sizes = $$props2.sizes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(0, size = $observer);
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(1, sizes = {
          sm: size == "sm",
          md: size == "md",
          lg: size == "lg",
          xlg: size == "xlg",
          max: size == "max"
        });
    }
    if ($$self.$$.dirty & 1) {
      $:
        if (size != void 0)
          dispatch("change", { size, breakpointValue: breakpoints[size] });
    }
  };
  return [size, sizes, observer, $observer, $$scope, slots];
}
var Breakpoint = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { size: 0, sizes: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breakpoint",
      options,
      id: create_fragment11.name
    });
  }
  get size() {
    throw new Error("<Breakpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Breakpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizes() {
    throw new Error("<Breakpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizes(value) {
    throw new Error("<Breakpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breakpoint_default = Breakpoint;

// node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte
var file11 = "node_modules/carbon-components-svelte/src/Button/ButtonSkeleton.svelte";
function create_else_block6(ctx) {
  let div;
  let mounted;
  let dispose;
  let div_levels = [ctx[2]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--btn", true);
      toggle_class(div, "bx--btn--field", ctx[1] === "field");
      toggle_class(div, "bx--btn--sm", ctx[1] === "small");
      toggle_class(div, "bx--btn--lg", ctx[1] === "lg");
      toggle_class(div, "bx--btn--xl", ctx[1] === "xl");
      add_location(div, file11, 35, 2, 801);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[7], false, false, false),
          listen_dev(div, "mouseover", ctx[8], false, false, false),
          listen_dev(div, "mouseenter", ctx[9], false, false, false),
          listen_dev(div, "mouseleave", ctx[10], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--btn", true);
      toggle_class(div, "bx--btn--field", ctx2[1] === "field");
      toggle_class(div, "bx--btn--sm", ctx2[1] === "small");
      toggle_class(div, "bx--btn--lg", ctx2[1] === "lg");
      toggle_class(div, "bx--btn--xl", ctx2[1] === "xl");
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(35:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let a;
  let t_value = "";
  let t;
  let a_rel_value;
  let mounted;
  let dispose;
  let a_levels = [
    { href: ctx[0] },
    {
      rel: a_rel_value = ctx[2].target === "_blank" ? "noopener noreferrer" : void 0
    },
    { role: "button" },
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      set_attributes(a, a_data);
      toggle_class(a, "bx--skeleton", true);
      toggle_class(a, "bx--btn", true);
      toggle_class(a, "bx--btn--field", ctx[1] === "field");
      toggle_class(a, "bx--btn--sm", ctx[1] === "small");
      toggle_class(a, "bx--btn--lg", ctx[1] === "lg");
      toggle_class(a, "bx--btn--xl", ctx[1] === "xl");
      add_location(a, file11, 16, 2, 337);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, t);
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[3], false, false, false),
          listen_dev(a, "mouseover", ctx[4], false, false, false),
          listen_dev(a, "mouseenter", ctx[5], false, false, false),
          listen_dev(a, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 1 && { href: ctx2[0] },
        dirty & 4 && a_rel_value !== (a_rel_value = ctx2[2].target === "_blank" ? "noopener noreferrer" : void 0) && { rel: a_rel_value },
        { role: "button" },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(a, "bx--skeleton", true);
      toggle_class(a, "bx--btn", true);
      toggle_class(a, "bx--btn--field", ctx2[1] === "field");
      toggle_class(a, "bx--btn--sm", ctx2[1] === "small");
      toggle_class(a, "bx--btn--lg", ctx2[1] === "lg");
      toggle_class(a, "bx--btn--xl", ctx2[1] === "xl");
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(16:0) {#if href}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block8;
    return create_else_block6;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonSkeleton", slots, []);
  let { href = void 0 } = $$props;
  let { size = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ href, size });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    size,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var ButtonSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { href: 0, size: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonSkeleton",
      options,
      id: create_fragment12.name
    });
  }
  get href() {
    throw new Error("<ButtonSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ButtonSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ButtonSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ButtonSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonSkeleton_default = ButtonSkeleton;

// node_modules/carbon-components-svelte/src/Button/Button.svelte
var file12 = "node_modules/carbon-components-svelte/src/Button/Button.svelte";
var get_default_slot_changes3 = (dirty) => ({ props: dirty[0] & 512 });
var get_default_slot_context3 = (ctx) => ({ props: ctx[9] });
function create_else_block7(ctx) {
  let button;
  let t;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_4(ctx);
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return {
      props: {
        "aria-hidden": "true",
        class: "bx--btn__icon",
        style: ctx2[8] ? "margin-left: 0" : void 0,
        "aria-label": ctx2[3]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [ctx[9]];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_attributes(button, button_data);
      add_location(button, file12, 163, 2, 4429);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_dev(button, t);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (switch_instance)
        mount_component(switch_instance, button, null);
      if (button.autofocus)
        button.focus();
      ctx[33](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[24], false, false, false),
          listen_dev(button, "mouseover", ctx[25], false, false, false),
          listen_dev(button, "mouseenter", ctx[26], false, false, false),
          listen_dev(button, "mouseleave", ctx[27], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
      const switch_instance_changes = {};
      if (dirty[0] & 256)
        switch_instance_changes.style = ctx2[8] ? "margin-left: 0" : void 0;
      if (dirty[0] & 8)
        switch_instance_changes["aria-label"] = ctx2[3];
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty[0] & 512 && ctx2[9]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[33](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(163:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let a;
  let t;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_3(ctx);
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return {
      props: {
        "aria-hidden": "true",
        class: "bx--btn__icon",
        "aria-label": ctx2[3]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let a_levels = [ctx[9]];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_attributes(a, a_data);
      add_location(a, file12, 144, 2, 4046);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (if_block)
        if_block.m(a, null);
      append_dev(a, t);
      if (default_slot) {
        default_slot.m(a, null);
      }
      if (switch_instance)
        mount_component(switch_instance, a, null);
      ctx[32](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[20], false, false, false),
          listen_dev(a, "mouseover", ctx[21], false, false, false),
          listen_dev(a, "mouseenter", ctx[22], false, false, false),
          listen_dev(a, "mouseleave", ctx[23], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(a, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
      const switch_instance_changes = {};
      if (dirty[0] & 8)
        switch_instance_changes["aria-label"] = ctx2[3];
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, a, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [dirty[0] & 512 && ctx2[9]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(143:28) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], get_default_slot_context3);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 262656)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, get_default_slot_changes3),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(141:13) ",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let buttonskeleton;
  let current;
  const buttonskeleton_spread_levels = [
    { href: ctx[7] },
    { size: ctx[1] },
    ctx[10],
    {
      style: ctx[8] && "width: 3rem;"
    }
  ];
  let buttonskeleton_props = {};
  for (let i = 0; i < buttonskeleton_spread_levels.length; i += 1) {
    buttonskeleton_props = assign(buttonskeleton_props, buttonskeleton_spread_levels[i]);
  }
  buttonskeleton = new ButtonSkeleton_default({
    props: buttonskeleton_props,
    $$inline: true
  });
  buttonskeleton.$on("click", ctx[28]);
  buttonskeleton.$on("mouseover", ctx[29]);
  buttonskeleton.$on("mouseenter", ctx[30]);
  buttonskeleton.$on("mouseleave", ctx[31]);
  const block = {
    c: function create() {
      create_component(buttonskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(buttonskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttonskeleton_changes = dirty[0] & 1410 ? get_spread_update(buttonskeleton_spread_levels, [
        dirty[0] & 128 && { href: ctx2[7] },
        dirty[0] & 2 && { size: ctx2[1] },
        dirty[0] & 1024 && get_spread_object(ctx2[10]),
        dirty[0] & 256 && {
          style: ctx2[8] && "width: 3rem;"
        }
      ]) : {};
      buttonskeleton.$set(buttonskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttonskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttonskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttonskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(130:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(ctx[3]);
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file12, 172, 6, 4578);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(172:4) {#if hasIconOnly}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(ctx[3]);
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file12, 153, 6, 4190);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(153:4) {#if hasIconOnly}",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block9, create_if_block_12, create_if_block_22, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    if (ctx2[4])
      return 1;
    if (ctx2[7] && !ctx2[6])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let hasIconOnly;
  let buttonProps;
  const omit_props_names = [
    "kind",
    "size",
    "expressive",
    "isSelected",
    "icon",
    "iconDescription",
    "tooltipAlignment",
    "tooltipPosition",
    "as",
    "skeleton",
    "disabled",
    "href",
    "tabindex",
    "type",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { kind = "primary" } = $$props;
  let { size = "default" } = $$props;
  let { expressive = false } = $$props;
  let { isSelected = false } = $$props;
  let { icon = void 0 } = $$props;
  let { iconDescription = void 0 } = $$props;
  let { tooltipAlignment = "center" } = $$props;
  let { tooltipPosition = "bottom" } = $$props;
  let { as = false } = $$props;
  let { skeleton = false } = $$props;
  let { disabled = false } = $$props;
  let { href = void 0 } = $$props;
  let { tabindex = "0" } = $$props;
  let { type = "button" } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("ComposedModal");
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props)
      $$invalidate(11, kind = $$new_props.kind);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("expressive" in $$new_props)
      $$invalidate(12, expressive = $$new_props.expressive);
    if ("isSelected" in $$new_props)
      $$invalidate(13, isSelected = $$new_props.isSelected);
    if ("icon" in $$new_props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("iconDescription" in $$new_props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("tooltipAlignment" in $$new_props)
      $$invalidate(14, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$new_props)
      $$invalidate(15, tooltipPosition = $$new_props.tooltipPosition);
    if ("as" in $$new_props)
      $$invalidate(4, as = $$new_props.as);
    if ("skeleton" in $$new_props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(7, href = $$new_props.href);
    if ("tabindex" in $$new_props)
      $$invalidate(16, tabindex = $$new_props.tabindex);
    if ("type" in $$new_props)
      $$invalidate(17, type = $$new_props.type);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    size,
    expressive,
    isSelected,
    icon,
    iconDescription,
    tooltipAlignment,
    tooltipPosition,
    as,
    skeleton,
    disabled,
    href,
    tabindex,
    type,
    ref,
    getContext,
    ButtonSkeleton: ButtonSkeleton_default,
    ctx,
    hasIconOnly,
    buttonProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props)
      $$invalidate(11, kind = $$new_props.kind);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("expressive" in $$props)
      $$invalidate(12, expressive = $$new_props.expressive);
    if ("isSelected" in $$props)
      $$invalidate(13, isSelected = $$new_props.isSelected);
    if ("icon" in $$props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("iconDescription" in $$props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("tooltipAlignment" in $$props)
      $$invalidate(14, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$props)
      $$invalidate(15, tooltipPosition = $$new_props.tooltipPosition);
    if ("as" in $$props)
      $$invalidate(4, as = $$new_props.as);
    if ("skeleton" in $$props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(7, href = $$new_props.href);
    if ("tabindex" in $$props)
      $$invalidate(16, tabindex = $$new_props.tabindex);
    if ("type" in $$props)
      $$invalidate(17, type = $$new_props.type);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("hasIconOnly" in $$props)
      $$invalidate(8, hasIconOnly = $$new_props.hasIconOnly);
    if ("buttonProps" in $$props)
      $$invalidate(9, buttonProps = $$new_props.buttonProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $:
        if (ctx && ref) {
          ctx.declareRef(ref);
        }
    }
    if ($$self.$$.dirty[0] & 4) {
      $:
        $$invalidate(8, hasIconOnly = icon && !$$slots.default);
    }
    $:
      $$invalidate(9, buttonProps = {
        type: href && !disabled ? void 0 : type,
        tabindex,
        disabled: disabled === true ? true : void 0,
        href,
        "aria-pressed": hasIconOnly && kind === "ghost" && !href ? isSelected : void 0,
        ...$$restProps,
        class: [
          "bx--btn",
          expressive && "bx--btn--expressive",
          (size === "small" && !expressive || size === "sm" && !expressive || size === "small" && !expressive) && "bx--btn--sm",
          size === "field" && !expressive || size === "md" && !expressive && "bx--btn--md",
          size === "field" && "bx--btn--field",
          size === "small" && "bx--btn--sm",
          size === "lg" && "bx--btn--lg",
          size === "xl" && "bx--btn--xl",
          kind && `bx--btn--${kind}`,
          disabled && "bx--btn--disabled",
          hasIconOnly && "bx--btn--icon-only",
          hasIconOnly && "bx--tooltip__trigger",
          hasIconOnly && "bx--tooltip--a11y",
          hasIconOnly && tooltipPosition && `bx--btn--icon-only--${tooltipPosition}`,
          hasIconOnly && tooltipAlignment && `bx--tooltip--align-${tooltipAlignment}`,
          hasIconOnly && isSelected && kind === "ghost" && "bx--btn--selected",
          $$restProps.class
        ].filter(Boolean).join(" ")
      });
  };
  return [
    ref,
    size,
    icon,
    iconDescription,
    as,
    skeleton,
    disabled,
    href,
    hasIconOnly,
    buttonProps,
    $$restProps,
    kind,
    expressive,
    isSelected,
    tooltipAlignment,
    tooltipPosition,
    tabindex,
    type,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler_2,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        kind: 11,
        size: 1,
        expressive: 12,
        isSelected: 13,
        icon: 2,
        iconDescription: 3,
        tooltipAlignment: 14,
        tooltipPosition: 15,
        as: 4,
        skeleton: 5,
        disabled: 6,
        href: 7,
        tabindex: 16,
        type: 17,
        ref: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment13.name
    });
  }
  get kind() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipAlignment() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipAlignment(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipPosition() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipPosition(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte
var file13 = "node_modules/carbon-components-svelte/src/Button/ButtonSet.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--btn-set", true);
      toggle_class(div, "bx--btn-set--stacked", ctx[0]);
      add_location(div, file13, 5, 0, 105);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div, "bx--btn-set", true);
      toggle_class(div, "bx--btn-set--stacked", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["stacked"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonSet", slots, ["default"]);
  let { stacked = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("stacked" in $$new_props)
      $$invalidate(0, stacked = $$new_props.stacked);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ stacked });
  $$self.$inject_state = ($$new_props) => {
    if ("stacked" in $$props)
      $$invalidate(0, stacked = $$new_props.stacked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [stacked, $$restProps, $$scope, slots];
}
var ButtonSet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { stacked: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonSet",
      options,
      id: create_fragment14.name
    });
  }
  get stacked() {
    throw new Error("<ButtonSet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stacked(value) {
    throw new Error("<ButtonSet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonSet_default = ButtonSet;

// node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte
var file14 = "node_modules/carbon-components-svelte/src/Checkbox/CheckboxSkeleton.svelte";
function create_fragment15(ctx) {
  let div;
  let span;
  let mounted;
  let dispose;
  let div_levels = [ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      toggle_class(span, "bx--checkbox-label-text", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file14, 11, 2, 248);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      toggle_class(div, "bx--checkbox-label", true);
      add_location(div, file14, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[1], false, false, false),
          listen_dev(div, "mouseover", ctx[2], false, false, false),
          listen_dev(div, "mouseenter", ctx[3], false, false, false),
          listen_dev(div, "mouseleave", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      toggle_class(div, "bx--checkbox-label", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CheckboxSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxSkeleton",
      options,
      id: create_fragment15.name
    });
  }
};
var CheckboxSkeleton_default = CheckboxSkeleton;

// node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte
var file15 = "node_modules/carbon-components-svelte/src/Checkbox/Checkbox.svelte";
var get_labelText_slot_changes = (dirty) => ({});
var get_labelText_slot_context = (ctx) => ({});
function create_else_block8(ctx) {
  let div;
  let input;
  let t;
  let label;
  let span;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = ctx[19].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[18], get_labelText_slot_context);
  const labelText_slot_or_fallback = labelText_slot || fallback_block3(ctx);
  let div_levels = [ctx[16]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      label = element("label");
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(input, "type", "checkbox");
      input.value = ctx[4];
      input.checked = ctx[0];
      input.disabled = ctx[9];
      attr_dev(input, "id", ctx[13]);
      input.indeterminate = ctx[5];
      attr_dev(input, "name", ctx[12]);
      input.required = ctx[7];
      input.readOnly = ctx[8];
      toggle_class(input, "bx--checkbox", true);
      add_location(input, file15, 90, 4, 2092);
      toggle_class(span, "bx--checkbox-label-text", true);
      toggle_class(span, "bx--visually-hidden", ctx[11]);
      add_location(span, file15, 115, 6, 2748);
      attr_dev(label, "for", ctx[13]);
      attr_dev(label, "title", ctx[2]);
      toggle_class(label, "bx--checkbox-label", true);
      add_location(label, file15, 114, 4, 2673);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
      add_location(div, file15, 81, 2, 1919);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      ctx[30](input);
      append_dev(div, t);
      append_dev(div, label);
      append_dev(label, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      ctx[32](span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[31], false, false, false),
          listen_dev(input, "change", ctx[24], false, false, false),
          listen_dev(input, "blur", ctx[25], false, false, false),
          listen_dev(div, "click", ctx[20], false, false, false),
          listen_dev(div, "mouseover", ctx[21], false, false, false),
          listen_dev(div, "mouseenter", ctx[22], false, false, false),
          listen_dev(div, "mouseleave", ctx[23], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 16) {
        prop_dev(input, "value", ctx2[4]);
      }
      if (!current || dirty[0] & 1) {
        prop_dev(input, "checked", ctx2[0]);
      }
      if (!current || dirty[0] & 512) {
        prop_dev(input, "disabled", ctx2[9]);
      }
      if (!current || dirty[0] & 8192) {
        attr_dev(input, "id", ctx2[13]);
      }
      if (!current || dirty[0] & 32) {
        prop_dev(input, "indeterminate", ctx2[5]);
      }
      if (!current || dirty[0] & 4096) {
        attr_dev(input, "name", ctx2[12]);
      }
      if (!current || dirty[0] & 128) {
        prop_dev(input, "required", ctx2[7]);
      }
      if (!current || dirty[0] & 256) {
        prop_dev(input, "readOnly", ctx2[8]);
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 262144)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(labelText_slot_template, ctx2[18], dirty, get_labelText_slot_changes),
            get_labelText_slot_context
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 1024)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 2048) {
        toggle_class(span, "bx--visually-hidden", ctx2[11]);
      }
      if (!current || dirty[0] & 8192) {
        attr_dev(label, "for", ctx2[13]);
      }
      if (!current || dirty[0] & 4) {
        attr_dev(label, "title", ctx2[2]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty[0] & 65536 && ctx2[16]]));
      toggle_class(div, "bx--form-item", true);
      toggle_class(div, "bx--checkbox-wrapper", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[30](null);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(81:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let checkboxskeleton;
  let current;
  const checkboxskeleton_spread_levels = [ctx[16]];
  let checkboxskeleton_props = {};
  for (let i = 0; i < checkboxskeleton_spread_levels.length; i += 1) {
    checkboxskeleton_props = assign(checkboxskeleton_props, checkboxskeleton_spread_levels[i]);
  }
  checkboxskeleton = new CheckboxSkeleton_default({
    props: checkboxskeleton_props,
    $$inline: true
  });
  checkboxskeleton.$on("click", ctx[26]);
  checkboxskeleton.$on("mouseover", ctx[27]);
  checkboxskeleton.$on("mouseenter", ctx[28]);
  checkboxskeleton.$on("mouseleave", ctx[29]);
  const block = {
    c: function create() {
      create_component(checkboxskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxskeleton_changes = dirty[0] & 65536 ? get_spread_update(checkboxskeleton_spread_levels, [get_spread_object(ctx2[16])]) : {};
      checkboxskeleton.$set(checkboxskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(73:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[10]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1024)
        set_data_dev(t, ctx2[10]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(121:31)            ",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let useGroup;
  let isTruncated;
  const omit_props_names = [
    "value",
    "checked",
    "group",
    "indeterminate",
    "skeleton",
    "required",
    "readonly",
    "disabled",
    "labelText",
    "hideLabel",
    "name",
    "title",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["labelText"]);
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { group = void 0 } = $$props;
  let { indeterminate = false } = $$props;
  let { skeleton = false } = $$props;
  let { required = false } = $$props;
  let { readonly = false } = $$props;
  let { disabled = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { name = "" } = $$props;
  let { title = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let refLabel = null;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const change_handler_1 = () => {
    if (useGroup) {
      $$invalidate(1, group = group.includes(value) ? group.filter((_value) => _value !== value) : [...group, value]);
    } else {
      $$invalidate(0, checked = !checked);
    }
  };
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(14, refLabel);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("group" in $$new_props)
      $$invalidate(1, group = $$new_props.group);
    if ("indeterminate" in $$new_props)
      $$invalidate(5, indeterminate = $$new_props.indeterminate);
    if ("skeleton" in $$new_props)
      $$invalidate(6, skeleton = $$new_props.skeleton);
    if ("required" in $$new_props)
      $$invalidate(7, required = $$new_props.required);
    if ("readonly" in $$new_props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelText" in $$new_props)
      $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("name" in $$new_props)
      $$invalidate(12, name = $$new_props.name);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    checked,
    group,
    indeterminate,
    skeleton,
    required,
    readonly,
    disabled,
    labelText,
    hideLabel,
    name,
    title,
    id,
    ref,
    createEventDispatcher,
    CheckboxSkeleton: CheckboxSkeleton_default,
    dispatch,
    refLabel,
    isTruncated,
    useGroup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("group" in $$props)
      $$invalidate(1, group = $$new_props.group);
    if ("indeterminate" in $$props)
      $$invalidate(5, indeterminate = $$new_props.indeterminate);
    if ("skeleton" in $$props)
      $$invalidate(6, skeleton = $$new_props.skeleton);
    if ("required" in $$props)
      $$invalidate(7, required = $$new_props.required);
    if ("readonly" in $$props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelText" in $$props)
      $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("name" in $$props)
      $$invalidate(12, name = $$new_props.name);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("refLabel" in $$props)
      $$invalidate(14, refLabel = $$new_props.refLabel);
    if ("isTruncated" in $$props)
      $$invalidate(17, isTruncated = $$new_props.isTruncated);
    if ("useGroup" in $$props)
      $$invalidate(15, useGroup = $$new_props.useGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(15, useGroup = Array.isArray(group));
    }
    if ($$self.$$.dirty[0] & 32787) {
      $:
        $$invalidate(0, checked = useGroup ? group.includes(value) : checked);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        dispatch("check", checked);
    }
    if ($$self.$$.dirty[0] & 16384) {
      $:
        $$invalidate(17, isTruncated = (refLabel == null ? void 0 : refLabel.offsetWidth) < (refLabel == null ? void 0 : refLabel.scrollWidth));
    }
    if ($$self.$$.dirty[0] & 147460) {
      $:
        $$invalidate(2, title = !title && isTruncated ? refLabel == null ? void 0 : refLabel.innerText : title);
    }
  };
  return [
    checked,
    group,
    title,
    ref,
    value,
    indeterminate,
    skeleton,
    required,
    readonly,
    disabled,
    labelText,
    hideLabel,
    name,
    id,
    refLabel,
    useGroup,
    $$restProps,
    isTruncated,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    change_handler,
    blur_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    input_binding,
    change_handler_1,
    span_binding
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        value: 4,
        checked: 0,
        group: 1,
        indeterminate: 5,
        skeleton: 6,
        required: 7,
        readonly: 8,
        disabled: 9,
        labelText: 10,
        hideLabel: 11,
        name: 12,
        title: 2,
        id: 13,
        ref: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment16.name
    });
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte
var file16 = "node_modules/carbon-components-svelte/src/Checkbox/InlineCheckbox.svelte";
function create_fragment17(ctx) {
  let div;
  let input;
  let input_checked_value;
  let input_aria_checked_value;
  let t;
  let label;
  let label_aria_label_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    {
      checked: input_checked_value = ctx[2] ? false : ctx[1]
    },
    { indeterminate: ctx[2] },
    { id: ctx[4] },
    ctx[5],
    {
      "aria-checked": input_aria_checked_value = ctx[2] ? void 0 : ctx[1]
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      label = element("label");
      set_attributes(input, input_data);
      toggle_class(input, "bx--checkbox", true);
      add_location(input, file16, 21, 2, 530);
      attr_dev(label, "for", ctx[4]);
      attr_dev(label, "title", ctx[3]);
      attr_dev(label, "aria-label", label_aria_label_value = ctx[6]["aria-label"]);
      toggle_class(label, "bx--checkbox-label", true);
      add_location(label, file16, 32, 2, 808);
      toggle_class(div, "bx--checkbox--inline", true);
      add_location(div, file16, 20, 0, 486);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      if (input.autofocus)
        input.focus();
      ctx[8](input);
      append_dev(div, t);
      append_dev(div, label);
      if (!mounted) {
        dispose = listen_dev(input, "change", ctx[7], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        dirty & 6 && input_checked_value !== (input_checked_value = ctx2[2] ? false : ctx2[1]) && { checked: input_checked_value },
        dirty & 4 && { indeterminate: ctx2[2] },
        dirty & 16 && { id: ctx2[4] },
        dirty & 32 && ctx2[5],
        dirty & 6 && input_aria_checked_value !== (input_aria_checked_value = ctx2[2] ? void 0 : ctx2[1]) && { "aria-checked": input_aria_checked_value }
      ]));
      toggle_class(input, "bx--checkbox", true);
      if (dirty & 16) {
        attr_dev(label, "for", ctx2[4]);
      }
      if (dirty & 8) {
        attr_dev(label, "title", ctx2[3]);
      }
      if (dirty & 64 && label_aria_label_value !== (label_aria_label_value = ctx2[6]["aria-label"])) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "indeterminate", "title", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineCheckbox", slots, []);
  let { checked = false } = $$props;
  let { indeterminate = false } = $$props;
  let { title = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({ checked, indeterminate, title, id, ref });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    ref,
    checked,
    indeterminate,
    title,
    id,
    $$restProps,
    $$props,
    change_handler,
    input_binding
  ];
}
var InlineCheckbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      checked: 1,
      indeterminate: 2,
      title: 3,
      id: 4,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineCheckbox",
      options,
      id: create_fragment17.name
    });
  }
  get checked() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<InlineCheckbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<InlineCheckbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineCheckbox_default = InlineCheckbox;

// node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte
var file17 = "node_modules/carbon-components-svelte/src/ContentSwitcher/ContentSwitcher.svelte";
function create_fragment18(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [{ role: "tablist" }, ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--content-switcher", true);
      toggle_class(div, "bx--content-switcher--sm", ctx[0] === "sm");
      toggle_class(div, "bx--content-switcher--xl", ctx[0] === "xl");
      add_location(div, file17, 60, 0, 1363);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[7], false, false, false),
          listen_dev(div, "mouseover", ctx[8], false, false, false),
          listen_dev(div, "mouseenter", ctx[9], false, false, false),
          listen_dev(div, "mouseleave", ctx[10], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "tablist" }, dirty & 2 && ctx2[1]]));
      toggle_class(div, "bx--content-switcher", true);
      toggle_class(div, "bx--content-switcher--sm", ctx2[0] === "sm");
      toggle_class(div, "bx--content-switcher--xl", ctx2[0] === "xl");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let currentIndex;
  let switches;
  const omit_props_names = ["selectedIndex", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContentSwitcher", slots, ["default"]);
  let { selectedIndex = 0 } = $$props;
  let { size = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const currentId = writable(null);
  setContext("ContentSwitcher", {
    currentId,
    add: ({ id, text: text2, selected }) => {
      if (selected) {
        $$invalidate(2, selectedIndex = switches.length);
      }
      $$invalidate(4, switches = [...switches, { id, text: text2, selected }]);
    },
    update: (id) => {
      $$invalidate(2, selectedIndex = switches.map(({ id: id2 }) => id2).indexOf(id));
    },
    change: (direction) => {
      let index = currentIndex + direction;
      if (index < 0) {
        index = switches.length - 1;
      } else if (index >= switches.length) {
        index = 0;
      }
      $$invalidate(2, selectedIndex = index);
    }
  });
  afterUpdate(() => {
    if (selectedIndex !== currentIndex) {
      $$invalidate(3, currentIndex = selectedIndex);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selectedIndex" in $$new_props)
      $$invalidate(2, selectedIndex = $$new_props.selectedIndex);
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedIndex,
    size,
    afterUpdate,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    currentId,
    currentIndex,
    switches
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selectedIndex" in $$props)
      $$invalidate(2, selectedIndex = $$new_props.selectedIndex);
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("currentIndex" in $$props)
      $$invalidate(3, currentIndex = $$new_props.currentIndex);
    if ("switches" in $$props)
      $$invalidate(4, switches = $$new_props.switches);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 24) {
      $:
        if (switches[currentIndex]) {
          dispatch("change", currentIndex);
          currentId.set(switches[currentIndex].id);
        }
    }
  };
  $:
    $$invalidate(3, currentIndex = -1);
  $:
    $$invalidate(4, switches = []);
  return [
    size,
    $$restProps,
    selectedIndex,
    currentIndex,
    switches,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ContentSwitcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { selectedIndex: 2, size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContentSwitcher",
      options,
      id: create_fragment18.name
    });
  }
  get selectedIndex() {
    throw new Error("<ContentSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIndex(value) {
    throw new Error("<ContentSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ContentSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ContentSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContentSwitcher_default = ContentSwitcher;

// node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte
var file18 = "node_modules/carbon-components-svelte/src/ContentSwitcher/Switch.svelte";
function fallback_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(70:10) {text}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let button;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const default_slot_or_fallback = default_slot || fallback_block4(ctx);
  let button_levels = [
    { type: "button" },
    { role: "tab" },
    {
      tabindex: button_tabindex_value = ctx[0] ? "0" : "-1"
    },
    { "aria-selected": ctx[0] },
    { disabled: ctx[3] },
    { id: ctx[4] },
    ctx[6]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      toggle_class(span, "bx--content-switcher__label", true);
      add_location(span, file18, 68, 2, 1499);
      set_attributes(button, button_data);
      toggle_class(button, "bx--content-switcher-btn", true);
      toggle_class(button, "bx--content-switcher--selected", ctx[0]);
      add_location(button, file18, 41, 0, 935);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[14](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[9], false, false, false),
          listen_dev(button, "click", prevent_default(ctx[15]), false, true, false),
          listen_dev(button, "mouseover", ctx[10], false, false, false),
          listen_dev(button, "mouseenter", ctx[11], false, false, false),
          listen_dev(button, "mouseleave", ctx[12], false, false, false),
          listen_dev(button, "keydown", ctx[13], false, false, false),
          listen_dev(button, "keydown", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { role: "tab" },
        (!current || dirty & 1 && button_tabindex_value !== (button_tabindex_value = ctx2[0] ? "0" : "-1")) && { tabindex: button_tabindex_value },
        (!current || dirty & 1) && { "aria-selected": ctx2[0] },
        (!current || dirty & 8) && { disabled: ctx2[3] },
        (!current || dirty & 16) && { id: ctx2[4] },
        dirty & 64 && ctx2[6]
      ]));
      toggle_class(button, "bx--content-switcher-btn", true);
      toggle_class(button, "bx--content-switcher--selected", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["text", "selected", "disabled", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, ["default"]);
  let { text: text2 = "Provide text" } = $$props;
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("ContentSwitcher");
  ctx.add({ id, text: text2, selected });
  const unsubscribe = ctx.currentId.subscribe(($) => {
    $$invalidate(0, selected = $ === id);
  });
  afterUpdate(() => {
    if (selected) {
      ref.focus();
    }
  });
  onMount(() => {
    return () => unsubscribe();
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    ctx.update(id);
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "ArrowRight") {
      ctx.change(1);
    } else if (key === "ArrowLeft") {
      ctx.change(-1);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    text: text2,
    selected,
    disabled,
    id,
    ref,
    afterUpdate,
    getContext,
    onMount,
    ctx,
    unsubscribe
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selected,
    ref,
    text2,
    disabled,
    id,
    ctx,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    button_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      text: 2,
      selected: 0,
      disabled: 3,
      id: 4,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment19.name
    });
  }
  get text() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte
var { window: window_1 } = globals;
var file19 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenu.svelte";
function create_fragment20(ctx) {
  let ul;
  let ul_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  let ul_levels = [
    { role: "menu" },
    { tabindex: "-1" },
    { "data-direction": ctx[10] },
    { "data-level": ctx[7] },
    ctx[13],
    {
      style: ul_style_value = "left: " + ctx[1] + "px; top: " + ctx[2] + "px; " + ctx[13].style
    }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--menu", true);
      toggle_class(ul, "bx--menu--open", ctx[0]);
      toggle_class(ul, "bx--menu--invisible", ctx[0] && ctx[1] === 0 && ctx[2] === 0);
      toggle_class(ul, "bx--menu--root", ctx[7] === 1);
      add_location(ul, file19, 155, 0, 3306);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[21](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window_1, "contextmenu", prevent_default(ctx[18]), false, true, false),
          listen_dev(window_1, "click", ctx[19], false, false, false),
          listen_dev(window_1, "keydown", ctx[20], false, false, false),
          listen_dev(ul, "click", ctx[16], false, false, false),
          listen_dev(ul, "click", ctx[22], false, false, false),
          listen_dev(ul, "keydown", ctx[17], false, false, false),
          listen_dev(ul, "keydown", ctx[23], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        { role: "menu" },
        { tabindex: "-1" },
        { "data-direction": ctx2[10] },
        (!current || dirty[0] & 128) && { "data-level": ctx2[7] },
        dirty[0] & 8192 && ctx2[13],
        (!current || dirty[0] & 8198 && ul_style_value !== (ul_style_value = "left: " + ctx2[1] + "px; top: " + ctx2[2] + "px; " + ctx2[13].style)) && { style: ul_style_value }
      ]));
      toggle_class(ul, "bx--menu", true);
      toggle_class(ul, "bx--menu--open", ctx2[0]);
      toggle_class(ul, "bx--menu--invisible", ctx2[0] && ctx2[1] === 0 && ctx2[2] === 0);
      toggle_class(ul, "bx--menu--root", ctx2[7] === 1);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let level;
  const omit_props_names = ["target", "open", "x", "y", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hasPopup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenu", slots, ["default"]);
  let { target = null } = $$props;
  let { open = false } = $$props;
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const position = writable([x, y]);
  const currentIndex = writable(-1);
  const hasPopup = writable(false);
  validate_store(hasPopup, "hasPopup");
  component_subscribe($$self, hasPopup, (value) => $$invalidate(8, $hasPopup = value));
  const menuOffsetX = writable(0);
  const ctx = getContext("ContextMenu");
  let options = [];
  let direction = 1;
  let prevX = 0;
  let prevY = 0;
  let focusIndex = -1;
  let openDetail = null;
  function close() {
    $$invalidate(0, open = false);
    $$invalidate(1, x = 0);
    $$invalidate(2, y = 0);
    prevX = 0;
    prevY = 0;
    $$invalidate(5, focusIndex = -1);
  }
  function openMenu(e) {
    const { height, width } = ref.getBoundingClientRect();
    if (open || x === 0) {
      if (window.innerWidth - width < e.x) {
        $$invalidate(1, x = e.x - width);
      } else {
        $$invalidate(1, x = e.x);
      }
    }
    if (open || y === 0) {
      menuOffsetX.set(e.x);
      if (window.innerHeight - height < e.y) {
        $$invalidate(2, y = e.y - height);
      } else {
        $$invalidate(2, y = e.y);
      }
    }
    position.set([x, y]);
    $$invalidate(0, open = true);
    openDetail = e.target;
  }
  onMount(() => {
    return () => {
      if (target != null) {
        if (Array.isArray(target)) {
          target.forEach((node) => node == null ? void 0 : node.removeEventListener("contextmenu", openMenu));
        } else {
          target.removeEventListener("contextmenu", openMenu);
        }
      }
    };
  });
  setContext("ContextMenu", {
    menuOffsetX,
    currentIndex,
    position,
    close,
    setPopup: (popup) => {
      hasPopup.set(popup);
    }
  });
  afterUpdate(() => {
    if (open) {
      $$invalidate(6, options = [...ref.querySelectorAll("li[data-nested='false']")]);
      if (level === 1) {
        if (prevX !== x || prevY !== y)
          ref.focus();
        prevX = x;
        prevY = y;
      }
      dispatch("open", openDetail);
    } else {
      dispatch("close");
    }
    if (!$hasPopup && options[focusIndex])
      options[focusIndex].focus();
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const contextmenu_handler = (e) => {
    if (target != null)
      return;
    if (level > 1)
      return;
    if (!ref)
      return;
    openMenu(e);
  };
  const click_handler_13 = (e) => {
    if (!open)
      return;
    close();
  };
  const keydown_handler_12 = (e) => {
    if (open && e.key === "Escape")
      close();
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler_2 = ({ target: target2 }) => {
    const closestOption = target2.closest("[tabindex]");
    if (closestOption && closestOption.getAttribute("role") !== "menuitem") {
      close();
    }
  };
  const keydown_handler_2 = (e) => {
    if (open)
      e.preventDefault();
    if ($hasPopup)
      return;
    if (e.key === "ArrowDown") {
      if (focusIndex < options.length - 1)
        $$invalidate(5, focusIndex++, focusIndex);
    } else if (e.key === "ArrowUp") {
      if (focusIndex === -1) {
        $$invalidate(5, focusIndex = options.length - 1);
      } else {
        if (focusIndex > 0)
          $$invalidate(5, focusIndex--, focusIndex);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("target" in $$new_props)
      $$invalidate(4, target = $$new_props.target);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("x" in $$new_props)
      $$invalidate(1, x = $$new_props.x);
    if ("y" in $$new_props)
      $$invalidate(2, y = $$new_props.y);
    if ("ref" in $$new_props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    target,
    open,
    x,
    y,
    ref,
    onMount,
    setContext,
    getContext,
    afterUpdate,
    createEventDispatcher,
    writable,
    dispatch,
    position,
    currentIndex,
    hasPopup,
    menuOffsetX,
    ctx,
    options,
    direction,
    prevX,
    prevY,
    focusIndex,
    openDetail,
    close,
    openMenu,
    level,
    $hasPopup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("target" in $$props)
      $$invalidate(4, target = $$new_props.target);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("x" in $$props)
      $$invalidate(1, x = $$new_props.x);
    if ("y" in $$props)
      $$invalidate(2, y = $$new_props.y);
    if ("ref" in $$props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("options" in $$props)
      $$invalidate(6, options = $$new_props.options);
    if ("direction" in $$props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("prevX" in $$props)
      prevX = $$new_props.prevX;
    if ("prevY" in $$props)
      prevY = $$new_props.prevY;
    if ("focusIndex" in $$props)
      $$invalidate(5, focusIndex = $$new_props.focusIndex);
    if ("openDetail" in $$props)
      openDetail = $$new_props.openDetail;
    if ("level" in $$props)
      $$invalidate(7, level = $$new_props.level);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16) {
      $:
        if (target != null) {
          if (Array.isArray(target)) {
            target.forEach((node) => node == null ? void 0 : node.addEventListener("contextmenu", openMenu));
          } else {
            target.addEventListener("contextmenu", openMenu);
          }
        }
    }
    if ($$self.$$.dirty[0] & 32) {
      $:
        currentIndex.set(focusIndex);
    }
  };
  $:
    $$invalidate(7, level = !ctx ? 1 : 2);
  return [
    open,
    x,
    y,
    ref,
    target,
    focusIndex,
    options,
    level,
    $hasPopup,
    hasPopup,
    direction,
    close,
    openMenu,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    contextmenu_handler,
    click_handler_13,
    keydown_handler_12,
    ul_binding,
    click_handler_2,
    keydown_handler_2
  ];
}
var ContextMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { target: 4, open: 0, x: 1, y: 2, ref: 3 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenu",
      options,
      id: create_fragment20.name
    });
  }
  get target() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ContextMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ContextMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenu_default = ContextMenu;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte
var file20 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuDivider.svelte";
function create_fragment21(ctx) {
  let li;
  const block = {
    c: function create() {
      li = element("li");
      attr_dev(li, "role", "separator");
      toggle_class(li, "bx--menu-divider", true);
      add_location(li, file20, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuDivider", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextMenuDivider> was created with unknown prop '${key}'`);
  });
  return [];
}
var ContextMenuDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuDivider",
      options,
      id: create_fragment21.name
    });
  }
};
var ContextMenuDivider_default = ContextMenuDivider;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte
var file21 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuGroup.svelte";
function create_fragment22(ctx) {
  let li;
  let ul;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      li = element("li");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr_dev(ul, "role", "group");
      attr_dev(ul, "aria-label", ctx[0]);
      add_location(ul, file21, 32, 2, 714);
      attr_dev(li, "role", "none");
      add_location(li, file21, 31, 0, 695);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr_dev(ul, "aria-label", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuGroup", slots, ["default"]);
  let { selectedIds = [] } = $$props;
  let { labelText = "" } = $$props;
  const currentIds = writable([]);
  setContext("ContextMenuGroup", {
    currentIds,
    addOption: ({ id }) => {
      if (!selectedIds.includes(id)) {
        $$invalidate(1, selectedIds = [...selectedIds, id]);
      }
    },
    toggleOption: ({ id }) => {
      if (!selectedIds.includes(id)) {
        $$invalidate(1, selectedIds = [...selectedIds, id]);
      } else {
        $$invalidate(1, selectedIds = selectedIds.filter((_) => _ !== id));
      }
    }
  });
  const writable_props = ["selectedIds", "labelText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextMenuGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selectedIds" in $$props2)
      $$invalidate(1, selectedIds = $$props2.selectedIds);
    if ("labelText" in $$props2)
      $$invalidate(0, labelText = $$props2.labelText);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedIds,
    labelText,
    setContext,
    writable,
    currentIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectedIds" in $$props2)
      $$invalidate(1, selectedIds = $$props2.selectedIds);
    if ("labelText" in $$props2)
      $$invalidate(0, labelText = $$props2.labelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        currentIds.set(selectedIds);
    }
  };
  return [labelText, selectedIds, $$scope, slots];
}
var ContextMenuGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { selectedIds: 1, labelText: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuGroup",
      options,
      id: create_fragment22.name
    });
  }
  get selectedIds() {
    throw new Error("<ContextMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<ContextMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuGroup_default = ContextMenuGroup;

// node_modules/carbon-components-svelte/src/icons/Checkmark.svelte
var file22 = "node_modules/carbon-components-svelte/src/icons/Checkmark.svelte";
function create_if_block11(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file22, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block11(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z");
      add_location(path, file22, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file22, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkmark", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Checkmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkmark",
      options,
      id: create_fragment23.name
    });
  }
  get size() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkmark_default = Checkmark;

// node_modules/carbon-components-svelte/src/icons/CaretRight.svelte
var file23 = "node_modules/carbon-components-svelte/src/icons/CaretRight.svelte";
function create_if_block12(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file23, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block12(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M12 8L22 16 12 24z");
      add_location(path, file23, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file23, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretRight", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretRight",
      options,
      id: create_fragment24.name
    });
  }
  get size() {
    throw new Error("<CaretRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretRight_default = CaretRight;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte
var file24 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuOption.svelte";
var get_shortcutText_slot_changes = (dirty) => ({});
var get_shortcutText_slot_context = (ctx) => ({});
var get_labelText_slot_changes_1 = (dirty) => ({});
var get_labelText_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes_12 = (dirty) => ({});
var get_icon_slot_context_12 = (ctx) => ({});
var get_labelText_slot_changes2 = (dirty) => ({});
var get_labelText_slot_context2 = (ctx) => ({});
var get_icon_slot_changes2 = (dirty) => ({});
var get_icon_slot_context2 = (ctx) => ({});
function create_else_block9(ctx) {
  let div1;
  let t0;
  let span;
  let t1;
  let div0;
  let current;
  let if_block = ctx[2] && create_if_block_23(ctx);
  const labelText_slot_template = ctx[23].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[31], get_labelText_slot_context_1);
  const labelText_slot_or_fallback = labelText_slot || fallback_block_3(ctx);
  const shortcutText_slot_template = ctx[23].shortcutText;
  const shortcutText_slot = create_slot(shortcutText_slot_template, ctx, ctx[31], get_shortcutText_slot_context);
  const shortcutText_slot_or_fallback = shortcutText_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (shortcutText_slot_or_fallback)
        shortcutText_slot_or_fallback.c();
      attr_dev(span, "title", ctx[6]);
      toggle_class(span, "bx--menu-option__label", true);
      add_location(span, file24, 277, 6, 7344);
      toggle_class(div0, "bx--menu-option__info", true);
      add_location(div0, file24, 280, 6, 7479);
      toggle_class(div1, "bx--menu-option__content", true);
      toggle_class(div1, "bx--menu-option__content--disabled", ctx[5]);
      add_location(div1, file24, 266, 4, 7028);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      if (shortcutText_slot_or_fallback) {
        shortcutText_slot_or_fallback.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(labelText_slot_template, ctx2[31], dirty, get_labelText_slot_changes_1),
            get_labelText_slot_context_1
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 64) {
        attr_dev(span, "title", ctx2[6]);
      }
      if (shortcutText_slot) {
        if (shortcutText_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            shortcutText_slot,
            shortcutText_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(shortcutText_slot_template, ctx2[31], dirty, get_shortcutText_slot_changes),
            get_shortcutText_slot_context
          );
        }
      } else {
        if (shortcutText_slot_or_fallback && shortcutText_slot_or_fallback.p && (!current || dirty[0] & 128)) {
          shortcutText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--menu-option__content--disabled", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(labelText_slot_or_fallback, local);
      transition_in(shortcutText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(labelText_slot_or_fallback, local);
      transition_out(shortcutText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (shortcutText_slot_or_fallback)
        shortcutText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(266:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let div1;
  let t0;
  let span;
  let t1;
  let div0;
  let caretright;
  let t2;
  let contextmenu;
  let current;
  let if_block = ctx[2] && create_if_block_13(ctx);
  const labelText_slot_template = ctx[23].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[31], get_labelText_slot_context2);
  const labelText_slot_or_fallback = labelText_slot || fallback_block5(ctx);
  caretright = new CaretRight_default({ $$inline: true });
  contextmenu = new ContextMenu_default({
    props: {
      open: ctx[9],
      x: ctx[16][0],
      y: ctx[16][1],
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      create_component(caretright.$$.fragment);
      t2 = space();
      create_component(contextmenu.$$.fragment);
      attr_dev(span, "title", ctx[6]);
      toggle_class(span, "bx--menu-option__label", true);
      add_location(span, file24, 252, 6, 6658);
      toggle_class(div0, "bx--menu-option__info", true);
      add_location(div0, file24, 255, 6, 6793);
      toggle_class(div1, "bx--menu-option__content", true);
      toggle_class(div1, "bx--menu-option__content--disabled", ctx[5]);
      add_location(div1, file24, 241, 4, 6342);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(caretright, div0, null);
      insert_dev(target, t2, anchor);
      mount_component(contextmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(labelText_slot_template, ctx2[31], dirty, get_labelText_slot_changes2),
            get_labelText_slot_context2
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 64) {
        attr_dev(span, "title", ctx2[6]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--menu-option__content--disabled", ctx2[5]);
      }
      const contextmenu_changes = {};
      if (dirty[0] & 512)
        contextmenu_changes.open = ctx2[9];
      if (dirty[0] & 65536)
        contextmenu_changes.x = ctx2[16][0];
      if (dirty[0] & 65536)
        contextmenu_changes.y = ctx2[16][1];
      if (dirty[1] & 1) {
        contextmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextmenu.$set(contextmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(labelText_slot_or_fallback, local);
      transition_in(caretright.$$.fragment, local);
      transition_in(contextmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(labelText_slot_or_fallback, local);
      transition_out(caretright.$$.fragment, local);
      transition_out(contextmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      destroy_component(caretright);
      if (detaching)
        detach_dev(t2);
      destroy_component(contextmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(241:2) {#if subOptions}",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[23].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[31], get_icon_slot_context_12);
  const icon_slot_or_fallback = icon_slot || fallback_block_4(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--menu-option__icon", true);
      add_location(div, file24, 271, 8, 7174);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(icon_slot_template, ctx2[31], dirty, get_icon_slot_changes_12),
            get_icon_slot_context_12
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & 8)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(271:6) {#if indented}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(273:28)              ",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[6]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(279:31) {labelText}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[7]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 128)
        set_data_dev(t, ctx2[7]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(282:34) {shortcutText}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[23].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[31], get_icon_slot_context2);
  const icon_slot_or_fallback = icon_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--menu-option__icon", true);
      add_location(div, file24, 246, 8, 6488);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(icon_slot_template, ctx2[31], dirty, get_icon_slot_changes2),
            get_icon_slot_context2
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & 8)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(246:6) {#if indented}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(248:28)              ",
    ctx
  });
  return block;
}
function fallback_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[6]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(254:31) {labelText}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = ctx[23].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[31], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[31],
            !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(default_slot_template, ctx2[31], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(259:4) <ContextMenu       open=\\"{submenuOpen}\\"       x=\\"{submenuPosition[0]}\\"       y=\\"{submenuPosition[1]}\\"     >',
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_aria_disabled_value;
  let li_aria_haspopup_value;
  let li_aria_expanded_value;
  let li_aria_checked_value;
  let li_data_nested_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block13, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[17])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    { role: ctx[15] },
    { tabindex: "-1" },
    {
      "aria-disabled": li_aria_disabled_value = !ctx[17] && ctx[5]
    },
    {
      "aria-haspopup": li_aria_haspopup_value = ctx[17] ? true : void 0
    },
    {
      "aria-expanded": li_aria_expanded_value = ctx[17] ? ctx[9] : void 0
    },
    { indented: ctx[2] },
    {
      "aria-checked": li_aria_checked_value = ctx[11] || ctx[10] ? ctx[0] : void 0
    },
    {
      "data-nested": li_data_nested_value = ctx[1] && ctx[1].closest(".bx--menu").getAttribute("data-level") === "2"
    },
    { "data-sub": ctx[17] },
    { "data-id": ctx[8] },
    ctx[19]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      set_attributes(li, li_data);
      toggle_class(li, "bx--menu-option", true);
      toggle_class(li, "bx--menu-option--disabled", true);
      toggle_class(li, "bx--menu-option--active", ctx[17] && ctx[9]);
      toggle_class(li, "bx--menu-option--danger", !ctx[17] && ctx[4] === "danger");
      add_location(li, file24, 168, 0, 4330);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      ctx[27](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "keydown", ctx[24], false, false, false),
          listen_dev(li, "keydown", ctx[28], false, false, false),
          listen_dev(li, "mouseenter", ctx[25], false, false, false),
          listen_dev(li, "mouseenter", ctx[29], false, false, false),
          listen_dev(li, "mouseleave", ctx[26], false, false, false),
          listen_dev(li, "mouseleave", ctx[30], false, false, false),
          listen_dev(li, "click", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty[0] & 32768) && { role: ctx2[15] },
        { tabindex: "-1" },
        (!current || dirty[0] & 131104 && li_aria_disabled_value !== (li_aria_disabled_value = !ctx2[17] && ctx2[5])) && { "aria-disabled": li_aria_disabled_value },
        (!current || dirty[0] & 131072 && li_aria_haspopup_value !== (li_aria_haspopup_value = ctx2[17] ? true : void 0)) && { "aria-haspopup": li_aria_haspopup_value },
        (!current || dirty[0] & 131584 && li_aria_expanded_value !== (li_aria_expanded_value = ctx2[17] ? ctx2[9] : void 0)) && { "aria-expanded": li_aria_expanded_value },
        (!current || dirty[0] & 4) && { indented: ctx2[2] },
        (!current || dirty[0] & 3073 && li_aria_checked_value !== (li_aria_checked_value = ctx2[11] || ctx2[10] ? ctx2[0] : void 0)) && { "aria-checked": li_aria_checked_value },
        (!current || dirty[0] & 2 && li_data_nested_value !== (li_data_nested_value = ctx2[1] && ctx2[1].closest(".bx--menu").getAttribute("data-level") === "2")) && { "data-nested": li_data_nested_value },
        (!current || dirty[0] & 131072) && { "data-sub": ctx2[17] },
        (!current || dirty[0] & 256) && { "data-id": ctx2[8] },
        dirty[0] & 524288 && ctx2[19]
      ]));
      toggle_class(li, "bx--menu-option", true);
      toggle_class(li, "bx--menu-option--disabled", true);
      toggle_class(li, "bx--menu-option--active", ctx2[17] && ctx2[9]);
      toggle_class(li, "bx--menu-option--danger", !ctx2[17] && ctx2[4] === "danger");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var moderate01 = 150;
function instance25($$self, $$props, $$invalidate) {
  let isSelectable;
  let isRadio;
  let subOptions;
  const omit_props_names = [
    "kind",
    "disabled",
    "indented",
    "icon",
    "labelText",
    "selected",
    "selectable",
    "shortcutText",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuOption", slots, ["icon", "labelText", "default", "shortcutText"]);
  const $$slots = compute_slots(slots);
  let { kind = "default" } = $$props;
  let { disabled = false } = $$props;
  let { indented = false } = $$props;
  let { icon = void 0 } = $$props;
  let { labelText = "" } = $$props;
  let { selected = false } = $$props;
  let { selectable = false } = $$props;
  let { shortcutText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const ctx = getContext("ContextMenu");
  const ctxGroup = getContext("ContextMenuGroup");
  const ctxRadioGroup = getContext("ContextMenuRadioGroup");
  let unsubCurrentIds = void 0;
  let unsubCurrentId = void 0;
  let timeoutHover = void 0;
  let rootMenuPosition = [0, 0];
  let focusIndex = 0;
  let options = [];
  let role = "menuitem";
  let submenuOpen = false;
  let submenuPosition = [0, 0];
  let menuOffsetX = 0;
  const unsubPosition = ctx.position.subscribe((position) => {
    $$invalidate(21, rootMenuPosition = position);
  });
  const unsubMenuOffsetX = ctx.menuOffsetX.subscribe((_menuOffsetX) => {
    $$invalidate(22, menuOffsetX = _menuOffsetX);
  });
  function handleClick(opts = {}) {
    if (disabled)
      return ctx.close();
    if (subOptions)
      return;
    if (!!ctxGroup) {
      ctxGroup.toggleOption({ id });
    } else if (!!ctxRadioGroup) {
      if (opts.fromKeyboard) {
        ctxRadioGroup.setOption({ id: opts.id });
      } else {
        ctxRadioGroup.setOption({ id });
      }
    } else {
      $$invalidate(0, selected = !selected);
    }
    ctx.close();
    dispatch("click");
  }
  onMount(() => {
    if (selected === true)
      $$invalidate(20, selectable = true);
    if (ctxGroup) {
      unsubCurrentIds = ctxGroup.currentIds.subscribe((_currentIds) => {
        $$invalidate(0, selected = _currentIds.includes(id));
      });
    }
    if (ctxRadioGroup) {
      unsubCurrentId = ctxRadioGroup.currentId.subscribe((_id) => {
        $$invalidate(0, selected = id === _id);
      });
    }
    return () => {
      unsubPosition();
      unsubMenuOffsetX();
      if (unsubCurrentIds)
        unsubCurrentIds();
      if (unsubCurrentId)
        unsubCurrentId();
      if (typeof timeoutHover === "number")
        clearTimeout(timeoutHover);
    };
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = async ({ key, target }) => {
    if (subOptions && (key === "ArrowRight" || key === " " || key === "Enter")) {
      $$invalidate(9, submenuOpen = true);
      await tick();
      $$invalidate(14, options = [...ref.querySelectorAll("li[tabindex]")]);
      if (options[focusIndex])
        options[focusIndex].focus();
      return;
    }
    if (submenuOpen) {
      if (key === "ArrowLeft") {
        $$invalidate(9, submenuOpen = false);
        $$invalidate(13, focusIndex = 0);
        return;
      }
      if (key === "ArrowDown") {
        if (focusIndex < options.length - 1)
          $$invalidate(13, focusIndex++, focusIndex);
      } else if (key === "ArrowUp") {
        if (focusIndex === -1) {
          $$invalidate(13, focusIndex = options.length - 1);
        } else {
          if (focusIndex > 0)
            $$invalidate(13, focusIndex--, focusIndex);
        }
      }
      if (options[focusIndex])
        options[focusIndex].focus();
    }
    if (key === " " || key === "Enter") {
      handleClick({
        fromKeyboard: true,
        id: target.getAttribute("data-id")
      });
    }
  };
  const mouseenter_handler_1 = () => {
    if (subOptions) {
      $$invalidate(12, timeoutHover = setTimeout(
        () => {
          $$invalidate(9, submenuOpen = true);
        },
        moderate01
      ));
    }
  };
  const mouseleave_handler_1 = (e) => {
    if (subOptions) {
      if (typeof timeoutHover === "number")
        clearTimeout(timeoutHover);
      $$invalidate(9, submenuOpen = false);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props)
      $$invalidate(4, kind = $$new_props.kind);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("indented" in $$new_props)
      $$invalidate(2, indented = $$new_props.indented);
    if ("icon" in $$new_props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("labelText" in $$new_props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("selectable" in $$new_props)
      $$invalidate(20, selectable = $$new_props.selectable);
    if ("shortcutText" in $$new_props)
      $$invalidate(7, shortcutText = $$new_props.shortcutText);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    disabled,
    indented,
    icon,
    labelText,
    selected,
    selectable,
    shortcutText,
    id,
    ref,
    onMount,
    getContext,
    createEventDispatcher,
    tick,
    ContextMenu: ContextMenu_default,
    Checkmark: Checkmark_default,
    CaretRight: CaretRight_default,
    dispatch,
    ctx,
    ctxGroup,
    ctxRadioGroup,
    moderate01,
    unsubCurrentIds,
    unsubCurrentId,
    timeoutHover,
    rootMenuPosition,
    focusIndex,
    options,
    role,
    submenuOpen,
    submenuPosition,
    menuOffsetX,
    unsubPosition,
    unsubMenuOffsetX,
    handleClick,
    isRadio,
    isSelectable,
    subOptions
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props)
      $$invalidate(4, kind = $$new_props.kind);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("indented" in $$props)
      $$invalidate(2, indented = $$new_props.indented);
    if ("icon" in $$props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("labelText" in $$props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("selectable" in $$props)
      $$invalidate(20, selectable = $$new_props.selectable);
    if ("shortcutText" in $$props)
      $$invalidate(7, shortcutText = $$new_props.shortcutText);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("unsubCurrentIds" in $$props)
      unsubCurrentIds = $$new_props.unsubCurrentIds;
    if ("unsubCurrentId" in $$props)
      unsubCurrentId = $$new_props.unsubCurrentId;
    if ("timeoutHover" in $$props)
      $$invalidate(12, timeoutHover = $$new_props.timeoutHover);
    if ("rootMenuPosition" in $$props)
      $$invalidate(21, rootMenuPosition = $$new_props.rootMenuPosition);
    if ("focusIndex" in $$props)
      $$invalidate(13, focusIndex = $$new_props.focusIndex);
    if ("options" in $$props)
      $$invalidate(14, options = $$new_props.options);
    if ("role" in $$props)
      $$invalidate(15, role = $$new_props.role);
    if ("submenuOpen" in $$props)
      $$invalidate(9, submenuOpen = $$new_props.submenuOpen);
    if ("submenuPosition" in $$props)
      $$invalidate(16, submenuPosition = $$new_props.submenuPosition);
    if ("menuOffsetX" in $$props)
      $$invalidate(22, menuOffsetX = $$new_props.menuOffsetX);
    if ("isRadio" in $$props)
      $$invalidate(10, isRadio = $$new_props.isRadio);
    if ("isSelectable" in $$props)
      $$invalidate(11, isSelectable = $$new_props.isSelectable);
    if ("subOptions" in $$props)
      $$invalidate(17, subOptions = $$new_props.subOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1048576) {
      $:
        $$invalidate(11, isSelectable = !!ctxGroup || selectable);
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        ctx.setPopup(submenuOpen);
    }
    if ($$self.$$.dirty[0] & 6291970) {
      $:
        if (submenuOpen) {
          const { width, y } = ref.getBoundingClientRect();
          let x = rootMenuPosition[0] + width;
          if (window.innerWidth - menuOffsetX < width) {
            x = rootMenuPosition[0] - width;
          }
          $$invalidate(16, submenuPosition = [x, y]);
        }
    }
    if ($$self.$$.dirty[0] & 3329) {
      $: {
        if (isSelectable) {
          $$invalidate(2, indented = true);
          $$invalidate(15, role = "menuitemcheckbox");
          if (selected) {
            if (ctxGroup)
              ctxGroup.addOption({ id });
            $$invalidate(3, icon = Checkmark_default);
          } else {
            $$invalidate(3, icon = void 0);
          }
        }
        if (isRadio) {
          $$invalidate(2, indented = true);
          $$invalidate(15, role = "menuitemradio");
          ctxRadioGroup.addOption({ id });
          if (selected) {
            if (ctxRadioGroup)
              ctxRadioGroup.setOption({ id });
            $$invalidate(3, icon = Checkmark_default);
          } else {
            $$invalidate(3, icon = void 0);
          }
        }
      }
    }
  };
  $:
    $$invalidate(10, isRadio = !!ctxRadioGroup);
  $:
    $$invalidate(17, subOptions = $$slots.default);
  return [
    selected,
    ref,
    indented,
    icon,
    kind,
    disabled,
    labelText,
    shortcutText,
    id,
    submenuOpen,
    isRadio,
    isSelectable,
    timeoutHover,
    focusIndex,
    options,
    role,
    submenuPosition,
    subOptions,
    handleClick,
    $$restProps,
    selectable,
    rootMenuPosition,
    menuOffsetX,
    slots,
    keydown_handler,
    mouseenter_handler,
    mouseleave_handler,
    li_binding,
    keydown_handler_12,
    mouseenter_handler_1,
    mouseleave_handler_1,
    $$scope
  ];
}
var ContextMenuOption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        kind: 4,
        disabled: 5,
        indented: 2,
        icon: 3,
        labelText: 6,
        selected: 0,
        selectable: 20,
        shortcutText: 7,
        id: 8,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuOption",
      options,
      id: create_fragment25.name
    });
  }
  get kind() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indented() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indented(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shortcutText() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shortcutText(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ContextMenuOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ContextMenuOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuOption_default = ContextMenuOption;

// node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte
var file25 = "node_modules/carbon-components-svelte/src/ContextMenu/ContextMenuRadioGroup.svelte";
function create_fragment26(ctx) {
  let li;
  let ul;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      li = element("li");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr_dev(ul, "role", "group");
      attr_dev(ul, "aria-label", ctx[0]);
      add_location(ul, file25, 30, 2, 616);
      attr_dev(li, "role", "none");
      add_location(li, file25, 29, 0, 597);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr_dev(ul, "aria-label", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let $radioIds;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextMenuRadioGroup", slots, ["default"]);
  let { selectedId = "" } = $$props;
  let { labelText = "" } = $$props;
  const currentId = writable("");
  const radioIds = writable([]);
  validate_store(radioIds, "radioIds");
  component_subscribe($$self, radioIds, (value) => $$invalidate(5, $radioIds = value));
  setContext("ContextMenuRadioGroup", {
    currentId,
    radioIds,
    addOption: ({ id }) => {
      if (!$radioIds.includes(id)) {
        radioIds.update((_) => [..._, id]);
      }
    },
    setOption: ({ id }) => {
      $$invalidate(2, selectedId = id);
    }
  });
  const writable_props = ["selectedId", "labelText"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextMenuRadioGroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selectedId" in $$props2)
      $$invalidate(2, selectedId = $$props2.selectedId);
    if ("labelText" in $$props2)
      $$invalidate(0, labelText = $$props2.labelText);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectedId,
    labelText,
    setContext,
    writable,
    currentId,
    radioIds,
    $radioIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectedId" in $$props2)
      $$invalidate(2, selectedId = $$props2.selectedId);
    if ("labelText" in $$props2)
      $$invalidate(0, labelText = $$props2.labelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        currentId.set(selectedId);
    }
  };
  return [labelText, radioIds, selectedId, $$scope, slots];
}
var ContextMenuRadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { selectedId: 2, labelText: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextMenuRadioGroup",
      options,
      id: create_fragment26.name
    });
  }
  get selectedId() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ContextMenuRadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextMenuRadioGroup_default = ContextMenuRadioGroup;

// node_modules/carbon-components-svelte/src/icons/Copy.svelte
var file26 = "node_modules/carbon-components-svelte/src/icons/Copy.svelte";
function create_if_block14(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file26, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block14(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z");
      add_location(path0, file26, 24, 2, 579);
      attr_dev(path1, "d", "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z");
      add_location(path1, file26, 26, 10, 695);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file26, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Copy", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Copy = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Copy",
      options,
      id: create_fragment27.name
    });
  }
  get size() {
    throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Copy_default = Copy;

// node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte
var { console: console_1 } = globals;
var file27 = "node_modules/carbon-components-svelte/src/CopyButton/CopyButton.svelte";
function create_fragment28(ctx) {
  let button;
  let copy_1;
  let t0;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  copy_1 = new Copy_default({
    props: { class: "bx--snippet__icon" },
    $$inline: true
  });
  let button_levels = [
    { type: "button" },
    { "aria-live": "polite" },
    { "aria-label": ctx[2] },
    { title: ctx[2] },
    ctx[8]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      create_component(copy_1.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(ctx[0]);
      attr_dev(span, "aria-hidden", "true");
      toggle_class(span, "bx--assistive-text", true);
      toggle_class(span, "bx--copy-btn__feedback", true);
      add_location(span, file27, 74, 2, 1828);
      set_attributes(button, button_data);
      toggle_class(button, "bx--copy-btn", true);
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--copy-btn--animating", ctx[5]);
      toggle_class(button, "bx--copy-btn--fade-in", ctx[5] === "fade-in");
      toggle_class(button, "bx--copy-btn--fade-out", ctx[5] === "fade-out");
      add_location(button, file27, 42, 0, 1020);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      mount_component(copy_1, button, null);
      append_dev(button, t0);
      append_dev(button, span);
      append_dev(span, t1);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[9], false, false, false),
          listen_dev(button, "click", ctx[11], false, false, false),
          listen_dev(button, "animationend", ctx[10], false, false, false),
          listen_dev(button, "animationend", ctx[12], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data_dev(t1, ctx2[0]);
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-live": "polite" },
        (!current || dirty & 4) && { "aria-label": ctx2[2] },
        (!current || dirty & 4) && { title: ctx2[2] },
        dirty & 256 && ctx2[8]
      ]));
      toggle_class(button, "bx--copy-btn", true);
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--copy-btn--animating", ctx2[5]);
      toggle_class(button, "bx--copy-btn--fade-in", ctx2[5] === "fade-in");
      toggle_class(button, "bx--copy-btn--fade-out", ctx2[5] === "fade-out");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copy_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copy_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(copy_1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["feedback", "feedbackTimeout", "iconDescription", "text", "copy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyButton", slots, []);
  let { feedback = "Copied!" } = $$props;
  let { feedbackTimeout = 2e3 } = $$props;
  let { iconDescription = "Copy to clipboard" } = $$props;
  let { text: text2 } = $$props;
  let { copy = async (text3) => {
    try {
      await navigator.clipboard.writeText(text3);
    } catch (e) {
      console.log(e);
    }
  } } = $$props;
  const dispatch = createEventDispatcher();
  let animation = void 0;
  let timeout = void 0;
  onMount(() => {
    return () => clearTimeout(timeout);
  });
  $$self.$$.on_mount.push(function() {
    if (text2 === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console_1.warn("<CopyButton> was created without expected prop 'text'");
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    if (text2 !== void 0) {
      copy(text2);
      dispatch("copy");
    }
    if (animation === "fade-in")
      return;
    $$invalidate(5, animation = "fade-in");
    $$invalidate(6, timeout = setTimeout(
      () => {
        $$invalidate(5, animation = "fade-out");
      },
      feedbackTimeout
    ));
  };
  const animationend_handler_1 = ({ animationName }) => {
    if (animationName === "hide-feedback") {
      $$invalidate(5, animation = void 0);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("feedback" in $$new_props)
      $$invalidate(0, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$new_props)
      $$invalidate(1, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("iconDescription" in $$new_props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("text" in $$new_props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("copy" in $$new_props)
      $$invalidate(4, copy = $$new_props.copy);
  };
  $$self.$capture_state = () => ({
    feedback,
    feedbackTimeout,
    iconDescription,
    text: text2,
    copy,
    createEventDispatcher,
    onMount,
    Copy: Copy_default,
    dispatch,
    animation,
    timeout
  });
  $$self.$inject_state = ($$new_props) => {
    if ("feedback" in $$props)
      $$invalidate(0, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$props)
      $$invalidate(1, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("iconDescription" in $$props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("text" in $$props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("copy" in $$props)
      $$invalidate(4, copy = $$new_props.copy);
    if ("animation" in $$props)
      $$invalidate(5, animation = $$new_props.animation);
    if ("timeout" in $$props)
      $$invalidate(6, timeout = $$new_props.timeout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    feedback,
    feedbackTimeout,
    iconDescription,
    text2,
    copy,
    animation,
    timeout,
    dispatch,
    $$restProps,
    click_handler,
    animationend_handler,
    click_handler_13,
    animationend_handler_1
  ];
}
var CopyButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      feedback: 0,
      feedbackTimeout: 1,
      iconDescription: 2,
      text: 3,
      copy: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyButton",
      options,
      id: create_fragment28.name
    });
  }
  get feedback() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedbackTimeout() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedbackTimeout(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error("<CopyButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error("<CopyButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyButton_default = CopyButton;

// node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte
var file28 = "node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte";
function create_if_block15(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file28, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block15(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M16,2C8.3,2,2,8.3,2,16s6.3,14,14,14s14-6.3,14-14C30,8.3,23.7,2,16,2z M14.9,8h2.2v11h-2.2V8z M16,25	c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22c0.8,0,1.5,0.7,1.5,1.5S16.8,25,16,25z");
      add_location(path0, file28, 24, 2, 579);
      attr_dev(path1, "fill", "none");
      attr_dev(path1, "d", "M17.5,23.5c0,0.8-0.7,1.5-1.5,1.5c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22	C16.8,22,17.5,22.7,17.5,23.5z M17.1,8h-2.2v11h2.2V8z");
      attr_dev(path1, "data-icon-path", "inner-path");
      attr_dev(path1, "opacity", "0");
      add_location(path1, file28, 26, 10, 777);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file28, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningFilled",
      options,
      id: create_fragment29.name
    });
  }
  get size() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningFilled_default = WarningFilled;

// node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte
var file29 = "node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte";
function create_if_block16(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file29, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let if_block = ctx[1] && create_if_block16(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file29, 24, 2, 579);
      attr_dev(path1, "d", "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z");
      add_location(path1, file29, 27, 39, 722);
      attr_dev(path2, "d", "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z");
      add_location(path2, file29, 29, 10, 886);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file29, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
      append_dev(svg, path2);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningAltFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningAltFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningAltFilled",
      options,
      id: create_fragment30.name
    });
  }
  get size() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningAltFilled_default = WarningAltFilled;

// node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte
var file30 = "node_modules/carbon-components-svelte/src/ListBox/ListBox.svelte";
function create_if_block_14(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[6]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file30, 59, 2, 1374);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(59:0) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[8]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file30, 62, 2, 1466);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256)
        set_data_dev(t, ctx2[8]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(62:0) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let div;
  let div_data_invalid_value;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let div_levels = [
    { role: "listbox" },
    { tabindex: "-1" },
    {
      "data-invalid": div_data_invalid_value = ctx[5] || void 0
    },
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block0 = ctx[5] && create_if_block_14(ctx);
  let if_block1 = !ctx[5] && ctx[7] && create_if_block17(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box", true);
      toggle_class(div, "bx--list-box--sm", ctx[0] === "sm");
      toggle_class(div, "bx--list-box--xl", ctx[0] === "xl");
      toggle_class(div, "bx--list-box--inline", ctx[1] === "inline");
      toggle_class(div, "bx--list-box--disabled", ctx[4]);
      toggle_class(div, "bx--list-box--expanded", ctx[2]);
      toggle_class(div, "bx--list-box--light", ctx[3]);
      toggle_class(div, "bx--list-box--warning", !ctx[5] && ctx[7]);
      add_location(div, file30, 35, 0, 769);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "keydown", ctx[12], false, false, false),
          listen_dev(div, "keydown", keydown_handler_1, false, false, false),
          listen_dev(div, "click", prevent_default(ctx[13]), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "listbox" },
        { tabindex: "-1" },
        (!current || dirty & 32 && div_data_invalid_value !== (div_data_invalid_value = ctx2[5] || void 0)) && { "data-invalid": div_data_invalid_value },
        dirty & 512 && ctx2[9]
      ]));
      toggle_class(div, "bx--list-box", true);
      toggle_class(div, "bx--list-box--sm", ctx2[0] === "sm");
      toggle_class(div, "bx--list-box--xl", ctx2[0] === "xl");
      toggle_class(div, "bx--list-box--inline", ctx2[1] === "inline");
      toggle_class(div, "bx--list-box--disabled", ctx2[4]);
      toggle_class(div, "bx--list-box--expanded", ctx2[2]);
      toggle_class(div, "bx--list-box--light", ctx2[3]);
      toggle_class(div, "bx--list-box--warning", !ctx2[5] && ctx2[7]);
      if (ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[5] && ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var keydown_handler_1 = (e) => {
  if (e.key === "Escape") {
    e.stopPropagation();
  }
};
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "type",
    "open",
    "light",
    "disabled",
    "invalid",
    "invalidText",
    "warn",
    "warnText"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("open" in $$new_props)
      $$invalidate(2, open = $$new_props.open);
    if ("light" in $$new_props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("invalid" in $$new_props)
      $$invalidate(5, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(6, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(7, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(8, warnText = $$new_props.warnText);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    type,
    open,
    light,
    disabled,
    invalid,
    invalidText,
    warn,
    warnText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
    if ("open" in $$props)
      $$invalidate(2, open = $$new_props.open);
    if ("light" in $$props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("invalid" in $$props)
      $$invalidate(5, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(6, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(7, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(8, warnText = $$new_props.warnText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    type,
    open,
    light,
    disabled,
    invalid,
    invalidText,
    warn,
    warnText,
    $$restProps,
    $$scope,
    slots,
    keydown_handler,
    click_handler
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      size: 0,
      type: 1,
      open: 2,
      light: 3,
      disabled: 4,
      invalid: 5,
      invalidText: 6,
      warn: 7,
      warnText: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment31.name
    });
  }
  get size() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte
var file31 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxField.svelte";
function create_fragment32(ctx) {
  let div;
  let div_aria_owns_value;
  let div_aria_controls_value;
  let div_aria_label_value;
  let div_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let div_levels = [
    { role: ctx[2] },
    { "aria-expanded": ctx[6] },
    {
      "aria-owns": div_aria_owns_value = ctx[6] && ctx[5] || void 0
    },
    {
      "aria-controls": div_aria_controls_value = ctx[6] && ctx[5] || void 0
    },
    { "aria-disabled": ctx[1] },
    {
      "aria-label": div_aria_label_value = ctx[6] ? ctx[4]("close") : ctx[4]("open")
    },
    {
      tabindex: div_tabindex_value = ctx[1] ? "-1" : ctx[3]
    },
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__field", true);
      add_location(div, file31, 46, 0, 1167);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[19](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[12], false, false, false),
          listen_dev(div, "mouseover", ctx[13], false, false, false),
          listen_dev(div, "mouseenter", ctx[14], false, false, false),
          listen_dev(div, "mouseleave", ctx[15], false, false, false),
          listen_dev(div, "keydown", stop_propagation(ctx[16]), false, false, true),
          listen_dev(div, "focus", ctx[17], false, false, false),
          listen_dev(div, "blur", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 4) && { role: ctx2[2] },
        (!current || dirty & 64) && { "aria-expanded": ctx2[6] },
        (!current || dirty & 96 && div_aria_owns_value !== (div_aria_owns_value = ctx2[6] && ctx2[5] || void 0)) && { "aria-owns": div_aria_owns_value },
        (!current || dirty & 96 && div_aria_controls_value !== (div_aria_controls_value = ctx2[6] && ctx2[5] || void 0)) && { "aria-controls": div_aria_controls_value },
        (!current || dirty & 2) && { "aria-disabled": ctx2[1] },
        (!current || dirty & 80 && div_aria_label_value !== (div_aria_label_value = ctx2[6] ? ctx2[4]("close") : ctx2[4]("open"))) && { "aria-label": div_aria_label_value },
        (!current || dirty & 10 && div_tabindex_value !== (div_tabindex_value = ctx2[1] ? "-1" : ctx2[3])) && { tabindex: div_tabindex_value },
        dirty & 128 && ctx2[7]
      ]));
      toggle_class(div, "bx--list-box__field", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let ariaExpanded;
  let menuId;
  const omit_props_names = ["disabled", "role", "tabindex", "translationIds", "translateWithId", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxField", slots, ["default"]);
  let { disabled = false } = $$props;
  let { role = "combobox" } = $$props;
  let { tabindex = "-1" } = $$props;
  const translationIds = { close: "close", open: "open" };
  let { translateWithId = (id2) => defaultTranslations[id2] } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  const ctx = getContext("MultiSelect");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("role" in $$new_props)
      $$invalidate(2, role = $$new_props.role);
    if ("tabindex" in $$new_props)
      $$invalidate(3, tabindex = $$new_props.tabindex);
    if ("translateWithId" in $$new_props)
      $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props)
      $$invalidate(9, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    disabled,
    role,
    tabindex,
    translationIds,
    translateWithId,
    id,
    ref,
    getContext,
    defaultTranslations,
    ctx,
    menuId,
    ariaExpanded
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("role" in $$props)
      $$invalidate(2, role = $$new_props.role);
    if ("tabindex" in $$props)
      $$invalidate(3, tabindex = $$new_props.tabindex);
    if ("translateWithId" in $$props)
      $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props)
      $$invalidate(9, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("menuId" in $$props)
      $$invalidate(5, menuId = $$new_props.menuId);
    if ("ariaExpanded" in $$props)
      $$invalidate(6, ariaExpanded = $$new_props.ariaExpanded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        if (ctx && ref) {
          ctx.declareRef({ key: "field", ref });
        }
    }
    $:
      $$invalidate(6, ariaExpanded = $$props["aria-expanded"]);
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(5, menuId = `menu-${id}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    ref,
    disabled,
    role,
    tabindex,
    translateWithId,
    menuId,
    ariaExpanded,
    $$restProps,
    translationIds,
    id,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    focus_handler,
    blur_handler,
    div_binding
  ];
}
var ListBoxField = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      disabled: 1,
      role: 2,
      tabindex: 3,
      translationIds: 8,
      translateWithId: 4,
      id: 9,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxField",
      options,
      id: create_fragment32.name
    });
  }
  get disabled() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[8];
  }
  set translationIds(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxField_default = ListBoxField;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte
var file32 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenu.svelte";
function create_fragment33(ctx) {
  let div;
  let div_id_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [
    { role: "listbox" },
    {
      id: div_id_value = "menu-" + ctx[1]
    },
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__menu", true);
      add_location(div, file32, 8, 0, 194);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[6](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "scroll", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "listbox" },
        (!current || dirty & 2 && div_id_value !== (div_id_value = "menu-" + ctx2[1])) && { id: div_id_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(div, "bx--list-box__menu", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenu", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  function scroll_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ id, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, id, $$restProps, $$scope, slots, scroll_handler, div_binding];
}
var ListBoxMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { id: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenu",
      options,
      id: create_fragment33.name
    });
  }
  get id() {
    throw new Error("<ListBoxMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenu_default = ListBoxMenu;

// node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte
var file33 = "node_modules/carbon-components-svelte/src/icons/ChevronDown.svelte";
function create_if_block18(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file33, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block18(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z");
      add_location(path, file33, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file33, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronDown", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ChevronDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronDown",
      options,
      id: create_fragment34.name
    });
  }
  get size() {
    throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronDown_default = ChevronDown;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte
var file34 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuIcon.svelte";
function create_fragment35(ctx) {
  let div;
  let chevrondown;
  let current;
  let mounted;
  let dispose;
  chevrondown = new ChevronDown_default({
    props: {
      "aria-label": ctx[1],
      title: ctx[1]
    },
    $$inline: true
  });
  let div_levels = [ctx[2]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(chevrondown.$$.fragment);
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__menu-icon", true);
      toggle_class(div, "bx--list-box__menu-icon--open", ctx[0]);
      add_location(div, file34, 29, 0, 799);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(chevrondown, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", prevent_default(ctx[6]), false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const chevrondown_changes = {};
      if (dirty & 2)
        chevrondown_changes["aria-label"] = ctx2[1];
      if (dirty & 2)
        chevrondown_changes.title = ctx2[1];
      chevrondown.$set(chevrondown_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(div, "bx--list-box__menu-icon", true);
      toggle_class(div, "bx--list-box__menu-icon--open", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(chevrondown);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let translationId;
  let description;
  const omit_props_names = ["open", "translationIds", "translateWithId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenuIcon", slots, []);
  let { open = false } = $$props;
  const translationIds = { close: "close", open: "open" };
  let { translateWithId = (id) => defaultTranslations[id] } = $$props;
  const defaultTranslations = {
    [translationIds.close]: "Close menu",
    [translationIds.open]: "Open menu"
  };
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("translateWithId" in $$new_props)
      $$invalidate(4, translateWithId = $$new_props.translateWithId);
  };
  $$self.$capture_state = () => ({
    open,
    translationIds,
    translateWithId,
    ChevronDown: ChevronDown_default,
    defaultTranslations,
    translationId,
    description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("translateWithId" in $$props)
      $$invalidate(4, translateWithId = $$new_props.translateWithId);
    if ("translationId" in $$props)
      $$invalidate(5, translationId = $$new_props.translationId);
    if ("description" in $$props)
      $$invalidate(1, description = $$new_props.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(5, translationId = open ? translationIds.close : translationIds.open);
    }
    if ($$self.$$.dirty & 48) {
      $:
        $$invalidate(1, description = (_a = translateWithId == null ? void 0 : translateWithId(translationId)) != null ? _a : defaultTranslations[translationId]);
    }
  };
  return [
    open,
    description,
    $$restProps,
    translationIds,
    translateWithId,
    translationId,
    click_handler
  ];
}
var ListBoxMenuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      open: 0,
      translationIds: 3,
      translateWithId: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenuIcon",
      options,
      id: create_fragment35.name
    });
  }
  get open() {
    throw new Error("<ListBoxMenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[3];
  }
  set translationIds(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxMenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxMenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenuIcon_default = ListBoxMenuIcon;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte
var file35 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxMenuItem.svelte";
function create_fragment36(ctx) {
  let div1;
  let div0;
  let div1_disabled_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let div1_levels = [
    { role: "option" },
    { "aria-selected": ctx[0] },
    {
      disabled: div1_disabled_value = ctx[2] ? true : void 0
    },
    ctx[5]
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "title", ctx[4]);
      toggle_class(div0, "bx--list-box__menu-item__option", true);
      add_location(div0, file35, 32, 2, 897);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--list-box__menu-item", true);
      toggle_class(div1, "bx--list-box__menu-item--active", ctx[0]);
      toggle_class(div1, "bx--list-box__menu-item--highlighted", ctx[1] || ctx[0]);
      add_location(div1, file35, 20, 0, 577);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[12](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[9], false, false, false),
          listen_dev(div1, "mouseenter", ctx[10], false, false, false),
          listen_dev(div1, "mouseleave", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 16) {
        attr_dev(div0, "title", ctx2[4]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        { role: "option" },
        (!current || dirty & 1) && { "aria-selected": ctx2[0] },
        (!current || dirty & 4 && div1_disabled_value !== (div1_disabled_value = ctx2[2] ? true : void 0)) && { disabled: div1_disabled_value },
        dirty & 32 && ctx2[5]
      ]));
      toggle_class(div1, "bx--list-box__menu-item", true);
      toggle_class(div1, "bx--list-box__menu-item--active", ctx2[0]);
      toggle_class(div1, "bx--list-box__menu-item--highlighted", ctx2[1] || ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let isTruncated;
  let title;
  const omit_props_names = ["active", "highlighted", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxMenuItem", slots, ["default"]);
  let { active = false } = $$props;
  let { highlighted = false } = $$props;
  let { disabled = false } = $$props;
  let ref = null;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("highlighted" in $$new_props)
      $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    active,
    highlighted,
    disabled,
    ref,
    isTruncated,
    title
  });
  $$self.$inject_state = ($$new_props) => {
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("highlighted" in $$props)
      $$invalidate(1, highlighted = $$new_props.highlighted);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("ref" in $$props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("isTruncated" in $$props)
      $$invalidate(6, isTruncated = $$new_props.isTruncated);
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(6, isTruncated = (ref == null ? void 0 : ref.offsetWidth) < (ref == null ? void 0 : ref.scrollWidth));
    }
    if ($$self.$$.dirty & 72) {
      $:
        $$invalidate(4, title = isTruncated ? ref == null ? void 0 : ref.innerText : void 0);
    }
    if ($$self.$$.dirty & 10) {
      $:
        if (highlighted && ref && !ref.matches(":hover")) {
          ref.scrollIntoView({ block: "nearest" });
        }
    }
  };
  return [
    active,
    highlighted,
    disabled,
    ref,
    title,
    $$restProps,
    isTruncated,
    $$scope,
    slots,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding
  ];
}
var ListBoxMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { active: 0, highlighted: 1, disabled: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxMenuItem",
      options,
      id: create_fragment36.name
    });
  }
  get active() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlighted() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlighted(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBoxMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxMenuItem_default = ListBoxMenuItem;

// node_modules/carbon-components-svelte/src/icons/Close.svelte
var file36 = "node_modules/carbon-components-svelte/src/icons/Close.svelte";
function create_if_block19(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file36, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block19(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
      add_location(path, file36, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file36, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Close", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Close = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Close",
      options,
      id: create_fragment37.name
    });
  }
  get size() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Close_default = Close;

// node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte
var file37 = "node_modules/carbon-components-svelte/src/ListBox/ListBoxSelection.svelte";
function create_else_block10(ctx) {
  let div;
  let t;
  let close;
  let div_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] !== void 0 && create_if_block_15(ctx);
  close = new Close_default({ $$inline: true });
  let div_levels = [
    { role: "button" },
    { "aria-label": ctx[4] },
    { title: ctx[4] },
    {
      tabindex: div_tabindex_value = ctx[2] ? "-1" : "0"
    },
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(close.$$.fragment);
      set_attributes(div, div_data);
      toggle_class(div, "bx--list-box__selection", true);
      toggle_class(div, "bx--tag--filter", ctx[1]);
      toggle_class(div, "bx--list-box__selection--multi", ctx[1]);
      add_location(div, file37, 84, 2, 2189);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      mount_component(close, div, null);
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", stop_propagation(prevent_default(ctx[13])), false, true, true),
          listen_dev(div, "keydown", stop_propagation(ctx[14]), false, false, true)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1] !== void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "button" },
        (!current || dirty & 16) && { "aria-label": ctx2[4] },
        (!current || dirty & 16) && { title: ctx2[4] },
        (!current || dirty & 4 && div_tabindex_value !== (div_tabindex_value = ctx2[2] ? "-1" : "0")) && { tabindex: div_tabindex_value },
        dirty & 64 && ctx2[6]
      ]));
      toggle_class(div, "bx--list-box__selection", true);
      toggle_class(div, "bx--tag--filter", ctx2[1]);
      toggle_class(div, "bx--list-box__selection--multi", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      destroy_component(close);
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(84:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block20(ctx) {
  let div1;
  let span;
  let t0;
  let t1;
  let div0;
  let close;
  let div0_tabindex_value;
  let div0_aria_label_value;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({ $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t0 = text(ctx[1]);
      t1 = space();
      div0 = element("div");
      create_component(close.$$.fragment);
      attr_dev(span, "title", ctx[1]);
      toggle_class(span, "bx--tag__label", true);
      add_location(span, file37, 58, 4, 1532);
      attr_dev(div0, "role", "button");
      attr_dev(div0, "tabindex", div0_tabindex_value = ctx[2] ? -1 : 0);
      attr_dev(div0, "disabled", ctx[2]);
      attr_dev(div0, "aria-label", div0_aria_label_value = ctx[3].clearAll);
      attr_dev(div0, "title", ctx[4]);
      toggle_class(div0, "bx--tag__close-icon", true);
      add_location(div0, file37, 61, 4, 1633);
      toggle_class(div1, "bx--tag", true);
      toggle_class(div1, "bx--tag--filter", true);
      toggle_class(div1, "bx--tag--high-contrast", true);
      toggle_class(div1, "bx--tag--disabled", ctx[2]);
      add_location(div1, file37, 52, 2, 1374);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, span);
      append_dev(span, t0);
      append_dev(div1, t1);
      append_dev(div1, div0);
      mount_component(close, div0, null);
      ctx[9](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", stop_propagation(prevent_default(ctx[10])), false, true, true),
          listen_dev(div0, "keydown", stop_propagation(ctx[11]), false, false, true)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data_dev(t0, ctx2[1]);
      if (!current || dirty & 2) {
        attr_dev(span, "title", ctx2[1]);
      }
      if (!current || dirty & 4 && div0_tabindex_value !== (div0_tabindex_value = ctx2[2] ? -1 : 0)) {
        attr_dev(div0, "tabindex", div0_tabindex_value);
      }
      if (!current || dirty & 4) {
        attr_dev(div0, "disabled", ctx2[2]);
      }
      if (!current || dirty & 16) {
        attr_dev(div0, "title", ctx2[4]);
      }
      if (!current || dirty & 4) {
        toggle_class(div1, "bx--tag--disabled", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(close);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(52:0) {#if selectionCount !== undefined}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(106:4) {#if selectionCount !== undefined}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block20, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] !== void 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let translationId;
  let description;
  const omit_props_names = ["selectionCount", "disabled", "translationIds", "translateWithId", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxSelection", slots, []);
  let { selectionCount = void 0 } = $$props;
  let { disabled = false } = $$props;
  const translationIds = {
    clearAll: "clearAll",
    clearSelection: "clearSelection"
  };
  let { translateWithId = (id) => defaultTranslations[id] } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.clearAll]: "Clear all selected items",
    [translationIds.clearSelection]: "Clear selected item"
  };
  const dispatch = createEventDispatcher();
  const ctx = getContext("MultiSelect");
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler = (e) => {
    if (!disabled) {
      dispatch("clear", e);
    }
  };
  const keydown_handler = (e) => {
    if (!disabled && e.key === "Enter") {
      dispatch("clear", e);
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_13 = (e) => {
    if (!disabled) {
      dispatch("clear", e);
    }
  };
  const keydown_handler_12 = (e) => {
    if (!disabled && e.key === "Enter") {
      dispatch("clear", e);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selectionCount" in $$new_props)
      $$invalidate(1, selectionCount = $$new_props.selectionCount);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("translateWithId" in $$new_props)
      $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    selectionCount,
    disabled,
    translationIds,
    translateWithId,
    ref,
    createEventDispatcher,
    getContext,
    Close: Close_default,
    defaultTranslations,
    dispatch,
    ctx,
    translationId,
    description
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selectionCount" in $$props)
      $$invalidate(1, selectionCount = $$new_props.selectionCount);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("translateWithId" in $$props)
      $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("translationId" in $$props)
      $$invalidate(8, translationId = $$new_props.translationId);
    if ("description" in $$props)
      $$invalidate(4, description = $$new_props.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 1) {
      $:
        if (ctx && ref) {
          ctx.declareRef({ key: "selection", ref });
        }
    }
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(8, translationId = selectionCount ? translationIds.clearAll : translationIds.clearSelection);
    }
    if ($$self.$$.dirty & 384) {
      $:
        $$invalidate(4, description = (_a = translateWithId == null ? void 0 : translateWithId(translationId)) != null ? _a : defaultTranslations[translationId]);
    }
  };
  return [
    ref,
    selectionCount,
    disabled,
    translationIds,
    description,
    dispatch,
    $$restProps,
    translateWithId,
    translationId,
    div0_binding,
    click_handler,
    keydown_handler,
    div_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var ListBoxSelection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      selectionCount: 1,
      disabled: 2,
      translationIds: 3,
      translateWithId: 7,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxSelection",
      options,
      id: create_fragment38.name
    });
  }
  get selectionCount() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionCount(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[3];
  }
  set translationIds(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ListBoxSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ListBoxSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxSelection_default = ListBoxSelection;

// node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte
var file38 = "node_modules/carbon-components-svelte/src/ComboBox/ComboBox.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[56] = list[i];
  child_ctx[58] = i;
  return child_ctx;
}
var get_default_slot_changes4 = (dirty) => ({
  item: dirty[0] & 16777216,
  index: dirty[0] & 16777216
});
var get_default_slot_context4 = (ctx) => ({
  item: ctx[56],
  index: ctx[58]
});
function create_if_block_6(ctx) {
  let label;
  let t;
  const block = {
    c: function create() {
      label = element("label");
      t = text(ctx[9]);
      attr_dev(label, "for", ctx[19]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--label--disabled", ctx[8]);
      add_location(label, file38, 221, 4, 6115);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
      if (dirty[0] & 524288) {
        attr_dev(label, "for", ctx2[19]);
      }
      if (dirty[0] & 256) {
        toggle_class(label, "bx--label--disabled", ctx2[8]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(221:2) {#if titleText}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(347:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(350:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      translateWithId: ctx[18],
      disabled: ctx[8],
      open: ctx[2]
    },
    $$inline: true
  });
  listboxselection.$on("clear", ctx[46]);
  listboxselection.$on("clear", ctx[21]);
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[0] & 262144)
        listboxselection_changes.translateWithId = ctx2[18];
      if (dirty[0] & 256)
        listboxselection_changes.disabled = ctx2[8];
      if (dirty[0] & 4)
        listboxselection_changes.open = ctx2[2];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(355:6) {#if value}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let input;
  let input_aria_controls_value;
  let input_aria_owns_value;
  let t0;
  let t1;
  let t2;
  let t3;
  let listboxmenuicon;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { tabindex: "0" },
    { autocomplete: "off" },
    { "aria-autocomplete": "list" },
    { "aria-expanded": ctx[2] },
    {
      "aria-activedescendant": ctx[25]
    },
    { "aria-labelledby": ctx[26] },
    { "aria-disabled": ctx[8] },
    {
      "aria-controls": input_aria_controls_value = ctx[2] ? ctx[27] : void 0
    },
    {
      "aria-owns": input_aria_owns_value = ctx[2] ? ctx[27] : void 0
    },
    { disabled: ctx[8] },
    { placeholder: ctx[10] },
    { id: ctx[19] },
    { name: ctx[20] },
    ctx[30]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = ctx[13] && create_if_block_5(ctx);
  let if_block1 = !ctx[13] && ctx[14] && create_if_block_42(ctx);
  let if_block2 = ctx[1] && create_if_block_32(ctx);
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      translateWithId: ctx[17],
      open: ctx[2]
    },
    $$inline: true
  });
  listboxmenuicon.$on("click", ctx[47]);
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      create_component(listboxmenuicon.$$.fragment);
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx[16]);
      toggle_class(input, "bx--text-input--empty", ctx[1] === "");
      add_location(input, file38, 256, 6, 6928);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[41](input);
      set_input_value(input, ctx[1]);
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[42]),
          listen_dev(input, "input", ctx[43], false, false, false),
          listen_dev(input, "keydown", ctx[35], false, false, false),
          listen_dev(input, "keydown", stop_propagation(ctx[44]), false, false, true),
          listen_dev(input, "keyup", ctx[36], false, false, false),
          listen_dev(input, "focus", ctx[37], false, false, false),
          listen_dev(input, "blur", ctx[38], false, false, false),
          listen_dev(input, "blur", ctx[45], false, false, false),
          listen_dev(input, "paste", ctx[39], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { tabindex: "0" },
        { autocomplete: "off" },
        { "aria-autocomplete": "list" },
        (!current || dirty[0] & 4) && { "aria-expanded": ctx2[2] },
        (!current || dirty[0] & 33554432) && {
          "aria-activedescendant": ctx2[25]
        },
        (!current || dirty[0] & 67108864) && { "aria-labelledby": ctx2[26] },
        (!current || dirty[0] & 256) && { "aria-disabled": ctx2[8] },
        (!current || dirty[0] & 134217732 && input_aria_controls_value !== (input_aria_controls_value = ctx2[2] ? ctx2[27] : void 0)) && {
          "aria-controls": input_aria_controls_value
        },
        (!current || dirty[0] & 134217732 && input_aria_owns_value !== (input_aria_owns_value = ctx2[2] ? ctx2[27] : void 0)) && { "aria-owns": input_aria_owns_value },
        (!current || dirty[0] & 256) && { disabled: ctx2[8] },
        (!current || dirty[0] & 1024) && { placeholder: ctx2[10] },
        (!current || dirty[0] & 524288) && { id: ctx2[19] },
        (!current || dirty[0] & 1048576) && { name: ctx2[20] },
        dirty[0] & 1073741824 && ctx2[30]
      ]));
      if (dirty[0] & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx2[16]);
      toggle_class(input, "bx--text-input--empty", ctx2[1] === "");
      if (ctx2[13]) {
        if (if_block0) {
          if (dirty[0] & 8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[13] && ctx2[14]) {
        if (if_block1) {
          if (dirty[0] & 24576) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & 131072)
        listboxmenuicon_changes.translateWithId = ctx2[17];
      if (dirty[0] & 4)
        listboxmenuicon_changes.open = ctx2[2];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[41](null);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(listboxmenuicon, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(244:4) <ListBoxField       role=\\"button\\"       aria-expanded=\\"{open}\\"       on:click=\\"{async () => {         if (disabled) return;         open = true;         await tick();         ref.focus();       }}\\"       id=\\"{id}\\"       disabled=\\"{disabled}\\"       translateWithId=\\"{translateWithId}\\"     >',
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let listboxmenu;
  let updating_ref;
  let current;
  function listboxmenu_ref_binding(value) {
    ctx[51](value);
  }
  let listboxmenu_props = {
    "aria-label": ctx[28],
    id: ctx[19],
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[4] !== void 0) {
    listboxmenu_props.ref = ctx[4];
  }
  listboxmenu = new ListBoxMenu_default({ props: listboxmenu_props, $$inline: true });
  binding_callbacks.push(() => bind(listboxmenu, "ref", listboxmenu_ref_binding));
  listboxmenu.$on("scroll", ctx[52]);
  const block = {
    c: function create() {
      create_component(listboxmenu.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxmenu_changes = {};
      if (dirty[0] & 268435456)
        listboxmenu_changes["aria-label"] = ctx2[28];
      if (dirty[0] & 524288)
        listboxmenu_changes.id = ctx2[19];
      if (dirty[0] & 29360167 | dirty[1] & 4194304) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty[0] & 16) {
        updating_ref = true;
        listboxmenu_changes.ref = ctx2[4];
        add_flush_callback(() => updating_ref = false);
      }
      listboxmenu.$set(listboxmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(374:4) {#if open}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let t_value = ctx[5](ctx[56]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16777248 && t_value !== (t_value = ctx2[5](ctx2[56]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(404:44)                ",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let checkmark;
  let current;
  checkmark = new Checkmark_default({
    props: {
      class: "bx--list-box__menu-item__selected-icon"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmark.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkmark, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(407:12) {#if selectedItem && selectedItem.id === item.id}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t0;
  let t1;
  let current;
  const default_slot_template = ctx[34].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[53], get_default_slot_context4);
  const default_slot_or_fallback = default_slot || fallback_block6(ctx);
  let if_block = ctx[22] && ctx[22].id === ctx[56].id && create_if_block_24(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 16777216 | dirty[1] & 4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[53],
            !current ? get_all_dirty_from_scope(ctx2[53]) : get_slot_changes(default_slot_template, ctx2[53], dirty, get_default_slot_changes4),
            get_default_slot_context4
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16777248)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (ctx2[22] && ctx2[22].id === ctx2[56].id) {
        if (if_block) {
          if (dirty[0] & 20971520) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(382:10) <ListBoxMenuItem             id=\\"{item.id}\\"             active=\\"{selectedId === item.id}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               selectedId = item.id;               open = false;                if (filteredItems[i]) {                 value = itemToString(filteredItems[i]);               }             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block4(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_3(...args) {
    return ctx[49](ctx[56], ctx[58], ...args);
  }
  function mouseenter_handler() {
    return ctx[50](ctx[56], ctx[58]);
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: ctx[56].id,
      active: ctx[0] === ctx[56].id,
      highlighted: ctx[23] === ctx[58],
      disabled: ctx[56].disabled,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_3);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & 16777216)
        listboxmenuitem_changes.id = ctx[56].id;
      if (dirty[0] & 16777217)
        listboxmenuitem_changes.active = ctx[0] === ctx[56].id;
      if (dirty[0] & 25165824)
        listboxmenuitem_changes.highlighted = ctx[23] === ctx[58];
      if (dirty[0] & 16777216)
        listboxmenuitem_changes.disabled = ctx[56].disabled;
      if (dirty[0] & 20971552 | dirty[1] & 4194304) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(381:8) {#each filteredItems as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[24];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[56].id;
  validate_each_keys(ctx, each_value, get_each_context4, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 29360167 | dirty[1] & 4194304) {
        each_value = ctx2[24];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context4, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block4, each_1_anchor, get_each_context4);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(375:6) <ListBoxMenu         aria-label=\\"{ariaLabel}\\"         id=\\"{id}\\"         on:scroll         bind:ref=\\"{listRef}\\"       >',
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let listboxfield;
  let t;
  let if_block_anchor;
  let current;
  listboxfield = new ListBoxField_default({
    props: {
      role: "button",
      "aria-expanded": ctx[2],
      id: ctx[19],
      disabled: ctx[8],
      translateWithId: ctx[17],
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxfield.$on("click", ctx[48]);
  let if_block = ctx[2] && create_if_block_16(ctx);
  const block = {
    c: function create() {
      create_component(listboxfield.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(listboxfield, target, anchor);
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxfield_changes = {};
      if (dirty[0] & 4)
        listboxfield_changes["aria-expanded"] = ctx2[2];
      if (dirty[0] & 524288)
        listboxfield_changes.id = ctx2[19];
      if (dirty[0] & 256)
        listboxfield_changes.disabled = ctx2[8];
      if (dirty[0] & 131072)
        listboxfield_changes.translateWithId = ctx2[17];
      if (dirty[0] & 1340040495 | dirty[1] & 4194304) {
        listboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxfield.$set(listboxfield_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxfield.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxfield.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxfield, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: `(230:2) <ListBox     class=\\"bx--combo-box {direction === 'top' &&       'bx--list-box--up'} {!invalid && warn && 'bx--combo-box--warning'}\\"     id=\\"{comboId}\\"     aria-label=\\"{ariaLabel}\\"     disabled=\\"{disabled}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     open=\\"{open}\\"     light=\\"{light}\\"     size=\\"{size}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[8]);
      add_location(div, file38, 415, 4, 11908);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
      if (dirty[0] & 256) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[8]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(415:2) {#if !invalid && helperText && !warn}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[9] && create_if_block_6(ctx);
  listbox = new ListBox_default({
    props: {
      class: "bx--combo-box " + (ctx[6] === "top" && "bx--list-box--up") + " " + (!ctx[13] && ctx[14] && "bx--combo-box--warning"),
      id: ctx[26],
      "aria-label": ctx[28],
      disabled: ctx[8],
      invalid: ctx[13],
      invalidText: ctx[12],
      open: ctx[2],
      light: ctx[16],
      size: ctx[7],
      warn: ctx[14],
      warnText: ctx[15],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = !ctx[13] && ctx[11] && !ctx[14] && create_if_block21(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div, "bx--list-box__wrapper", true);
      add_location(div, file38, 219, 0, 6050);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      mount_component(listbox, div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "click", ctx[40], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const listbox_changes = {};
      if (dirty[0] & 24640)
        listbox_changes.class = "bx--combo-box " + (ctx2[6] === "top" && "bx--list-box--up") + " " + (!ctx2[13] && ctx2[14] && "bx--combo-box--warning");
      if (dirty[0] & 67108864)
        listbox_changes.id = ctx2[26];
      if (dirty[0] & 268435456)
        listbox_changes["aria-label"] = ctx2[28];
      if (dirty[0] & 256)
        listbox_changes.disabled = ctx2[8];
      if (dirty[0] & 8192)
        listbox_changes.invalid = ctx2[13];
      if (dirty[0] & 4096)
        listbox_changes.invalidText = ctx2[12];
      if (dirty[0] & 4)
        listbox_changes.open = ctx2[2];
      if (dirty[0] & 65536)
        listbox_changes.light = ctx2[16];
      if (dirty[0] & 128)
        listbox_changes.size = ctx2[7];
      if (dirty[0] & 16384)
        listbox_changes.warn = ctx2[14];
      if (dirty[0] & 32768)
        listbox_changes.warnText = ctx2[15];
      if (dirty[0] & 1608475967 | dirty[1] & 4194304) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!ctx2[13] && ctx2[11] && !ctx2[14]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block21(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      destroy_component(listbox);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let ariaLabel;
  let menuId;
  let comboId;
  let highlightedId;
  let filteredItems;
  const omit_props_names = [
    "items",
    "itemToString",
    "selectedId",
    "value",
    "direction",
    "size",
    "disabled",
    "titleText",
    "placeholder",
    "helperText",
    "invalidText",
    "invalid",
    "warn",
    "warnText",
    "light",
    "open",
    "shouldFilterItem",
    "translateWithId",
    "translateWithIdSelection",
    "id",
    "name",
    "ref",
    "listRef",
    "clear"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComboBox", slots, ["default"]);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { selectedId = void 0 } = $$props;
  let { value = "" } = $$props;
  let { direction = "bottom" } = $$props;
  let { size = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { titleText = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { helperText = "" } = $$props;
  let { invalidText = "" } = $$props;
  let { invalid = false } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { light = false } = $$props;
  let { open = false } = $$props;
  let { shouldFilterItem = () => true } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { translateWithIdSelection = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  let { listRef = null } = $$props;
  const dispatch = createEventDispatcher();
  let selectedItem = void 0;
  let prevSelectedId = null;
  let highlightedIndex = -1;
  function change(dir) {
    let index = highlightedIndex + dir;
    let _items = !(filteredItems == null ? void 0 : filteredItems.length) ? items : filteredItems;
    if (_items.length === 0)
      return;
    if (index < 0) {
      index = _items.length - 1;
    } else if (index >= _items.length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + dir;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(23, highlightedIndex = index);
  }
  function clear(options = {}) {
    $$invalidate(33, prevSelectedId = null);
    $$invalidate(23, highlightedIndex = -1);
    $$invalidate(25, highlightedId = void 0);
    $$invalidate(0, selectedId = void 0);
    $$invalidate(22, selectedItem = void 0);
    $$invalidate(2, open = false);
    $$invalidate(1, value = "");
    if ((options == null ? void 0 : options.focus) !== false)
      ref == null ? void 0 : ref.focus();
  }
  afterUpdate(() => {
    if (open) {
      ref.focus();
      $$invalidate(24, filteredItems = items.filter((item) => shouldFilterItem(item, value)));
    } else {
      $$invalidate(23, highlightedIndex = -1);
      $$invalidate(24, filteredItems = []);
      if (!selectedItem) {
        $$invalidate(0, selectedId = void 0);
        $$invalidate(1, value = "");
        $$invalidate(23, highlightedIndex = -1);
        $$invalidate(25, highlightedId = void 0);
      } else {
        $$invalidate(1, value = itemToString(selectedItem));
      }
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler = ({ target }) => {
    if (open && ref && !ref.contains(target)) {
      $$invalidate(2, open = false);
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const input_handler = ({ target }) => {
    if (!open && target.value.length > 0) {
      $$invalidate(2, open = true);
    }
    if (!value.length) {
      clear();
      $$invalidate(2, open = true);
    }
  };
  const keydown_handler_12 = (e) => {
    var _a, _b;
    const { key } = e;
    if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
      e.preventDefault();
    }
    if (key === "Enter") {
      $$invalidate(2, open = !open);
      if (highlightedIndex > -1 && ((_a = filteredItems[highlightedIndex]) == null ? void 0 : _a.id) !== selectedId) {
        $$invalidate(2, open = false);
        if (filteredItems[highlightedIndex]) {
          $$invalidate(1, value = itemToString(filteredItems[highlightedIndex]));
          $$invalidate(22, selectedItem = filteredItems[highlightedIndex]);
          $$invalidate(0, selectedId = filteredItems[highlightedIndex].id);
        }
      } else {
        const matchedItem = (_b = filteredItems.find((e2) => e2.text.toLowerCase() === (value == null ? void 0 : value.toLowerCase()) && !e2.disabled)) != null ? _b : filteredItems.find((e2) => !e2.disabled);
        if (matchedItem) {
          $$invalidate(2, open = false);
          $$invalidate(22, selectedItem = matchedItem);
          $$invalidate(1, value = itemToString(selectedItem));
          $$invalidate(0, selectedId = selectedItem.id);
        }
      }
      $$invalidate(23, highlightedIndex = -1);
    } else if (key === "Tab") {
      $$invalidate(2, open = false);
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(2, open = false);
    }
  };
  const blur_handler_1 = ({ relatedTarget }) => {
    if (!open || !relatedTarget)
      return;
    if (relatedTarget && !["INPUT", "SELECT", "TEXTAREA"].includes(relatedTarget.tagName) && relatedTarget.getAttribute("role") !== "button" && relatedTarget.getAttribute("role") !== "searchbox") {
      ref.focus();
    }
  };
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = (e) => {
    if (disabled)
      return;
    e.stopPropagation();
    $$invalidate(2, open = !open);
  };
  const click_handler_2 = async () => {
    if (disabled)
      return;
    $$invalidate(2, open = true);
    await tick();
    ref.focus();
  };
  const click_handler_3 = (item, i, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(0, selectedId = item.id);
    $$invalidate(2, open = false);
    if (filteredItems[i]) {
      $$invalidate(1, value = itemToString(filteredItems[i]));
    }
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled)
      return;
    $$invalidate(23, highlightedIndex = i);
  };
  function listboxmenu_ref_binding(value2) {
    listRef = value2;
    $$invalidate(4, listRef);
  }
  function scroll_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(55, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(30, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props)
      $$invalidate(31, items = $$new_props.items);
    if ("itemToString" in $$new_props)
      $$invalidate(5, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$new_props)
      $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("direction" in $$new_props)
      $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("titleText" in $$new_props)
      $$invalidate(9, titleText = $$new_props.titleText);
    if ("placeholder" in $$new_props)
      $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("helperText" in $$new_props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("invalidText" in $$new_props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("invalid" in $$new_props)
      $$invalidate(13, invalid = $$new_props.invalid);
    if ("warn" in $$new_props)
      $$invalidate(14, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(15, warnText = $$new_props.warnText);
    if ("light" in $$new_props)
      $$invalidate(16, light = $$new_props.light);
    if ("open" in $$new_props)
      $$invalidate(2, open = $$new_props.open);
    if ("shouldFilterItem" in $$new_props)
      $$invalidate(32, shouldFilterItem = $$new_props.shouldFilterItem);
    if ("translateWithId" in $$new_props)
      $$invalidate(17, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$new_props)
      $$invalidate(18, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("id" in $$new_props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("listRef" in $$new_props)
      $$invalidate(4, listRef = $$new_props.listRef);
    if ("$$scope" in $$new_props)
      $$invalidate(53, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    selectedId,
    value,
    direction,
    size,
    disabled,
    titleText,
    placeholder,
    helperText,
    invalidText,
    invalid,
    warn,
    warnText,
    light,
    open,
    shouldFilterItem,
    translateWithId,
    translateWithIdSelection,
    id,
    name,
    ref,
    listRef,
    createEventDispatcher,
    afterUpdate,
    tick,
    Checkmark: Checkmark_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    ListBox: ListBox_default,
    ListBoxField: ListBoxField_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    ListBoxSelection: ListBoxSelection_default,
    dispatch,
    selectedItem,
    prevSelectedId,
    highlightedIndex,
    change,
    clear,
    filteredItems,
    highlightedId,
    comboId,
    menuId,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(55, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props)
      $$invalidate(31, items = $$new_props.items);
    if ("itemToString" in $$props)
      $$invalidate(5, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$props)
      $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("direction" in $$props)
      $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$props)
      $$invalidate(7, size = $$new_props.size);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("titleText" in $$props)
      $$invalidate(9, titleText = $$new_props.titleText);
    if ("placeholder" in $$props)
      $$invalidate(10, placeholder = $$new_props.placeholder);
    if ("helperText" in $$props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("invalidText" in $$props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("invalid" in $$props)
      $$invalidate(13, invalid = $$new_props.invalid);
    if ("warn" in $$props)
      $$invalidate(14, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(15, warnText = $$new_props.warnText);
    if ("light" in $$props)
      $$invalidate(16, light = $$new_props.light);
    if ("open" in $$props)
      $$invalidate(2, open = $$new_props.open);
    if ("shouldFilterItem" in $$props)
      $$invalidate(32, shouldFilterItem = $$new_props.shouldFilterItem);
    if ("translateWithId" in $$props)
      $$invalidate(17, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$props)
      $$invalidate(18, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("id" in $$props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("listRef" in $$props)
      $$invalidate(4, listRef = $$new_props.listRef);
    if ("selectedItem" in $$props)
      $$invalidate(22, selectedItem = $$new_props.selectedItem);
    if ("prevSelectedId" in $$props)
      $$invalidate(33, prevSelectedId = $$new_props.prevSelectedId);
    if ("highlightedIndex" in $$props)
      $$invalidate(23, highlightedIndex = $$new_props.highlightedIndex);
    if ("filteredItems" in $$props)
      $$invalidate(24, filteredItems = $$new_props.filteredItems);
    if ("highlightedId" in $$props)
      $$invalidate(25, highlightedId = $$new_props.highlightedId);
    if ("comboId" in $$props)
      $$invalidate(26, comboId = $$new_props.comboId);
    if ("menuId" in $$props)
      $$invalidate(27, menuId = $$new_props.menuId);
    if ("ariaLabel" in $$props)
      $$invalidate(28, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[1] & 3) {
      $:
        $$invalidate(24, filteredItems = items.filter((item) => shouldFilterItem(item, value)));
    }
    if ($$self.$$.dirty[0] & 20971525 | $$self.$$.dirty[1] & 5) {
      $:
        if (selectedId !== void 0) {
          if (prevSelectedId !== selectedId) {
            $$invalidate(33, prevSelectedId = selectedId);
            if ((filteredItems == null ? void 0 : filteredItems.length) === 1 && open) {
              $$invalidate(0, selectedId = filteredItems[0].id);
              $$invalidate(22, selectedItem = filteredItems[0]);
              $$invalidate(23, highlightedIndex = -1);
              $$invalidate(25, highlightedId = void 0);
            } else {
              $$invalidate(22, selectedItem = items.find((item) => item.id === selectedId));
            }
            dispatch("select", { selectedId, selectedItem });
          }
        } else {
          $$invalidate(33, prevSelectedId = selectedId);
          $$invalidate(22, selectedItem = void 0);
        }
    }
    $:
      $$invalidate(28, ariaLabel = $$props["aria-label"] || "Choose an item");
    if ($$self.$$.dirty[0] & 524288) {
      $:
        $$invalidate(27, menuId = `menu-${id}`);
    }
    if ($$self.$$.dirty[0] & 524288) {
      $:
        $$invalidate(26, comboId = `combo-${id}`);
    }
    if ($$self.$$.dirty[0] & 8388608 | $$self.$$.dirty[1] & 1) {
      $:
        $$invalidate(25, highlightedId = items[highlightedIndex] ? items[highlightedIndex].id : 0);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedId,
    value,
    open,
    ref,
    listRef,
    itemToString,
    direction,
    size,
    disabled,
    titleText,
    placeholder,
    helperText,
    invalidText,
    invalid,
    warn,
    warnText,
    light,
    translateWithId,
    translateWithIdSelection,
    id,
    name,
    clear,
    selectedItem,
    highlightedIndex,
    filteredItems,
    highlightedId,
    comboId,
    menuId,
    ariaLabel,
    change,
    $$restProps,
    items,
    shouldFilterItem,
    prevSelectedId,
    slots,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    click_handler,
    input_binding,
    input_input_handler,
    input_handler,
    keydown_handler_12,
    blur_handler_1,
    clear_handler,
    click_handler_13,
    click_handler_2,
    click_handler_3,
    mouseenter_handler,
    listboxmenu_ref_binding,
    scroll_handler,
    $$scope
  ];
}
var ComboBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment39,
      safe_not_equal,
      {
        items: 31,
        itemToString: 5,
        selectedId: 0,
        value: 1,
        direction: 6,
        size: 7,
        disabled: 8,
        titleText: 9,
        placeholder: 10,
        helperText: 11,
        invalidText: 12,
        invalid: 13,
        warn: 14,
        warnText: 15,
        light: 16,
        open: 2,
        shouldFilterItem: 32,
        translateWithId: 17,
        translateWithIdSelection: 18,
        id: 19,
        name: 20,
        ref: 3,
        listRef: 4,
        clear: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComboBox",
      options,
      id: create_fragment39.name
    });
  }
  get items() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedId() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFilterItem() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFilterItem(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithIdSelection() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithIdSelection(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listRef() {
    throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listRef(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clear() {
    return this.$$.ctx[21];
  }
  set clear(value) {
    throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComboBox_default = ComboBox;

// node_modules/carbon-components-svelte/src/Modal/modalStore.js
var stores = /* @__PURE__ */ new Set();
var modalsOpen = writable(0);
var updateModalsOpen = () => modalsOpen.set([...stores].filter((open) => get_store_value(open)).length);
var trackModal = (openStore) => onMount(() => {
  stores.add(openStore);
  const unsubscribe = openStore.subscribe(updateModalsOpen);
  return () => {
    unsubscribe();
    stores.delete(openStore);
    updateModalsOpen();
  };
});
modalsOpen.subscribe((openCount) => {
  if (typeof document !== "undefined")
    document.body.classList.toggle("bx--body--with-modal-open", openCount > 0);
});

// node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte
var file39 = "node_modules/carbon-components-svelte/src/ComposedModal/ComposedModal.svelte";
function create_fragment40(ctx) {
  let div1;
  let div0;
  let div0_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[18].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[17], null);
  let div1_levels = [{ role: "presentation" }, ctx[14]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(div0, "aria-label", div0_aria_label_value = ctx[15]["aria-label"] || ctx[9] || void 0);
      attr_dev(div0, "class", ctx[5]);
      toggle_class(div0, "bx--modal-container", true);
      toggle_class(div0, "bx--modal-container--xs", ctx[2] === "xs");
      toggle_class(div0, "bx--modal-container--sm", ctx[2] === "sm");
      toggle_class(div0, "bx--modal-container--lg", ctx[2] === "lg");
      add_location(div0, file39, 153, 2, 3761);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--modal", true);
      toggle_class(div1, "is-visible", ctx[0]);
      toggle_class(div1, "bx--modal--danger", ctx[3]);
      add_location(div1, file39, 99, 0, 2151);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[24](div0);
      ctx[26](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", ctx[25], false, false, false),
          listen_dev(div1, "keydown", ctx[19], false, false, false),
          listen_dev(div1, "keydown", ctx[27], false, false, false),
          listen_dev(div1, "click", ctx[20], false, false, false),
          listen_dev(div1, "click", ctx[28], false, false, false),
          listen_dev(div1, "mouseover", ctx[21], false, false, false),
          listen_dev(div1, "mouseenter", ctx[22], false, false, false),
          listen_dev(div1, "mouseleave", ctx[23], false, false, false),
          listen_dev(div1, "transitionend", ctx[29], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(default_slot_template, ctx2[17], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 33280 && div0_aria_label_value !== (div0_aria_label_value = ctx2[15]["aria-label"] || ctx2[9] || void 0)) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(div0, "class", ctx2[5]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div0, "bx--modal-container", true);
      }
      if (!current || dirty[0] & 36) {
        toggle_class(div0, "bx--modal-container--xs", ctx2[2] === "xs");
      }
      if (!current || dirty[0] & 36) {
        toggle_class(div0, "bx--modal-container--sm", ctx2[2] === "sm");
      }
      if (!current || dirty[0] & 36) {
        toggle_class(div0, "bx--modal-container--lg", ctx2[2] === "lg");
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        { role: "presentation" },
        dirty[0] & 16384 && ctx2[14]
      ]));
      toggle_class(div1, "bx--modal", true);
      toggle_class(div1, "is-visible", ctx2[0]);
      toggle_class(div1, "bx--modal--danger", ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let didOpen;
  const omit_props_names = [
    "size",
    "open",
    "danger",
    "preventCloseOnClickOutside",
    "containerClass",
    "selectorPrimaryFocus",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openStore;
  let $label;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposedModal", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { danger = false } = $$props;
  let { preventCloseOnClickOutside = false } = $$props;
  let { containerClass = "" } = $$props;
  let { selectorPrimaryFocus = "[data-modal-primary-focus]" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const label = writable(void 0);
  validate_store(label, "label");
  component_subscribe($$self, label, (value) => $$invalidate(9, $label = value));
  let buttonRef = null;
  let innerModal = null;
  let didClickInnerModal = false;
  setContext("ComposedModal", {
    closeModal: () => {
      $$invalidate(0, open = false);
    },
    submit: () => {
      dispatch("submit");
      dispatch("click:button--primary");
    },
    declareRef: (ref2) => {
      buttonRef = ref2;
    },
    updateLabel: (value) => {
      label.set(value);
    }
  });
  function focus(element2) {
    var _a;
    if (selectorPrimaryFocus == null)
      return;
    const node = ((_a = element2 || innerModal) == null ? void 0 : _a.querySelector(selectorPrimaryFocus)) || buttonRef;
    if (node != null)
      node.focus();
  }
  let opened = false;
  const openStore = writable(open);
  validate_store(openStore, "openStore");
  component_subscribe($$self, openStore, (value) => $$invalidate(32, $openStore = value));
  trackModal(openStore);
  onMount(() => {
    tick().then(() => {
      focus();
    });
  });
  afterUpdate(() => {
    if (opened) {
      if (!open) {
        opened = false;
        dispatch("close");
      }
    } else if (open) {
      opened = true;
      dispatch("open");
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerModal = $$value;
      $$invalidate(6, innerModal);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(7, didClickInnerModal = true);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (open) {
      if (e.key === "Escape") {
        $$invalidate(0, open = false);
      } else if (e.key === "Tab") {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref.querySelectorAll(selectorTabbable));
        let index = tabbable.indexOf(document.activeElement);
        if (index === -1 && e.shiftKey)
          index = 0;
        index += tabbable.length + (e.shiftKey ? -1 : 1);
        index %= tabbable.length;
        tabbable[index].focus();
        e.preventDefault();
      }
    }
  };
  const click_handler_2 = () => {
    if (!didClickInnerModal && !preventCloseOnClickOutside)
      $$invalidate(0, open = false);
    $$invalidate(7, didClickInnerModal = false);
  };
  const transitionend_handler = ({ propertyName, currentTarget }) => {
    if (propertyName === "transform") {
      dispatch("transitionend", { open });
    }
    if (didOpen) {
      focus(currentTarget);
      $$invalidate(8, didOpen = false);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$new_props)
      $$invalidate(3, danger = $$new_props.danger);
    if ("preventCloseOnClickOutside" in $$new_props)
      $$invalidate(4, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("containerClass" in $$new_props)
      $$invalidate(5, containerClass = $$new_props.containerClass);
    if ("selectorPrimaryFocus" in $$new_props)
      $$invalidate(16, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    open,
    danger,
    preventCloseOnClickOutside,
    containerClass,
    selectorPrimaryFocus,
    ref,
    createEventDispatcher,
    tick,
    setContext,
    onMount,
    afterUpdate,
    writable,
    trackModal,
    dispatch,
    label,
    buttonRef,
    innerModal,
    didClickInnerModal,
    focus,
    opened,
    openStore,
    didOpen,
    $openStore,
    $label
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$props)
      $$invalidate(3, danger = $$new_props.danger);
    if ("preventCloseOnClickOutside" in $$props)
      $$invalidate(4, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("containerClass" in $$props)
      $$invalidate(5, containerClass = $$new_props.containerClass);
    if ("selectorPrimaryFocus" in $$props)
      $$invalidate(16, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("buttonRef" in $$props)
      buttonRef = $$new_props.buttonRef;
    if ("innerModal" in $$props)
      $$invalidate(6, innerModal = $$new_props.innerModal);
    if ("didClickInnerModal" in $$props)
      $$invalidate(7, didClickInnerModal = $$new_props.didClickInnerModal);
    if ("opened" in $$props)
      opened = $$new_props.opened;
    if ("didOpen" in $$props)
      $$invalidate(8, didOpen = $$new_props.didOpen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(8, didOpen = open);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        set_store_value(openStore, $openStore = open, $openStore);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    ref,
    size,
    danger,
    preventCloseOnClickOutside,
    containerClass,
    innerModal,
    didClickInnerModal,
    didOpen,
    $label,
    dispatch,
    label,
    focus,
    openStore,
    $$restProps,
    $$props,
    selectorPrimaryFocus,
    $$scope,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    click_handler_13,
    div1_binding,
    keydown_handler_12,
    click_handler_2,
    transitionend_handler
  ];
}
var ComposedModal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance40,
      create_fragment40,
      safe_not_equal,
      {
        size: 2,
        open: 0,
        danger: 3,
        preventCloseOnClickOutside: 4,
        containerClass: 5,
        selectorPrimaryFocus: 16,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposedModal",
      options,
      id: create_fragment40.name
    });
  }
  get size() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventCloseOnClickOutside() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventCloseOnClickOutside(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerClass() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerClass(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectorPrimaryFocus() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ComposedModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ComposedModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposedModal_default = ComposedModal;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte
var file40 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalHeader.svelte";
function create_if_block_17(ctx) {
  let h2;
  let t;
  const block = {
    c: function create() {
      h2 = element("h2");
      t = text(ctx[1]);
      attr_dev(h2, "class", ctx[2]);
      toggle_class(h2, "bx--modal-header__label", true);
      toggle_class(h2, "bx--type-delta", true);
      add_location(h2, file40, 32, 4, 746);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      append_dev(h2, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
      if (dirty & 4) {
        attr_dev(h2, "class", ctx2[2]);
      }
      if (dirty & 4) {
        toggle_class(h2, "bx--modal-header__label", true);
      }
      if (dirty & 4) {
        toggle_class(h2, "bx--type-delta", true);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(32:2) {#if label}",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let h3;
  let t;
  const block = {
    c: function create() {
      h3 = element("h3");
      t = text(ctx[0]);
      attr_dev(h3, "class", ctx[3]);
      toggle_class(h3, "bx--modal-header__heading", true);
      toggle_class(h3, "bx--type-beta", true);
      add_location(h3, file40, 41, 4, 914);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      append_dev(h3, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
      if (dirty & 8) {
        attr_dev(h3, "class", ctx2[3]);
      }
      if (dirty & 8) {
        toggle_class(h3, "bx--modal-header__heading", true);
      }
      if (dirty & 8) {
        toggle_class(h3, "bx--type-beta", true);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(41:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_17(ctx);
  let if_block1 = ctx[0] && create_if_block22(ctx);
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon " + ctx[5],
      "aria-hidden": "true"
    },
    $$inline: true
  });
  let div_levels = [ctx[8]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      button = element("button");
      create_component(close.$$.fragment);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", ctx[6]);
      attr_dev(button, "class", ctx[4]);
      toggle_class(button, "bx--modal-close", true);
      add_location(button, file40, 50, 2, 1078);
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-header", true);
      add_location(div, file40, 30, 0, 673);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t2);
      append_dev(div, button);
      mount_component(close, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[11], false, false, false),
          listen_dev(button, "click", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_17(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block22(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      const close_changes = {};
      if (dirty & 32)
        close_changes.class = "bx--modal-close__icon " + ctx2[5];
      close.$set(close_changes);
      if (!current || dirty & 64) {
        attr_dev(button, "aria-label", ctx2[6]);
      }
      if (!current || dirty & 16) {
        attr_dev(button, "class", ctx2[4]);
      }
      if (!current || dirty & 16) {
        toggle_class(button, "bx--modal-close", true);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 256 && ctx2[8]]));
      toggle_class(div, "bx--modal-header", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "title",
    "label",
    "labelClass",
    "titleClass",
    "closeClass",
    "closeIconClass",
    "iconDescription"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalHeader", slots, ["default"]);
  let { title = "" } = $$props;
  let { label = "" } = $$props;
  let { labelClass = "" } = $$props;
  let { titleClass = "" } = $$props;
  let { closeClass = "" } = $$props;
  let { closeIconClass = "" } = $$props;
  let { iconDescription = "Close" } = $$props;
  const { closeModal, updateLabel } = getContext("ComposedModal");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("labelClass" in $$new_props)
      $$invalidate(2, labelClass = $$new_props.labelClass);
    if ("titleClass" in $$new_props)
      $$invalidate(3, titleClass = $$new_props.titleClass);
    if ("closeClass" in $$new_props)
      $$invalidate(4, closeClass = $$new_props.closeClass);
    if ("closeIconClass" in $$new_props)
      $$invalidate(5, closeIconClass = $$new_props.closeIconClass);
    if ("iconDescription" in $$new_props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    label,
    labelClass,
    titleClass,
    closeClass,
    closeIconClass,
    iconDescription,
    getContext,
    Close: Close_default,
    closeModal,
    updateLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("labelClass" in $$props)
      $$invalidate(2, labelClass = $$new_props.labelClass);
    if ("titleClass" in $$props)
      $$invalidate(3, titleClass = $$new_props.titleClass);
    if ("closeClass" in $$props)
      $$invalidate(4, closeClass = $$new_props.closeClass);
    if ("closeIconClass" in $$props)
      $$invalidate(5, closeIconClass = $$new_props.closeIconClass);
    if ("iconDescription" in $$props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        updateLabel(label);
    }
  };
  return [
    title,
    label,
    labelClass,
    titleClass,
    closeClass,
    closeIconClass,
    iconDescription,
    closeModal,
    $$restProps,
    $$scope,
    slots,
    click_handler
  ];
}
var ModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      title: 0,
      label: 1,
      labelClass: 2,
      titleClass: 3,
      closeClass: 4,
      closeIconClass: 5,
      iconDescription: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalHeader",
      options,
      id: create_fragment41.name
    });
  }
  get title() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeIconClass() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeIconClass(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalHeader_default = ModalHeader;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte
var file41 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalBody.svelte";
function create_if_block23(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      toggle_class(div, "bx--modal-content--overflow-indicator", true);
      add_location(div, file41, 20, 2, 590);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(20:0) {#if hasScrollingContent}",
    ctx
  });
  return block;
}
function create_fragment42(ctx) {
  let div;
  let div_tabindex_value;
  let div_role_value;
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [
    {
      tabindex: div_tabindex_value = ctx[1] ? "0" : void 0
    },
    {
      role: div_role_value = ctx[1] ? "region" : void 0
    },
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block = ctx[1] && create_if_block23(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-content", true);
      toggle_class(div, "bx--modal-content--with-form", ctx[0]);
      toggle_class(div, "bx--modal-scroll-content", ctx[1]);
      add_location(div, file41, 9, 0, 270);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 2 && div_tabindex_value !== (div_tabindex_value = ctx2[1] ? "0" : void 0)) && { tabindex: div_tabindex_value },
        (!current || dirty & 2 && div_role_value !== (div_role_value = ctx2[1] ? "region" : void 0)) && { role: div_role_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(div, "bx--modal-content", true);
      toggle_class(div, "bx--modal-content--with-form", ctx2[0]);
      toggle_class(div, "bx--modal-scroll-content", ctx2[1]);
      if (ctx2[1]) {
        if (if_block) {
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["hasForm", "hasScrollingContent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBody", slots, ["default"]);
  let { hasForm = false } = $$props;
  let { hasScrollingContent = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hasForm" in $$new_props)
      $$invalidate(0, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$new_props)
      $$invalidate(1, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ hasForm, hasScrollingContent });
  $$self.$inject_state = ($$new_props) => {
    if ("hasForm" in $$props)
      $$invalidate(0, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$props)
      $$invalidate(1, hasScrollingContent = $$new_props.hasScrollingContent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [hasForm, hasScrollingContent, $$restProps, $$scope, slots];
}
var ModalBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { hasForm: 0, hasScrollingContent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBody",
      options,
      id: create_fragment42.name
    });
  }
  get hasForm() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasForm(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasScrollingContent() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasScrollingContent(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBody_default = ModalBody;

// node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte
var file42 = "node_modules/carbon-components-svelte/src/ComposedModal/ModalFooter.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_if_block_25(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      kind: "secondary",
      class: ctx[6],
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[14]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 64)
        button_changes.class = ctx2[6];
      if (dirty & 32784) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(66:32) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 288) {
        each_value = ctx2[5];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(55:2) {#if secondaryButtons.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: `(67:4) <Button       kind=\\"secondary\\"       class=\\"{secondaryClass}\\"       on:click=\\"{() => {         closeModal();         dispatch('click:button--secondary', { text: secondaryButtonText });       }}\\"     >`,
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t0_value = ctx[16].text + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32 && t0_value !== (t0_value = ctx2[16].text + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: `(57:6) <Button         kind=\\"secondary\\"         on:click=\\"{() => {           dispatch('click:button--secondary', { text: button.text });         }}\\"       >`,
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let button;
  let current;
  function click_handler() {
    return ctx[13](ctx[16]);
  }
  button = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 32800) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(56:4) {#each secondaryButtons as button}",
    ctx
  });
  return block;
}
function create_if_block24(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      kind: ctx[7] ? "danger" : "primary",
      disabled: ctx[2],
      class: ctx[3],
      icon: ctx[1],
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[10]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 128)
        button_changes.kind = ctx2[7] ? "danger" : "primary";
      if (dirty & 4)
        button_changes.disabled = ctx2[2];
      if (dirty & 8)
        button_changes.class = ctx2[3];
      if (dirty & 2)
        button_changes.icon = ctx2[1];
      if (dirty & 32769) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(78:2) {#if primaryButtonText}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: `(79:4) <Button       kind=\\"{danger ? 'danger' : 'primary'}\\"       disabled=\\"{primaryButtonDisabled}\\"       class=\\"{primaryClass}\\"       icon=\\"{primaryButtonIcon}\\"       on:click=\\"{submit}\\"     >`,
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let current;
  const if_block_creators = [create_if_block_18, create_if_block_25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].length > 0)
      return 0;
    if (ctx2[4])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[0] && create_if_block24(ctx);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  let div_levels = [ctx[11]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(div, "bx--modal-footer--three-button", ctx[5].length === 2);
      add_location(div, file42, 49, 0, 1238);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2048 && ctx2[11]]));
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(div, "bx--modal-footer--three-button", ctx2[5].length === 2);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "primaryButtonText",
    "primaryButtonIcon",
    "primaryButtonDisabled",
    "primaryClass",
    "secondaryButtonText",
    "secondaryButtons",
    "secondaryClass",
    "danger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalFooter", slots, ["default"]);
  let { primaryButtonText = "" } = $$props;
  let { primaryButtonIcon = void 0 } = $$props;
  let { primaryButtonDisabled = false } = $$props;
  let { primaryClass = void 0 } = $$props;
  let { secondaryButtonText = "" } = $$props;
  let { secondaryButtons = [] } = $$props;
  let { secondaryClass = void 0 } = $$props;
  let { danger = false } = $$props;
  const dispatch = createEventDispatcher();
  const { closeModal, submit } = getContext("ComposedModal");
  const click_handler = (button) => {
    dispatch("click:button--secondary", { text: button.text });
  };
  const click_handler_13 = () => {
    closeModal();
    dispatch("click:button--secondary", { text: secondaryButtonText });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("primaryButtonText" in $$new_props)
      $$invalidate(0, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonIcon" in $$new_props)
      $$invalidate(1, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("primaryButtonDisabled" in $$new_props)
      $$invalidate(2, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryClass" in $$new_props)
      $$invalidate(3, primaryClass = $$new_props.primaryClass);
    if ("secondaryButtonText" in $$new_props)
      $$invalidate(4, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$new_props)
      $$invalidate(5, secondaryButtons = $$new_props.secondaryButtons);
    if ("secondaryClass" in $$new_props)
      $$invalidate(6, secondaryClass = $$new_props.secondaryClass);
    if ("danger" in $$new_props)
      $$invalidate(7, danger = $$new_props.danger);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    primaryButtonText,
    primaryButtonIcon,
    primaryButtonDisabled,
    primaryClass,
    secondaryButtonText,
    secondaryButtons,
    secondaryClass,
    danger,
    getContext,
    createEventDispatcher,
    Button: Button_default,
    dispatch,
    closeModal,
    submit
  });
  $$self.$inject_state = ($$new_props) => {
    if ("primaryButtonText" in $$props)
      $$invalidate(0, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonIcon" in $$props)
      $$invalidate(1, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("primaryButtonDisabled" in $$props)
      $$invalidate(2, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryClass" in $$props)
      $$invalidate(3, primaryClass = $$new_props.primaryClass);
    if ("secondaryButtonText" in $$props)
      $$invalidate(4, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$props)
      $$invalidate(5, secondaryButtons = $$new_props.secondaryButtons);
    if ("secondaryClass" in $$props)
      $$invalidate(6, secondaryClass = $$new_props.secondaryClass);
    if ("danger" in $$props)
      $$invalidate(7, danger = $$new_props.danger);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    primaryButtonText,
    primaryButtonIcon,
    primaryButtonDisabled,
    primaryClass,
    secondaryButtonText,
    secondaryButtons,
    secondaryClass,
    danger,
    dispatch,
    closeModal,
    submit,
    $$restProps,
    slots,
    click_handler,
    click_handler_13,
    $$scope
  ];
}
var ModalFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      primaryButtonText: 0,
      primaryButtonIcon: 1,
      primaryButtonDisabled: 2,
      primaryClass: 3,
      secondaryButtonText: 4,
      secondaryButtons: 5,
      secondaryClass: 6,
      danger: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalFooter",
      options,
      id: create_fragment43.name
    });
  }
  get primaryButtonText() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonText(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonIcon() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonIcon(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonDisabled() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonDisabled(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryClass() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryClass(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtonText() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtonText(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtons() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtons(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryClass() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryClass(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalFooter_default = ModalFooter;

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte
var file43 = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippetSkeleton.svelte";
function create_if_block_19(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let span2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      span2 = element("span");
      add_location(span0, file43, 23, 31, 550);
      add_location(span1, file43, 23, 45, 564);
      add_location(span2, file43, 23, 59, 578);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span0, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, span1, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, span2, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span1);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(span2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(24:31) ",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      add_location(span, file43, 22, 6, 505);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: '(22:4) {#if type === \\"single\\"}',
    ctx
  });
  return block;
}
function create_fragment44(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "single")
      return create_if_block25;
    if (ctx2[0] === "multi")
      return create_if_block_19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      toggle_class(div0, "bx--snippet-container", true);
      add_location(div0, file43, 20, 2, 428);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(div1, "bx--snippet--single", ctx[0] === "single");
      toggle_class(div1, "bx--snippet--multi", ctx[0] === "multi");
      add_location(div1, file43, 9, 0, 185);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(div1, "bx--snippet--single", ctx2[0] === "single");
      toggle_class(div1, "bx--snippet--multi", ctx2[0] === "multi");
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  const omit_props_names = ["type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeSnippetSkeleton", slots, []);
  let { type = "single" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({ type });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(0, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CodeSnippetSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { type: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeSnippetSkeleton",
      options,
      id: create_fragment44.name
    });
  }
  get type() {
    throw new Error("<CodeSnippetSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<CodeSnippetSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeSnippetSkeleton_default = CodeSnippetSkeleton;

// node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte
var file44 = "node_modules/carbon-components-svelte/src/CodeSnippet/CodeSnippet.svelte";
function create_else_block_1(ctx) {
  let div1;
  let div0;
  let pre;
  let code_1;
  let div0_role_value;
  let div0_tabindex_value;
  let div0_aria_label_value;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[44], null);
  const default_slot_or_fallback = default_slot || fallback_block_22(ctx);
  let if_block0 = !ctx[6] && create_if_block_43(ctx);
  let if_block1 = ctx[2] && create_if_block_33(ctx);
  let div1_levels = [ctx[22]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      pre = element("pre");
      code_1 = element("code");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      add_location(code_1, file44, 225, 29, 6374);
      add_location(pre, file44, 225, 6, 6351);
      attr_dev(div0, "role", div0_role_value = ctx[3] === "single" ? "textbox" : void 0);
      attr_dev(div0, "tabindex", div0_tabindex_value = ctx[3] === "single" && !ctx[7] ? "0" : void 0);
      attr_dev(div0, "aria-label", div0_aria_label_value = ctx[22]["aria-label"] || ctx[12] || "code-snippet");
      set_style(div0, "width", "100%");
      set_style(div0, "min-height", ctx[19] + "px");
      set_style(div0, "max-height", ctx[18]);
      toggle_class(div0, "bx--snippet-container", true);
      add_location(div0, file44, 218, 4, 6010);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--snippet", true);
      toggle_class(div1, "bx--snippet--expand", ctx[0]);
      toggle_class(div1, "bx--snippet--light", ctx[9]);
      toggle_class(div1, "bx--snippet--no-copy", ctx[6]);
      toggle_class(div1, "bx--snippet--wraptext", ctx[8]);
      toggle_class(div1, "bx--snippet--single", ctx[3] === "single");
      toggle_class(div1, "bx--snippet--inline", ctx[3] === "inline");
      toggle_class(div1, "bx--snippet--multi", ctx[3] === "multi");
      toggle_class(div1, "bx--snippet--disabled", ctx[3] !== "inline" && ctx[7]);
      add_location(div1, file44, 202, 2, 5436);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, pre);
      append_dev(pre, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      ctx[39](pre);
      append_dev(div1, t0);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "mouseover", ctx[30], false, false, false),
          listen_dev(div1, "mouseenter", ctx[31], false, false, false),
          listen_dev(div1, "mouseleave", ctx[32], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[44],
            !current ? get_all_dirty_from_scope(ctx2[44]) : get_slot_changes(default_slot_template, ctx2[44], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 8 && div0_role_value !== (div0_role_value = ctx2[3] === "single" ? "textbox" : void 0)) {
        attr_dev(div0, "role", div0_role_value);
      }
      if (!current || dirty[0] & 136 && div0_tabindex_value !== (div0_tabindex_value = ctx2[3] === "single" && !ctx2[7] ? "0" : void 0)) {
        attr_dev(div0, "tabindex", div0_tabindex_value);
      }
      if (!current || dirty[0] & 4198400 && div0_aria_label_value !== (div0_aria_label_value = ctx2[22]["aria-label"] || ctx2[12] || "code-snippet")) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty[0] & 524288) {
        set_style(div0, "min-height", ctx2[19] + "px");
      }
      if (!current || dirty[0] & 262144) {
        set_style(div0, "max-height", ctx2[18]);
      }
      if (!ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_33(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty[0] & 4194304 && ctx2[22]]));
      toggle_class(div1, "bx--snippet", true);
      toggle_class(div1, "bx--snippet--expand", ctx2[0]);
      toggle_class(div1, "bx--snippet--light", ctx2[9]);
      toggle_class(div1, "bx--snippet--no-copy", ctx2[6]);
      toggle_class(div1, "bx--snippet--wraptext", ctx2[8]);
      toggle_class(div1, "bx--snippet--single", ctx2[3] === "single");
      toggle_class(div1, "bx--snippet--inline", ctx2[3] === "inline");
      toggle_class(div1, "bx--snippet--multi", ctx2[3] === "multi");
      toggle_class(div1, "bx--snippet--disabled", ctx2[3] !== "inline" && ctx2[7]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[39](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(202:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_26, create_else_block11];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(138:28) ",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let codesnippetskeleton;
  let current;
  const codesnippetskeleton_spread_levels = [{ type: ctx[3] }, ctx[22]];
  let codesnippetskeleton_props = {};
  for (let i = 0; i < codesnippetskeleton_spread_levels.length; i += 1) {
    codesnippetskeleton_props = assign(codesnippetskeleton_props, codesnippetskeleton_spread_levels[i]);
  }
  codesnippetskeleton = new CodeSnippetSkeleton_default({
    props: codesnippetskeleton_props,
    $$inline: true
  });
  codesnippetskeleton.$on("click", ctx[33]);
  codesnippetskeleton.$on("mouseover", ctx[34]);
  codesnippetskeleton.$on("mouseenter", ctx[35]);
  codesnippetskeleton.$on("mouseleave", ctx[36]);
  const block = {
    c: function create() {
      create_component(codesnippetskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(codesnippetskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const codesnippetskeleton_changes = dirty[0] & 4194312 ? get_spread_update(codesnippetskeleton_spread_levels, [
        dirty[0] & 8 && { type: ctx2[3] },
        dirty[0] & 4194304 && get_spread_object(ctx2[22])
      ]) : {};
      codesnippetskeleton.$set(codesnippetskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(codesnippetskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(codesnippetskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(codesnippetskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(129:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_22.name,
    type: "fallback",
    source: "(226:41) {code}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let copybutton;
  let current;
  copybutton = new CopyButton_default({
    props: {
      text: ctx[4],
      copy: ctx[5],
      disabled: ctx[7],
      feedback: ctx[13],
      feedbackTimeout: ctx[14],
      iconDescription: ctx[11]
    },
    $$inline: true
  });
  copybutton.$on("click", ctx[40]);
  copybutton.$on("copy", ctx[41]);
  copybutton.$on("animationend", ctx[42]);
  const block = {
    c: function create() {
      create_component(copybutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(copybutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const copybutton_changes = {};
      if (dirty[0] & 16)
        copybutton_changes.text = ctx2[4];
      if (dirty[0] & 32)
        copybutton_changes.copy = ctx2[5];
      if (dirty[0] & 128)
        copybutton_changes.disabled = ctx2[7];
      if (dirty[0] & 8192)
        copybutton_changes.feedback = ctx2[13];
      if (dirty[0] & 16384)
        copybutton_changes.feedbackTimeout = ctx2[14];
      if (dirty[0] & 2048)
        copybutton_changes.iconDescription = ctx2[11];
      copybutton.$set(copybutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copybutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copybutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(copybutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(228:4) {#if !hideCopyButton}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      kind: "ghost",
      size: "small",
      class: "bx--snippet-btn--expand",
      disabled: ctx[7],
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[43]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & 128)
        button_changes.disabled = ctx2[7];
      if (dirty[0] & 1048576 | dirty[1] & 8192) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(241:4) {#if showMoreLess}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let span;
  let t0;
  let t1;
  let chevrondown;
  let current;
  chevrondown = new ChevronDown_default({
    props: {
      class: "bx--icon-chevron--down bx--snippet__icon",
      "aria-label": ctx[20]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(ctx[20]);
      t1 = space();
      create_component(chevrondown.$$.fragment);
      toggle_class(span, "bx--snippet-btn--text", true);
      add_location(span, file44, 250, 8, 6978);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t0);
      insert_dev(target, t1, anchor);
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 1048576)
        set_data_dev(t0, ctx2[20]);
      const chevrondown_changes = {};
      if (dirty[0] & 1048576)
        chevrondown_changes["aria-label"] = ctx2[20];
      chevrondown.$set(chevrondown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (detaching)
        detach_dev(t1);
      destroy_component(chevrondown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(242:6) <Button         kind=\\"ghost\\"         size=\\"small\\"         class=\\"bx--snippet-btn--expand\\"         disabled=\\"{disabled}\\"         on:click=\\"{() => {           expanded = !expanded;         }}\\"       >',
    ctx
  });
  return block;
}
function create_else_block11(ctx) {
  let button;
  let code_1;
  let t0;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[44], null);
  const default_slot_or_fallback = default_slot || fallback_block_13(ctx);
  let button_levels = [
    { type: "button" },
    { "aria-live": "polite" },
    { "aria-label": ctx[12] },
    ctx[22]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      code_1 = element("code");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      span = element("span");
      t1 = text(ctx[13]);
      attr_dev(code_1, "id", ctx[15]);
      add_location(code_1, file44, 189, 6, 5177);
      attr_dev(span, "aria-hidden", "true");
      toggle_class(span, "bx--assistive-text", true);
      toggle_class(span, "bx--copy-btn__feedback", true);
      add_location(span, file44, 192, 6, 5242);
      set_attributes(button, button_data);
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--btn--copy", true);
      toggle_class(button, "bx--copy-btn--animating", ctx[16]);
      toggle_class(button, "bx--copy-btn--fade-in", ctx[16] === "fade-in");
      toggle_class(button, "bx--copy-btn--fade-out", ctx[16] === "fade-out");
      toggle_class(button, "bx--snippet", true);
      toggle_class(button, "bx--snippet--inline", ctx[3] === "inline");
      toggle_class(button, "bx--snippet--expand", ctx[0]);
      toggle_class(button, "bx--snippet--light", ctx[9]);
      toggle_class(button, "bx--snippet--wraptext", ctx[8]);
      add_location(button, file44, 155, 4, 4115);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      append_dev(button, t0);
      append_dev(button, span);
      append_dev(span, t1);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[26], false, false, false),
          listen_dev(button, "click", ctx[37], false, false, false),
          listen_dev(button, "animationend", ctx[38], false, false, false),
          listen_dev(button, "mouseover", ctx[27], false, false, false),
          listen_dev(button, "mouseenter", ctx[28], false, false, false),
          listen_dev(button, "mouseleave", ctx[29], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[44],
            !current ? get_all_dirty_from_scope(ctx2[44]) : get_slot_changes(default_slot_template, ctx2[44], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 32768) {
        attr_dev(code_1, "id", ctx2[15]);
      }
      if (!current || dirty[0] & 8192)
        set_data_dev(t1, ctx2[13]);
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-live": "polite" },
        (!current || dirty[0] & 4096) && { "aria-label": ctx2[12] },
        dirty[0] & 4194304 && ctx2[22]
      ]));
      toggle_class(button, "bx--copy", true);
      toggle_class(button, "bx--btn--copy", true);
      toggle_class(button, "bx--copy-btn--animating", ctx2[16]);
      toggle_class(button, "bx--copy-btn--fade-in", ctx2[16] === "fade-in");
      toggle_class(button, "bx--copy-btn--fade-out", ctx2[16] === "fade-out");
      toggle_class(button, "bx--snippet", true);
      toggle_class(button, "bx--snippet--inline", ctx2[3] === "inline");
      toggle_class(button, "bx--snippet--expand", ctx2[0]);
      toggle_class(button, "bx--snippet--light", ctx2[9]);
      toggle_class(button, "bx--snippet--wraptext", ctx2[8]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(155:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let span;
  let code_1;
  let current;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[44], null);
  const default_slot_or_fallback = default_slot || fallback_block7(ctx);
  let span_levels = [ctx[22]];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      code_1 = element("code");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr_dev(code_1, "id", ctx[15]);
      add_location(code_1, file44, 150, 6, 4030);
      set_attributes(span, span_data);
      toggle_class(span, "bx--snippet", true);
      toggle_class(span, "bx--snippet--expand", ctx[0]);
      toggle_class(span, "bx--snippet--light", ctx[9]);
      toggle_class(span, "bx--snippet--no-copy", ctx[6]);
      toggle_class(span, "bx--snippet--wraptext", ctx[8]);
      toggle_class(span, "bx--snippet--single", ctx[3] === "single");
      toggle_class(span, "bx--snippet--inline", ctx[3] === "inline");
      toggle_class(span, "bx--snippet--multi", ctx[3] === "multi");
      add_location(span, file44, 139, 4, 3611);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, code_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[44],
            !current ? get_all_dirty_from_scope(ctx2[44]) : get_slot_changes(default_slot_template, ctx2[44], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 32768) {
        attr_dev(code_1, "id", ctx2[15]);
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty[0] & 4194304 && ctx2[22]]));
      toggle_class(span, "bx--snippet", true);
      toggle_class(span, "bx--snippet--expand", ctx2[0]);
      toggle_class(span, "bx--snippet--light", ctx2[9]);
      toggle_class(span, "bx--snippet--no-copy", ctx2[6]);
      toggle_class(span, "bx--snippet--wraptext", ctx2[8]);
      toggle_class(span, "bx--snippet--single", ctx2[3] === "single");
      toggle_class(span, "bx--snippet--inline", ctx2[3] === "inline");
      toggle_class(span, "bx--snippet--multi", ctx2[3] === "multi");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(139:2) {#if hideCopyButton}",
    ctx
  });
  return block;
}
function fallback_block_13(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_13.name,
    type: "fallback",
    source: "(191:14) {code}",
    ctx
  });
  return block;
}
function fallback_block7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(152:14) {code}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block26, create_if_block_110, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[10])
      return 0;
    if (ctx2[3] === "inline")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let expandText;
  let minHeight;
  let maxHeight;
  const omit_props_names = [
    "type",
    "code",
    "copy",
    "expanded",
    "hideCopyButton",
    "disabled",
    "wrapText",
    "light",
    "skeleton",
    "copyButtonDescription",
    "copyLabel",
    "feedback",
    "feedbackTimeout",
    "showLessText",
    "showMoreText",
    "showMoreLess",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeSnippet", slots, ["default"]);
  let { type = "single" } = $$props;
  let { code = void 0 } = $$props;
  let { copy = async (code2) => {
    try {
      await navigator.clipboard.writeText(code2);
    } catch (e) {
      console.log(e);
    }
  } } = $$props;
  let { expanded = false } = $$props;
  let { hideCopyButton = false } = $$props;
  let { disabled = false } = $$props;
  let { wrapText = false } = $$props;
  let { light = false } = $$props;
  let { skeleton = false } = $$props;
  let { copyButtonDescription = void 0 } = $$props;
  let { copyLabel = void 0 } = $$props;
  let { feedback = "Copied!" } = $$props;
  let { feedbackTimeout = 2e3 } = $$props;
  let { showLessText = "Show less" } = $$props;
  let { showMoreText = "Show more" } = $$props;
  let { showMoreLess = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let animation = void 0;
  let timeout = void 0;
  function setShowMoreLess() {
    const { height } = ref.getBoundingClientRect();
    if (height > 0)
      $$invalidate(2, showMoreLess = ref.getBoundingClientRect().height > 255);
  }
  onMount(() => {
    return () => clearTimeout(timeout);
  });
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_3 = () => {
    copy(code);
    dispatch("copy");
    if (animation === "fade-in")
      return;
    $$invalidate(16, animation = "fade-in");
    $$invalidate(17, timeout = setTimeout(
      () => {
        $$invalidate(16, animation = "fade-out");
      },
      feedbackTimeout
    ));
  };
  const animationend_handler_1 = ({ animationName }) => {
    if (animationName === "hide-feedback") {
      $$invalidate(16, animation = void 0);
    }
  };
  function pre_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function copy_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function animationend_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_4 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("code" in $$new_props)
      $$invalidate(4, code = $$new_props.code);
    if ("copy" in $$new_props)
      $$invalidate(5, copy = $$new_props.copy);
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("hideCopyButton" in $$new_props)
      $$invalidate(6, hideCopyButton = $$new_props.hideCopyButton);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("wrapText" in $$new_props)
      $$invalidate(8, wrapText = $$new_props.wrapText);
    if ("light" in $$new_props)
      $$invalidate(9, light = $$new_props.light);
    if ("skeleton" in $$new_props)
      $$invalidate(10, skeleton = $$new_props.skeleton);
    if ("copyButtonDescription" in $$new_props)
      $$invalidate(11, copyButtonDescription = $$new_props.copyButtonDescription);
    if ("copyLabel" in $$new_props)
      $$invalidate(12, copyLabel = $$new_props.copyLabel);
    if ("feedback" in $$new_props)
      $$invalidate(13, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$new_props)
      $$invalidate(14, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("showLessText" in $$new_props)
      $$invalidate(23, showLessText = $$new_props.showLessText);
    if ("showMoreText" in $$new_props)
      $$invalidate(24, showMoreText = $$new_props.showMoreText);
    if ("showMoreLess" in $$new_props)
      $$invalidate(2, showMoreLess = $$new_props.showMoreLess);
    if ("id" in $$new_props)
      $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(44, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    type,
    code,
    copy,
    expanded,
    hideCopyButton,
    disabled,
    wrapText,
    light,
    skeleton,
    copyButtonDescription,
    copyLabel,
    feedback,
    feedbackTimeout,
    showLessText,
    showMoreText,
    showMoreLess,
    id,
    ref,
    createEventDispatcher,
    tick,
    onMount,
    ChevronDown: ChevronDown_default,
    Button: Button_default,
    CopyButton: CopyButton_default,
    CodeSnippetSkeleton: CodeSnippetSkeleton_default,
    dispatch,
    animation,
    timeout,
    setShowMoreLess,
    maxHeight,
    minHeight,
    expandText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("code" in $$props)
      $$invalidate(4, code = $$new_props.code);
    if ("copy" in $$props)
      $$invalidate(5, copy = $$new_props.copy);
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("hideCopyButton" in $$props)
      $$invalidate(6, hideCopyButton = $$new_props.hideCopyButton);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("wrapText" in $$props)
      $$invalidate(8, wrapText = $$new_props.wrapText);
    if ("light" in $$props)
      $$invalidate(9, light = $$new_props.light);
    if ("skeleton" in $$props)
      $$invalidate(10, skeleton = $$new_props.skeleton);
    if ("copyButtonDescription" in $$props)
      $$invalidate(11, copyButtonDescription = $$new_props.copyButtonDescription);
    if ("copyLabel" in $$props)
      $$invalidate(12, copyLabel = $$new_props.copyLabel);
    if ("feedback" in $$props)
      $$invalidate(13, feedback = $$new_props.feedback);
    if ("feedbackTimeout" in $$props)
      $$invalidate(14, feedbackTimeout = $$new_props.feedbackTimeout);
    if ("showLessText" in $$props)
      $$invalidate(23, showLessText = $$new_props.showLessText);
    if ("showMoreText" in $$props)
      $$invalidate(24, showMoreText = $$new_props.showMoreText);
    if ("showMoreLess" in $$props)
      $$invalidate(2, showMoreLess = $$new_props.showMoreLess);
    if ("id" in $$props)
      $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("animation" in $$props)
      $$invalidate(16, animation = $$new_props.animation);
    if ("timeout" in $$props)
      $$invalidate(17, timeout = $$new_props.timeout);
    if ("maxHeight" in $$props)
      $$invalidate(18, maxHeight = $$new_props.maxHeight);
    if ("minHeight" in $$props)
      $$invalidate(19, minHeight = $$new_props.minHeight);
    if ("expandText" in $$props)
      $$invalidate(20, expandText = $$new_props.expandText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 25165825) {
      $:
        $$invalidate(20, expandText = expanded ? showLessText : showMoreText);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(19, minHeight = expanded ? 16 * 15 : 48);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(18, maxHeight = expanded ? "none" : 16 * 15 + "px");
    }
    if ($$self.$$.dirty[0] & 26) {
      $:
        if (type === "multi" && ref) {
          if (code === void 0)
            setShowMoreLess();
          if (code)
            tick().then(setShowMoreLess);
        }
    }
    if ($$self.$$.dirty[0] & 9) {
      $:
        if (type === "multi")
          dispatch(expanded ? "expand" : "collapse");
    }
  };
  return [
    expanded,
    ref,
    showMoreLess,
    type,
    code,
    copy,
    hideCopyButton,
    disabled,
    wrapText,
    light,
    skeleton,
    copyButtonDescription,
    copyLabel,
    feedback,
    feedbackTimeout,
    id,
    animation,
    timeout,
    maxHeight,
    minHeight,
    expandText,
    dispatch,
    $$restProps,
    showLessText,
    showMoreText,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_3,
    animationend_handler_1,
    pre_binding,
    click_handler_2,
    copy_handler,
    animationend_handler,
    click_handler_4,
    $$scope
  ];
}
var CodeSnippet = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance45,
      create_fragment45,
      safe_not_equal,
      {
        type: 3,
        code: 4,
        copy: 5,
        expanded: 0,
        hideCopyButton: 6,
        disabled: 7,
        wrapText: 8,
        light: 9,
        skeleton: 10,
        copyButtonDescription: 11,
        copyLabel: 12,
        feedback: 13,
        feedbackTimeout: 14,
        showLessText: 23,
        showMoreText: 24,
        showMoreLess: 2,
        id: 15,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeSnippet",
      options,
      id: create_fragment45.name
    });
  }
  get type() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCopyButton() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCopyButton(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copyButtonDescription() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copyButtonDescription(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copyLabel() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copyLabel(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedback() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedbackTimeout() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedbackTimeout(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLessText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLessText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showMoreText() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showMoreText(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showMoreLess() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showMoreLess(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<CodeSnippet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<CodeSnippet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeSnippet_default = CodeSnippet;

// node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte
var file45 = "node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte";
var get_labelText_slot_changes3 = (dirty) => ({});
var get_labelText_slot_context3 = (ctx) => ({});
function create_if_block27(ctx) {
  let span;
  let current;
  const labelText_slot_template = ctx[16].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[15], get_labelText_slot_context3);
  const labelText_slot_or_fallback = labelText_slot || fallback_block8(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      toggle_class(span, "bx--visually-hidden", ctx[7]);
      add_location(span, file45, 74, 6, 1826);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(labelText_slot_template, ctx2[15], dirty, get_labelText_slot_changes3),
            get_labelText_slot_context3
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 128) {
        toggle_class(span, "bx--visually-hidden", ctx2[7]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(74:4) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[6]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(76:31)            ",
    ctx
  });
  return block;
}
function create_fragment46(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[6] || ctx[13].labelText) && create_if_block27(ctx);
  let div_levels = [ctx[12]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span = element("span");
      t1 = space();
      if (if_block)
        if_block.c();
      attr_dev(input, "type", "radio");
      attr_dev(input, "id", ctx[8]);
      attr_dev(input, "name", ctx[9]);
      input.checked = ctx[0];
      input.disabled = ctx[3];
      input.required = ctx[4];
      input.value = ctx[2];
      toggle_class(input, "bx--radio-button", true);
      add_location(input, file45, 54, 2, 1344);
      toggle_class(span, "bx--radio-button__appearance", true);
      add_location(span, file45, 72, 4, 1721);
      attr_dev(label, "for", ctx[8]);
      toggle_class(label, "bx--radio-button__label", true);
      add_location(label, file45, 71, 2, 1659);
      set_attributes(div, div_data);
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(div, "bx--radio-button-wrapper--label-left", ctx[5] === "left");
      add_location(div, file45, 49, 0, 1200);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      ctx[18](input);
      append_dev(div, t0);
      append_dev(div, label);
      append_dev(label, span);
      append_dev(label, t1);
      if (if_block)
        if_block.m(label, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[17], false, false, false),
          listen_dev(input, "change", ctx[19], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 256) {
        attr_dev(input, "id", ctx2[8]);
      }
      if (!current || dirty & 512) {
        attr_dev(input, "name", ctx2[9]);
      }
      if (!current || dirty & 1) {
        prop_dev(input, "checked", ctx2[0]);
      }
      if (!current || dirty & 8) {
        prop_dev(input, "disabled", ctx2[3]);
      }
      if (!current || dirty & 16) {
        prop_dev(input, "required", ctx2[4]);
      }
      if (!current || dirty & 4) {
        prop_dev(input, "value", ctx2[2]);
      }
      if (ctx2[6] || ctx2[13].labelText) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 256) {
        attr_dev(label, "for", ctx2[8]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 4096 && ctx2[12]]));
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(div, "bx--radio-button-wrapper--label-left", ctx2[5] === "left");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[18](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "checked",
    "disabled",
    "required",
    "labelPosition",
    "labelText",
    "hideLabel",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButton", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("RadioButtonGroup");
  const selectedValue = ctx ? ctx.selectedValue : writable(checked ? value : void 0);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(14, $selectedValue = value2));
  if (ctx) {
    ctx.add({ id, checked, disabled, value });
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler_1 = () => {
    if (ctx) {
      ctx.update(value);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$new_props)
      $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$new_props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    checked,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    ref,
    getContext,
    writable,
    ctx,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$props)
      $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16388) {
      $:
        $$invalidate(0, checked = $selectedValue === value);
    }
  };
  return [
    checked,
    ref,
    value,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    ctx,
    selectedValue,
    $$restProps,
    $$slots,
    $selectedValue,
    $$scope,
    slots,
    change_handler,
    input_binding,
    change_handler_1
  ];
}
var RadioButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      value: 2,
      checked: 0,
      disabled: 3,
      required: 4,
      labelPosition: 5,
      labelText: 6,
      hideLabel: 7,
      id: 8,
      name: 9,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButton",
      options,
      id: create_fragment46.name
    });
  }
  get value() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButton_default = RadioButton;

// node_modules/carbon-components-svelte/src/DataTable/Table.svelte
var file46 = "node_modules/carbon-components-svelte/src/DataTable/Table.svelte";
function create_else_block12(ctx) {
  let table;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let table_levels = [ctx[6], { style: ctx[5] }];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if (default_slot)
        default_slot.c();
      set_attributes(table, table_data);
      toggle_class(table, "bx--data-table", true);
      toggle_class(table, "bx--data-table--compact", ctx[0] === "compact");
      toggle_class(table, "bx--data-table--short", ctx[0] === "short");
      toggle_class(table, "bx--data-table--tall", ctx[0] === "tall");
      toggle_class(table, "bx--data-table--md", ctx[0] === "medium");
      toggle_class(table, "bx--data-table--sort", ctx[3]);
      toggle_class(table, "bx--data-table--zebra", ctx[1]);
      toggle_class(table, "bx--data-table--static", ctx[2]);
      toggle_class(table, "bx--data-table--sticky-header", ctx[4]);
      add_location(table, file46, 44, 2, 1235);
    },
    m: function mount(target, anchor) {
      insert_dev(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        dirty & 64 && ctx2[6],
        (!current || dirty & 32) && { style: ctx2[5] }
      ]));
      toggle_class(table, "bx--data-table", true);
      toggle_class(table, "bx--data-table--compact", ctx2[0] === "compact");
      toggle_class(table, "bx--data-table--short", ctx2[0] === "short");
      toggle_class(table, "bx--data-table--tall", ctx2[0] === "tall");
      toggle_class(table, "bx--data-table--md", ctx2[0] === "medium");
      toggle_class(table, "bx--data-table--sort", ctx2[3]);
      toggle_class(table, "bx--data-table--zebra", ctx2[1]);
      toggle_class(table, "bx--data-table--static", ctx2[2]);
      toggle_class(table, "bx--data-table--sticky-header", ctx2[4]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block28(ctx) {
  let section;
  let table;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let section_levels = [ctx[6]];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      table = element("table");
      if (default_slot)
        default_slot.c();
      attr_dev(table, "style", ctx[5]);
      toggle_class(table, "bx--data-table", true);
      toggle_class(table, "bx--data-table--compact", ctx[0] === "compact");
      toggle_class(table, "bx--data-table--short", ctx[0] === "short");
      toggle_class(table, "bx--data-table--tall", ctx[0] === "tall");
      toggle_class(table, "bx--data-table--md", ctx[0] === "medium");
      toggle_class(table, "bx--data-table--sort", ctx[3]);
      toggle_class(table, "bx--data-table--zebra", ctx[1]);
      toggle_class(table, "bx--data-table--static", ctx[2]);
      toggle_class(table, "bx--data-table--sticky-header", ctx[4]);
      add_location(table, file46, 28, 4, 685);
      set_attributes(section, section_data);
      toggle_class(section, "bx--data-table_inner-container", true);
      add_location(section, file46, 27, 2, 608);
    },
    m: function mount(target, anchor) {
      insert_dev(target, section, anchor);
      append_dev(section, table);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(table, "style", ctx2[5]);
      }
      if (!current || dirty & 1) {
        toggle_class(table, "bx--data-table--compact", ctx2[0] === "compact");
      }
      if (!current || dirty & 1) {
        toggle_class(table, "bx--data-table--short", ctx2[0] === "short");
      }
      if (!current || dirty & 1) {
        toggle_class(table, "bx--data-table--tall", ctx2[0] === "tall");
      }
      if (!current || dirty & 1) {
        toggle_class(table, "bx--data-table--md", ctx2[0] === "medium");
      }
      if (!current || dirty & 8) {
        toggle_class(table, "bx--data-table--sort", ctx2[3]);
      }
      if (!current || dirty & 2) {
        toggle_class(table, "bx--data-table--zebra", ctx2[1]);
      }
      if (!current || dirty & 4) {
        toggle_class(table, "bx--data-table--static", ctx2[2]);
      }
      if (!current || dirty & 16) {
        toggle_class(table, "bx--data-table--sticky-header", ctx2[4]);
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [dirty & 64 && ctx2[6]]));
      toggle_class(section, "bx--data-table_inner-container", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(27:0) {#if stickyHeader}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block28, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "zebra", "useStaticWidth", "sortable", "stickyHeader", "tableStyle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { size = void 0 } = $$props;
  let { zebra = false } = $$props;
  let { useStaticWidth = false } = $$props;
  let { sortable = false } = $$props;
  let { stickyHeader = false } = $$props;
  let { tableStyle = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("zebra" in $$new_props)
      $$invalidate(1, zebra = $$new_props.zebra);
    if ("useStaticWidth" in $$new_props)
      $$invalidate(2, useStaticWidth = $$new_props.useStaticWidth);
    if ("sortable" in $$new_props)
      $$invalidate(3, sortable = $$new_props.sortable);
    if ("stickyHeader" in $$new_props)
      $$invalidate(4, stickyHeader = $$new_props.stickyHeader);
    if ("tableStyle" in $$new_props)
      $$invalidate(5, tableStyle = $$new_props.tableStyle);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    zebra,
    useStaticWidth,
    sortable,
    stickyHeader,
    tableStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("zebra" in $$props)
      $$invalidate(1, zebra = $$new_props.zebra);
    if ("useStaticWidth" in $$props)
      $$invalidate(2, useStaticWidth = $$new_props.useStaticWidth);
    if ("sortable" in $$props)
      $$invalidate(3, sortable = $$new_props.sortable);
    if ("stickyHeader" in $$props)
      $$invalidate(4, stickyHeader = $$new_props.stickyHeader);
    if ("tableStyle" in $$props)
      $$invalidate(5, tableStyle = $$new_props.tableStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    zebra,
    useStaticWidth,
    sortable,
    stickyHeader,
    tableStyle,
    $$restProps,
    $$scope,
    slots
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      size: 0,
      zebra: 1,
      useStaticWidth: 2,
      sortable: 3,
      stickyHeader: 4,
      tableStyle: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment47.name
    });
  }
  get size() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tableStyle() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tableStyle(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte
var file47 = "node_modules/carbon-components-svelte/src/DataTable/TableBody.svelte";
function create_fragment48(ctx) {
  let tbody;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let tbody_levels = [{ "aria-live": "polite" }, ctx[0]];
  let tbody_data = {};
  for (let i = 0; i < tbody_levels.length; i += 1) {
    tbody_data = assign(tbody_data, tbody_levels[i]);
  }
  const block = {
    c: function create() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
      set_attributes(tbody, tbody_data);
      add_location(tbody, file47, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
        { "aria-live": "polite" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tbody);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableBody", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$scope, slots];
}
var TableBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableBody",
      options,
      id: create_fragment48.name
    });
  }
};
var TableBody_default = TableBody;

// node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte
var file48 = "node_modules/carbon-components-svelte/src/DataTable/TableCell.svelte";
function create_fragment49(ctx) {
  let td;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let td_levels = [ctx[0]];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      set_attributes(td, td_data);
      add_location(td, file48, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(td, "click", ctx[3], false, false, false),
          listen_dev(td, "mouseover", ctx[4], false, false, false),
          listen_dev(td, "mouseenter", ctx[5], false, false, false),
          listen_dev(td, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [dirty & 1 && ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableCell", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableCell",
      options,
      id: create_fragment49.name
    });
  }
};
var TableCell_default = TableCell;

// node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte
var file49 = "node_modules/carbon-components-svelte/src/DataTable/TableContainer.svelte";
function create_if_block29(ctx) {
  let div;
  let h4;
  let t0;
  let t1;
  let p;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      h4 = element("h4");
      t0 = text(ctx[0]);
      t1 = space();
      p = element("p");
      t2 = text(ctx[1]);
      toggle_class(h4, "bx--data-table-header__title", true);
      add_location(h4, file49, 22, 6, 585);
      toggle_class(p, "bx--data-table-header__description", true);
      add_location(p, file49, 23, 6, 652);
      toggle_class(div, "bx--data-table-header", true);
      add_location(div, file49, 21, 4, 536);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h4);
      append_dev(h4, t0);
      append_dev(div, t1);
      append_dev(div, p);
      append_dev(p, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t0, ctx2[0]);
      if (dirty & 2)
        set_data_dev(t2, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(21:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let div;
  let t;
  let current;
  let if_block = ctx[0] && create_if_block29(ctx);
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[4]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--data-table-container", true);
      toggle_class(div, "bx--data-table-container--static", ctx[3]);
      toggle_class(div, "bx--data-table--max-width", ctx[2]);
      add_location(div, file49, 14, 0, 339);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 16 && ctx2[4]]));
      toggle_class(div, "bx--data-table-container", true);
      toggle_class(div, "bx--data-table-container--static", ctx2[3]);
      toggle_class(div, "bx--data-table--max-width", ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "description", "stickyHeader", "useStaticWidth"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableContainer", slots, ["default"]);
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { stickyHeader = false } = $$props;
  let { useStaticWidth = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("description" in $$new_props)
      $$invalidate(1, description = $$new_props.description);
    if ("stickyHeader" in $$new_props)
      $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$new_props)
      $$invalidate(3, useStaticWidth = $$new_props.useStaticWidth);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    description,
    stickyHeader,
    useStaticWidth
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("description" in $$props)
      $$invalidate(1, description = $$new_props.description);
    if ("stickyHeader" in $$props)
      $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$props)
      $$invalidate(3, useStaticWidth = $$new_props.useStaticWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, description, stickyHeader, useStaticWidth, $$restProps, $$scope, slots];
}
var TableContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      title: 0,
      description: 1,
      stickyHeader: 2,
      useStaticWidth: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableContainer",
      options,
      id: create_fragment50.name
    });
  }
  get title() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<TableContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<TableContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableContainer_default = TableContainer;

// node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte
var file50 = "node_modules/carbon-components-svelte/src/DataTable/TableHead.svelte";
function create_fragment51(ctx) {
  let thead;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let thead_levels = [ctx[0]];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
      set_attributes(thead, thead_data);
      add_location(thead, file50, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(thead, "click", ctx[3], false, false, false),
          listen_dev(thead, "mouseover", ctx[4], false, false, false),
          listen_dev(thead, "mouseenter", ctx[5], false, false, false),
          listen_dev(thead, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & 1 && ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(thead);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHead", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHead",
      options,
      id: create_fragment51.name
    });
  }
};
var TableHead_default = TableHead;

// node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte
var file51 = "node_modules/carbon-components-svelte/src/icons/ArrowUp.svelte";
function create_if_block30(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file51, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment52(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block30(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M16 4L6 14 7.41 15.41 15 7.83 15 28 17 28 17 7.83 24.59 15.41 26 14 16 4z");
      add_location(path, file51, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file51, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowUp", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ArrowUp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUp",
      options,
      id: create_fragment52.name
    });
  }
  get size() {
    throw new Error("<ArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowUp_default = ArrowUp;

// node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte
var file52 = "node_modules/carbon-components-svelte/src/icons/ArrowsVertical.svelte";
function create_if_block31(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file52, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block31(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M27.6 20.6L24 24.2 24 4 22 4 22 24.2 18.4 20.6 17 22 23 28 29 22zM9 4L3 10 4.4 11.4 8 7.8 8 28 10 28 10 7.8 13.6 11.4 15 10z");
      add_location(path, file52, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file52, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block31(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ArrowsVertical", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ArrowsVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowsVertical",
      options,
      id: create_fragment53.name
    });
  }
  get size() {
    throw new Error("<ArrowsVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ArrowsVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ArrowsVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ArrowsVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ArrowsVertical_default = ArrowsVertical;

// node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte
var file53 = "node_modules/carbon-components-svelte/src/DataTable/TableHeader.svelte";
function create_else_block13(ctx) {
  let th;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let th_levels = [
    { scope: ctx[3] },
    { "data-header": ctx[4] },
    ctx[6]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      div = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div, "bx--table-header-label", true);
      add_location(div, file53, 76, 4, 1748);
      set_attributes(th, th_data);
      add_location(th, file53, 67, 2, 1606);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      append_dev(th, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(th, "click", ctx[14], false, false, false),
          listen_dev(th, "mouseover", ctx[15], false, false, false),
          listen_dev(th, "mouseenter", ctx[16], false, false, false),
          listen_dev(th, "mouseleave", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & 8) && { scope: ctx2[3] },
        (!current || dirty & 16) && { "data-header": ctx2[4] },
        dirty & 64 && ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(67:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let th;
  let button;
  let div;
  let t0;
  let arrowup;
  let t1;
  let arrowsvertical;
  let th_aria_sort_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  arrowup = new ArrowUp_default({
    props: {
      size: 20,
      "aria-label": ctx[5],
      class: "bx--table-sort__icon"
    },
    $$inline: true
  });
  arrowsvertical = new ArrowsVertical_default({
    props: {
      size: 20,
      "aria-label": ctx[5],
      class: "bx--table-sort__icon-unsorted"
    },
    $$inline: true
  });
  let th_levels = [
    {
      "aria-sort": th_aria_sort_value = ctx[2] ? ctx[1] : "none"
    },
    { scope: ctx[3] },
    { "data-header": ctx[4] },
    ctx[6]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      button = element("button");
      div = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(arrowup.$$.fragment);
      t1 = space();
      create_component(arrowsvertical.$$.fragment);
      toggle_class(div, "bx--table-header-label", true);
      add_location(div, file53, 51, 6, 1256);
      attr_dev(button, "type", "button");
      toggle_class(button, "bx--table-sort", true);
      toggle_class(button, "bx--table-sort--active", ctx[2]);
      toggle_class(button, "bx--table-sort--ascending", ctx[2] && ctx[1] === "descending");
      add_location(button, file53, 43, 4, 1028);
      set_attributes(th, th_data);
      add_location(th, file53, 34, 2, 849);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      append_dev(th, button);
      append_dev(button, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(button, t0);
      mount_component(arrowup, button, null);
      append_dev(button, t1);
      mount_component(arrowsvertical, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[13], false, false, false),
          listen_dev(th, "mouseover", ctx[10], false, false, false),
          listen_dev(th, "mouseenter", ctx[11], false, false, false),
          listen_dev(th, "mouseleave", ctx[12], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      const arrowup_changes = {};
      if (dirty & 32)
        arrowup_changes["aria-label"] = ctx2[5];
      arrowup.$set(arrowup_changes);
      const arrowsvertical_changes = {};
      if (dirty & 32)
        arrowsvertical_changes["aria-label"] = ctx2[5];
      arrowsvertical.$set(arrowsvertical_changes);
      if (!current || dirty & 4) {
        toggle_class(button, "bx--table-sort--active", ctx2[2]);
      }
      if (!current || dirty & 6) {
        toggle_class(button, "bx--table-sort--ascending", ctx2[2] && ctx2[1] === "descending");
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & 6 && th_aria_sort_value !== (th_aria_sort_value = ctx2[2] ? ctx2[1] : "none")) && { "aria-sort": th_aria_sort_value },
        (!current || dirty & 8) && { scope: ctx2[3] },
        (!current || dirty & 16) && { "data-header": ctx2[4] },
        dirty & 64 && ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(arrowup.$$.fragment, local);
      transition_in(arrowsvertical.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(arrowup.$$.fragment, local);
      transition_out(arrowsvertical.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(arrowup);
      destroy_component(arrowsvertical);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(34:0) {#if sortable}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block32, create_else_block13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let ariaLabel;
  const omit_props_names = ["sortable", "sortDirection", "active", "scope", "translateWithId", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeader", slots, ["default"]);
  let { sortable = false } = $$props;
  let { sortDirection = "none" } = $$props;
  let { active = false } = $$props;
  let { scope = "col" } = $$props;
  let { translateWithId = () => "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sortable" in $$new_props)
      $$invalidate(0, sortable = $$new_props.sortable);
    if ("sortDirection" in $$new_props)
      $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("active" in $$new_props)
      $$invalidate(2, active = $$new_props.active);
    if ("scope" in $$new_props)
      $$invalidate(3, scope = $$new_props.scope);
    if ("translateWithId" in $$new_props)
      $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    sortable,
    sortDirection,
    active,
    scope,
    translateWithId,
    id,
    ArrowUp: ArrowUp_default,
    ArrowsVertical: ArrowsVertical_default,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("sortable" in $$props)
      $$invalidate(0, sortable = $$new_props.sortable);
    if ("sortDirection" in $$props)
      $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("active" in $$props)
      $$invalidate(2, active = $$new_props.active);
    if ("scope" in $$props)
      $$invalidate(3, scope = $$new_props.scope);
    if ("translateWithId" in $$props)
      $$invalidate(7, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("ariaLabel" in $$props)
      $$invalidate(5, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(5, ariaLabel = translateWithId());
    }
  };
  return [
    sortable,
    sortDirection,
    active,
    scope,
    id,
    ariaLabel,
    $$restProps,
    translateWithId,
    $$scope,
    slots,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var TableHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {
      sortable: 0,
      sortDirection: 1,
      active: 2,
      scope: 3,
      translateWithId: 7,
      id: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeader",
      options,
      id: create_fragment54.name
    });
  }
  get sortable() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDirection() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDirection(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scope() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scope(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableHeader_default = TableHeader;

// node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte
var file54 = "node_modules/carbon-components-svelte/src/DataTable/TableRow.svelte";
function create_fragment55(ctx) {
  let tr;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let tr_levels = [ctx[0]];
  let tr_data = {};
  for (let i = 0; i < tr_levels.length; i += 1) {
    tr_data = assign(tr_data, tr_levels[i]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      set_attributes(tr, tr_data);
      add_location(tr, file54, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", ctx[3], false, false, false),
          listen_dev(tr, "mouseover", ctx[4], false, false, false),
          listen_dev(tr, "mouseenter", ctx[5], false, false, false),
          listen_dev(tr, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(tr, tr_data = get_spread_update(tr_levels, [dirty & 1 && ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableRow", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TableRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableRow",
      options,
      id: create_fragment55.name
    });
  }
};
var TableRow_default = TableRow;

// node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte
var file55 = "node_modules/carbon-components-svelte/src/DataTable/DataTable.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i];
  child_ctx[68] = i;
  return child_ctx;
}
var get_expanded_row_slot_changes = (dirty) => ({
  row: dirty[0] & 201850880
});
var get_expanded_row_slot_context = (ctx) => ({ row: ctx[66] });
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[69] = list[i];
  child_ctx[71] = i;
  return child_ctx;
}
var get_cell_slot_changes_1 = (dirty) => ({
  row: dirty[0] & 201850880,
  cell: dirty[0] & 470286336,
  rowIndex: dirty[0] & 201850880,
  cellIndex: dirty[0] & 470286336
});
var get_cell_slot_context_1 = (ctx) => ({
  row: ctx[66],
  cell: ctx[69],
  rowIndex: ctx[68],
  cellIndex: ctx[71]
});
var get_cell_slot_changes = (dirty) => ({
  row: dirty[0] & 201850880,
  cell: dirty[0] & 470286336,
  rowIndex: dirty[0] & 201850880,
  cellIndex: dirty[0] & 470286336
});
var get_cell_slot_context = (ctx) => ({
  row: ctx[66],
  cell: ctx[69],
  rowIndex: ctx[68],
  cellIndex: ctx[71]
});
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[72] = list[i];
  return child_ctx;
}
var get_cell_header_slot_changes = (dirty) => ({ header: dirty[0] & 64 });
var get_cell_header_slot_context = (ctx) => ({ header: ctx[72] });
var get_description_slot_changes = (dirty) => ({});
var get_description_slot_context = (ctx) => ({});
var get_title_slot_changes2 = (dirty) => ({});
var get_title_slot_context2 = (ctx) => ({});
function create_if_block_132(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = (ctx[8] || ctx[38].title) && create_if_block_152(ctx);
  let if_block1 = (ctx[9] || ctx[38].description) && create_if_block_142(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div, "bx--data-table-header", true);
      add_location(div, file55, 262, 4, 8703);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8] || ctx2[38].title) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 256 | dirty[1] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_152(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[9] || ctx2[38].description) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 512 | dirty[1] & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_142(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(262:2) {#if title || $$slots.title || description || $$slots.description}",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let h4;
  let current;
  const title_slot_template = ctx[48].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[62], get_title_slot_context2);
  const title_slot_or_fallback = title_slot || fallback_block_42(ctx);
  const block = {
    c: function create() {
      h4 = element("h4");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      toggle_class(h4, "bx--data-table-header__title", true);
      add_location(h4, file55, 264, 8, 8789);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[2] & 1)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(title_slot_template, ctx2[62], dirty, get_title_slot_changes2),
            get_title_slot_context2
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty[0] & 256)) {
          title_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(264:6) {#if title || $$slots.title}",
    ctx
  });
  return block;
}
function fallback_block_42(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[8]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data_dev(t, ctx2[8]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_42.name,
    type: "fallback",
    source: "(266:29) {title}",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let p;
  let current;
  const description_slot_template = ctx[48].description;
  const description_slot = create_slot(description_slot_template, ctx, ctx[62], get_description_slot_context);
  const description_slot_or_fallback = description_slot || fallback_block_32(ctx);
  const block = {
    c: function create() {
      p = element("p");
      if (description_slot_or_fallback)
        description_slot_or_fallback.c();
      toggle_class(p, "bx--data-table-header__description", true);
      add_location(p, file55, 269, 8, 8963);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (description_slot_or_fallback) {
        description_slot_or_fallback.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (description_slot) {
        if (description_slot.p && (!current || dirty[2] & 1)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(description_slot_template, ctx2[62], dirty, get_description_slot_changes),
            get_description_slot_context
          );
        }
      } else {
        if (description_slot_or_fallback && description_slot_or_fallback.p && (!current || dirty[0] & 512)) {
          description_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(description_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(description_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (description_slot_or_fallback)
        description_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(269:6) {#if description || $$slots.description}",
    ctx
  });
  return block;
}
function fallback_block_32(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[9]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_32.name,
    type: "fallback",
    source: "(271:35) {description}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let th;
  let th_data_previous_value_value;
  let current;
  let if_block = ctx[12] && create_if_block_122(ctx);
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      attr_dev(th, "scope", "col");
      attr_dev(th, "data-previous-value", th_data_previous_value_value = ctx[22] ? "collapsed" : void 0);
      toggle_class(th, "bx--table-expand", true);
      add_location(th, file55, 287, 10, 9410);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[12]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_122(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(th, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4194304 && th_data_previous_value_value !== (th_data_previous_value_value = ctx2[22] ? "collapsed" : void 0)) {
        attr_dev(th, "data-previous-value", th_data_previous_value_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(287:8) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let button;
  let chevronright;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: { class: "bx--table-expand__svg" },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(chevronright.$$.fragment);
      attr_dev(button, "type", "button");
      toggle_class(button, "bx--table-expand__button", true);
      add_location(button, file55, 293, 14, 9612);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      mount_component(chevronright, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[49], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(chevronright);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(293:12) {#if batchExpansion}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      attr_dev(th, "scope", "col");
      add_location(th, file55, 309, 10, 10142);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(309:8) {#if selectable && !batchSelection}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let th;
  let inlinecheckbox;
  let updating_ref;
  let current;
  function inlinecheckbox_ref_binding(value) {
    ctx[50](value);
  }
  let inlinecheckbox_props = {
    "aria-label": "Select all rows",
    checked: ctx[30],
    indeterminate: ctx[29]
  };
  if (ctx[24] !== void 0) {
    inlinecheckbox_props.ref = ctx[24];
  }
  inlinecheckbox = new InlineCheckbox_default({
    props: inlinecheckbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inlinecheckbox, "ref", inlinecheckbox_ref_binding));
  inlinecheckbox.$on("change", ctx[51]);
  const block = {
    c: function create() {
      th = element("th");
      create_component(inlinecheckbox.$$.fragment);
      attr_dev(th, "scope", "col");
      toggle_class(th, "bx--table-column-checkbox", true);
      add_location(th, file55, 312, 10, 10227);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      mount_component(inlinecheckbox, th, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const inlinecheckbox_changes = {};
      if (dirty[0] & 1073741824)
        inlinecheckbox_changes.checked = ctx2[30];
      if (dirty[0] & 536870912)
        inlinecheckbox_changes.indeterminate = ctx2[29];
      if (!updating_ref && dirty[0] & 16777216) {
        updating_ref = true;
        inlinecheckbox_changes.ref = ctx2[24];
        add_flush_callback(() => updating_ref = false);
      }
      inlinecheckbox.$set(inlinecheckbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inlinecheckbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inlinecheckbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      destroy_component(inlinecheckbox);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(312:8) {#if batchSelection && !radio}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let tableheader;
  let current;
  function click_handler_13() {
    return ctx[52](ctx[72]);
  }
  tableheader = new TableHeader_default({
    props: {
      id: ctx[72].key,
      style: ctx[36](ctx[72]),
      sortable: ctx[11] && ctx[72].sort !== false,
      sortDirection: ctx[0] === ctx[72].key ? ctx[1] : "none",
      active: ctx[0] === ctx[72].key,
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tableheader.$on("click", click_handler_13);
  const block = {
    c: function create() {
      create_component(tableheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tableheader, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tableheader_changes = {};
      if (dirty[0] & 64)
        tableheader_changes.id = ctx[72].key;
      if (dirty[0] & 64)
        tableheader_changes.style = ctx[36](ctx[72]);
      if (dirty[0] & 2112)
        tableheader_changes.sortable = ctx[11] && ctx[72].sort !== false;
      if (dirty[0] & 67)
        tableheader_changes.sortDirection = ctx[0] === ctx[72].key ? ctx[1] : "none";
      if (dirty[0] & 65)
        tableheader_changes.active = ctx[0] === ctx[72].key;
      if (dirty[0] & 64 | dirty[2] & 1) {
        tableheader_changes.$$scope = { dirty, ctx };
      }
      tableheader.$set(tableheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tableheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tableheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tableheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(344:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let th;
  let th_style_value;
  const block = {
    c: function create() {
      th = element("th");
      attr_dev(th, "scope", "col");
      attr_dev(th, "style", th_style_value = ctx[36](ctx[72]));
      add_location(th, file55, 342, 12, 11210);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64 && th_style_value !== (th_style_value = ctx2[36](ctx2[72]))) {
        attr_dev(th, "style", th_style_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(342:10) {#if header.empty}",
    ctx
  });
  return block;
}
function fallback_block_23(ctx) {
  let t_value = ctx[72].value + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64 && t_value !== (t_value = ctx2[72].value + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_23.name,
    type: "fallback",
    source: "(366:57) {header.value}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let t;
  let current;
  const cell_header_slot_template = ctx[48]["cell-header"];
  const cell_header_slot = create_slot(cell_header_slot_template, ctx, ctx[62], get_cell_header_slot_context);
  const cell_header_slot_or_fallback = cell_header_slot || fallback_block_23(ctx);
  const block = {
    c: function create() {
      if (cell_header_slot_or_fallback)
        cell_header_slot_or_fallback.c();
      t = space();
    },
    m: function mount(target, anchor) {
      if (cell_header_slot_or_fallback) {
        cell_header_slot_or_fallback.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_header_slot) {
        if (cell_header_slot.p && (!current || dirty[0] & 64 | dirty[2] & 1)) {
          update_slot_base(
            cell_header_slot,
            cell_header_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(cell_header_slot_template, ctx2[62], dirty, get_cell_header_slot_changes),
            get_cell_header_slot_context
          );
        }
      } else {
        if (cell_header_slot_or_fallback && cell_header_slot_or_fallback.p && (!current || dirty[0] & 64)) {
          cell_header_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cell_header_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_header_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (cell_header_slot_or_fallback)
        cell_header_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: `(345:12) <TableHeader               id=\\"{header.key}\\"               style=\\"{formatHeaderWidth(header)}\\"               sortable=\\"{sortable && header.sort !== false}\\"               sortDirection=\\"{sortKey === header.key ? sortDirection : 'none'}\\"               active=\\"{sortKey === header.key}\\"               on:click=\\"{() => {                 dispatch('click', { header });                  if (header.sort === false) {                   dispatch('click:header', { header });                 } else {                   let currentSortDirection =                     sortKey === header.key ? sortDirection : 'none';                   sortDirection = sortDirectionMap[currentSortDirection];                   sortKey =                     sortDirection === 'none' ? null : thKeys[header.key];                   dispatch('click:header', { header, sortDirection });                 }               }}\\"             >`,
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_8, create_else_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[72].empty)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(341:8) {#each headers as header (header.key)}",
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let t0;
  let t1;
  let t2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block0 = ctx[4] && create_if_block_11(ctx);
  let if_block1 = ctx[5] && !ctx[15] && create_if_block_10(ctx);
  let if_block2 = ctx[15] && !ctx[14] && create_if_block_9(ctx);
  let each_value_2 = ctx[6];
  validate_each_argument(each_value_2);
  const get_key = (ctx2) => ctx2[72].key;
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_11(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[5] && !ctx2[15]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[15] && !ctx2[14]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & 2115 | dirty[1] & 46 | dirty[2] & 1) {
        each_value_2 = ctx2[6];
        validate_each_argument(each_value_2);
        group_outros();
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: "(286:6) <TableRow>",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablerow.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & 1634785407 | dirty[1] & 2 | dirty[2] & 1) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(285:4) <TableHead>",
    ctx
  });
  return block;
}
function create_if_block_62(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      class: "bx--table-expand",
      headers: "expand",
      "data-previous-value": !ctx[13].includes(ctx[66].id) && ctx[31][ctx[66].id] ? "collapsed" : void 0,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecell_changes = {};
      if (dirty[0] & 201859072 | dirty[1] & 1)
        tablecell_changes["data-previous-value"] = !ctx2[13].includes(ctx2[66].id) && ctx2[31][ctx2[66].id] ? "collapsed" : void 0;
      if (dirty[0] & 201859076 | dirty[1] & 1 | dirty[2] & 1) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(404:10) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let button;
  let chevronright;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  chevronright = new ChevronRight_default({
    props: { class: "bx--table-expand__svg" },
    $$inline: true
  });
  function click_handler_2() {
    return ctx[53](ctx[66]);
  }
  const block = {
    c: function create() {
      button = element("button");
      create_component(chevronright.$$.fragment);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", button_aria_label_value = ctx[31][ctx[66].id] ? "Collapse current row" : "Expand current row");
      toggle_class(button, "bx--table-expand__button", true);
      add_location(button, file55, 413, 16, 13943);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      mount_component(chevronright, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", stop_propagation(click_handler_2), false, false, true);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 201850880 | dirty[1] & 1 && button_aria_label_value !== (button_aria_label_value = ctx[31][ctx[66].id] ? "Collapse current row" : "Expand current row")) {
        attr_dev(button, "aria-label", button_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(chevronright);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(413:14) {#if !nonExpandableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let show_if = !ctx[13].includes(ctx[66].id);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_7(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 201859072)
        show_if = !ctx2[13].includes(ctx2[66].id);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 201859072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: `(405:12) <TableCell               class=\\"bx--table-expand\\"               headers=\\"expand\\"               data-previous-value=\\"{!nonExpandableRowIds.includes(row.id) &&               expandedRows[row.id]                 ? 'collapsed'                 : undefined}\\"             >`,
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let td;
  let show_if = !ctx[16].includes(ctx[66].id);
  let current;
  let if_block = show_if && create_if_block_44(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if (if_block)
        if_block.c();
      toggle_class(td, "bx--table-column-checkbox", true);
      toggle_class(td, "bx--table-column-radio", ctx[14]);
      add_location(td, file55, 438, 12, 14853);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (if_block)
        if_block.m(td, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 201916416)
        show_if = !ctx2[16].includes(ctx2[66].id);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 201916416) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_44(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(td, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 16384) {
        toggle_class(td, "bx--table-column-radio", ctx2[14]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(438:10) {#if selectable}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_52, create_else_block_12];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[14])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(443:14) {#if !nonSelectableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_else_block_12(ctx) {
  let inlinecheckbox;
  let current;
  function change_handler_2() {
    return ctx[55](ctx[66]);
  }
  inlinecheckbox = new InlineCheckbox_default({
    props: {
      name: "select-row-" + ctx[66].id,
      checked: ctx[3].includes(ctx[66].id)
    },
    $$inline: true
  });
  inlinecheckbox.$on("change", change_handler_2);
  const block = {
    c: function create() {
      create_component(inlinecheckbox.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(inlinecheckbox, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const inlinecheckbox_changes = {};
      if (dirty[0] & 201850880)
        inlinecheckbox_changes.name = "select-row-" + ctx[66].id;
      if (dirty[0] & 201850888)
        inlinecheckbox_changes.checked = ctx[3].includes(ctx[66].id);
      inlinecheckbox.$set(inlinecheckbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inlinecheckbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inlinecheckbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inlinecheckbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(453:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let radiobutton;
  let current;
  function change_handler_1() {
    return ctx[54](ctx[66]);
  }
  radiobutton = new RadioButton_default({
    props: {
      name: "select-row-" + ctx[66].id,
      checked: ctx[3].includes(ctx[66].id)
    },
    $$inline: true
  });
  radiobutton.$on("change", change_handler_1);
  const block = {
    c: function create() {
      create_component(radiobutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(radiobutton, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const radiobutton_changes = {};
      if (dirty[0] & 201850880)
        radiobutton_changes.name = "select-row-" + ctx[66].id;
      if (dirty[0] & 201850888)
        radiobutton_changes.checked = ctx[3].includes(ctx[66].id);
      radiobutton.$set(radiobutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(444:16) {#if radio}",
    ctx
  });
  return block;
}
function create_else_block14(ctx) {
  let tablecell;
  let current;
  function click_handler_3() {
    return ctx[56](ctx[66], ctx[69]);
  }
  tablecell = new TableCell_default({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablecell.$on("click", click_handler_3);
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tablecell_changes = {};
      if (dirty[0] & 470286336 | dirty[2] & 1) {
        tablecell_changes.$$scope = { dirty, ctx };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(486:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let td;
  let t;
  let current;
  const cell_slot_template = ctx[48].cell;
  const cell_slot = create_slot(cell_slot_template, ctx, ctx[62], get_cell_slot_context);
  const cell_slot_or_fallback = cell_slot || fallback_block9(ctx);
  const block = {
    c: function create() {
      td = element("td");
      if (cell_slot_or_fallback)
        cell_slot_or_fallback.c();
      t = space();
      toggle_class(td, "bx--table-column-menu", ctx[6][ctx[71]].columnMenu);
      add_location(td, file55, 474, 14, 16350);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (cell_slot_or_fallback) {
        cell_slot_or_fallback.m(td, null);
      }
      append_dev(td, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_slot) {
        if (cell_slot.p && (!current || dirty[0] & 470286336 | dirty[2] & 1)) {
          update_slot_base(
            cell_slot,
            cell_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(cell_slot_template, ctx2[62], dirty, get_cell_slot_changes),
            get_cell_slot_context
          );
        }
      } else {
        if (cell_slot_or_fallback && cell_slot_or_fallback.p && (!current || dirty[0] & 470286336)) {
          cell_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 470286400) {
        toggle_class(td, "bx--table-column-menu", ctx2[6][ctx2[71]].columnMenu);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cell_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (cell_slot_or_fallback)
        cell_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(474:12) {#if headers[j].empty}",
    ctx
  });
  return block;
}
function fallback_block_14(ctx) {
  let t_value = (ctx[69].display ? ctx[69].display(ctx[69].value) : ctx[69].value) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 470286336 && t_value !== (t_value = (ctx2[69].display ? ctx2[69].display(ctx2[69].value) : ctx2[69].value) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_14.name,
    type: "fallback",
    source: "(499:17)                    ",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t;
  let current;
  const cell_slot_template = ctx[48].cell;
  const cell_slot = create_slot(cell_slot_template, ctx, ctx[62], get_cell_slot_context_1);
  const cell_slot_or_fallback = cell_slot || fallback_block_14(ctx);
  const block = {
    c: function create() {
      if (cell_slot_or_fallback)
        cell_slot_or_fallback.c();
      t = space();
    },
    m: function mount(target, anchor) {
      if (cell_slot_or_fallback) {
        cell_slot_or_fallback.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cell_slot) {
        if (cell_slot.p && (!current || dirty[0] & 470286336 | dirty[2] & 1)) {
          update_slot_base(
            cell_slot,
            cell_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(cell_slot_template, ctx2[62], dirty, get_cell_slot_changes_1),
            get_cell_slot_context_1
          );
        }
      } else {
        if (cell_slot_or_fallback && cell_slot_or_fallback.p && (!current || dirty[0] & 470286336)) {
          cell_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cell_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cell_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (cell_slot_or_fallback)
        cell_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: `(487:14) <TableCell                 on:click=\\"{() => {                   dispatch('click', { row, cell });                   dispatch('click:cell', cell);                 }}\\"               >`,
    ctx
  });
  return block;
}
function fallback_block9(ctx) {
  let t_value = (ctx[69].display ? ctx[69].display(ctx[69].value) : ctx[69].value) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 470286336 && t_value !== (t_value = (ctx2[69].display ? ctx2[69].display(ctx2[69].value) : ctx2[69].value) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block9.name,
    type: "fallback",
    source: "(482:17)                    ",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_27, create_else_block14];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[6][ctx2[71]].empty)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(473:10) {#each tableCellsByRowId[row.id] as cell, j (cell.key)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t0;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block0 = ctx[4] && create_if_block_62(ctx);
  let if_block1 = ctx[5] && create_if_block_34(ctx);
  let each_value_1 = ctx[28][ctx[66].id];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[69].key;
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_62(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & 470286400 | dirty[1] & 8 | dirty[2] & 1) {
        each_value_1 = ctx2[28][ctx2[66].id];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: `(374:8) <TableRow           data-row=\\"{row.id}\\"           data-parent-row=\\"{expandable ? true : undefined}\\"           class=\\"{selectedRowIds.includes(row.id)             ? 'bx--data-table--selected'             : ''} {expandedRows[row.id] ? 'bx--expandable-row' : ''} {expandable             ? 'bx--parent-row'             : ''} {expandable && parentRowId === row.id             ? 'bx--expandable-row--hover'             : ''}\\"           on:click=\\"{({ target }) => {             // forgo \\"click\\", \\"click:row\\" events if target             // resembles an overflow menu, a checkbox, or radio button             if (               [...target.classList].some((name) =>                 /^bx--(overflow-menu|checkbox|radio-button)/.test(name)               )             ) {               return;             }             dispatch('click', { row });             dispatch('click:row', row);           }}\\"           on:mouseenter=\\"{() => {             dispatch('mouseenter:row', row);           }}\\"           on:mouseleave=\\"{() => {             dispatch('mouseleave:row', row);           }}\\"         >`,
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let tr;
  let show_if = ctx[31][ctx[66].id] && !ctx[13].includes(ctx[66].id);
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block_111(ctx);
  function mouseenter_handler_1() {
    return ctx[60](ctx[66]);
  }
  function mouseleave_handler_1() {
    return ctx[61](ctx[66]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (if_block)
        if_block.c();
      t = space();
      attr_dev(tr, "data-child-row", "");
      toggle_class(tr, "bx--expandable-row", true);
      add_location(tr, file55, 507, 10, 17356);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (if_block)
        if_block.m(tr, null);
      append_dev(tr, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(tr, "mouseenter", mouseenter_handler_1, false, false, false),
          listen_dev(tr, "mouseleave", mouseleave_handler_1, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 201859072 | dirty[1] & 1)
        show_if = ctx[31][ctx[66].id] && !ctx[13].includes(ctx[66].id);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 201859072 | dirty[1] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_111(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(507:8) {#if expandable}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      colspan: ctx[5] ? ctx[6].length + 2 : ctx[6].length + 1,
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecell_changes = {};
      if (dirty[0] & 96)
        tablecell_changes.colspan = ctx2[5] ? ctx2[6].length + 2 : ctx2[6].length + 1;
      if (dirty[0] & 201850880 | dirty[2] & 1) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(520:12) {#if expandedRows[row.id] && !nonExpandableRowIds.includes(row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let div;
  let current;
  const expanded_row_slot_template = ctx[48]["expanded-row"];
  const expanded_row_slot = create_slot(expanded_row_slot_template, ctx, ctx[62], get_expanded_row_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (expanded_row_slot)
        expanded_row_slot.c();
      toggle_class(div, "bx--child-row-inner-container", true);
      add_location(div, file55, 523, 16, 17965);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (expanded_row_slot) {
        expanded_row_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (expanded_row_slot) {
        if (expanded_row_slot.p && (!current || dirty[0] & 201850880 | dirty[2] & 1)) {
          update_slot_base(
            expanded_row_slot,
            expanded_row_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(expanded_row_slot_template, ctx2[62], dirty, get_expanded_row_slot_changes),
            get_expanded_row_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(expanded_row_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(expanded_row_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (expanded_row_slot)
        expanded_row_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: '(521:14) <TableCell                 colspan=\\"{selectable ? headers.length + 2 : headers.length + 1}\\"               >',
    ctx
  });
  return block;
}
function create_each_block6(key_1, ctx) {
  let first;
  let tablerow;
  let t;
  let if_block_anchor;
  let current;
  function click_handler_4(...args) {
    return ctx[57](ctx[66], ...args);
  }
  function mouseenter_handler() {
    return ctx[58](ctx[66]);
  }
  function mouseleave_handler() {
    return ctx[59](ctx[66]);
  }
  tablerow = new TableRow_default({
    props: {
      "data-row": ctx[66].id,
      "data-parent-row": ctx[4] ? true : void 0,
      class: (ctx[3].includes(ctx[66].id) ? "bx--data-table--selected" : "") + " " + (ctx[31][ctx[66].id] ? "bx--expandable-row" : "") + " " + (ctx[4] ? "bx--parent-row" : "") + " " + (ctx[4] && ctx[23] === ctx[66].id ? "bx--expandable-row--hover" : ""),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablerow.$on("click", click_handler_4);
  tablerow.$on("mouseenter", mouseenter_handler);
  tablerow.$on("mouseleave", mouseleave_handler);
  let if_block = ctx[4] && create_if_block33(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(tablerow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(tablerow, target, anchor);
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tablerow_changes = {};
      if (dirty[0] & 201850880)
        tablerow_changes["data-row"] = ctx[66].id;
      if (dirty[0] & 16)
        tablerow_changes["data-parent-row"] = ctx[4] ? true : void 0;
      if (dirty[0] & 210239512 | dirty[1] & 1)
        tablerow_changes.class = (ctx[3].includes(ctx[66].id) ? "bx--data-table--selected" : "") + " " + (ctx[31][ctx[66].id] ? "bx--expandable-row" : "") + " " + (ctx[4] ? "bx--parent-row" : "") + " " + (ctx[4] && ctx[23] === ctx[66].id ? "bx--expandable-row--hover" : "");
      if (dirty[0] & 470376572 | dirty[1] & 1 | dirty[2] & 1) {
        tablerow_changes.$$scope = { dirty, ctx };
      }
      tablerow.$set(tablerow_changes);
      if (ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block33(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablerow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(tablerow, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(373:6) {#each sorting ? displayedSortedRows : displayedRows as row, i (row.id)}",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[19] ? ctx[26] : ctx[27];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[66].id;
  validate_each_keys(ctx, each_value, get_each_context6, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 478765180 | dirty[1] & 9 | dirty[2] & 1) {
        each_value = ctx2[19] ? ctx2[26] : ctx2[27];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context6, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block6, each_1_anchor, get_each_context6);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(372:4) <TableBody>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let tablehead;
  let t;
  let tablebody;
  let current;
  tablehead = new TableHead_default({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablebody = new TableBody_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablehead.$$.fragment);
      t = space();
      create_component(tablebody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablehead, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(tablebody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablehead_changes = {};
      if (dirty[0] & 1634785407 | dirty[1] & 2 | dirty[2] & 1) {
        tablehead_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablehead.$set(tablehead_changes);
      const tablebody_changes = {};
      if (dirty[0] & 478765180 | dirty[1] & 1 | dirty[2] & 1) {
        tablebody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablebody.$set(tablebody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablehead.$$.fragment, local);
      transition_in(tablebody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablehead.$$.fragment, local);
      transition_out(tablebody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablehead, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tablebody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: `(277:2) <Table     zebra=\\"{zebra}\\"     size=\\"{size}\\"     stickyHeader=\\"{stickyHeader}\\"     sortable=\\"{sortable}\\"     useStaticWidth=\\"{useStaticWidth}\\"     tableStyle=\\"{hasCustomHeaderWidth && 'table-layout: fixed'}\\"   >`,
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t0;
  let t1;
  let table;
  let current;
  let if_block = (ctx[8] || ctx[38].title || ctx[9] || ctx[38].description) && create_if_block_132(ctx);
  const default_slot_template = ctx[48].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[62], null);
  table = new Table_default({
    props: {
      zebra: ctx[10],
      size: ctx[7],
      stickyHeader: ctx[17],
      sortable: ctx[11],
      useStaticWidth: ctx[18],
      tableStyle: ctx[25] && "table-layout: fixed",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(table.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t1, anchor);
      mount_component(table, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[8] || ctx2[38].title || ctx2[9] || ctx2[38].description) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 768 | dirty[1] & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_132(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[62],
            !current ? get_all_dirty_from_scope(ctx2[62]) : get_slot_changes(default_slot_template, ctx2[62], dirty, null),
            null
          );
        }
      }
      const table_changes = {};
      if (dirty[0] & 1024)
        table_changes.zebra = ctx2[10];
      if (dirty[0] & 128)
        table_changes.size = ctx2[7];
      if (dirty[0] & 131072)
        table_changes.stickyHeader = ctx2[17];
      if (dirty[0] & 2048)
        table_changes.sortable = ctx2[11];
      if (dirty[0] & 262144)
        table_changes.useStaticWidth = ctx2[18];
      if (dirty[0] & 33554432)
        table_changes.tableStyle = ctx2[25] && "table-layout: fixed";
      if (dirty[0] & 2113534079 | dirty[1] & 3 | dirty[2] & 1) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(table, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(261:0) <TableContainer useStaticWidth=\\"{useStaticWidth}\\" {...$$restProps}>',
    ctx
  });
  return block;
}
function create_fragment56(ctx) {
  let tablecontainer;
  let current;
  const tablecontainer_spread_levels = [
    {
      useStaticWidth: ctx[18]
    },
    ctx[37]
  ];
  let tablecontainer_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tablecontainer_spread_levels.length; i += 1) {
    tablecontainer_props = assign(tablecontainer_props, tablecontainer_spread_levels[i]);
  }
  tablecontainer = new TableContainer_default({
    props: tablecontainer_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecontainer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(tablecontainer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecontainer_changes = dirty[0] & 262144 | dirty[1] & 64 ? get_spread_update(tablecontainer_spread_levels, [
        dirty[0] & 262144 && {
          useStaticWidth: ctx2[18]
        },
        dirty[1] & 64 && get_spread_object(ctx2[37])
      ]) : {};
      if (dirty[0] & 2147483647 | dirty[1] & 131 | dirty[2] & 1) {
        tablecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecontainer.$set(tablecontainer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let thKeys;
  let expandedRows;
  let rowIds;
  let expandableRowIds;
  let selectableRowIds;
  let selectAll;
  let indeterminate;
  let headerKeys;
  let tableCellsByRowId;
  let sortedRows;
  let ascending;
  let sorting;
  let sortingHeader;
  let displayedRows;
  let displayedSortedRows;
  let hasCustomHeaderWidth;
  const omit_props_names = [
    "headers",
    "rows",
    "size",
    "title",
    "description",
    "zebra",
    "sortable",
    "sortKey",
    "sortDirection",
    "expandable",
    "batchExpansion",
    "expandedRowIds",
    "nonExpandableRowIds",
    "radio",
    "selectable",
    "batchSelection",
    "selectedRowIds",
    "nonSelectableRowIds",
    "stickyHeader",
    "useStaticWidth",
    "pageSize",
    "page"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tableRows;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTable", slots, ["title", "description", "default", "cell-header", "cell", "expanded-row"]);
  const $$slots = compute_slots(slots);
  let { headers = [] } = $$props;
  let { rows = [] } = $$props;
  let { size = void 0 } = $$props;
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { zebra = false } = $$props;
  let { sortable = false } = $$props;
  let { sortKey = null } = $$props;
  let { sortDirection = "none" } = $$props;
  let { expandable = false } = $$props;
  let { batchExpansion = false } = $$props;
  let { expandedRowIds = [] } = $$props;
  let { nonExpandableRowIds = [] } = $$props;
  let { radio = false } = $$props;
  let { selectable = false } = $$props;
  let { batchSelection = false } = $$props;
  let { selectedRowIds = [] } = $$props;
  let { nonSelectableRowIds = [] } = $$props;
  let { stickyHeader = false } = $$props;
  let { useStaticWidth = false } = $$props;
  let { pageSize = 0 } = $$props;
  let { page = 0 } = $$props;
  const sortDirectionMap = {
    none: "ascending",
    ascending: "descending",
    descending: "none"
  };
  const dispatch = createEventDispatcher();
  const batchSelectedIds = writable(false);
  const tableRows = writable(rows);
  validate_store(tableRows, "tableRows");
  component_subscribe($$self, tableRows, (value) => $$invalidate(47, $tableRows = value));
  const resolvePath = (object, path) => {
    if (path in object)
      return object[path];
    return path.split(/[\.\[\]\'\"]/).filter((p) => p).reduce((o, p) => o && typeof o === "object" ? o[p] : o, object);
  };
  setContext("DataTable", {
    batchSelectedIds,
    tableRows,
    resetSelectedRowIds: () => {
      $$invalidate(30, selectAll = false);
      $$invalidate(3, selectedRowIds = []);
      if (refSelectAll)
        $$invalidate(24, refSelectAll.checked = false, refSelectAll);
    }
  });
  let expanded = false;
  let parentRowId = null;
  let refSelectAll = null;
  const getDisplayedRows = (rows2, page2, pageSize2) => page2 && pageSize2 ? rows2.slice((page2 - 1) * pageSize2, page2 * pageSize2) : rows2;
  const formatHeaderWidth = (header) => {
    const styles = [
      header.width && `width: ${header.width}`,
      header.minWidth && `min-width: ${header.minWidth}`
    ].filter(Boolean);
    if (styles.length === 0)
      return void 0;
    return styles.join(";");
  };
  const click_handler = () => {
    $$invalidate(22, expanded = !expanded);
    $$invalidate(2, expandedRowIds = expanded ? expandableRowIds : []);
    dispatch("click:header--expand", { expanded });
  };
  function inlinecheckbox_ref_binding(value) {
    refSelectAll = value;
    $$invalidate(24, refSelectAll);
  }
  const change_handler = (e) => {
    dispatch("click:header--select", {
      indeterminate,
      selected: !indeterminate && e.target.checked
    });
    if (indeterminate) {
      e.target.checked = false;
      $$invalidate(30, selectAll = false);
      $$invalidate(3, selectedRowIds = []);
      return;
    }
    if (e.target.checked) {
      $$invalidate(3, selectedRowIds = selectableRowIds);
    } else {
      $$invalidate(3, selectedRowIds = []);
    }
  };
  const click_handler_13 = (header) => {
    dispatch("click", { header });
    if (header.sort === false) {
      dispatch("click:header", { header });
    } else {
      let currentSortDirection = sortKey === header.key ? sortDirection : "none";
      $$invalidate(1, sortDirection = sortDirectionMap[currentSortDirection]);
      $$invalidate(0, sortKey = sortDirection === "none" ? null : thKeys[header.key]);
      dispatch("click:header", { header, sortDirection });
    }
  };
  const click_handler_2 = (row) => {
    const rowExpanded = !!expandedRows[row.id];
    $$invalidate(2, expandedRowIds = rowExpanded ? expandedRowIds.filter((id) => id !== row.id) : [...expandedRowIds, row.id]);
    dispatch("click:row--expand", { row, expanded: !rowExpanded });
  };
  const change_handler_1 = (row) => {
    $$invalidate(3, selectedRowIds = [row.id]);
    dispatch("click:row--select", { row, selected: true });
  };
  const change_handler_2 = (row) => {
    if (selectedRowIds.includes(row.id)) {
      $$invalidate(3, selectedRowIds = selectedRowIds.filter((id) => id !== row.id));
      dispatch("click:row--select", { row, selected: false });
    } else {
      $$invalidate(3, selectedRowIds = [...selectedRowIds, row.id]);
      dispatch("click:row--select", { row, selected: true });
    }
  };
  const click_handler_3 = (row, cell) => {
    dispatch("click", { row, cell });
    dispatch("click:cell", cell);
  };
  const click_handler_4 = (row, { target }) => {
    if ([...target.classList].some((name) => /^bx--(overflow-menu|checkbox|radio-button)/.test(name))) {
      return;
    }
    dispatch("click", { row });
    dispatch("click:row", row);
  };
  const mouseenter_handler = (row) => {
    dispatch("mouseenter:row", row);
  };
  const mouseleave_handler = (row) => {
    dispatch("mouseleave:row", row);
  };
  const mouseenter_handler_1 = (row) => {
    if (nonExpandableRowIds.includes(row.id))
      return;
    $$invalidate(23, parentRowId = row.id);
  };
  const mouseleave_handler_1 = (row) => {
    if (nonExpandableRowIds.includes(row.id))
      return;
    $$invalidate(23, parentRowId = null);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(37, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("headers" in $$new_props)
      $$invalidate(6, headers = $$new_props.headers);
    if ("rows" in $$new_props)
      $$invalidate(39, rows = $$new_props.rows);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(8, title = $$new_props.title);
    if ("description" in $$new_props)
      $$invalidate(9, description = $$new_props.description);
    if ("zebra" in $$new_props)
      $$invalidate(10, zebra = $$new_props.zebra);
    if ("sortable" in $$new_props)
      $$invalidate(11, sortable = $$new_props.sortable);
    if ("sortKey" in $$new_props)
      $$invalidate(0, sortKey = $$new_props.sortKey);
    if ("sortDirection" in $$new_props)
      $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("expandable" in $$new_props)
      $$invalidate(4, expandable = $$new_props.expandable);
    if ("batchExpansion" in $$new_props)
      $$invalidate(12, batchExpansion = $$new_props.batchExpansion);
    if ("expandedRowIds" in $$new_props)
      $$invalidate(2, expandedRowIds = $$new_props.expandedRowIds);
    if ("nonExpandableRowIds" in $$new_props)
      $$invalidate(13, nonExpandableRowIds = $$new_props.nonExpandableRowIds);
    if ("radio" in $$new_props)
      $$invalidate(14, radio = $$new_props.radio);
    if ("selectable" in $$new_props)
      $$invalidate(5, selectable = $$new_props.selectable);
    if ("batchSelection" in $$new_props)
      $$invalidate(15, batchSelection = $$new_props.batchSelection);
    if ("selectedRowIds" in $$new_props)
      $$invalidate(3, selectedRowIds = $$new_props.selectedRowIds);
    if ("nonSelectableRowIds" in $$new_props)
      $$invalidate(16, nonSelectableRowIds = $$new_props.nonSelectableRowIds);
    if ("stickyHeader" in $$new_props)
      $$invalidate(17, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$new_props)
      $$invalidate(18, useStaticWidth = $$new_props.useStaticWidth);
    if ("pageSize" in $$new_props)
      $$invalidate(40, pageSize = $$new_props.pageSize);
    if ("page" in $$new_props)
      $$invalidate(41, page = $$new_props.page);
    if ("$$scope" in $$new_props)
      $$invalidate(62, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    headers,
    rows,
    size,
    title,
    description,
    zebra,
    sortable,
    sortKey,
    sortDirection,
    expandable,
    batchExpansion,
    expandedRowIds,
    nonExpandableRowIds,
    radio,
    selectable,
    batchSelection,
    selectedRowIds,
    nonSelectableRowIds,
    stickyHeader,
    useStaticWidth,
    pageSize,
    page,
    createEventDispatcher,
    setContext,
    writable,
    ChevronRight: ChevronRight_default,
    InlineCheckbox: InlineCheckbox_default,
    RadioButton: RadioButton_default,
    Table: Table_default,
    TableBody: TableBody_default,
    TableCell: TableCell_default,
    TableContainer: TableContainer_default,
    TableHead: TableHead_default,
    TableHeader: TableHeader_default,
    TableRow: TableRow_default,
    sortDirectionMap,
    dispatch,
    batchSelectedIds,
    tableRows,
    resolvePath,
    expanded,
    parentRowId,
    refSelectAll,
    getDisplayedRows,
    formatHeaderWidth,
    hasCustomHeaderWidth,
    sortedRows,
    displayedSortedRows,
    displayedRows,
    ascending,
    sortingHeader,
    sorting,
    headerKeys,
    tableCellsByRowId,
    expandableRowIds,
    selectableRowIds,
    indeterminate,
    selectAll,
    rowIds,
    expandedRows,
    thKeys,
    $tableRows
  });
  $$self.$inject_state = ($$new_props) => {
    if ("headers" in $$props)
      $$invalidate(6, headers = $$new_props.headers);
    if ("rows" in $$props)
      $$invalidate(39, rows = $$new_props.rows);
    if ("size" in $$props)
      $$invalidate(7, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(8, title = $$new_props.title);
    if ("description" in $$props)
      $$invalidate(9, description = $$new_props.description);
    if ("zebra" in $$props)
      $$invalidate(10, zebra = $$new_props.zebra);
    if ("sortable" in $$props)
      $$invalidate(11, sortable = $$new_props.sortable);
    if ("sortKey" in $$props)
      $$invalidate(0, sortKey = $$new_props.sortKey);
    if ("sortDirection" in $$props)
      $$invalidate(1, sortDirection = $$new_props.sortDirection);
    if ("expandable" in $$props)
      $$invalidate(4, expandable = $$new_props.expandable);
    if ("batchExpansion" in $$props)
      $$invalidate(12, batchExpansion = $$new_props.batchExpansion);
    if ("expandedRowIds" in $$props)
      $$invalidate(2, expandedRowIds = $$new_props.expandedRowIds);
    if ("nonExpandableRowIds" in $$props)
      $$invalidate(13, nonExpandableRowIds = $$new_props.nonExpandableRowIds);
    if ("radio" in $$props)
      $$invalidate(14, radio = $$new_props.radio);
    if ("selectable" in $$props)
      $$invalidate(5, selectable = $$new_props.selectable);
    if ("batchSelection" in $$props)
      $$invalidate(15, batchSelection = $$new_props.batchSelection);
    if ("selectedRowIds" in $$props)
      $$invalidate(3, selectedRowIds = $$new_props.selectedRowIds);
    if ("nonSelectableRowIds" in $$props)
      $$invalidate(16, nonSelectableRowIds = $$new_props.nonSelectableRowIds);
    if ("stickyHeader" in $$props)
      $$invalidate(17, stickyHeader = $$new_props.stickyHeader);
    if ("useStaticWidth" in $$props)
      $$invalidate(18, useStaticWidth = $$new_props.useStaticWidth);
    if ("pageSize" in $$props)
      $$invalidate(40, pageSize = $$new_props.pageSize);
    if ("page" in $$props)
      $$invalidate(41, page = $$new_props.page);
    if ("expanded" in $$props)
      $$invalidate(22, expanded = $$new_props.expanded);
    if ("parentRowId" in $$props)
      $$invalidate(23, parentRowId = $$new_props.parentRowId);
    if ("refSelectAll" in $$props)
      $$invalidate(24, refSelectAll = $$new_props.refSelectAll);
    if ("hasCustomHeaderWidth" in $$props)
      $$invalidate(25, hasCustomHeaderWidth = $$new_props.hasCustomHeaderWidth);
    if ("sortedRows" in $$props)
      $$invalidate(42, sortedRows = $$new_props.sortedRows);
    if ("displayedSortedRows" in $$props)
      $$invalidate(26, displayedSortedRows = $$new_props.displayedSortedRows);
    if ("displayedRows" in $$props)
      $$invalidate(27, displayedRows = $$new_props.displayedRows);
    if ("ascending" in $$props)
      $$invalidate(43, ascending = $$new_props.ascending);
    if ("sortingHeader" in $$props)
      $$invalidate(44, sortingHeader = $$new_props.sortingHeader);
    if ("sorting" in $$props)
      $$invalidate(19, sorting = $$new_props.sorting);
    if ("headerKeys" in $$props)
      $$invalidate(45, headerKeys = $$new_props.headerKeys);
    if ("tableCellsByRowId" in $$props)
      $$invalidate(28, tableCellsByRowId = $$new_props.tableCellsByRowId);
    if ("expandableRowIds" in $$props)
      $$invalidate(20, expandableRowIds = $$new_props.expandableRowIds);
    if ("selectableRowIds" in $$props)
      $$invalidate(21, selectableRowIds = $$new_props.selectableRowIds);
    if ("indeterminate" in $$props)
      $$invalidate(29, indeterminate = $$new_props.indeterminate);
    if ("selectAll" in $$props)
      $$invalidate(30, selectAll = $$new_props.selectAll);
    if ("rowIds" in $$props)
      $$invalidate(46, rowIds = $$new_props.rowIds);
    if ("expandedRows" in $$props)
      $$invalidate(31, expandedRows = $$new_props.expandedRows);
    if ("thKeys" in $$props)
      $$invalidate(32, thKeys = $$new_props.thKeys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 64) {
      $:
        $$invalidate(32, thKeys = headers.reduce((a, c) => ({ ...a, [c.key]: c.key }), {}));
    }
    if ($$self.$$.dirty[0] & 4) {
      $:
        $$invalidate(31, expandedRows = expandedRowIds.reduce((a, id) => ({ ...a, [id]: true }), {}));
    }
    if ($$self.$$.dirty[0] & 8) {
      $:
        batchSelectedIds.set(selectedRowIds);
    }
    if ($$self.$$.dirty[0] & 64) {
      $:
        $$invalidate(45, headerKeys = headers.map(({ key }) => key));
    }
    if ($$self.$$.dirty[0] & 64 | $$self.$$.dirty[1] & 16640) {
      $:
        $$invalidate(28, tableCellsByRowId = rows.reduce(
          (rows2, row) => {
            rows2[row.id] = headerKeys.map((key, index) => ({
              key,
              value: resolvePath(row, key),
              display: headers[index].display
            }));
            return rows2;
          },
          {}
        ));
    }
    if ($$self.$$.dirty[1] & 256) {
      $:
        set_store_value(tableRows, $tableRows = rows, $tableRows);
    }
    if ($$self.$$.dirty[1] & 65536) {
      $:
        $$invalidate(46, rowIds = $tableRows.map((row) => row.id));
    }
    if ($$self.$$.dirty[0] & 8192 | $$self.$$.dirty[1] & 32768) {
      $:
        $$invalidate(20, expandableRowIds = rowIds.filter((id) => !nonExpandableRowIds.includes(id)));
    }
    if ($$self.$$.dirty[0] & 65536 | $$self.$$.dirty[1] & 32768) {
      $:
        $$invalidate(21, selectableRowIds = rowIds.filter((id) => !nonSelectableRowIds.includes(id)));
    }
    if ($$self.$$.dirty[0] & 2097160) {
      $:
        $$invalidate(30, selectAll = selectableRowIds.length > 0 && selectedRowIds.length === selectableRowIds.length);
    }
    if ($$self.$$.dirty[0] & 2097160) {
      $:
        $$invalidate(29, indeterminate = selectedRowIds.length > 0 && selectedRowIds.length < selectableRowIds.length);
    }
    if ($$self.$$.dirty[0] & 1052676) {
      $:
        if (batchExpansion) {
          $$invalidate(4, expandable = true);
          $$invalidate(22, expanded = expandedRowIds.length === expandableRowIds.length);
        }
    }
    if ($$self.$$.dirty[0] & 49152) {
      $:
        if (radio || batchSelection)
          $$invalidate(5, selectable = true);
    }
    if ($$self.$$.dirty[1] & 65536) {
      $:
        $$invalidate(42, sortedRows = [...$tableRows]);
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(43, ascending = sortDirection === "ascending");
    }
    if ($$self.$$.dirty[0] & 2049) {
      $:
        $$invalidate(19, sorting = sortable && sortKey != null);
    }
    if ($$self.$$.dirty[0] & 65) {
      $:
        $$invalidate(44, sortingHeader = headers.find((header) => header.key === sortKey));
    }
    if ($$self.$$.dirty[0] & 524291 | $$self.$$.dirty[1] & 77824) {
      $:
        if (sorting) {
          if (sortDirection === "none") {
            $$invalidate(42, sortedRows = $tableRows);
          } else {
            $$invalidate(42, sortedRows = [...$tableRows].sort((a, b) => {
              const itemA = ascending ? resolvePath(a, sortKey) : resolvePath(b, sortKey);
              const itemB = ascending ? resolvePath(b, sortKey) : resolvePath(a, sortKey);
              if (sortingHeader == null ? void 0 : sortingHeader.sort)
                return sortingHeader.sort(itemA, itemB);
              if (typeof itemA === "number" && typeof itemB === "number")
                return itemA - itemB;
              if ([itemA, itemB].every((item) => !item && item !== 0))
                return 0;
              if (!itemA && itemA !== 0)
                return ascending ? 1 : -1;
              if (!itemB && itemB !== 0)
                return ascending ? -1 : 1;
              return itemA.toString().localeCompare(itemB.toString(), "en", { numeric: true });
            }));
          }
        }
    }
    if ($$self.$$.dirty[1] & 67072) {
      $:
        $$invalidate(27, displayedRows = getDisplayedRows($tableRows, page, pageSize));
    }
    if ($$self.$$.dirty[1] & 3584) {
      $:
        $$invalidate(26, displayedSortedRows = getDisplayedRows(sortedRows, page, pageSize));
    }
    if ($$self.$$.dirty[0] & 64) {
      $:
        $$invalidate(25, hasCustomHeaderWidth = headers.some((header) => header.width || header.minWidth));
    }
  };
  return [
    sortKey,
    sortDirection,
    expandedRowIds,
    selectedRowIds,
    expandable,
    selectable,
    headers,
    size,
    title,
    description,
    zebra,
    sortable,
    batchExpansion,
    nonExpandableRowIds,
    radio,
    batchSelection,
    nonSelectableRowIds,
    stickyHeader,
    useStaticWidth,
    sorting,
    expandableRowIds,
    selectableRowIds,
    expanded,
    parentRowId,
    refSelectAll,
    hasCustomHeaderWidth,
    displayedSortedRows,
    displayedRows,
    tableCellsByRowId,
    indeterminate,
    selectAll,
    expandedRows,
    thKeys,
    sortDirectionMap,
    dispatch,
    tableRows,
    formatHeaderWidth,
    $$restProps,
    $$slots,
    rows,
    pageSize,
    page,
    sortedRows,
    ascending,
    sortingHeader,
    headerKeys,
    rowIds,
    $tableRows,
    slots,
    click_handler,
    inlinecheckbox_ref_binding,
    change_handler,
    click_handler_13,
    click_handler_2,
    change_handler_1,
    change_handler_2,
    click_handler_3,
    click_handler_4,
    mouseenter_handler,
    mouseleave_handler,
    mouseenter_handler_1,
    mouseleave_handler_1,
    $$scope
  ];
}
var DataTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance56,
      create_fragment56,
      safe_not_equal,
      {
        headers: 6,
        rows: 39,
        size: 7,
        title: 8,
        description: 9,
        zebra: 10,
        sortable: 11,
        sortKey: 0,
        sortDirection: 1,
        expandable: 4,
        batchExpansion: 12,
        expandedRowIds: 2,
        nonExpandableRowIds: 13,
        radio: 14,
        selectable: 5,
        batchSelection: 15,
        selectedRowIds: 3,
        nonSelectableRowIds: 16,
        stickyHeader: 17,
        useStaticWidth: 18,
        pageSize: 40,
        page: 41
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTable",
      options,
      id: create_fragment56.name
    });
  }
  get headers() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortKey() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortKey(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDirection() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDirection(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get batchExpansion() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set batchExpansion(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonExpandableRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonExpandableRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radio() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radio(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get batchSelection() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set batchSelection(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonSelectableRowIds() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonSelectableRowIds(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useStaticWidth() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useStaticWidth(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSize() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSize(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get page() {
    throw new Error("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTable_default = DataTable;

// node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte
var file56 = "node_modules/carbon-components-svelte/src/DataTable/DataTableSkeleton.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_if_block_28(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      toggle_class(div0, "bx--data-table-header__title", true);
      add_location(div0, file56, 51, 6, 1266);
      toggle_class(div1, "bx--data-table-header__description", true);
      add_location(div1, file56, 52, 6, 1328);
      toggle_class(div2, "bx--data-table-header", true);
      add_location(div2, file56, 50, 4, 1217);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(50:2) {#if showHeader}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let section;
  let div;
  let span;
  const block = {
    c: function create() {
      section = element("section");
      div = element("div");
      span = element("span");
      toggle_class(span, "bx--skeleton", true);
      toggle_class(span, "bx--btn", true);
      toggle_class(span, "bx--btn--sm", true);
      add_location(span, file56, 58, 8, 1563);
      toggle_class(div, "bx--toolbar-content", true);
      add_location(div, file56, 57, 6, 1514);
      attr_dev(section, "aria-label", "data table toolbar");
      toggle_class(section, "bx--table-toolbar", true);
      add_location(section, file56, 56, 4, 1433);
    },
    m: function mount(target, anchor) {
      insert_dev(target, section, anchor);
      append_dev(section, div);
      append_dev(div, span);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(56:2) {#if showToolbar}",
    ctx
  });
  return block;
}
function create_else_block15(ctx) {
  let th;
  let t_value = (ctx[6][ctx[17]] || "") + "";
  let t;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      add_location(th, file56, 84, 12, 2315);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      append_dev(th, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 96 && t_value !== (t_value = (ctx2[6][ctx2[17]] || "") + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(84:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      add_location(th, file56, 82, 12, 2275);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: '(82:10) {#if typeof values[col] === \\"object\\" && values[col].empty === true}',
    ctx
  });
  return block;
}
function create_each_block_22(key_1, ctx) {
  let first;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[6][ctx2[17]] === "object" && ctx2[6][ctx2[17]].empty === true)
      return create_if_block34;
    return create_else_block15;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_22.name,
    type: "each",
    source: "(81:8) {#each cols as col (col)}",
    ctx
  });
  return block;
}
function create_each_block_12(key_1, ctx) {
  let td;
  let span;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      td = element("td");
      span = element("span");
      add_location(span, file56, 93, 16, 2547);
      add_location(td, file56, 93, 12, 2543);
      this.first = td;
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      append_dev(td, span);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(93:10) {#each cols as col (col)}",
    ctx
  });
  return block;
}
function create_each_block7(key_1, ctx) {
  let tr;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value_1 = ctx[5];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[17];
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      add_location(tr, file56, 91, 8, 2490);
      this.first = tr;
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_dev(tr, t);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32) {
        each_value_1 = ctx[5];
        validate_each_argument(each_value_1);
        validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, destroy_block, create_each_block_12, t, get_each_context_12);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(91:6) {#each Array.from({ length: rows }, (_, i) => i) as row (row)}",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let div;
  let t0;
  let t1;
  let table;
  let thead;
  let tr;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t2;
  let tbody;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_28(ctx);
  let if_block1 = ctx[4] && create_if_block_112(ctx);
  let each_value_2 = ctx[5];
  validate_each_argument(each_value_2);
  const get_key = (ctx2) => ctx2[17];
  validate_each_keys(ctx, each_value_2, get_each_context_22, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_22(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_22(key, child_ctx));
  }
  let each_value = Array.from({ length: ctx[0] }, func3);
  validate_each_argument(each_value);
  const get_key_1 = (ctx2) => ctx2[14];
  validate_each_keys(ctx, each_value, get_each_context7, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  let div_levels = [ctx[7]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(tr, file56, 79, 6, 2146);
      add_location(thead, file56, 78, 4, 2132);
      add_location(tbody, file56, 89, 4, 2405);
      toggle_class(table, "bx--skeleton", true);
      toggle_class(table, "bx--data-table", true);
      toggle_class(table, "bx--data-table--compact", ctx[1] === "compact");
      toggle_class(table, "bx--data-table--short", ctx[1] === "short");
      toggle_class(table, "bx--data-table--tall", ctx[1] === "tall");
      toggle_class(table, "bx--data-table--zebra", ctx[2]);
      add_location(table, file56, 66, 2, 1782);
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--data-table-container", true);
      add_location(div, file56, 44, 0, 1096);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      append_dev(div, table);
      append_dev(table, thead);
      append_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr, null);
      }
      append_dev(table, t2);
      append_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(table, "click", ctx[10], false, false, false),
          listen_dev(table, "mouseover", ctx[11], false, false, false),
          listen_dev(table, "mouseenter", ctx[12], false, false, false),
          listen_dev(table, "mouseleave", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_28(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_112(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 96) {
        each_value_2 = ctx2[5];
        validate_each_argument(each_value_2);
        validate_each_keys(ctx2, each_value_2, get_each_context_22, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_2, each0_lookup, tr, destroy_block, create_each_block_22, null, get_each_context_22);
      }
      if (dirty & 33) {
        each_value = Array.from({ length: ctx2[0] }, func3);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context7, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx2, each_value, each1_lookup, tbody, destroy_block, create_each_block7, null, get_each_context7);
      }
      if (dirty & 2) {
        toggle_class(table, "bx--data-table--compact", ctx2[1] === "compact");
      }
      if (dirty & 2) {
        toggle_class(table, "bx--data-table--short", ctx2[1] === "short");
      }
      if (dirty & 2) {
        toggle_class(table, "bx--data-table--tall", ctx2[1] === "tall");
      }
      if (dirty & 4) {
        toggle_class(table, "bx--data-table--zebra", ctx2[2]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 128 && ctx2[7]]));
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--data-table-container", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func3 = (_, i) => i;
function instance57($$self, $$props, $$invalidate) {
  let values;
  let cols;
  const omit_props_names = ["columns", "rows", "size", "zebra", "showHeader", "headers", "showToolbar"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTableSkeleton", slots, []);
  let { columns = 5 } = $$props;
  let { rows = 5 } = $$props;
  let { size = void 0 } = $$props;
  let { zebra = false } = $$props;
  let { showHeader = true } = $$props;
  let { headers = [] } = $$props;
  let { showToolbar = true } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("columns" in $$new_props)
      $$invalidate(8, columns = $$new_props.columns);
    if ("rows" in $$new_props)
      $$invalidate(0, rows = $$new_props.rows);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("zebra" in $$new_props)
      $$invalidate(2, zebra = $$new_props.zebra);
    if ("showHeader" in $$new_props)
      $$invalidate(3, showHeader = $$new_props.showHeader);
    if ("headers" in $$new_props)
      $$invalidate(9, headers = $$new_props.headers);
    if ("showToolbar" in $$new_props)
      $$invalidate(4, showToolbar = $$new_props.showToolbar);
  };
  $$self.$capture_state = () => ({
    columns,
    rows,
    size,
    zebra,
    showHeader,
    headers,
    showToolbar,
    cols,
    values
  });
  $$self.$inject_state = ($$new_props) => {
    if ("columns" in $$props)
      $$invalidate(8, columns = $$new_props.columns);
    if ("rows" in $$props)
      $$invalidate(0, rows = $$new_props.rows);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("zebra" in $$props)
      $$invalidate(2, zebra = $$new_props.zebra);
    if ("showHeader" in $$props)
      $$invalidate(3, showHeader = $$new_props.showHeader);
    if ("headers" in $$props)
      $$invalidate(9, headers = $$new_props.headers);
    if ("showToolbar" in $$props)
      $$invalidate(4, showToolbar = $$new_props.showToolbar);
    if ("cols" in $$props)
      $$invalidate(5, cols = $$new_props.cols);
    if ("values" in $$props)
      $$invalidate(6, values = $$new_props.values);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(6, values = headers.map((header) => header.value !== void 0 ? header.value : header));
    }
    if ($$self.$$.dirty & 768) {
      $:
        $$invalidate(5, cols = Array.from(
          {
            length: headers.length > 0 ? headers.length : columns
          },
          (_, i) => i
        ));
    }
  };
  return [
    rows,
    size,
    zebra,
    showHeader,
    showToolbar,
    cols,
    values,
    $$restProps,
    columns,
    headers,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DataTableSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      columns: 8,
      rows: 0,
      size: 1,
      zebra: 2,
      showHeader: 3,
      headers: 9,
      showToolbar: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTableSkeleton",
      options,
      id: create_fragment57.name
    });
  }
  get columns() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zebra() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zebra(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showHeader() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showHeader(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headers() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headers(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showToolbar() {
    throw new Error("<DataTableSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showToolbar(value) {
    throw new Error("<DataTableSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTableSkeleton_default = DataTableSkeleton;

// node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte
var file57 = "node_modules/carbon-components-svelte/src/DataTable/Toolbar.svelte";
function create_fragment58(ctx) {
  let section;
  let section_style_value;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let section_levels = [
    { "aria-label": "data table toolbar" },
    ctx[2],
    {
      style: section_style_value = "z-index: 1; " + ctx[2].style
    }
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      if (default_slot)
        default_slot.c();
      set_attributes(section, section_data);
      toggle_class(section, "bx--table-toolbar", true);
      toggle_class(section, "bx--table-toolbar--small", ctx[0] === "sm");
      toggle_class(section, "bx--table-toolbar--normal", ctx[0] === "default");
      add_location(section, file57, 23, 0, 474);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[5](section);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [
        { "aria-label": "data table toolbar" },
        dirty & 4 && ctx2[2],
        (!current || dirty & 4 && section_style_value !== (section_style_value = "z-index: 1; " + ctx2[2].style)) && { style: section_style_value }
      ]));
      toggle_class(section, "bx--table-toolbar", true);
      toggle_class(section, "bx--table-toolbar--small", ctx2[0] === "sm");
      toggle_class(section, "bx--table-toolbar--normal", ctx2[0] === "default");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, ["default"]);
  let { size = "default" } = $$props;
  let ref = null;
  const overflowVisible = writable(false);
  setContext("Toolbar", {
    overflowVisible,
    setOverflowVisible: (visible) => {
      overflowVisible.set(visible);
      if (ref)
        $$invalidate(1, ref.style.overflow = visible ? "visible" : "inherit", ref);
    }
  });
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    setContext,
    writable,
    ref,
    overflowVisible
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, ref, $$restProps, $$scope, slots, section_binding];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment58.name
    });
  }
  get size() {
    throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toolbar_default = Toolbar;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte
var file58 = "node_modules/carbon-components-svelte/src/DataTable/ToolbarContent.svelte";
function create_fragment59(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div, "bx--toolbar-content", true);
      add_location(div, file58, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarContent", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToolbarContent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ToolbarContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarContent",
      options,
      id: create_fragment59.name
    });
  }
};
var ToolbarContent_default = ToolbarContent;

// node_modules/carbon-components-svelte/src/icons/IconSearch.svelte
var file59 = "node_modules/carbon-components-svelte/src/icons/IconSearch.svelte";
function create_if_block35(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file59, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment60(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block35(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M29,27.5859l-7.5521-7.5521a11.0177,11.0177,0,1,0-1.4141,1.4141L27.5859,29ZM4,13a9,9,0,1,1,9,9A9.01,9.01,0,0,1,4,13Z");
      add_location(path, file59, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file59, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IconSearch", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var IconSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IconSearch",
      options,
      id: create_fragment60.name
    });
  }
  get size() {
    throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IconSearch_default = IconSearch;

// node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte
var file60 = "node_modules/carbon-components-svelte/src/Search/SearchSkeleton.svelte";
function create_fragment61(ctx) {
  let div1;
  let span;
  let t;
  let div0;
  let mounted;
  let dispose;
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t = space();
      div0 = element("div");
      toggle_class(span, "bx--label", true);
      add_location(span, file60, 20, 2, 428);
      toggle_class(div0, "bx--search-input", true);
      add_location(div0, file60, 21, 2, 469);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--search--sm", ctx[0] === "sm");
      toggle_class(div1, "bx--search--lg", ctx[0] === "lg");
      toggle_class(div1, "bx--search--xl", ctx[0] === "xl");
      add_location(div1, file60, 9, 0, 189);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, span);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--search--sm", ctx2[0] === "sm");
      toggle_class(div1, "bx--search--lg", ctx2[0] === "lg");
      toggle_class(div1, "bx--search--xl", ctx2[0] === "xl");
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance61($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchSkeleton", slots, []);
  let { size = "xl" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ size });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SearchSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchSkeleton",
      options,
      id: create_fragment61.name
    });
  }
  get size() {
    throw new Error("<SearchSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SearchSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SearchSkeleton_default = SearchSkeleton;

// node_modules/carbon-components-svelte/src/Search/Search.svelte
var file61 = "node_modules/carbon-components-svelte/src/Search/Search.svelte";
var get_labelText_slot_changes4 = (dirty) => ({});
var get_labelText_slot_context4 = (ctx) => ({});
function create_else_block16(ctx) {
  let div1;
  let div0;
  let switch_instance0;
  let t0;
  let label;
  let label_id_value;
  let t1;
  let input;
  let input_autofocus_value;
  let t2;
  let button;
  let switch_instance1;
  let div1_aria_labelledby_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[14];
  function switch_props(ctx2) {
    return {
      props: { class: "bx--search-magnifier-icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const labelText_slot_template = ctx[20].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[19], get_labelText_slot_context4);
  const labelText_slot_or_fallback = labelText_slot || fallback_block10(ctx);
  let input_levels = [
    { type: "text" },
    { role: "searchbox" },
    {
      autofocus: input_autofocus_value = ctx[11] === true ? true : void 0
    },
    { autocomplete: ctx[10] },
    { disabled: ctx[7] },
    { id: ctx[15] },
    { placeholder: ctx[9] },
    ctx[18]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  var switch_value_1 = Close_default;
  function switch_props_1(ctx2) {
    return {
      props: { size: ctx2[3] === "xl" ? 20 : 16 },
      $$inline: true
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t1 = space();
      input = element("input");
      t2 = space();
      button = element("button");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      toggle_class(div0, "bx--search-magnifier", true);
      add_location(div0, file61, 105, 4, 2656);
      attr_dev(label, "id", label_id_value = ctx[15] + "-search");
      attr_dev(label, "for", ctx[15]);
      toggle_class(label, "bx--label", true);
      add_location(label, file61, 114, 4, 2905);
      set_attributes(input, input_data);
      toggle_class(input, "bx--search-input", true);
      add_location(input, file61, 120, 4, 3089);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", ctx[12]);
      button.disabled = ctx[7];
      toggle_class(button, "bx--search-close", true);
      toggle_class(button, "bx--search-close--hidden", ctx[2] === "");
      add_location(button, file61, 154, 4, 3867);
      attr_dev(div1, "role", "search");
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = ctx[15] + "-search");
      attr_dev(div1, "class", ctx[4]);
      toggle_class(div1, "bx--search", true);
      toggle_class(div1, "bx--search--light", ctx[6]);
      toggle_class(div1, "bx--search--disabled", ctx[7]);
      toggle_class(div1, "bx--search--sm", ctx[3] === "sm");
      toggle_class(div1, "bx--search--lg", ctx[3] === "lg");
      toggle_class(div1, "bx--search--xl", ctx[3] === "xl");
      toggle_class(div1, "bx--search--expandable", ctx[8]);
      toggle_class(div1, "bx--search--expanded", ctx[0]);
      add_location(div1, file61, 91, 2, 2171);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (switch_instance0)
        mount_component(switch_instance0, div0, null);
      ctx[33](div0);
      append_dev(div1, t0);
      append_dev(div1, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_dev(div1, t1);
      append_dev(div1, input);
      if (input.autofocus)
        input.focus();
      ctx[35](input);
      set_input_value(input, ctx[2]);
      append_dev(div1, t2);
      append_dev(div1, button);
      if (switch_instance1)
        mount_component(switch_instance1, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", ctx[34], false, false, false),
          listen_dev(input, "input", ctx[36]),
          listen_dev(input, "change", ctx[22], false, false, false),
          listen_dev(input, "input", ctx[23], false, false, false),
          listen_dev(input, "focus", ctx[24], false, false, false),
          listen_dev(input, "focus", ctx[37], false, false, false),
          listen_dev(input, "blur", ctx[25], false, false, false),
          listen_dev(input, "blur", ctx[38], false, false, false),
          listen_dev(input, "keydown", ctx[26], false, false, false),
          listen_dev(input, "keydown", ctx[39], false, false, false),
          listen_dev(input, "keyup", ctx[27], false, false, false),
          listen_dev(input, "paste", ctx[28], false, false, false),
          listen_dev(button, "click", ctx[21], false, false, false),
          listen_dev(button, "click", ctx[40], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[14])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div0, null);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(labelText_slot_template, ctx2[19], dirty, get_labelText_slot_changes4),
            get_labelText_slot_context4
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 8192)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 32768 && label_id_value !== (label_id_value = ctx2[15] + "-search")) {
        attr_dev(label, "id", label_id_value);
      }
      if (!current || dirty[0] & 32768) {
        attr_dev(label, "for", ctx2[15]);
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { role: "searchbox" },
        (!current || dirty[0] & 2048 && input_autofocus_value !== (input_autofocus_value = ctx2[11] === true ? true : void 0)) && { autofocus: input_autofocus_value },
        (!current || dirty[0] & 1024) && { autocomplete: ctx2[10] },
        (!current || dirty[0] & 128) && { disabled: ctx2[7] },
        (!current || dirty[0] & 32768) && { id: ctx2[15] },
        (!current || dirty[0] & 512) && { placeholder: ctx2[9] },
        dirty[0] & 262144 && ctx2[18]
      ]));
      if (dirty[0] & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      toggle_class(input, "bx--search-input", true);
      const switch_instance1_changes = {};
      if (dirty[0] & 8)
        switch_instance1_changes.size = ctx2[3] === "xl" ? 20 : 16;
      if (switch_value_1 !== (switch_value_1 = Close_default)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, button, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
      if (!current || dirty[0] & 4096) {
        attr_dev(button, "aria-label", ctx2[12]);
      }
      if (!current || dirty[0] & 128) {
        prop_dev(button, "disabled", ctx2[7]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(button, "bx--search-close--hidden", ctx2[2] === "");
      }
      if (!current || dirty[0] & 32768 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = ctx2[15] + "-search")) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & 16) {
        attr_dev(div1, "class", ctx2[4]);
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div1, "bx--search", true);
      }
      if (!current || dirty[0] & 80) {
        toggle_class(div1, "bx--search--light", ctx2[6]);
      }
      if (!current || dirty[0] & 144) {
        toggle_class(div1, "bx--search--disabled", ctx2[7]);
      }
      if (!current || dirty[0] & 24) {
        toggle_class(div1, "bx--search--sm", ctx2[3] === "sm");
      }
      if (!current || dirty[0] & 24) {
        toggle_class(div1, "bx--search--lg", ctx2[3] === "lg");
      }
      if (!current || dirty[0] & 24) {
        toggle_class(div1, "bx--search--xl", ctx2[3] === "xl");
      }
      if (!current || dirty[0] & 272) {
        toggle_class(div1, "bx--search--expandable", ctx2[8]);
      }
      if (!current || dirty[0] & 17) {
        toggle_class(div1, "bx--search--expanded", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      transition_in(labelText_slot_or_fallback, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      transition_out(labelText_slot_or_fallback, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (switch_instance0)
        destroy_component(switch_instance0);
      ctx[33](null);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      ctx[35](null);
      if (switch_instance1)
        destroy_component(switch_instance1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(91:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block36(ctx) {
  let searchskeleton;
  let current;
  const searchskeleton_spread_levels = [{ size: ctx[3] }, ctx[18]];
  let searchskeleton_props = {};
  for (let i = 0; i < searchskeleton_spread_levels.length; i += 1) {
    searchskeleton_props = assign(searchskeleton_props, searchskeleton_spread_levels[i]);
  }
  searchskeleton = new SearchSkeleton_default({
    props: searchskeleton_props,
    $$inline: true
  });
  searchskeleton.$on("click", ctx[29]);
  searchskeleton.$on("mouseover", ctx[30]);
  searchskeleton.$on("mouseenter", ctx[31]);
  searchskeleton.$on("mouseleave", ctx[32]);
  const block = {
    c: function create() {
      create_component(searchskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(searchskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const searchskeleton_changes = dirty[0] & 262152 ? get_spread_update(searchskeleton_spread_levels, [
        dirty[0] & 8 && { size: ctx2[3] },
        dirty[0] & 262144 && get_spread_object(ctx2[18])
      ]) : {};
      searchskeleton.$set(searchskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(searchskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(82:0) {#if skeleton}",
    ctx
  });
  return block;
}
function fallback_block10(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[13]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8192)
        set_data_dev(t, ctx2[13]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(116:29)          ",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block36, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "size",
    "searchClass",
    "skeleton",
    "light",
    "disabled",
    "expandable",
    "expanded",
    "placeholder",
    "autocomplete",
    "autofocus",
    "closeButtonLabelText",
    "labelText",
    "icon",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, ["labelText"]);
  let { value = "" } = $$props;
  let { size = "xl" } = $$props;
  let { searchClass = "" } = $$props;
  let { skeleton = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { expandable = false } = $$props;
  let { expanded = false } = $$props;
  let { placeholder = "Search..." } = $$props;
  let { autocomplete = "off" } = $$props;
  let { autofocus = false } = $$props;
  let { closeButtonLabelText = "Clear search input" } = $$props;
  let { labelText = "" } = $$props;
  let { icon = IconSearch_default } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let searchRef = null;
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      searchRef = $$value;
      $$invalidate(16, searchRef);
    });
  }
  const click_handler_2 = () => {
    if (expandable)
      $$invalidate(0, expanded = true);
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(2, value);
  }
  const focus_handler_1 = () => {
    if (expandable)
      $$invalidate(0, expanded = true);
  };
  const blur_handler_1 = () => {
    if (expanded && value.trim().length === 0) {
      $$invalidate(0, expanded = false);
    }
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "Escape") {
      $$invalidate(2, value = "");
      dispatch("clear");
    }
  };
  const click_handler_3 = () => {
    $$invalidate(2, value = "");
    ref.focus();
    dispatch("clear");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("searchClass" in $$new_props)
      $$invalidate(4, searchClass = $$new_props.searchClass);
    if ("skeleton" in $$new_props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("light" in $$new_props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("expandable" in $$new_props)
      $$invalidate(8, expandable = $$new_props.expandable);
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("placeholder" in $$new_props)
      $$invalidate(9, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$new_props)
      $$invalidate(10, autocomplete = $$new_props.autocomplete);
    if ("autofocus" in $$new_props)
      $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("closeButtonLabelText" in $$new_props)
      $$invalidate(12, closeButtonLabelText = $$new_props.closeButtonLabelText);
    if ("labelText" in $$new_props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("icon" in $$new_props)
      $$invalidate(14, icon = $$new_props.icon);
    if ("id" in $$new_props)
      $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    size,
    searchClass,
    skeleton,
    light,
    disabled,
    expandable,
    expanded,
    placeholder,
    autocomplete,
    autofocus,
    closeButtonLabelText,
    labelText,
    icon,
    id,
    ref,
    createEventDispatcher,
    Close: Close_default,
    IconSearch: IconSearch_default,
    SearchSkeleton: SearchSkeleton_default,
    dispatch,
    searchRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("searchClass" in $$props)
      $$invalidate(4, searchClass = $$new_props.searchClass);
    if ("skeleton" in $$props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("light" in $$props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("expandable" in $$props)
      $$invalidate(8, expandable = $$new_props.expandable);
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("placeholder" in $$props)
      $$invalidate(9, placeholder = $$new_props.placeholder);
    if ("autocomplete" in $$props)
      $$invalidate(10, autocomplete = $$new_props.autocomplete);
    if ("autofocus" in $$props)
      $$invalidate(11, autofocus = $$new_props.autofocus);
    if ("closeButtonLabelText" in $$props)
      $$invalidate(12, closeButtonLabelText = $$new_props.closeButtonLabelText);
    if ("labelText" in $$props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("icon" in $$props)
      $$invalidate(14, icon = $$new_props.icon);
    if ("id" in $$props)
      $$invalidate(15, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("searchRef" in $$props)
      $$invalidate(16, searchRef = $$new_props.searchRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 3) {
      $:
        if (expanded && ref)
          ref.focus();
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        dispatch(expanded ? "expand" : "collapse");
    }
  };
  return [
    expanded,
    ref,
    value,
    size,
    searchClass,
    skeleton,
    light,
    disabled,
    expandable,
    placeholder,
    autocomplete,
    autofocus,
    closeButtonLabelText,
    labelText,
    icon,
    id,
    searchRef,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler_13,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    paste_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    click_handler_2,
    input_binding,
    input_input_handler,
    focus_handler_1,
    blur_handler_1,
    keydown_handler_12,
    click_handler_3
  ];
}
var Search = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance62,
      create_fragment62,
      safe_not_equal,
      {
        value: 2,
        size: 3,
        searchClass: 4,
        skeleton: 5,
        light: 6,
        disabled: 7,
        expandable: 8,
        expanded: 0,
        placeholder: 9,
        autocomplete: 10,
        autofocus: 11,
        closeButtonLabelText: 12,
        labelText: 13,
        icon: 14,
        id: 15,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment62.name
    });
  }
  get value() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchClass() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchClass(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandable() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandable(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonLabelText() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonLabelText(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Search_default = Search;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarSearch.svelte
function create_fragment63(ctx) {
  let search;
  let updating_ref;
  let updating_value;
  let current;
  const search_spread_levels = [
    { tabindex: ctx[5] },
    { disabled: ctx[4] },
    ctx[9],
    {
      searchClass: ctx[6] + " " + ctx[9].class
    }
  ];
  function search_ref_binding(value) {
    ctx[14](value);
  }
  function search_value_binding(value) {
    ctx[15](value);
  }
  let search_props = {};
  for (let i = 0; i < search_spread_levels.length; i += 1) {
    search_props = assign(search_props, search_spread_levels[i]);
  }
  if (ctx[2] !== void 0) {
    search_props.ref = ctx[2];
  }
  if (ctx[0] !== void 0) {
    search_props.value = ctx[0];
  }
  search = new Search_default({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "ref", search_ref_binding));
  binding_callbacks.push(() => bind(search, "value", search_value_binding));
  search.$on("clear", ctx[16]);
  search.$on("clear", ctx[8]);
  search.$on("change", ctx[17]);
  search.$on("input", ctx[18]);
  search.$on("focus", ctx[19]);
  search.$on("focus", ctx[8]);
  search.$on("blur", ctx[20]);
  search.$on("blur", ctx[21]);
  search.$on("keyup", ctx[22]);
  search.$on("keydown", ctx[23]);
  search.$on("paste", ctx[24]);
  const block = {
    c: function create() {
      create_component(search.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(search, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const search_changes = dirty & 624 ? get_spread_update(search_spread_levels, [
        dirty & 32 && { tabindex: ctx2[5] },
        dirty & 16 && { disabled: ctx2[4] },
        dirty & 512 && get_spread_object(ctx2[9]),
        dirty & 576 && {
          searchClass: ctx2[6] + " " + ctx2[9].class
        }
      ]) : {};
      if (!updating_ref && dirty & 4) {
        updating_ref = true;
        search_changes.ref = ctx2[2];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        search_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      search.$set(search_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(search, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  var _a;
  let originalRows;
  let classes;
  const omit_props_names = [
    "value",
    "expanded",
    "persistent",
    "disabled",
    "shouldFilterRows",
    "filteredRowIds",
    "tabindex",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tableRows;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarSearch", slots, []);
  let { value = "" } = $$props;
  let { expanded = false } = $$props;
  let { persistent = false } = $$props;
  let { disabled = false } = $$props;
  let { shouldFilterRows = false } = $$props;
  let { filteredRowIds = [] } = $$props;
  let { tabindex = "0" } = $$props;
  let { ref = null } = $$props;
  const { tableRows } = (_a = getContext("DataTable")) != null ? _a : {};
  validate_store(tableRows, "tableRows");
  component_subscribe($$self, tableRows, (value2) => $$invalidate(13, $tableRows = value2));
  async function expandSearch() {
    await tick();
    if (disabled || persistent || expanded)
      return;
    $$invalidate(1, expanded = true);
    await tick();
    ref.focus();
  }
  function search_ref_binding(value2) {
    ref = value2;
    $$invalidate(2, ref);
  }
  function search_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const blur_handler_1 = () => {
    $$invalidate(1, expanded = !persistent && !!value.length);
  };
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("expanded" in $$new_props)
      $$invalidate(1, expanded = $$new_props.expanded);
    if ("persistent" in $$new_props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("shouldFilterRows" in $$new_props)
      $$invalidate(11, shouldFilterRows = $$new_props.shouldFilterRows);
    if ("filteredRowIds" in $$new_props)
      $$invalidate(10, filteredRowIds = $$new_props.filteredRowIds);
    if ("tabindex" in $$new_props)
      $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("ref" in $$new_props)
      $$invalidate(2, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    value,
    expanded,
    persistent,
    disabled,
    shouldFilterRows,
    filteredRowIds,
    tabindex,
    ref,
    tick,
    getContext,
    Search: Search_default,
    tableRows,
    expandSearch,
    classes,
    originalRows,
    $tableRows
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("expanded" in $$props)
      $$invalidate(1, expanded = $$new_props.expanded);
    if ("persistent" in $$props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("shouldFilterRows" in $$props)
      $$invalidate(11, shouldFilterRows = $$new_props.shouldFilterRows);
    if ("filteredRowIds" in $$props)
      $$invalidate(10, filteredRowIds = $$new_props.filteredRowIds);
    if ("tabindex" in $$props)
      $$invalidate(5, tabindex = $$new_props.tabindex);
    if ("ref" in $$props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("originalRows" in $$props)
      $$invalidate(12, originalRows = $$new_props.originalRows);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(12, originalRows = tableRows ? [...$tableRows] : []);
    }
    if ($$self.$$.dirty & 6145) {
      $:
        if (shouldFilterRows) {
          let rows = originalRows;
          if (value.trim().length > 0) {
            if (shouldFilterRows === true) {
              rows = rows.filter((row) => {
                return Object.entries(row).filter(([key]) => key !== "id").some(([key, _value]) => {
                  var _a2;
                  if (typeof _value === "string" || typeof _value === "number") {
                    return (_a2 = _value + "") == null ? void 0 : _a2.toLowerCase().includes(value.trim().toLowerCase());
                  }
                });
              });
            } else if (typeof shouldFilterRows === "function") {
              rows = rows.filter((row) => {
                var _a2;
                return (_a2 = shouldFilterRows(row, value)) != null ? _a2 : false;
              });
            }
          }
          tableRows.set(rows);
          $$invalidate(10, filteredRowIds = rows.map((row) => row.id));
        }
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(1, expanded = !!value.length);
    }
    if ($$self.$$.dirty & 26) {
      $:
        $$invalidate(6, classes = [
          expanded && "bx--toolbar-search-container-active",
          persistent ? "bx--toolbar-search-container-persistent" : "bx--toolbar-search-container-expandable",
          disabled && "bx--toolbar-search-container-disabled"
        ].filter(Boolean).join(" "));
    }
  };
  return [
    value,
    expanded,
    ref,
    persistent,
    disabled,
    tabindex,
    classes,
    tableRows,
    expandSearch,
    $$restProps,
    filteredRowIds,
    shouldFilterRows,
    originalRows,
    $tableRows,
    search_ref_binding,
    search_value_binding,
    clear_handler,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    blur_handler_1,
    keyup_handler,
    keydown_handler,
    paste_handler
  ];
}
var ToolbarSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, {
      value: 0,
      expanded: 1,
      persistent: 3,
      disabled: 4,
      shouldFilterRows: 11,
      filteredRowIds: 10,
      tabindex: 5,
      ref: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarSearch",
      options,
      id: create_fragment63.name
    });
  }
  get value() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFilterRows() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFilterRows(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filteredRowIds() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filteredRowIds(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ToolbarSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ToolbarSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolbarSearch_default = ToolbarSearch;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte
var file62 = "node_modules/carbon-components-svelte/src/DataTable/ToolbarBatchActions.svelte";
var get_cancel_slot_changes = (dirty) => ({});
var get_cancel_slot_context = (ctx) => ({});
function create_if_block37(ctx) {
  let div2;
  let div0;
  let p;
  let span;
  let t0_value = ctx[0](ctx[1].length) + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let button;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  button = new Button_default({
    props: {
      class: "bx--batch-summary__cancel",
      tabindex: ctx[3] ? "0" : "-1",
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[4]);
  let div2_levels = [ctx[5]];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      p = element("p");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(button.$$.fragment);
      add_location(span, file62, 84, 8, 1788);
      toggle_class(p, "bx--batch-summary__para", true);
      add_location(p, file62, 83, 6, 1737);
      toggle_class(div0, "bx--batch-summary", true);
      add_location(div0, file62, 82, 4, 1692);
      toggle_class(div1, "bx--action-list", true);
      add_location(div1, file62, 87, 4, 1876);
      set_attributes(div2, div2_data);
      toggle_class(div2, "bx--batch-actions", true);
      toggle_class(div2, "bx--batch-actions--active", ctx[3]);
      add_location(div2, file62, 77, 2, 1569);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div0, p);
      append_dev(p, span);
      append_dev(span, t0);
      append_dev(div2, t1);
      append_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div1, t2);
      mount_component(button, div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty & 3) && t0_value !== (t0_value = ctx2[0](ctx2[1].length) + ""))
        set_data_dev(t0, t0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      const button_changes = {};
      if (dirty & 8)
        button_changes.tabindex = ctx2[3] ? "0" : "-1";
      if (dirty & 512) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [dirty & 32 && ctx2[5]]));
      toggle_class(div2, "bx--batch-actions", true);
      toggle_class(div2, "bx--batch-actions--active", ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(77:0) {#if !overflowVisible}",
    ctx
  });
  return block;
}
function fallback_block11(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Cancel");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block11.name,
    type: "fallback",
    source: "(95:28) Cancel",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let current;
  const cancel_slot_template = ctx[8].cancel;
  const cancel_slot = create_slot(cancel_slot_template, ctx, ctx[9], get_cancel_slot_context);
  const cancel_slot_or_fallback = cancel_slot || fallback_block11(ctx);
  const block = {
    c: function create() {
      if (cancel_slot_or_fallback)
        cancel_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (cancel_slot_or_fallback) {
        cancel_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (cancel_slot) {
        if (cancel_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            cancel_slot,
            cancel_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(cancel_slot_template, ctx2[9], dirty, get_cancel_slot_changes),
            get_cancel_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cancel_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cancel_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (cancel_slot_or_fallback)
        cancel_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: `(90:6) <Button         class=\\"bx--batch-summary__cancel\\"         tabindex=\\"{showActions ? '0' : '-1'}\\"         on:click=\\"{cancel}\\"       >`,
    ctx
  });
  return block;
}
function create_fragment64(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[2] && create_if_block37(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block37(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let showActions;
  const omit_props_names = ["formatTotalSelected", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarBatchActions", slots, ["default", "cancel"]);
  let { formatTotalSelected = (totalSelected) => `${totalSelected} item${totalSelected === 1 ? "" : "s"} selected` } = $$props;
  let { active = void 0 } = $$props;
  let batchSelectedIds = [];
  let prevActive;
  const dispatch = createEventDispatcher();
  const ctx = getContext("DataTable");
  function cancel() {
    const shouldContinue = dispatch("cancel", null, { cancelable: true });
    if (shouldContinue) {
      ctx.resetSelectedRowIds();
    }
  }
  const unsubscribe = ctx.batchSelectedIds.subscribe((value) => {
    $$invalidate(1, batchSelectedIds = value);
  });
  let overflowVisible = false;
  const ctxToolbar = getContext("Toolbar");
  const unsubscribeOverflow = ctxToolbar.overflowVisible.subscribe((value) => {
    $$invalidate(2, overflowVisible = value);
  });
  onMount(() => {
    return () => {
      unsubscribe();
      unsubscribeOverflow();
    };
  });
  afterUpdate(() => {
    if (active === false && showActions) {
      $$invalidate(6, active = true);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formatTotalSelected" in $$new_props)
      $$invalidate(0, formatTotalSelected = $$new_props.formatTotalSelected);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    formatTotalSelected,
    active,
    onMount,
    getContext,
    createEventDispatcher,
    afterUpdate,
    Button: Button_default,
    batchSelectedIds,
    prevActive,
    dispatch,
    ctx,
    cancel,
    unsubscribe,
    overflowVisible,
    ctxToolbar,
    unsubscribeOverflow,
    showActions
  });
  $$self.$inject_state = ($$new_props) => {
    if ("formatTotalSelected" in $$props)
      $$invalidate(0, formatTotalSelected = $$new_props.formatTotalSelected);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("batchSelectedIds" in $$props)
      $$invalidate(1, batchSelectedIds = $$new_props.batchSelectedIds);
    if ("prevActive" in $$props)
      $$invalidate(7, prevActive = $$new_props.prevActive);
    if ("overflowVisible" in $$props)
      $$invalidate(2, overflowVisible = $$new_props.overflowVisible);
    if ("showActions" in $$props)
      $$invalidate(3, showActions = $$new_props.showActions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 66) {
      $:
        $$invalidate(3, showActions = batchSelectedIds.length > 0 || active);
    }
    if ($$self.$$.dirty & 192) {
      $: {
        if (prevActive !== active && active === false) {
          $$invalidate(3, showActions = false);
        }
        $$invalidate(7, prevActive = active);
      }
    }
  };
  return [
    formatTotalSelected,
    batchSelectedIds,
    overflowVisible,
    showActions,
    cancel,
    $$restProps,
    active,
    prevActive,
    slots,
    $$scope
  ];
}
var ToolbarBatchActions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, { formatTotalSelected: 0, active: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarBatchActions",
      options,
      id: create_fragment64.name
    });
  }
  get formatTotalSelected() {
    throw new Error("<ToolbarBatchActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatTotalSelected(value) {
    throw new Error("<ToolbarBatchActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ToolbarBatchActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ToolbarBatchActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolbarBatchActions_default = ToolbarBatchActions;

// node_modules/carbon-components-svelte/src/icons/Settings.svelte
var file63 = "node_modules/carbon-components-svelte/src/icons/Settings.svelte";
function create_if_block38(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file63, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment65(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block38(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M27,16.76c0-.25,0-.5,0-.76s0-.51,0-.77l1.92-1.68A2,2,0,0,0,29.3,11L26.94,7a2,2,0,0,0-1.73-1,2,2,0,0,0-.64.1l-2.43.82a11.35,11.35,0,0,0-1.31-.75l-.51-2.52a2,2,0,0,0-2-1.61H13.64a2,2,0,0,0-2,1.61l-.51,2.52a11.48,11.48,0,0,0-1.32.75L7.43,6.06A2,2,0,0,0,6.79,6,2,2,0,0,0,5.06,7L2.7,11a2,2,0,0,0,.41,2.51L5,15.24c0,.25,0,.5,0,.76s0,.51,0,.77L3.11,18.45A2,2,0,0,0,2.7,21L5.06,25a2,2,0,0,0,1.73,1,2,2,0,0,0,.64-.1l2.43-.82a11.35,11.35,0,0,0,1.31.75l.51,2.52a2,2,0,0,0,2,1.61h4.72a2,2,0,0,0,2-1.61l.51-2.52a11.48,11.48,0,0,0,1.32-.75l2.42.82a2,2,0,0,0,.64.1,2,2,0,0,0,1.73-1L29.3,21a2,2,0,0,0-.41-2.51ZM25.21,24l-3.43-1.16a8.86,8.86,0,0,1-2.71,1.57L18.36,28H13.64l-.71-3.55a9.36,9.36,0,0,1-2.7-1.57L6.79,24,4.43,20l2.72-2.4a8.9,8.9,0,0,1,0-3.13L4.43,12,6.79,8l3.43,1.16a8.86,8.86,0,0,1,2.71-1.57L13.64,4h4.72l.71,3.55a9.36,9.36,0,0,1,2.7,1.57L25.21,8,27.57,12l-2.72,2.4a8.9,8.9,0,0,1,0,3.13L27.57,20Z");
      add_location(path0, file63, 24, 2, 579);
      attr_dev(path1, "d", "M16,22a6,6,0,1,1,6-6A5.94,5.94,0,0,1,16,22Zm0-10a3.91,3.91,0,0,0-4,4,3.91,3.91,0,0,0,4,4,3.91,3.91,0,0,0,4-4A3.91,3.91,0,0,0,16,12Z");
      add_location(path1, file63, 26, 10, 1496);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file63, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block38(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Settings", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Settings = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Settings",
      options,
      id: create_fragment65.name
    });
  }
  get size() {
    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Settings_default = Settings;

// node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte
var file64 = "node_modules/carbon-components-svelte/src/icons/OverflowMenuVertical.svelte";
function create_if_block39(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file64, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let if_block = ctx[1] && create_if_block39(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr_dev(circle0, "cx", "16");
      attr_dev(circle0, "cy", "8");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file64, 24, 2, 579);
      attr_dev(circle1, "cx", "16");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file64, 24, 40, 617);
      attr_dev(circle2, "cx", "16");
      attr_dev(circle2, "cy", "24");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file64, 25, 12, 659);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file64, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, circle0);
      append_dev(svg, circle1);
      append_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block39(ctx2);
          if_block.c();
          if_block.m(svg, circle0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuVertical", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var OverflowMenuVertical = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuVertical",
      options,
      id: create_fragment66.name
    });
  }
  get size() {
    throw new Error("<OverflowMenuVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenuVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<OverflowMenuVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<OverflowMenuVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuVertical_default = OverflowMenuVertical;

// node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte
var file65 = "node_modules/carbon-components-svelte/src/icons/OverflowMenuHorizontal.svelte";
function create_if_block40(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file65, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let svg;
  let circle0;
  let circle1;
  let circle2;
  let if_block = ctx[1] && create_if_block40(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr_dev(circle0, "cx", "8");
      attr_dev(circle0, "cy", "16");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file65, 24, 2, 579);
      attr_dev(circle1, "cx", "16");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file65, 24, 40, 617);
      attr_dev(circle2, "cx", "24");
      attr_dev(circle2, "cy", "16");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file65, 25, 12, 659);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file65, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, circle0);
      append_dev(svg, circle1);
      append_dev(svg, circle2);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block40(ctx2);
          if_block.c();
          if_block.m(svg, circle0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuHorizontal", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var OverflowMenuHorizontal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuHorizontal",
      options,
      id: create_fragment67.name
    });
  }
  get size() {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<OverflowMenuHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuHorizontal_default = OverflowMenuHorizontal;

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte
var file66 = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenu.svelte";
var get_menu_slot_changes = (dirty) => ({});
var get_menu_slot_context = (ctx) => ({});
function fallback_block12(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    return {
      props: {
        "aria-label": ctx2[10],
        title: ctx2[10],
        class: "bx--overflow-menu__icon " + ctx2[9]
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 1024)
        switch_instance_changes["aria-label"] = ctx2[10];
      if (dirty[0] & 1024)
        switch_instance_changes.title = ctx2[10];
      if (dirty[0] & 512)
        switch_instance_changes.class = "bx--overflow-menu__icon " + ctx2[9];
      if (switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block12.name,
    type: "fallback",
    source: "(236:20)      ",
    ctx
  });
  return block;
}
function create_if_block41(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[24].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[23], null);
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "tabindex", "-1");
      attr_dev(ul, "aria-label", ctx[13]);
      attr_dev(ul, "data-floating-menu-direction", ctx[5]);
      attr_dev(ul, "class", ctx[8]);
      toggle_class(ul, "bx--overflow-menu-options", true);
      toggle_class(ul, "bx--overflow-menu--flip", ctx[7]);
      toggle_class(ul, "bx--overflow-menu-options--open", ctx[0]);
      toggle_class(ul, "bx--overflow-menu-options--light", ctx[6]);
      toggle_class(ul, "bx--overflow-menu-options--sm", ctx[4] === "sm");
      toggle_class(ul, "bx--overflow-menu-options--xl", ctx[4] === "xl");
      toggle_class(ul, "bx--breadcrumb-menu-options", !!ctx[14]);
      add_location(ul, file66, 244, 4, 5817);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[31](ul);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[23],
            !current ? get_all_dirty_from_scope(ctx2[23]) : get_slot_changes(default_slot_template, ctx2[23], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 8192) {
        attr_dev(ul, "aria-label", ctx2[13]);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(ul, "data-floating-menu-direction", ctx2[5]);
      }
      if (!current || dirty[0] & 256) {
        attr_dev(ul, "class", ctx2[8]);
      }
      if (!current || dirty[0] & 256) {
        toggle_class(ul, "bx--overflow-menu-options", true);
      }
      if (!current || dirty[0] & 384) {
        toggle_class(ul, "bx--overflow-menu--flip", ctx2[7]);
      }
      if (!current || dirty[0] & 257) {
        toggle_class(ul, "bx--overflow-menu-options--open", ctx2[0]);
      }
      if (!current || dirty[0] & 320) {
        toggle_class(ul, "bx--overflow-menu-options--light", ctx2[6]);
      }
      if (!current || dirty[0] & 272) {
        toggle_class(ul, "bx--overflow-menu-options--sm", ctx2[4] === "sm");
      }
      if (!current || dirty[0] & 272) {
        toggle_class(ul, "bx--overflow-menu-options--xl", ctx2[4] === "xl");
      }
      if (!current || dirty[0] & 16640) {
        toggle_class(ul, "bx--breadcrumb-menu-options", !!ctx2[14]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      ctx[31](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(244:2) {#if open}",
    ctx
  });
  return block;
}
function create_fragment68(ctx) {
  let html_tag;
  let html_anchor;
  let t0;
  let button;
  let t1;
  let current;
  let mounted;
  let dispose;
  const menu_slot_template = ctx[24].menu;
  const menu_slot = create_slot(menu_slot_template, ctx, ctx[23], get_menu_slot_context);
  const menu_slot_or_fallback = menu_slot || fallback_block12(ctx);
  let if_block = ctx[0] && create_if_block41(ctx);
  let button_levels = [
    { type: "button" },
    { "aria-haspopup": "" },
    { "aria-expanded": ctx[0] },
    { "aria-label": ctx[13] },
    { id: ctx[11] },
    ctx[19]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      t0 = space();
      button = element("button");
      if (menu_slot_or_fallback)
        menu_slot_or_fallback.c();
      t1 = space();
      if (if_block)
        if_block.c();
      html_tag.a = html_anchor;
      set_attributes(button, button_data);
      toggle_class(button, "bx--overflow-menu", true);
      toggle_class(button, "bx--overflow-menu--open", ctx[0]);
      toggle_class(button, "bx--overflow-menu--light", ctx[6]);
      toggle_class(button, "bx--overflow-menu--sm", ctx[4] === "sm");
      toggle_class(button, "bx--overflow-menu--xl", ctx[4] === "xl");
      add_location(button, file66, 190, 0, 4542);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      html_tag.m(ctx[12], document.head);
      append_dev(document.head, html_anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, button, anchor);
      if (menu_slot_or_fallback) {
        menu_slot_or_fallback.m(button, null);
      }
      append_dev(button, t1);
      if (if_block)
        if_block.m(button, null);
      if (button.autofocus)
        button.focus();
      ctx[32](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[30], false, false, false),
          listen_dev(button, "click", ctx[25], false, false, false),
          listen_dev(button, "click", ctx[33], false, false, false),
          listen_dev(button, "mouseover", ctx[26], false, false, false),
          listen_dev(button, "mouseenter", ctx[27], false, false, false),
          listen_dev(button, "mouseleave", ctx[28], false, false, false),
          listen_dev(button, "keydown", ctx[29], false, false, false),
          listen_dev(button, "keydown", ctx[34], false, false, false),
          listen_dev(button, "focusout", ctx[35], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 4096)
        html_tag.p(ctx2[12]);
      if (menu_slot) {
        if (menu_slot.p && (!current || dirty[0] & 8388608)) {
          update_slot_base(
            menu_slot,
            menu_slot_template,
            ctx2,
            ctx2[23],
            !current ? get_all_dirty_from_scope(ctx2[23]) : get_slot_changes(menu_slot_template, ctx2[23], dirty, get_menu_slot_changes),
            get_menu_slot_context
          );
        }
      } else {
        if (menu_slot_or_fallback && menu_slot_or_fallback.p && (!current || dirty[0] & 1538)) {
          menu_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block41(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        { "aria-haspopup": "" },
        (!current || dirty[0] & 1) && { "aria-expanded": ctx2[0] },
        (!current || dirty[0] & 8192) && { "aria-label": ctx2[13] },
        (!current || dirty[0] & 2048) && { id: ctx2[11] },
        dirty[0] & 524288 && ctx2[19]
      ]));
      toggle_class(button, "bx--overflow-menu", true);
      toggle_class(button, "bx--overflow-menu--open", ctx2[0]);
      toggle_class(button, "bx--overflow-menu--light", ctx2[6]);
      toggle_class(button, "bx--overflow-menu--sm", ctx2[4] === "sm");
      toggle_class(button, "bx--overflow-menu--xl", ctx2[4] === "xl");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menu_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(menu_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(button);
      if (menu_slot_or_fallback)
        menu_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let ariaLabel;
  let styles;
  const omit_props_names = [
    "size",
    "direction",
    "open",
    "light",
    "flipped",
    "menuOptionsClass",
    "icon",
    "iconClass",
    "iconDescription",
    "id",
    "buttonRef",
    "menuRef"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $currentIndex;
  let $items;
  let $currentId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenu", slots, ["menu", "default"]);
  let { size = void 0 } = $$props;
  let { direction = "bottom" } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { flipped = false } = $$props;
  let { menuOptionsClass = void 0 } = $$props;
  let { icon = OverflowMenuVertical_default } = $$props;
  let { iconClass = void 0 } = $$props;
  let { iconDescription = "Open and close list of options" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { buttonRef = null } = $$props;
  let { menuRef = null } = $$props;
  const ctxBreadcrumbItem = getContext("BreadcrumbItem");
  const dispatch = createEventDispatcher();
  const items = writable([]);
  validate_store(items, "items");
  component_subscribe($$self, items, (value) => $$invalidate(22, $items = value));
  const currentId = writable(void 0);
  validate_store(currentId, "currentId");
  component_subscribe($$self, currentId, (value) => $$invalidate(37, $currentId = value));
  const focusedId = writable(void 0);
  const currentIndex = writable(-1);
  validate_store(currentIndex, "currentIndex");
  component_subscribe($$self, currentIndex, (value) => $$invalidate(21, $currentIndex = value));
  let buttonWidth = void 0;
  let onMountAfterUpdate = true;
  setContext("OverflowMenu", {
    focusedId,
    add: ({ id: id2, text: text2, primaryFocus, disabled }) => {
      items.update((_) => {
        if (primaryFocus) {
          currentIndex.set(_.length);
        }
        return [
          ..._,
          {
            id: id2,
            text: text2,
            primaryFocus,
            disabled,
            index: _.length
          }
        ];
      });
    },
    update: (id2) => {
      currentId.set(id2);
    },
    change: (direction2) => {
      let index = $currentIndex + direction2;
      if (index < 0) {
        index = $items.length - 1;
      } else if (index >= $items.length) {
        index = 0;
      }
      let disabled = $items[index].disabled;
      while (disabled) {
        index = index + direction2;
        if (index < 0) {
          index = $items.length - 1;
        } else if (index >= $items.length) {
          index = 0;
        }
        disabled = $items[index].disabled;
      }
      currentIndex.set(index);
    }
  });
  afterUpdate(() => {
    if ($currentId) {
      const { index, text: text2 } = $items.filter((_) => _.id === $currentId)[0];
      dispatch("close", { index, text: text2 });
      $$invalidate(0, open = false);
    }
    if (open) {
      const { width, height } = buttonRef.getBoundingClientRect();
      $$invalidate(20, buttonWidth = width);
      if (!onMountAfterUpdate && $currentIndex < 0) {
        menuRef.focus();
      }
      if (flipped) {
        $$invalidate(3, menuRef.style.left = "auto", menuRef);
        $$invalidate(3, menuRef.style.right = 0, menuRef);
      }
      if (direction === "top") {
        $$invalidate(3, menuRef.style.top = "auto", menuRef);
        $$invalidate(3, menuRef.style.bottom = height + "px", menuRef);
      } else if (direction === "bottom") {
        $$invalidate(3, menuRef.style.top = height + "px", menuRef);
      }
      if (ctxBreadcrumbItem) {
        $$invalidate(3, menuRef.style.top = height + 10 + "px", menuRef);
        $$invalidate(3, menuRef.style.left = -11 + "px", menuRef);
      }
    }
    if (!open) {
      items.set([]);
      currentId.set(void 0);
      currentIndex.set(0);
    }
    onMountAfterUpdate = false;
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (buttonRef && buttonRef.contains(target))
      return;
    if (menuRef && !menuRef.contains(target)) {
      $$invalidate(0, open = false);
    }
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuRef = $$value;
      $$invalidate(3, menuRef);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(2, buttonRef);
    });
  }
  const click_handler_2 = ({ target }) => {
    if (!(menuRef && menuRef.contains(target))) {
      $$invalidate(0, open = !open);
      if (!open)
        dispatch("close");
    }
  };
  const keydown_handler_12 = (e) => {
    if (open) {
      if (["ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      } else if (e.key === "Escape") {
        e.stopPropagation();
        dispatch("close");
        $$invalidate(0, open = false);
        buttonRef.focus();
      }
    }
  };
  const focusout_handler = (e) => {
    if (open) {
      if (!buttonRef.contains(e.relatedTarget)) {
        dispatch("close");
        $$invalidate(0, open = false);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("direction" in $$new_props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("light" in $$new_props)
      $$invalidate(6, light = $$new_props.light);
    if ("flipped" in $$new_props)
      $$invalidate(7, flipped = $$new_props.flipped);
    if ("menuOptionsClass" in $$new_props)
      $$invalidate(8, menuOptionsClass = $$new_props.menuOptionsClass);
    if ("icon" in $$new_props)
      $$invalidate(1, icon = $$new_props.icon);
    if ("iconClass" in $$new_props)
      $$invalidate(9, iconClass = $$new_props.iconClass);
    if ("iconDescription" in $$new_props)
      $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props)
      $$invalidate(11, id = $$new_props.id);
    if ("buttonRef" in $$new_props)
      $$invalidate(2, buttonRef = $$new_props.buttonRef);
    if ("menuRef" in $$new_props)
      $$invalidate(3, menuRef = $$new_props.menuRef);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    direction,
    open,
    light,
    flipped,
    menuOptionsClass,
    icon,
    iconClass,
    iconDescription,
    id,
    buttonRef,
    menuRef,
    createEventDispatcher,
    getContext,
    setContext,
    afterUpdate,
    writable,
    OverflowMenuVertical: OverflowMenuVertical_default,
    OverflowMenuHorizontal: OverflowMenuHorizontal_default,
    ctxBreadcrumbItem,
    dispatch,
    items,
    currentId,
    focusedId,
    currentIndex,
    buttonWidth,
    onMountAfterUpdate,
    styles,
    ariaLabel,
    $currentIndex,
    $items,
    $currentId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(39, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("direction" in $$props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("light" in $$props)
      $$invalidate(6, light = $$new_props.light);
    if ("flipped" in $$props)
      $$invalidate(7, flipped = $$new_props.flipped);
    if ("menuOptionsClass" in $$props)
      $$invalidate(8, menuOptionsClass = $$new_props.menuOptionsClass);
    if ("icon" in $$props)
      $$invalidate(1, icon = $$new_props.icon);
    if ("iconClass" in $$props)
      $$invalidate(9, iconClass = $$new_props.iconClass);
    if ("iconDescription" in $$props)
      $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props)
      $$invalidate(11, id = $$new_props.id);
    if ("buttonRef" in $$props)
      $$invalidate(2, buttonRef = $$new_props.buttonRef);
    if ("menuRef" in $$props)
      $$invalidate(3, menuRef = $$new_props.menuRef);
    if ("buttonWidth" in $$props)
      $$invalidate(20, buttonWidth = $$new_props.buttonWidth);
    if ("onMountAfterUpdate" in $$props)
      onMountAfterUpdate = $$new_props.onMountAfterUpdate;
    if ("styles" in $$props)
      $$invalidate(12, styles = $$new_props.styles);
    if ("ariaLabel" in $$props)
      $$invalidate(13, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(13, ariaLabel = $$props["aria-label"] || "menu");
    if ($$self.$$.dirty[0] & 6291456) {
      $:
        if ($items[$currentIndex]) {
          focusedId.set($items[$currentIndex].id);
        }
    }
    if ($$self.$$.dirty[0] & 1050624) {
      $:
        $$invalidate(12, styles = `<style>
    #${id} .bx--overflow-menu-options.bx--overflow-menu-options:after {
      width: ${buttonWidth ? buttonWidth + "px" : "2rem"};
    }
  </style>`);
    }
  };
  $:
    if (ctxBreadcrumbItem) {
      $$invalidate(1, icon = OverflowMenuHorizontal_default);
    }
  $$props = exclude_internal_props($$props);
  return [
    open,
    icon,
    buttonRef,
    menuRef,
    size,
    direction,
    light,
    flipped,
    menuOptionsClass,
    iconClass,
    iconDescription,
    id,
    styles,
    ariaLabel,
    ctxBreadcrumbItem,
    dispatch,
    items,
    currentId,
    currentIndex,
    $$restProps,
    buttonWidth,
    $currentIndex,
    $items,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    ul_binding,
    button_binding,
    click_handler_2,
    keydown_handler_12,
    focusout_handler
  ];
}
var OverflowMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance68,
      create_fragment68,
      safe_not_equal,
      {
        size: 4,
        direction: 5,
        open: 0,
        light: 6,
        flipped: 7,
        menuOptionsClass: 8,
        icon: 1,
        iconClass: 9,
        iconDescription: 10,
        id: 11,
        buttonRef: 2,
        menuRef: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenu",
      options,
      id: create_fragment68.name
    });
  }
  get size() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipped() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipped(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuOptionsClass() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuOptionsClass(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClass() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClass(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonRef() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonRef(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuRef() {
    throw new Error("<OverflowMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuRef(value) {
    throw new Error("<OverflowMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenu_default = OverflowMenu;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenu.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: '(16:0) <OverflowMenu   bind:menuRef   icon=\\"{Settings}\\"   {...$$restProps}   class=\\"bx--toolbar-action bx--overflow-menu {$$restProps.class}\\"   flipped >',
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let overflowmenu;
  let updating_menuRef;
  let current;
  const overflowmenu_spread_levels = [
    { icon: Settings_default },
    ctx[1],
    {
      class: "bx--toolbar-action bx--overflow-menu " + ctx[1].class
    },
    { flipped: true }
  ];
  function overflowmenu_menuRef_binding(value) {
    ctx[3](value);
  }
  let overflowmenu_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < overflowmenu_spread_levels.length; i += 1) {
    overflowmenu_props = assign(overflowmenu_props, overflowmenu_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    overflowmenu_props.menuRef = ctx[0];
  }
  overflowmenu = new OverflowMenu_default({
    props: overflowmenu_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(overflowmenu, "menuRef", overflowmenu_menuRef_binding));
  const block = {
    c: function create() {
      create_component(overflowmenu.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(overflowmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const overflowmenu_changes = dirty & 2 ? get_spread_update(overflowmenu_spread_levels, [
        dirty & 0 && { icon: Settings_default },
        dirty & 2 && get_spread_object(ctx2[1]),
        dirty & 2 && {
          class: "bx--toolbar-action bx--overflow-menu " + ctx2[1].class
        },
        overflowmenu_spread_levels[3]
      ]) : {};
      if (dirty & 16) {
        overflowmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_menuRef && dirty & 1) {
        updating_menuRef = true;
        overflowmenu_changes.menuRef = ctx2[0];
        add_flush_callback(() => updating_menuRef = false);
      }
      overflowmenu.$set(overflowmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(overflowmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(overflowmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarMenu", slots, ["default"]);
  const ctx = getContext("Toolbar");
  let menuRef = null;
  function overflowmenu_menuRef_binding(value) {
    menuRef = value;
    $$invalidate(0, menuRef);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    Settings: Settings_default,
    OverflowMenu: OverflowMenu_default,
    ctx,
    menuRef
  });
  $$self.$inject_state = ($$new_props) => {
    if ("menuRef" in $$props)
      $$invalidate(0, menuRef = $$new_props.menuRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        if (menuRef)
          $$invalidate(0, menuRef.style.top = "100%", menuRef);
    }
    if ($$self.$$.dirty & 1) {
      $:
        ctx.setOverflowVisible(menuRef != null);
    }
  };
  return [menuRef, $$restProps, slots, overflowmenu_menuRef_binding, $$scope];
}
var ToolbarMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarMenu",
      options,
      id: create_fragment69.name
    });
  }
};
var ToolbarMenu_default = ToolbarMenu;

// node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte
var file67 = "node_modules/carbon-components-svelte/src/OverflowMenu/OverflowMenuItem.svelte";
function create_else_block17(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const default_slot_or_fallback = default_slot || fallback_block_15(ctx);
  let button_levels = [ctx[7]];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file67, 88, 4, 2234);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[24](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[19], false, false, false),
          listen_dev(button, "click", ctx[25], false, false, false),
          listen_dev(button, "keydown", ctx[20], false, false, false),
          listen_dev(button, "keydown", ctx[26], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty & 128 && ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(88:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block42(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const default_slot_or_fallback = default_slot || fallback_block13(ctx);
  let a_levels = [ctx[7]];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(a, a_data);
      add_location(a, file67, 65, 4, 1766);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[21](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[17], false, false, false),
          listen_dev(a, "click", ctx[22], false, false, false),
          listen_dev(a, "keydown", ctx[18], false, false, false),
          listen_dev(a, "keydown", ctx[23], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [dirty & 128 && ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block42.name,
    type: "if",
    source: "(64:2) {#if href}",
    ctx
  });
  return block;
}
function fallback_block_15(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[1]);
      toggle_class(div, "bx--overflow-menu-options__option-content", true);
      add_location(div, file67, 105, 8, 2575);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_15.name,
    type: "fallback",
    source: "(105:12)          ",
    ctx
  });
  return block;
}
function fallback_block13(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[1]);
      toggle_class(div, "bx--overflow-menu-options__option-content", true);
      add_location(div, file67, 82, 8, 2102);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block13.name,
    type: "fallback",
    source: "(82:12)          ",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block42, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [{ role: "none" }, { id: ctx[6] }, ctx[11]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      set_attributes(li, li_data);
      toggle_class(li, "bx--overflow-menu-options__option", true);
      toggle_class(li, "bx--overflow-menu--divider", ctx[4]);
      toggle_class(li, "bx--overflow-menu-options__option--danger", ctx[5]);
      toggle_class(li, "bx--overflow-menu-options__option--disabled", ctx[3]);
      add_location(li, file67, 54, 0, 1421);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        { role: "none" },
        (!current || dirty & 64) && { id: ctx2[6] },
        dirty & 2048 && ctx2[11]
      ]));
      toggle_class(li, "bx--overflow-menu-options__option", true);
      toggle_class(li, "bx--overflow-menu--divider", ctx2[4]);
      toggle_class(li, "bx--overflow-menu-options__option--danger", ctx2[5]);
      toggle_class(li, "bx--overflow-menu-options__option--disabled", ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let buttonProps;
  const omit_props_names = [
    "text",
    "href",
    "primaryFocus",
    "disabled",
    "hasDivider",
    "danger",
    "requireTitle",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $focusedId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverflowMenuItem", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { text: text2 = "Provide text" } = $$props;
  let { href = "" } = $$props;
  let { primaryFocus = false } = $$props;
  let { disabled = false } = $$props;
  let { hasDivider = false } = $$props;
  let { danger = false } = $$props;
  let { requireTitle = true } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const { focusedId, add, update, change } = getContext("OverflowMenu");
  validate_store(focusedId, "focusedId");
  component_subscribe($$self, focusedId, (value) => $$invalidate(14, $focusedId = value));
  add({ id, text: text2, primaryFocus, disabled });
  afterUpdate(() => {
    if (ref && primaryFocus) {
      ref.focus();
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler_12(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_2 = () => {
    update(id);
  };
  const keydown_handler_2 = ({ key }) => {
    if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_3 = () => {
    update(id);
  };
  const keydown_handler_3 = ({ key }) => {
    if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("primaryFocus" in $$new_props)
      $$invalidate(12, primaryFocus = $$new_props.primaryFocus);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("hasDivider" in $$new_props)
      $$invalidate(4, hasDivider = $$new_props.hasDivider);
    if ("danger" in $$new_props)
      $$invalidate(5, danger = $$new_props.danger);
    if ("requireTitle" in $$new_props)
      $$invalidate(13, requireTitle = $$new_props.requireTitle);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    text: text2,
    href,
    primaryFocus,
    disabled,
    hasDivider,
    danger,
    requireTitle,
    id,
    ref,
    getContext,
    afterUpdate,
    focusedId,
    add,
    update,
    change,
    buttonProps,
    $focusedId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("primaryFocus" in $$props)
      $$invalidate(12, primaryFocus = $$new_props.primaryFocus);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("hasDivider" in $$props)
      $$invalidate(4, hasDivider = $$new_props.hasDivider);
    if ("danger" in $$props)
      $$invalidate(5, danger = $$new_props.danger);
    if ("requireTitle" in $$props)
      $$invalidate(13, requireTitle = $$new_props.requireTitle);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("buttonProps" in $$props)
      $$invalidate(7, buttonProps = $$new_props.buttonProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16448) {
      $:
        $$invalidate(12, primaryFocus = $focusedId === id);
    }
    if ($$self.$$.dirty & 8206) {
      $:
        $$invalidate(7, buttonProps = {
          role: "menuitem",
          tabindex: "-1",
          class: "bx--overflow-menu-options__btn",
          disabled: href ? void 0 : disabled,
          href: href ? href : void 0,
          title: requireTitle ? $$slots.default ? void 0 : text2 : void 0
        });
    }
  };
  return [
    ref,
    text2,
    href,
    disabled,
    hasDivider,
    danger,
    id,
    buttonProps,
    focusedId,
    update,
    change,
    $$restProps,
    primaryFocus,
    requireTitle,
    $focusedId,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12,
    a_binding,
    click_handler_2,
    keydown_handler_2,
    button_binding,
    click_handler_3,
    keydown_handler_3
  ];
}
var OverflowMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {
      text: 1,
      href: 2,
      primaryFocus: 12,
      disabled: 3,
      hasDivider: 4,
      danger: 5,
      requireTitle: 13,
      id: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverflowMenuItem",
      options,
      id: create_fragment70.name
    });
  }
  get text() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryFocus() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryFocus(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasDivider() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasDivider(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get requireTitle() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set requireTitle(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<OverflowMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<OverflowMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OverflowMenuItem_default = OverflowMenuItem;

// node_modules/carbon-components-svelte/src/DataTable/ToolbarMenuItem.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(7:0) <OverflowMenuItem {...$$restProps} on:click on:keydown>",
    ctx
  });
  return block;
}
function create_fragment71(ctx) {
  let overflowmenuitem;
  let current;
  const overflowmenuitem_spread_levels = [ctx[0]];
  let overflowmenuitem_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < overflowmenuitem_spread_levels.length; i += 1) {
    overflowmenuitem_props = assign(overflowmenuitem_props, overflowmenuitem_spread_levels[i]);
  }
  overflowmenuitem = new OverflowMenuItem_default({
    props: overflowmenuitem_props,
    $$inline: true
  });
  overflowmenuitem.$on("click", ctx[2]);
  overflowmenuitem.$on("keydown", ctx[3]);
  const block = {
    c: function create() {
      create_component(overflowmenuitem.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(overflowmenuitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const overflowmenuitem_changes = dirty & 1 ? get_spread_update(overflowmenuitem_spread_levels, [get_spread_object(ctx2[0])]) : {};
      if (dirty & 16) {
        overflowmenuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      overflowmenuitem.$set(overflowmenuitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(overflowmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(overflowmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolbarMenuItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ OverflowMenuItem: OverflowMenuItem_default });
  return [$$restProps, slots, click_handler, keydown_handler, $$scope];
}
var ToolbarMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolbarMenuItem",
      options,
      id: create_fragment71.name
    });
  }
};
var ToolbarMenuItem_default = ToolbarMenuItem;

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
  getWeek: (givenDate) => {
    const date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: (nth) => {
    const s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = (number, length = 2) => `000${number}`.slice(length * -1);
var int = (bool) => bool === true ? 1 : 0;
function debounce(fn, wait) {
  let t;
  return function() {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, arguments), wait);
  };
}
var arrayify = (obj) => obj instanceof Array ? obj : [obj];

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  const e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0)
    e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (const key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event2) {
  try {
    if (typeof event2.composedPath === "function") {
      const path = event2.composedPath();
      return path[0];
    }
    return event2.target;
  } catch (error) {
    return event2.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = () => void 0;
var monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  H: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  J: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  K: (dateObj, amPM, locale) => {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: (dateObj, seconds) => {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1e3),
  W: function(dateObj, weekNum, locale) {
    const weekNumber = parseInt(weekNum);
    const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: (dateObj, year) => {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: (_, ISODate) => new Date(ISODate),
  d: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  h: (dateObj, hour) => {
    dateObj.setHours(parseFloat(hour));
  },
  i: (dateObj, minutes) => {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: (dateObj, day) => {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: (dateObj, month) => {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: (dateObj, month) => {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: (dateObj, seconds) => {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
  w: doNothing,
  y: (dateObj, year) => {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "(\\w+)",
  F: "(\\w+)",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "(\\w+)",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "(\\w+)",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: (date) => date.toISOString(),
  D: function(date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function(date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function(date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: (date) => pad(date.getHours()),
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: (date, locale) => locale.amPM[int(date.getHours() > 11)],
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: (date) => pad(date.getSeconds()),
  U: (date) => date.getTime() / 1e3,
  W: function(date, _, options) {
    return options.getWeek(date);
  },
  Y: (date) => pad(date.getFullYear(), 4),
  d: (date) => pad(date.getDate()),
  h: (date) => date.getHours() % 12 ? date.getHours() % 12 : 12,
  i: (date) => pad(date.getMinutes()),
  j: (date) => date.getDate(),
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: (date) => pad(date.getMonth() + 1),
  n: (date) => date.getMonth() + 1,
  s: (date) => date.getSeconds(),
  u: (date) => date.getTime(),
  w: (date) => date.getDay(),
  y: (date) => String(date.getFullYear()).substring(2)
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = ({ config = defaults, l10n: l10n2 = english, isMobile = false }) => (dateObj, frmt, overrideLocale) => {
  const locale = overrideLocale || l10n2;
  if (config.formatDate !== void 0 && !isMobile) {
    return config.formatDate(dateObj, frmt, locale);
  }
  return frmt.split("").map((c, i, arr) => formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "").join("");
};
var createDateParser = ({ config = defaults, l10n: l10n2 = english }) => (date, givenFormat, timeless, customLocale) => {
  if (date !== 0 && !date)
    return void 0;
  const locale = customLocale || l10n2;
  let parsedDate;
  const dateOrig = date;
  if (date instanceof Date)
    parsedDate = new Date(date.getTime());
  else if (typeof date !== "string" && date.toFixed !== void 0)
    parsedDate = new Date(date);
  else if (typeof date === "string") {
    const format = givenFormat || (config || defaults).dateFormat;
    const datestr = String(date).trim();
    if (datestr === "today") {
      parsedDate = new Date();
      timeless = true;
    } else if (/Z$/.test(datestr) || /GMT$/.test(datestr))
      parsedDate = new Date(date);
    else if (config && config.parseDate)
      parsedDate = config.parseDate(date, format);
    else {
      parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
      let matched, ops = [];
      for (let i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
        const token = format[i];
        const isBackSlash = token === "\\";
        const escaped = format[i - 1] === "\\" || isBackSlash;
        if (tokenRegex[token] && !escaped) {
          regexStr += tokenRegex[token];
          const match = new RegExp(regexStr).exec(date);
          if (match && (matched = true)) {
            ops[token !== "Y" ? "push" : "unshift"]({
              fn: revFormat[token],
              val: match[++matchIndex]
            });
          }
        } else if (!isBackSlash)
          regexStr += ".";
        ops.forEach(({ fn, val }) => parsedDate = fn(parsedDate, val, locale) || parsedDate);
      }
      parsedDate = matched ? parsedDate : void 0;
    }
  }
  if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
    config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
    return void 0;
  }
  if (timeless === true)
    parsedDate.setHours(0, 0, 0, 0);
  return parsedDate;
};
function compareDates(date1, date2, timeless = true) {
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = (ts, ts1, ts2) => {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  let hours = config.defaultHour;
  let minutes = config.defaultMinute;
  let seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    const minHour = config.minDate.getHours();
    const minMinutes = config.minDate.getMinutes();
    const minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    const maxHr = config.maxDate.getHours();
    const maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target, ...args) {
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    for (const source of args) {
      if (source) {
        Object.keys(source).forEach((key) => target[key] = source[key]);
      }
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element2, instanceConfig) {
  const self = {
    config: Object.assign(Object.assign({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind2;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self._createElement = createElement;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.open = open;
  self.redraw = redraw;
  self.set = set;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth(month = self.currentMonth, yr = self.currentYear) {
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init2() {
    self.element = self.input = element2;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile)
      build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function bindToInstance(fn) {
    return fn.bind(self);
  }
  function setCalendarWidth() {
    const config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self.calendarContainer !== void 0) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== void 0) {
          const daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== void 0 ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      const defaultDate = self.config.minDate === void 0 || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      const defaults2 = getDefaultHours(self.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    const prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === void 0 || self.minuteElement === void 0)
      return;
    let hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== void 0 ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== void 0) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    const limitMinHours = self.config.minTime !== void 0 || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    const limitMaxHours = self.config.maxTime !== void 0 || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (limitMaxHours) {
      const maxTime = self.config.maxTime !== void 0 ? self.config.maxTime : self.config.maxDate;
      hours = Math.min(hours, maxTime.getHours());
      if (hours === maxTime.getHours())
        minutes = Math.min(minutes, maxTime.getMinutes());
      if (minutes === maxTime.getMinutes())
        seconds = Math.min(seconds, maxTime.getSeconds());
    }
    if (limitMinHours) {
      const minTime = self.config.minTime !== void 0 ? self.config.minTime : self.config.minDate;
      hours = Math.max(hours, minTime.getHours());
      if (hours === minTime.getHours() && minutes < minTime.getMinutes())
        minutes = minTime.getMinutes();
      if (minutes === minTime.getMinutes())
        seconds = Math.max(seconds, minTime.getSeconds());
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    const date = dateObj || self.latestSelectedDateObj;
    if (date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== void 0) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile)
      return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== void 0)
      self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
    if (self.secondElement !== void 0)
      self.secondElement.value = pad(seconds);
  }
  function onYearInput(event2) {
    const eventTarget = getEventTarget(event2);
    const year = parseInt(eventTarget.value) + (event2.delta || 0);
    if (year / 1e3 > 1 || event2.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind2(element3, event2, handler, options) {
    if (event2 instanceof Array)
      return event2.forEach((ev) => bind2(element3, ev, handler, options));
    if (element3 instanceof Array)
      return element3.forEach((el) => bind2(el, event2, handler, options));
    element3.addEventListener(event2, handler, options);
    self._handlers.push({
      remove: () => element3.removeEventListener(event2, handler)
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach((evt) => {
        Array.prototype.forEach.call(self.element.querySelectorAll(`[data-${evt}]`), (el) => bind2(el, "click", self[evt]));
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    const debouncedResize = debounce(onResize, 50);
    self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind2(self.daysContainer, "mouseover", (e) => {
        if (self.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind2(window.document.body, "keydown", onKeyDown);
    if (!self.config.inline && !self.config.static)
      bind2(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind2(window.document, "touchstart", documentClick);
    else
      bind2(window.document, "mousedown", documentClick);
    bind2(window.document, "focus", documentClick, { capture: true });
    if (self.config.clickOpens === true) {
      bind2(self._input, "focus", self.open);
      bind2(self._input, "click", self.open);
    }
    if (self.daysContainer !== void 0) {
      bind2(self.monthNav, "click", onMonthNavClick);
      bind2(self.monthNav, ["keyup", "increment"], onYearInput);
      bind2(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0) {
      const selText = (e) => getEventTarget(e).select();
      bind2(self.timeContainer, ["increment"], updateTime);
      bind2(self.timeContainer, "blur", updateTime, { capture: true });
      bind2(self.timeContainer, "click", timeIncrement);
      bind2([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== void 0)
        bind2(self.secondElement, "focus", () => self.secondElement && self.secondElement.select());
      if (self.amPM !== void 0) {
        bind2(self.amPM, "click", (e) => {
          updateTime(e);
          triggerChange();
        });
      }
    }
    if (self.config.allowInput) {
      bind2(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    const jumpTo = jumpDate !== void 0 ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    const oldYear = self.currentYear;
    const oldMonth = self.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange2 && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    const eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    const target = e && getEventTarget(e);
    const input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    const event2 = createEvent("increment");
    event2.delta = delta;
    input && input.dispatchEvent(event2);
  }
  function build() {
    const fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        const { weekWrapper, weekNumbers } = buildWeeks();
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    const customAppend = self.config.appendTo !== void 0 && self.config.appendTo.nodeType !== void 0;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode)
          self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
        else if (self.config.appendTo !== void 0)
          self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        const wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode)
          self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput)
          wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline)
      (self.config.appendTo !== void 0 ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, dayNumber, i) {
    const dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    const startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    const endMonth = delta > 0 ? self.config.showMonths : -1;
    for (let m = startMonth; m != endMonth; m += delta) {
      const month = self.daysContainer.children[m];
      const startIndex = delta > 0 ? 0 : month.children.length - 1;
      const endIndex = delta > 0 ? month.children.length : -1;
      for (let i = startIndex; i != endIndex; i += delta) {
        const c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    const givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    const endMonth = delta > 0 ? self.config.showMonths : -1;
    const loopDelta = delta > 0 ? 1 : -1;
    for (let m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      const month = self.daysContainer.children[m];
      const startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      const numMonthDays = month.children.length;
      for (let i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        const c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset) {
    const dayFocused = isInView(document.activeElement || document.body);
    const startElem = current !== void 0 ? current : dayFocused ? document.activeElement : self.selectedDateElem !== void 0 && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== void 0 && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
    if (startElem === void 0) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset);
    }
  }
  function buildMonthDays(year, month) {
    const firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    const prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    const daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    const dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === void 0) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers)
      clearNode(self.weekNumbers);
    const frag = document.createDocumentFragment();
    for (let i = 0; i < self.config.showMonths; i++) {
      const d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown")
      return;
    const shouldBuildMonth = function(month) {
      if (self.config.minDate !== void 0 && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== void 0 && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (let i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      const month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    const container = createElement("div", "flatpickr-month");
    const monthNavFragment = window.document.createDocumentFragment();
    let monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind2(self.monthsDropdownContainer, "change", (e) => {
        const target = getEventTarget(e);
        const selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    const yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    const currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (let m = self.config.showMonths; m--; ) {
      const month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: () => self.__hidePrevMonthArrow,
      set(bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: () => self.__hideNextMonthArrow,
      set(bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar)
      self.calendarContainer.classList.add("noCalendar");
    const defaults2 = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    const separator = createElement("span", "flatpickr-time-separator", ":");
    const hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    const minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr)
      self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      const secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer)
      self.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self.weekdayContainer);
    for (let i = self.config.showMonths; i--; ) {
      const container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    const firstDayOfWeek = self.l10n.firstDayOfWeek;
    let weekdays = [...self.l10n.weekdays.shorthand];
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = [
        ...weekdays.splice(firstDayOfWeek, weekdays.length),
        ...weekdays.splice(0, firstDayOfWeek)
      ];
    }
    for (let i = self.config.showMonths; i--; ) {
      self.weekdayContainer.children[i].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    const weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    const weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset = true) {
    const delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true)
      return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent = true, toInitial = true) {
    self.input.value = "";
    if (self.altInput !== void 0)
      self.altInput.value = "";
    if (self.mobileInput !== void 0)
      self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      const { hours, minutes, seconds } = getDefaultHours(self.config);
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== void 0) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== void 0) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== void 0)
      triggerEvent("onDestroy");
    for (let i = self._handlers.length; i--; ) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode)
        self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = void 0;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        const wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode)
        self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach((k) => {
      try {
        delete self[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    if (self.config.appendTo && self.config.appendTo.contains(elem))
      return true;
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      const eventTarget = getEventTarget(e);
      const isCalendarElement = isCalendarElem(eventTarget);
      const isInput = eventTarget === self.input || eventTarget === self.altInput || self.element.contains(eventTarget) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      const lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      const isIgnored = !self.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
      if (lostFocus && isIgnored) {
        if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0 && self.input.value !== "" && self.input.value !== void 0) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) {
          self.clear(false);
          self.redraw();
        }
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear())
      return;
    const newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless = true) {
    var _a;
    const dateToCheck = self.parseDate(date, void 0, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== void 0 ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== void 0 ? timeless : !self.maxDateHasTime) > 0)
      return false;
    if (!self.config.enable && self.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    const bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (let i = 0, d; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        const parsed = self.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    const isInput = e.target === self._input;
    if (isInput && (self.selectedDates.length > 0 || self._input.value.length > 0) && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    const eventTarget = getEventTarget(e);
    const isInput = self.config.wrap ? element2.contains(eventTarget) : eventTarget === self._input;
    const allowInput = self.config.allowInput;
    const allowKeydown = self.isOpen && (!allowInput || !isInput);
    const allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      const isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            if (self.daysContainer !== void 0 && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
              const delta2 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta2);
              else {
                e.stopPropagation();
                changeMonth(delta2);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement)
            self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          const delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== void 0 || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement)
              self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            const elems = [
              self.hourElement,
              self.minuteElement,
              self.secondElement,
              self.amPM
            ].concat(self.pluginElements).filter((x) => x);
            const i = elems.indexOf(eventTarget);
            if (i !== -1) {
              const target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem) {
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled")))
      return;
    const hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    let containsDisabled = false;
    let minRange = 0, maxRange = 0;
    for (let t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange))
          minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange))
          maxRange = t;
      }
    }
    for (let m = 0; m < self.config.showMonths; m++) {
      const month = self.daysContainer.children[m];
      for (let i = 0, l = month.children.length; i < l; i++) {
        const dayElem = month.children[i], date = dayElem.dateObj;
        const timestamp = date.getTime();
        const outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach((c) => {
            dayElem.classList.remove(c);
          });
          continue;
        } else if (containsDisabled && !outOfRange)
          continue;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach((c) => {
          dayElem.classList.remove(c);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      }
    }
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline)
      positionCalendar();
  }
  function open(e, positionElement = self._positionElement) {
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        const eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== void 0) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    const wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === void 0 || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(() => self.hourElement.select(), 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return (date) => {
      const dateObj = self.config[`_${type}Date`] = self.parseDate(date, self.config.dateFormat);
      const inverseDateObj = self.config[`_${type === "min" ? "max" : "min"}Date`];
      if (dateObj !== void 0) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter((d) => isEnabled(d));
        if (!self.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    const boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element2.dataset || {}))), instanceConfig);
    const formats2 = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: () => self.config._enable,
      set: (dates) => {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: () => self.config._disable,
      set: (dates) => {
        self.config._disable = parseDateRules(dates);
      }
    });
    const timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
    }
    Object.defineProperty(self.config, "minDate", {
      get: () => self.config._minDate,
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: () => self.config._maxDate,
      set: minMaxDateSetter("max")
    });
    const minMaxTimeSetter = (type) => (val) => {
      self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
    };
    Object.defineProperty(self.config, "minTime", {
      get: () => self.config._minTime,
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: () => self.config._maxTime,
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats2, userConfig);
    for (let i = 0; i < boolOpts.length; i++)
      self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter((hook) => self.config[hook] !== void 0).forEach((hook) => {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (let i = 0; i < self.config.plugins.length; i++) {
      const pluginConf = self.config.plugins[i](self) || {};
      for (const key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element2.querySelector("[data-input]") : element2;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined")
      self.config.errorHandler(new Error(`flatpickr: invalid locale ${self.config.locale}`));
    self.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : void 0);
    tokenRegex.K = `(${self.l10n.amPM[0]}|${self.l10n.amPM[1]}|${self.l10n.amPM[0].toLowerCase()}|${self.l10n.amPM[1].toLowerCase()})`;
    const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element2.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    const positionElement = customPositionElement || self._positionElement;
    const calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (acc, child) => acc + child.offsetHeight, 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    const top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline)
      return;
    let left = window.pageXOffset + inputBounds.left;
    let isCenter = false;
    let isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    const right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    const rightMost = left + calendarWidth > window.document.body.offsetWidth;
    const centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static)
      return;
    self.calendarContainer.style.top = `${top}px`;
    if (!rightMost) {
      self.calendarContainer.style.left = `${left}px`;
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = `${right}px`;
    } else {
      const doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      const bodyWidth = window.document.body.offsetWidth;
      const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      const centerBefore = ".flatpickr-calendar.centerMost:before";
      const centerAfter = ".flatpickr-calendar.centerMost:after";
      const centerIndex = doc.cssRules.length;
      const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
      self.calendarContainer.style.left = `${centerLeft}px`;
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    let editableSheet = null;
    for (let i = 0; i < document.styleSheets.length; i++) {
      const sheet = document.styleSheets[i];
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    const style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    const isSelectable = (day) => day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    const t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0)
      return;
    const target = t;
    const selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    const shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single")
      self.selectedDates = [selectedDate];
    else if (self.config.mode === "multiple") {
      const selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
        self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      const isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self.selectedDateElem !== void 0 && self.hourElement === void 0) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== void 0)
      self.hourElement !== void 0 && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      const single = self.config.mode === "single" && !self.config.enableTime;
      const range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  const CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    clickOpens: [
      () => {
        if (self.config.clickOpens === true) {
          bind2(self._input, "focus", self.open);
          bind2(self._input, "click", self.open);
        } else {
          self._input.removeEventListener("focus", self.open);
          self._input.removeEventListener("click", self.open);
        }
      }
    ]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (const key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach((x) => x());
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach((x) => x());
      else if (HOOKS.indexOf(option) > -1)
        self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    let dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map((d) => self.parseDate(d, format));
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map((date) => self.parseDate(date, format));
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map((date) => self.parseDate(date, format));
          break;
        default:
          break;
      }
    } else
      self.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter((d) => d instanceof Date && isEnabled(d, false));
    if (self.config.mode === "range")
      self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
  }
  function setDate(date, triggerChange2 = false, format = self.config.dateFormat) {
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self.clear(triggerChange2);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map((rule) => {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self.parseDate(rule.from, void 0),
          to: self.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter((x) => x);
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    const preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0)
      self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== void 0)
      self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== void 0)
      self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode)
        self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput)
      self._input.setAttribute("readonly", "readonly");
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    const inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate)
      self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate)
      self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step"))
      self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== void 0)
      self.altInput.type = "hidden";
    try {
      if (self.input.parentNode)
        self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {
    }
    bind2(self.mobileInput, "change", (e) => {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true)
      return self.close();
    self.open(e);
  }
  function triggerEvent(event2, data) {
    if (self.config === void 0)
      return;
    const hooks = self.config[event2];
    if (hooks !== void 0 && hooks.length > 0) {
      for (let i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event2 === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    const e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (let i = 0; i < self.selectedDates.length; i++) {
      if (compareDates(self.selectedDates[i], date) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2)
      return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav)
      return;
    self.yearElements.forEach((yearElement, i) => {
      const d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== void 0 && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== void 0 && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(format) {
    return self.selectedDates.map((dObj) => self.formatDate(dObj, format)).filter((d, i, arr) => self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2 = true) {
    if (self.mobileInput !== void 0 && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== void 0 ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== void 0) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    const eventTarget = getEventTarget(e);
    const isPrevMonth = self.prevMonthNav.contains(eventTarget);
    const isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    const isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    const min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    let newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      const isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self.hourElement);
      } else if (newValue > max) {
        newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init2();
  return self;
}
function _flatpickr(nodeList, config) {
  const nodes = Array.prototype.slice.call(nodeList).filter((x) => x instanceof HTMLElement);
  const instances = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: Object.assign({}, default_default),
  default: Object.assign({}, default_default)
};
flatpickr.localize = (l10n2) => {
  flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n2);
};
flatpickr.setDefaults = (config) => {
  flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// node_modules/carbon-components-svelte/src/DatePicker/createCalendar.js
var l10n;
function updateClasses(instance207) {
  const {
    calendarContainer,
    days,
    daysContainer,
    weekdayContainer,
    selectedDates
  } = instance207;
  calendarContainer.classList.add("bx--date-picker__calendar");
  calendarContainer.querySelector(".flatpickr-month").classList.add("bx--date-picker__month");
  weekdayContainer.classList.add("bx--date-picker__weekdays");
  weekdayContainer.querySelectorAll(".flatpickr-weekday").forEach((node) => {
    node.classList.add("bx--date-picker__weekday");
  });
  daysContainer.classList.add("bx--date-picker__days");
  days.querySelectorAll(".flatpickr-day").forEach((node) => {
    node.classList.add("bx--date-picker__day");
    if (node.classList.contains("today") && selectedDates.length > 0) {
      node.classList.add("no-border");
    } else if (node.classList.contains("today") && selectedDates.length === 0) {
      node.classList.remove("no-border");
    }
  });
}
function updateMonthNode(instance207) {
  const monthText = instance207.l10n.months.longhand[instance207.currentMonth];
  const staticMonthNode = instance207.monthNav.querySelector(".cur-month");
  if (staticMonthNode) {
    staticMonthNode.textContent = monthText;
  } else {
    const monthSelectNode = instance207.monthsDropdownContainer;
    const span = document.createElement("span");
    span.setAttribute("class", "cur-month");
    span.textContent = monthText;
    monthSelectNode.parentNode.replaceChild(span, monthSelectNode);
  }
}
async function createCalendar({ options, base, input, dispatch }) {
  let locale = options.locale;
  if (options.locale === "en" && l10n && l10n.en) {
    l10n.en.weekdays.shorthand.forEach((_, index) => {
      const shorthand = _.slice(0, 2);
      l10n.en.weekdays.shorthand[index] = shorthand === "Th" ? "Th" : shorthand.charAt(0);
    });
    locale = l10n.en;
  }
  let rangePlugin;
  if (options.mode === "range") {
    const importee = await import("./rangePlugin-YON54I2L.js");
    rangePlugin = importee.default;
  }
  return new esm_default(base, {
    allowInput: true,
    disableMobile: true,
    clickOpens: true,
    locale,
    plugins: [
      options.mode === "range" && new rangePlugin({ position: "left", input })
    ].filter(Boolean),
    nextArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/><rect width="16" height="16" style="fill: none" /></svg>',
    prevArrow: '<svg width="16px" height="16px" viewBox="0 0 16 16"><polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/><rect width="16" height="16" style="fill: none" /></svg>',
    onChange: () => {
      dispatch("change");
    },
    onClose: () => {
      dispatch("close");
    },
    onMonthChange: (s, d, instance207) => {
      updateMonthNode(instance207);
    },
    onOpen: (s, d, instance207) => {
      dispatch("open");
      updateClasses(instance207);
      updateMonthNode(instance207);
    },
    ...options
  });
}

// node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte
var file68 = "node_modules/carbon-components-svelte/src/DatePicker/DatePicker.svelte";
function create_fragment72(ctx) {
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[30].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[29], null);
  let div1_levels = [ctx[15]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "id", ctx[3]);
      toggle_class(div0, "bx--date-picker", true);
      toggle_class(div0, "bx--date-picker--short", ctx[1]);
      toggle_class(div0, "bx--date-picker--light", ctx[2]);
      toggle_class(div0, "bx--date-picker--simple", ctx[0] === "simple");
      toggle_class(div0, "bx--date-picker--single", ctx[0] === "single");
      toggle_class(div0, "bx--date-picker--range", ctx[0] === "range");
      toggle_class(div0, "bx--date-picker--nolabel", ctx[0] === "range" && ctx[6]);
      add_location(div0, file68, 248, 2, 6128);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file68, 240, 0, 6011);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[36](div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[35], false, false, false),
          listen_dev(div0, "keydown", ctx[37], false, false, false),
          listen_dev(div1, "click", ctx[31], false, false, false),
          listen_dev(div1, "mouseover", ctx[32], false, false, false),
          listen_dev(div1, "mouseenter", ctx[33], false, false, false),
          listen_dev(div1, "mouseleave", ctx[34], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(default_slot_template, ctx2[29], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 8) {
        attr_dev(div0, "id", ctx2[3]);
      }
      if (!current || dirty[0] & 2) {
        toggle_class(div0, "bx--date-picker--short", ctx2[1]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div0, "bx--date-picker--light", ctx2[2]);
      }
      if (!current || dirty[0] & 1) {
        toggle_class(div0, "bx--date-picker--simple", ctx2[0] === "simple");
      }
      if (!current || dirty[0] & 1) {
        toggle_class(div0, "bx--date-picker--single", ctx2[0] === "single");
      }
      if (!current || dirty[0] & 1) {
        toggle_class(div0, "bx--date-picker--range", ctx2[0] === "range");
      }
      if (!current || dirty[0] & 65) {
        toggle_class(div0, "bx--date-picker--nolabel", ctx2[0] === "range" && ctx2[6]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty[0] & 32768 && ctx2[15]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[36](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "datePickerType",
    "value",
    "valueFrom",
    "valueTo",
    "dateFormat",
    "maxDate",
    "minDate",
    "locale",
    "short",
    "light",
    "id",
    "flatpickrProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $hasCalendar;
  let $inputValueTo;
  let $inputValueFrom;
  let $inputValue;
  let $range;
  let $mode;
  let $inputIds;
  let $labelTextEmpty;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePicker", slots, ["default"]);
  let { datePickerType = "simple" } = $$props;
  let { value = "" } = $$props;
  let { valueFrom = "" } = $$props;
  let { valueTo = "" } = $$props;
  let { dateFormat = "m/d/Y" } = $$props;
  let { maxDate = null } = $$props;
  let { minDate = null } = $$props;
  let { locale = "en" } = $$props;
  let { short = false } = $$props;
  let { light = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { flatpickrProps = { static: true } } = $$props;
  const dispatch = createEventDispatcher();
  const inputs = writable([]);
  const inputIds = derived(inputs, (_) => _.map(({ id: id2 }) => id2));
  validate_store(inputIds, "inputIds");
  component_subscribe($$self, inputIds, (value2) => $$invalidate(41, $inputIds = value2));
  const labelTextEmpty = derived(inputs, (_) => _.filter(({ labelText }) => !!labelText).length === 0);
  validate_store(labelTextEmpty, "labelTextEmpty");
  component_subscribe($$self, labelTextEmpty, (value2) => $$invalidate(6, $labelTextEmpty = value2));
  const inputValue = writable(value);
  validate_store(inputValue, "inputValue");
  component_subscribe($$self, inputValue, (value2) => $$invalidate(28, $inputValue = value2));
  const inputValueFrom = writable(valueFrom);
  validate_store(inputValueFrom, "inputValueFrom");
  component_subscribe($$self, inputValueFrom, (value2) => $$invalidate(27, $inputValueFrom = value2));
  const inputValueTo = writable(valueTo);
  validate_store(inputValueTo, "inputValueTo");
  component_subscribe($$self, inputValueTo, (value2) => $$invalidate(26, $inputValueTo = value2));
  const mode = writable(datePickerType);
  validate_store(mode, "mode");
  component_subscribe($$self, mode, (value2) => $$invalidate(40, $mode = value2));
  const range = derived(mode, (_) => _ === "range");
  validate_store(range, "range");
  component_subscribe($$self, range, (value2) => $$invalidate(39, $range = value2));
  const hasCalendar = derived(mode, (_) => _ === "single" || _ === "range");
  validate_store(hasCalendar, "hasCalendar");
  component_subscribe($$self, hasCalendar, (value2) => $$invalidate(25, $hasCalendar = value2));
  let calendar = null;
  let datePickerRef = null;
  let inputRef = null;
  let inputRefTo = null;
  setContext("DatePicker", {
    range,
    inputValue,
    inputValueFrom,
    inputValueTo,
    inputIds,
    hasCalendar,
    add: (data) => {
      inputs.update((_) => [..._, data]);
    },
    declareRef: ({ id: id2, ref }) => {
      if ($inputIds.indexOf(id2) === 0) {
        $$invalidate(24, inputRef = ref);
      } else {
        inputRefTo = ref;
      }
    },
    updateValue: ({ type, value: value2 }) => {
      if (!calendar && type === "input" || type === "change") {
        inputValue.set(value2);
      }
      if (!calendar && type === "change") {
        dispatch("change", value2);
      }
    },
    blurInput: (relatedTarget) => {
      if (calendar && !calendar.calendarContainer.contains(relatedTarget)) {
        calendar.close();
      }
    },
    openCalendar: () => {
      calendar.open();
    },
    focusCalendar: () => {
      (calendar.selectedDateElem || calendar.todayDateElem || calendar.calendarContainer.querySelector(".flatpickr-day[tabindex]") || calendar.calendarContainer).focus();
    }
  });
  async function initCalendar(options) {
    var _a, _b;
    if (calendar) {
      calendar.set("minDate", minDate);
      calendar.set("maxDate", maxDate);
      calendar.set("locale", locale);
      calendar.set("dateFormat", dateFormat);
      Object.entries(flatpickrProps).forEach(([option, value2]) => {
        calendar.set(options, value2);
      });
      return;
    }
    $$invalidate(4, calendar = await createCalendar({
      options: {
        ...options,
        appendTo: datePickerRef,
        defaultDate: $inputValue,
        mode: $mode
      },
      base: inputRef,
      input: inputRefTo,
      dispatch: (event2) => {
        const detail = { selectedDates: calendar.selectedDates };
        if ($range) {
          const from = inputRef.value;
          const to = inputRefTo.value;
          detail.dateStr = {
            from: inputRef.value,
            to: inputRefTo.value
          };
          $$invalidate(17, valueFrom = from);
          $$invalidate(18, valueTo = to);
        } else {
          detail.dateStr = inputRef.value;
        }
        return dispatch(event2, detail);
      }
    }));
    (_a = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _a.setAttribute("role", "application");
    (_b = calendar == null ? void 0 : calendar.calendarContainer) == null ? void 0 : _b.setAttribute("aria-label", "calendar-container");
  }
  onMount(() => {
    return () => {
      if (calendar) {
        calendar.destroy();
        $$invalidate(4, calendar = null);
      }
    };
  });
  afterUpdate(() => {
    if (calendar) {
      if ($range) {
        calendar.setDate([$inputValueFrom, $inputValueTo]);
        $$invalidate(24, inputRef.value = $inputValueFrom, inputRef);
      } else {
        calendar.setDate($inputValue);
      }
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (!calendar || !calendar.isOpen)
      return;
    if (datePickerRef && datePickerRef.contains(target))
      return;
    if (!calendar.calendarContainer.contains(target))
      calendar.close();
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      datePickerRef = $$value;
      $$invalidate(5, datePickerRef);
    });
  }
  const keydown_handler = (e) => {
    if ((calendar == null ? void 0 : calendar.isOpen) && e.key === "Escape") {
      e.stopPropagation();
      calendar.close();
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("datePickerType" in $$new_props)
      $$invalidate(0, datePickerType = $$new_props.datePickerType);
    if ("value" in $$new_props)
      $$invalidate(16, value = $$new_props.value);
    if ("valueFrom" in $$new_props)
      $$invalidate(17, valueFrom = $$new_props.valueFrom);
    if ("valueTo" in $$new_props)
      $$invalidate(18, valueTo = $$new_props.valueTo);
    if ("dateFormat" in $$new_props)
      $$invalidate(19, dateFormat = $$new_props.dateFormat);
    if ("maxDate" in $$new_props)
      $$invalidate(20, maxDate = $$new_props.maxDate);
    if ("minDate" in $$new_props)
      $$invalidate(21, minDate = $$new_props.minDate);
    if ("locale" in $$new_props)
      $$invalidate(22, locale = $$new_props.locale);
    if ("short" in $$new_props)
      $$invalidate(1, short = $$new_props.short);
    if ("light" in $$new_props)
      $$invalidate(2, light = $$new_props.light);
    if ("id" in $$new_props)
      $$invalidate(3, id = $$new_props.id);
    if ("flatpickrProps" in $$new_props)
      $$invalidate(23, flatpickrProps = $$new_props.flatpickrProps);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    datePickerType,
    value,
    valueFrom,
    valueTo,
    dateFormat,
    maxDate,
    minDate,
    locale,
    short,
    light,
    id,
    flatpickrProps,
    createEventDispatcher,
    setContext,
    afterUpdate,
    onMount,
    writable,
    derived,
    createCalendar,
    dispatch,
    inputs,
    inputIds,
    labelTextEmpty,
    inputValue,
    inputValueFrom,
    inputValueTo,
    mode,
    range,
    hasCalendar,
    calendar,
    datePickerRef,
    inputRef,
    inputRefTo,
    initCalendar,
    $hasCalendar,
    $inputValueTo,
    $inputValueFrom,
    $inputValue,
    $range,
    $mode,
    $inputIds,
    $labelTextEmpty
  });
  $$self.$inject_state = ($$new_props) => {
    if ("datePickerType" in $$props)
      $$invalidate(0, datePickerType = $$new_props.datePickerType);
    if ("value" in $$props)
      $$invalidate(16, value = $$new_props.value);
    if ("valueFrom" in $$props)
      $$invalidate(17, valueFrom = $$new_props.valueFrom);
    if ("valueTo" in $$props)
      $$invalidate(18, valueTo = $$new_props.valueTo);
    if ("dateFormat" in $$props)
      $$invalidate(19, dateFormat = $$new_props.dateFormat);
    if ("maxDate" in $$props)
      $$invalidate(20, maxDate = $$new_props.maxDate);
    if ("minDate" in $$props)
      $$invalidate(21, minDate = $$new_props.minDate);
    if ("locale" in $$props)
      $$invalidate(22, locale = $$new_props.locale);
    if ("short" in $$props)
      $$invalidate(1, short = $$new_props.short);
    if ("light" in $$props)
      $$invalidate(2, light = $$new_props.light);
    if ("id" in $$props)
      $$invalidate(3, id = $$new_props.id);
    if ("flatpickrProps" in $$props)
      $$invalidate(23, flatpickrProps = $$new_props.flatpickrProps);
    if ("calendar" in $$props)
      $$invalidate(4, calendar = $$new_props.calendar);
    if ("datePickerRef" in $$props)
      $$invalidate(5, datePickerRef = $$new_props.datePickerRef);
    if ("inputRef" in $$props)
      $$invalidate(24, inputRef = $$new_props.inputRef);
    if ("inputRefTo" in $$props)
      inputRefTo = $$new_props.inputRefTo;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 268435456) {
      $:
        $$invalidate(16, value = $inputValue);
    }
    if ($$self.$$.dirty[0] & 65536) {
      $:
        inputValue.set(value);
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(17, valueFrom = $inputValueFrom);
    }
    if ($$self.$$.dirty[0] & 131072) {
      $:
        inputValueFrom.set(valueFrom);
    }
    if ($$self.$$.dirty[0] & 67108864) {
      $:
        $$invalidate(18, valueTo = $inputValueTo);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        inputValueTo.set(valueTo);
    }
    if ($$self.$$.dirty[0] & 66584576) {
      $:
        if ($hasCalendar && inputRef) {
          initCalendar({
            dateFormat,
            locale,
            maxDate,
            minDate,
            static: true,
            ...flatpickrProps
          });
        }
    }
  };
  return [
    datePickerType,
    short,
    light,
    id,
    calendar,
    datePickerRef,
    $labelTextEmpty,
    inputIds,
    labelTextEmpty,
    inputValue,
    inputValueFrom,
    inputValueTo,
    mode,
    range,
    hasCalendar,
    $$restProps,
    value,
    valueFrom,
    valueTo,
    dateFormat,
    maxDate,
    minDate,
    locale,
    flatpickrProps,
    inputRef,
    $hasCalendar,
    $inputValueTo,
    $inputValueFrom,
    $inputValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_13,
    div0_binding,
    keydown_handler
  ];
}
var DatePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance72,
      create_fragment72,
      safe_not_equal,
      {
        datePickerType: 0,
        value: 16,
        valueFrom: 17,
        valueTo: 18,
        dateFormat: 19,
        maxDate: 20,
        minDate: 21,
        locale: 22,
        short: 1,
        light: 2,
        id: 3,
        flatpickrProps: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePicker",
      options,
      id: create_fragment72.name
    });
  }
  get datePickerType() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set datePickerType(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueFrom() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueFrom(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueTo() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueTo(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFormat() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dateFormat(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDate() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDate(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDate() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDate(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get short() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set short(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flatpickrProps() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flatpickrProps(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePicker_default = DatePicker;

// node_modules/carbon-components-svelte/src/icons/Calendar.svelte
var file69 = "node_modules/carbon-components-svelte/src/icons/Calendar.svelte";
function create_if_block43(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file69, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block43.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block43(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20	V26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z");
      add_location(path, file69, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file69, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block43(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment73.name
    });
  }
  get size() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte
var file70 = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerInput.svelte";
var get_labelText_slot_changes5 = (dirty) => ({});
var get_labelText_slot_context5 = (ctx) => ({});
function create_if_block_63(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[35].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[34], get_labelText_slot_context5);
  const labelText_slot_or_fallback = labelText_slot || fallback_block14(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[8]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[10]);
      toggle_class(label, "bx--label--disabled", ctx[5]);
      add_location(label, file70, 85, 4, 1995);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[1] & 8)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[34],
            !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(labelText_slot_template, ctx2[34], dirty, get_labelText_slot_changes5),
            get_labelText_slot_context5
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 256) {
        attr_dev(label, "for", ctx2[8]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--visually-hidden", ctx2[10]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(label, "bx--label--disabled", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_63.name,
    type: "if",
    source: "(85:2) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[9]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block14.name,
    type: "fallback",
    source: "(92:29)          ",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: {
      class: "bx--date-picker__icon bx--date-picker__icon--invalid"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(141:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--date-picker__icon bx--date-picker__icon--warn"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(146:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let calendar;
  let current;
  calendar = new Calendar_default({
    props: {
      class: "bx--date-picker__icon",
      "aria-label": ctx[7]
    },
    $$inline: true
  });
  calendar.$on("click", ctx[27]);
  const block = {
    c: function create() {
      create_component(calendar.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(calendar, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const calendar_changes = {};
      if (dirty[0] & 128)
        calendar_changes["aria-label"] = ctx2[7];
      calendar.$set(calendar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(calendar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(151:4) {#if $hasCalendar && !invalid && !warn}",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[12]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file70, 159, 4, 3988);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(159:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[14]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file70, 162, 4, 4086);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16384)
        set_data_dev(t, ctx2[14]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(162:2) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block44(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[6]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[5]);
      add_location(div, file70, 165, 4, 4175);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
      if (dirty[0] & 32) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[5]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block44.name,
    type: "if",
    source: "(165:2) {#if helperText}",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_data_invalid_value;
  let input_value_value;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[9] || ctx[32].labelText) && create_if_block_63(ctx);
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = ctx[11] || void 0
    },
    { id: ctx[8] },
    { name: ctx[15] },
    { placeholder: ctx[3] },
    { type: ctx[2] },
    { pattern: ctx[4] },
    { disabled: ctx[5] },
    ctx[33],
    {
      value: input_value_value = ctx[16] ? ctx[17].indexOf(ctx[8]) === 0 ? ctx[18] : ctx[19] : ctx[20]
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = ctx[11] && create_if_block_53(ctx);
  let if_block2 = !ctx[11] && ctx[13] && create_if_block_45(ctx);
  let if_block3 = ctx[21] && !ctx[11] && !ctx[13] && create_if_block_35(ctx);
  let if_block4 = ctx[11] && create_if_block_29(ctx);
  let if_block5 = !ctx[11] && ctx[13] && create_if_block_113(ctx);
  let if_block6 = ctx[6] && create_if_block44(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      set_attributes(input, input_data);
      toggle_class(input, "bx--date-picker__input", true);
      toggle_class(input, "bx--date-picker__input--invalid", ctx[11]);
      toggle_class(input, "bx--date-picker__input--sm", ctx[1] === "sm");
      toggle_class(input, "bx--date-picker__input--xl", ctx[1] === "xl");
      add_location(input, file70, 101, 4, 2415);
      toggle_class(div0, "bx--date-picker-input__wrapper", true);
      toggle_class(div0, "bx--date-picker-input__wrapper--invalid", ctx[11]);
      toggle_class(div0, "bx--date-picker-input__wrapper--warn", ctx[13]);
      add_location(div0, file70, 96, 2, 2234);
      toggle_class(div1, "bx--date-picker-container", true);
      toggle_class(div1, "bx--date-picker--nolabel", !ctx[9]);
      add_location(div1, file70, 80, 0, 1854);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, div0);
      append_dev(div0, input);
      input.value = input_data.value;
      if (input.autofocus)
        input.focus();
      ctx[41](input);
      append_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t2);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div1, t4);
      if (if_block4)
        if_block4.m(div1, null);
      append_dev(div1, t5);
      if (if_block5)
        if_block5.m(div1, null);
      append_dev(div1, t6);
      if (if_block6)
        if_block6.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[36], false, false, false),
          listen_dev(input, "input", ctx[42], false, false, false),
          listen_dev(input, "change", ctx[43], false, false, false),
          listen_dev(input, "keydown", ctx[37], false, false, false),
          listen_dev(input, "keydown", ctx[44], false, false, false),
          listen_dev(input, "keyup", ctx[38], false, false, false),
          listen_dev(input, "blur", ctx[39], false, false, false),
          listen_dev(input, "blur", ctx[45], false, false, false),
          listen_dev(input, "paste", ctx[40], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[9] || ctx2[32].labelText) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 512 | dirty[1] & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_63(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & 2048 && input_data_invalid_value !== (input_data_invalid_value = ctx2[11] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & 256) && { id: ctx2[8] },
        (!current || dirty[0] & 32768) && { name: ctx2[15] },
        (!current || dirty[0] & 8) && { placeholder: ctx2[3] },
        (!current || dirty[0] & 4) && { type: ctx2[2] },
        (!current || dirty[0] & 16) && { pattern: ctx2[4] },
        (!current || dirty[0] & 32) && { disabled: ctx2[5] },
        dirty[1] & 4 && ctx2[33],
        (!current || dirty[0] & 2031872 && input_value_value !== (input_value_value = ctx2[16] ? ctx2[17].indexOf(ctx2[8]) === 0 ? ctx2[18] : ctx2[19] : ctx2[20]) && input.value !== input_value_value) && { value: input_value_value }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "bx--date-picker__input", true);
      toggle_class(input, "bx--date-picker__input--invalid", ctx2[11]);
      toggle_class(input, "bx--date-picker__input--sm", ctx2[1] === "sm");
      toggle_class(input, "bx--date-picker__input--xl", ctx2[1] === "xl");
      if (ctx2[11]) {
        if (if_block1) {
          if (dirty[0] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_53(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[11] && ctx2[13]) {
        if (if_block2) {
          if (dirty[0] & 10240) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_45(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[21] && !ctx2[11] && !ctx2[13]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 2107392) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_35(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 2048) {
        toggle_class(div0, "bx--date-picker-input__wrapper--invalid", ctx2[11]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(div0, "bx--date-picker-input__wrapper--warn", ctx2[13]);
      }
      if (ctx2[11]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_29(ctx2);
          if_block4.c();
          if_block4.m(div1, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!ctx2[11] && ctx2[13]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_113(ctx2);
          if_block5.c();
          if_block5.m(div1, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[6]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block44(ctx2);
          if_block6.c();
          if_block6.m(div1, null);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div1, "bx--date-picker--nolabel", !ctx2[9]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      ctx[41](null);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "type",
    "placeholder",
    "pattern",
    "disabled",
    "helperText",
    "iconDescription",
    "id",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $range;
  let $inputIds;
  let $inputValueFrom;
  let $inputValueTo;
  let $inputValue;
  let $hasCalendar;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePickerInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = "" } = $$props;
  let { pattern = "\\d{1,2}\\/\\d{1,2}\\/\\d{4}" } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { iconDescription = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const { range, add, hasCalendar, declareRef, inputIds, updateValue, blurInput, openCalendar, focusCalendar, inputValue, inputValueFrom, inputValueTo } = getContext("DatePicker");
  validate_store(range, "range");
  component_subscribe($$self, range, (value) => $$invalidate(16, $range = value));
  validate_store(hasCalendar, "hasCalendar");
  component_subscribe($$self, hasCalendar, (value) => $$invalidate(21, $hasCalendar = value));
  validate_store(inputIds, "inputIds");
  component_subscribe($$self, inputIds, (value) => $$invalidate(17, $inputIds = value));
  validate_store(inputValue, "inputValue");
  component_subscribe($$self, inputValue, (value) => $$invalidate(20, $inputValue = value));
  validate_store(inputValueFrom, "inputValueFrom");
  component_subscribe($$self, inputValueFrom, (value) => $$invalidate(18, $inputValueFrom = value));
  validate_store(inputValueTo, "inputValueTo");
  component_subscribe($$self, inputValueTo, (value) => $$invalidate(19, $inputValueTo = value));
  add({ id, labelText });
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const input_handler_1 = ({ target }) => {
    updateValue({ type: "input", value: target.value });
  };
  const change_handler = ({ target }) => {
    updateValue({ type: "change", value: target.value });
  };
  const keydown_handler_12 = ({ key }) => {
    if (key === "ArrowDown") {
      focusCalendar();
    }
  };
  const blur_handler_1 = ({ relatedTarget }) => {
    blurInput(relatedTarget);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$new_props)
      $$invalidate(4, pattern = $$new_props.pattern);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props)
      $$invalidate(6, helperText = $$new_props.helperText);
    if ("iconDescription" in $$new_props)
      $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("labelText" in $$new_props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("name" in $$new_props)
      $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(34, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    type,
    placeholder,
    pattern,
    disabled,
    helperText,
    iconDescription,
    id,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    name,
    ref,
    getContext,
    Calendar: Calendar_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    range,
    add,
    hasCalendar,
    declareRef,
    inputIds,
    updateValue,
    blurInput,
    openCalendar,
    focusCalendar,
    inputValue,
    inputValueFrom,
    inputValueTo,
    $range,
    $inputIds,
    $inputValueFrom,
    $inputValueTo,
    $inputValue,
    $hasCalendar
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$props)
      $$invalidate(4, pattern = $$new_props.pattern);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$props)
      $$invalidate(6, helperText = $$new_props.helperText);
    if ("iconDescription" in $$props)
      $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
    if ("labelText" in $$props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("name" in $$props)
      $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 257) {
      $:
        if (ref)
          declareRef({ id, ref });
    }
  };
  return [
    ref,
    size,
    type,
    placeholder,
    pattern,
    disabled,
    helperText,
    iconDescription,
    id,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    name,
    $range,
    $inputIds,
    $inputValueFrom,
    $inputValueTo,
    $inputValue,
    $hasCalendar,
    range,
    hasCalendar,
    inputIds,
    updateValue,
    blurInput,
    openCalendar,
    focusCalendar,
    inputValue,
    inputValueFrom,
    inputValueTo,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    input_handler,
    keydown_handler,
    keyup_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_handler_1,
    change_handler,
    keydown_handler_12,
    blur_handler_1
  ];
}
var DatePickerInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance74,
      create_fragment74,
      safe_not_equal,
      {
        size: 1,
        type: 2,
        placeholder: 3,
        pattern: 4,
        disabled: 5,
        helperText: 6,
        iconDescription: 7,
        id: 8,
        labelText: 9,
        hideLabel: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        name: 15,
        ref: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePickerInput",
      options,
      id: create_fragment74.name
    });
  }
  get size() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<DatePickerInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<DatePickerInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePickerInput_default = DatePickerInput;

// node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte
var file71 = "node_modules/carbon-components-svelte/src/DatePicker/DatePickerSkeleton.svelte";
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block8(key_1, ctx) {
  let div1;
  let label;
  let t0;
  let div0;
  let t1;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div1 = element("div");
      label = element("label");
      t0 = space();
      div0 = element("div");
      t1 = space();
      attr_dev(label, "for", ctx[1]);
      toggle_class(label, "bx--label", true);
      add_location(label, file71, 26, 8, 728);
      toggle_class(div0, "bx--date-picker__input", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file71, 27, 8, 788);
      toggle_class(div1, "bx--date-picker-container", true);
      add_location(div1, file71, 25, 6, 673);
      this.first = div1;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, label);
      append_dev(div1, t0);
      append_dev(div1, div0);
      append_dev(div1, t1);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2) {
        attr_dev(label, "for", ctx[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(25:4) {#each Array.from({ length: range ? 2 : 1 }, (_, i) => i) as input, i (input)}",
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[0] ? 2 : 1 }, func4);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[7];
  validate_each_keys(ctx, each_value, get_each_context8, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block8(key, child_ctx));
  }
  let div1_levels = [ctx[2]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      toggle_class(div0, "bx--date-picker", true);
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--date-picker--range", true);
      toggle_class(div0, "bx--date-picker--short", !ctx[0]);
      toggle_class(div0, "bx--date-picker--simple", !ctx[0]);
      add_location(div0, file71, 17, 2, 377);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file71, 9, 0, 260);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[3], false, false, false),
          listen_dev(div1, "mouseover", ctx[4], false, false, false),
          listen_dev(div1, "mouseenter", ctx[5], false, false, false),
          listen_dev(div1, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = Array.from({ length: ctx2[0] ? 2 : 1 }, func4);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context8, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, destroy_block, create_each_block8, null, get_each_context8);
      }
      if (dirty & 1) {
        toggle_class(div0, "bx--date-picker--short", !ctx2[0]);
      }
      if (dirty & 1) {
        toggle_class(div0, "bx--date-picker--simple", !ctx2[0]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func4 = (_, i) => i;
function instance75($$self, $$props, $$invalidate) {
  const omit_props_names = ["range", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePickerSkeleton", slots, []);
  let { range = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("range" in $$new_props)
      $$invalidate(0, range = $$new_props.range);
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({ range, id });
  $$self.$inject_state = ($$new_props) => {
    if ("range" in $$props)
      $$invalidate(0, range = $$new_props.range);
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    range,
    id,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DatePickerSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, { range: 0, id: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePickerSkeleton",
      options,
      id: create_fragment75.name
    });
  }
  get range() {
    throw new Error("<DatePickerSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<DatePickerSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DatePickerSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DatePickerSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePickerSkeleton_default = DatePickerSkeleton;

// node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte
var file72 = "node_modules/carbon-components-svelte/src/Dropdown/Dropdown.svelte";
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  child_ctx[41] = i;
  return child_ctx;
}
var get_default_slot_changes5 = (dirty) => ({
  item: dirty[0] & 8,
  index: dirty[0] & 8
});
var get_default_slot_context5 = (ctx) => ({
  item: ctx[39],
  index: ctx[41]
});
function create_if_block_54(ctx) {
  let label_1;
  let t;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(ctx[10]);
      attr_dev(label_1, "for", ctx[19]);
      toggle_class(label_1, "bx--label", true);
      toggle_class(label_1, "bx--label--disabled", ctx[9]);
      toggle_class(label_1, "bx--visually-hidden", ctx[17]);
      add_location(label_1, file72, 169, 4, 4037);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1024)
        set_data_dev(t, ctx2[10]);
      if (dirty[0] & 524288) {
        attr_dev(label_1, "for", ctx2[19]);
      }
      if (dirty[0] & 512) {
        toggle_class(label_1, "bx--label--disabled", ctx2[9]);
      }
      if (dirty[0] & 131072) {
        toggle_class(label_1, "bx--visually-hidden", ctx2[17]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(169:2) {#if titleText}",
    ctx
  });
  return block;
}
function create_if_block_46(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(206:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(209:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_else_block18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[16]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536)
        set_data_dev(t, ctx2[16]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(271:54) {:else}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let t_value = ctx[4](ctx[22]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4194320 && t_value !== (t_value = ctx2[4](ctx2[22]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(271:8) {#if selectedItem}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let listboxmenu;
  let current;
  listboxmenu = new ListBoxMenu_default({
    props: {
      "aria-labelledby": ctx[19],
      id: ctx[19],
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(listboxmenu.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxmenu_changes = {};
      if (dirty[0] & 524288)
        listboxmenu_changes["aria-labelledby"] = ctx2[19];
      if (dirty[0] & 524288)
        listboxmenu_changes.id = ctx2[19];
      if (dirty[0] & 2097181 | dirty[1] & 64) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxmenu.$set(listboxmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(283:4) {#if open}",
    ctx
  });
  return block;
}
function fallback_block15(ctx) {
  let t_value = ctx[4](ctx[39]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 24 && t_value !== (t_value = ctx2[4](ctx2[39]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block15.name,
    type: "fallback",
    source: "(305:44)                ",
    ctx
  });
  return block;
}
function create_default_slot_24(ctx) {
  let t;
  let current;
  const default_slot_template = ctx[28].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[37], get_default_slot_context5);
  const default_slot_or_fallback = default_slot || fallback_block15(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 8 | dirty[1] & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[37],
            !current ? get_all_dirty_from_scope(ctx2[37]) : get_slot_changes(default_slot_template, ctx2[37], dirty, get_default_slot_changes5),
            get_default_slot_context5
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 24)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: '(286:10) <ListBoxMenuItem             id=\\"{item.id}\\"             active=\\"{selectedId === item.id}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               selectedId = item.id;               dispatchSelect();               ref.focus();             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block9(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_2(...args) {
    return ctx[34](ctx[39], ...args);
  }
  function mouseenter_handler() {
    return ctx[35](ctx[39], ctx[41]);
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: ctx[39].id,
      active: ctx[0] === ctx[39].id,
      highlighted: ctx[21] === ctx[41],
      disabled: ctx[39].disabled,
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_2);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & 8)
        listboxmenuitem_changes.id = ctx[39].id;
      if (dirty[0] & 9)
        listboxmenuitem_changes.active = ctx[0] === ctx[39].id;
      if (dirty[0] & 2097160)
        listboxmenuitem_changes.highlighted = ctx[21] === ctx[41];
      if (dirty[0] & 8)
        listboxmenuitem_changes.disabled = ctx[39].disabled;
      if (dirty[0] & 24 | dirty[1] & 64) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(285:8) {#each items as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[39].id;
  validate_each_keys(ctx, each_value, get_each_context9, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context9(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block9(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 35651613 | dirty[1] & 64) {
        each_value = ctx2[3];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context9, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block9, each_1_anchor, get_each_context9);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: '(284:6) <ListBoxMenu aria-labelledby=\\"{id}\\" id=\\"{id}\\">',
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let t0;
  let t1;
  let button;
  let span;
  let t2;
  let listboxmenuicon;
  let t3;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[11] && create_if_block_46(ctx);
  let if_block1 = !ctx[11] && ctx[13] && create_if_block_36(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[22])
      return create_if_block_210;
    return create_else_block18;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block2 = current_block_type(ctx);
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      translateWithId: ctx[18],
      open: ctx[1]
    },
    $$inline: true
  });
  listboxmenuicon.$on("click", ctx[30]);
  let if_block3 = ctx[1] && create_if_block_114(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      button = element("button");
      span = element("span");
      if_block2.c();
      t2 = space();
      create_component(listboxmenuicon.$$.fragment);
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file72, 269, 6, 6771);
      attr_dev(button, "type", "button");
      attr_dev(button, "tabindex", "0");
      attr_dev(button, "aria-expanded", ctx[1]);
      button.disabled = ctx[9];
      attr_dev(button, "translatewithid", ctx[18]);
      attr_dev(button, "id", ctx[19]);
      toggle_class(button, "bx--list-box__field", true);
      add_location(button, file72, 213, 4, 5299);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, button, anchor);
      append_dev(button, span);
      if_block2.m(span, null);
      append_dev(button, t2);
      mount_component(listboxmenuicon, button, null);
      ctx[31](button);
      insert_dev(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "keydown", ctx[32], false, false, false),
          listen_dev(button, "keyup", ctx[33], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[11]) {
        if (if_block0) {
          if (dirty[0] & 2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_46(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[11] && ctx2[13]) {
        if (if_block1) {
          if (dirty[0] & 10240) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_36(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(span, null);
        }
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & 262144)
        listboxmenuicon_changes.translateWithId = ctx2[18];
      if (dirty[0] & 2)
        listboxmenuicon_changes.open = ctx2[1];
      listboxmenuicon.$set(listboxmenuicon_changes);
      if (!current || dirty[0] & 2) {
        attr_dev(button, "aria-expanded", ctx2[1]);
      }
      if (!current || dirty[0] & 512) {
        prop_dev(button, "disabled", ctx2[9]);
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(button, "translatewithid", ctx2[18]);
      }
      if (!current || dirty[0] & 524288) {
        attr_dev(button, "id", ctx2[19]);
      }
      if (ctx2[1]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_114(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxmenuicon.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxmenuicon.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(button);
      if_block2.d();
      destroy_component(listboxmenuicon);
      ctx[31](null);
      if (detaching)
        detach_dev(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(if_block3_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: `(179:2) <ListBox     role=\\"{undefined}\\"     type=\\"{type}\\"     size=\\"{size}\\"     name=\\"{name}\\"     aria-label=\\"{$$props['aria-label']}\\"     class=\\"bx--dropdown {direction === 'top' && 'bx--list-box--up'} {invalid &&       'bx--dropdown--invalid'} {!invalid &&       warn &&       'bx--dropdown--warning'} {open && 'bx--dropdown--open'}       {size === 'sm' && 'bx--dropdown--sm'}       {size === 'xl' && 'bx--dropdown--xl'}       {inline && 'bx--dropdown--inline'}       {disabled && 'bx--dropdown--disabled'}       {light && 'bx--dropdown--light'}\\"     on:click=\\"{({ target }) => {       if (disabled) return;       open = ref.contains(target) ? !open : false;     }}\\"     disabled=\\"{disabled}\\"     open=\\"{open}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     light=\\"{light}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block45(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[15]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[9]);
      add_location(div, file72, 313, 4, 8081);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data_dev(t, ctx2[15]);
      if (dirty[0] & 512) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[9]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block45.name,
    type: "if",
    source: "(313:2) {#if !inline && !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_fragment76(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[10] && create_if_block_54(ctx);
  listbox = new ListBox_default({
    props: {
      role: void 0,
      type: ctx[5],
      size: ctx[7],
      name: ctx[20],
      "aria-label": ctx[27]["aria-label"],
      class: "bx--dropdown " + (ctx[6] === "top" && "bx--list-box--up") + " " + (ctx[11] && "bx--dropdown--invalid") + " " + (!ctx[11] && ctx[13] && "bx--dropdown--warning") + " " + (ctx[1] && "bx--dropdown--open") + "\n      " + (ctx[7] === "sm" && "bx--dropdown--sm") + "\n      " + (ctx[7] === "xl" && "bx--dropdown--xl") + "\n      " + (ctx[23] && "bx--dropdown--inline") + "\n      " + (ctx[9] && "bx--dropdown--disabled") + "\n      " + (ctx[8] && "bx--dropdown--light"),
      disabled: ctx[9],
      open: ctx[1],
      invalid: ctx[11],
      invalidText: ctx[12],
      light: ctx[8],
      warn: ctx[13],
      warnText: ctx[14],
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listbox.$on("click", ctx[36]);
  let if_block1 = !ctx[23] && !ctx[11] && !ctx[13] && ctx[15] && create_if_block45(ctx);
  let div_levels = [ctx[26]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--dropdown__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(div, "bx--dropdown__wrapper--inline", ctx[23]);
      toggle_class(div, "bx--list-box__wrapper--inline", ctx[23]);
      toggle_class(div, "bx--dropdown__wrapper--inline--invalid", ctx[23] && ctx[11]);
      add_location(div, file72, 160, 0, 3744);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      mount_component(listbox, div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "click", ctx[29], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[10]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_54(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const listbox_changes = {};
      if (dirty[0] & 32)
        listbox_changes.type = ctx2[5];
      if (dirty[0] & 128)
        listbox_changes.size = ctx2[7];
      if (dirty[0] & 1048576)
        listbox_changes.name = ctx2[20];
      if (dirty[0] & 134217728)
        listbox_changes["aria-label"] = ctx2[27]["aria-label"];
      if (dirty[0] & 8399810)
        listbox_changes.class = "bx--dropdown " + (ctx2[6] === "top" && "bx--list-box--up") + " " + (ctx2[11] && "bx--dropdown--invalid") + " " + (!ctx2[11] && ctx2[13] && "bx--dropdown--warning") + " " + (ctx2[1] && "bx--dropdown--open") + "\n      " + (ctx2[7] === "sm" && "bx--dropdown--sm") + "\n      " + (ctx2[7] === "xl" && "bx--dropdown--xl") + "\n      " + (ctx2[23] && "bx--dropdown--inline") + "\n      " + (ctx2[9] && "bx--dropdown--disabled") + "\n      " + (ctx2[8] && "bx--dropdown--light");
      if (dirty[0] & 512)
        listbox_changes.disabled = ctx2[9];
      if (dirty[0] & 2)
        listbox_changes.open = ctx2[1];
      if (dirty[0] & 2048)
        listbox_changes.invalid = ctx2[11];
      if (dirty[0] & 4096)
        listbox_changes.invalidText = ctx2[12];
      if (dirty[0] & 256)
        listbox_changes.light = ctx2[8];
      if (dirty[0] & 8192)
        listbox_changes.warn = ctx2[13];
      if (dirty[0] & 16384)
        listbox_changes.warnText = ctx2[14];
      if (dirty[0] & 7154207 | dirty[1] & 64) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!ctx2[23] && !ctx2[11] && !ctx2[13] && ctx2[15]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block45(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty[0] & 67108864 && ctx2[26]]));
      toggle_class(div, "bx--dropdown__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(div, "bx--dropdown__wrapper--inline", ctx2[23]);
      toggle_class(div, "bx--list-box__wrapper--inline", ctx2[23]);
      toggle_class(div, "bx--dropdown__wrapper--inline--invalid", ctx2[23] && ctx2[11]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      destroy_component(listbox);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  let inline;
  let selectedItem;
  const omit_props_names = [
    "items",
    "itemToString",
    "selectedId",
    "type",
    "direction",
    "size",
    "open",
    "light",
    "disabled",
    "titleText",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { selectedId } = $$props;
  let { type = "default" } = $$props;
  let { direction = "bottom" } = $$props;
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { titleText = "" } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = void 0 } = $$props;
  let { hideLabel = false } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let highlightedIndex = -1;
  function change(dir) {
    let index = highlightedIndex + dir;
    if (items.length === 0)
      return;
    if (index < 0) {
      index = items.length - 1;
    } else if (index >= items.length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + dir;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(21, highlightedIndex = index);
  }
  const dispatchSelect = () => {
    dispatch("select", { selectedId, selectedItem });
  };
  $$self.$$.on_mount.push(function() {
    if (selectedId === void 0 && !("selectedId" in $$props || $$self.$$.bound[$$self.$$.props["selectedId"]])) {
      console.warn("<Dropdown> was created without expected prop 'selectedId'");
    }
  });
  const click_handler = ({ target }) => {
    if (open && ref && !ref.contains(target)) {
      $$invalidate(1, open = false);
    }
  };
  const click_handler_13 = (e) => {
    e.stopPropagation();
    if (disabled)
      return;
    $$invalidate(1, open = !open);
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const keydown_handler = (e) => {
    const { key } = e;
    if (["Enter", "ArrowDown", "ArrowUp"].includes(key)) {
      e.preventDefault();
    }
    if (key === "Enter") {
      $$invalidate(1, open = !open);
      if (highlightedIndex > -1 && items[highlightedIndex].id !== selectedId) {
        $$invalidate(0, selectedId = items[highlightedIndex].id);
        dispatchSelect();
        $$invalidate(1, open = false);
      }
    } else if (key === "Tab") {
      $$invalidate(1, open = false);
      ref.blur();
    } else if (key === "ArrowDown") {
      if (!open)
        $$invalidate(1, open = true);
      change(1);
    } else if (key === "ArrowUp") {
      if (!open)
        $$invalidate(1, open = true);
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(1, open = false);
    }
  };
  const keyup_handler = (e) => {
    const { key } = e;
    if ([" "].includes(key)) {
      e.preventDefault();
    } else {
      return;
    }
    $$invalidate(1, open = !open);
    if (highlightedIndex > -1 && items[highlightedIndex].id !== selectedId) {
      $$invalidate(0, selectedId = items[highlightedIndex].id);
      dispatchSelect();
      $$invalidate(1, open = false);
    }
  };
  const click_handler_2 = (item, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(0, selectedId = item.id);
    dispatchSelect();
    ref.focus();
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled)
      return;
    $$invalidate(21, highlightedIndex = i);
  };
  const click_handler_3 = ({ target }) => {
    if (disabled)
      return;
    $$invalidate(1, open = ref.contains(target) ? !open : false);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props)
      $$invalidate(3, items = $$new_props.items);
    if ("itemToString" in $$new_props)
      $$invalidate(4, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$new_props)
      $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("type" in $$new_props)
      $$invalidate(5, type = $$new_props.type);
    if ("direction" in $$new_props)
      $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("open" in $$new_props)
      $$invalidate(1, open = $$new_props.open);
    if ("light" in $$new_props)
      $$invalidate(8, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("titleText" in $$new_props)
      $$invalidate(10, titleText = $$new_props.titleText);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props)
      $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$new_props)
      $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$new_props)
      $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$new_props)
      $$invalidate(18, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    selectedId,
    type,
    direction,
    size,
    open,
    light,
    disabled,
    titleText,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    id,
    name,
    ref,
    createEventDispatcher,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    ListBox: ListBox_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    dispatch,
    highlightedIndex,
    change,
    dispatchSelect,
    selectedItem,
    inline
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props)
      $$invalidate(3, items = $$new_props.items);
    if ("itemToString" in $$props)
      $$invalidate(4, itemToString = $$new_props.itemToString);
    if ("selectedId" in $$props)
      $$invalidate(0, selectedId = $$new_props.selectedId);
    if ("type" in $$props)
      $$invalidate(5, type = $$new_props.type);
    if ("direction" in $$props)
      $$invalidate(6, direction = $$new_props.direction);
    if ("size" in $$props)
      $$invalidate(7, size = $$new_props.size);
    if ("open" in $$props)
      $$invalidate(1, open = $$new_props.open);
    if ("light" in $$props)
      $$invalidate(8, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("titleText" in $$props)
      $$invalidate(10, titleText = $$new_props.titleText);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$props)
      $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$props)
      $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$props)
      $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$props)
      $$invalidate(18, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("highlightedIndex" in $$props)
      $$invalidate(21, highlightedIndex = $$new_props.highlightedIndex);
    if ("selectedItem" in $$props)
      $$invalidate(22, selectedItem = $$new_props.selectedItem);
    if ("inline" in $$props)
      $$invalidate(23, inline = $$new_props.inline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 32) {
      $:
        $$invalidate(23, inline = type === "inline");
    }
    if ($$self.$$.dirty[0] & 9) {
      $:
        $$invalidate(22, selectedItem = items.find((item) => item.id === selectedId));
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        if (!open) {
          $$invalidate(21, highlightedIndex = -1);
        }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    selectedId,
    open,
    ref,
    items,
    itemToString,
    type,
    direction,
    size,
    light,
    disabled,
    titleText,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    id,
    name,
    highlightedIndex,
    selectedItem,
    inline,
    change,
    dispatchSelect,
    $$restProps,
    $$props,
    slots,
    click_handler,
    click_handler_13,
    button_binding,
    keydown_handler,
    keyup_handler,
    click_handler_2,
    mouseenter_handler,
    click_handler_3,
    $$scope
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance76,
      create_fragment76,
      safe_not_equal,
      {
        items: 3,
        itemToString: 4,
        selectedId: 0,
        type: 5,
        direction: 6,
        size: 7,
        open: 1,
        light: 8,
        disabled: 9,
        titleText: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        helperText: 15,
        label: 16,
        hideLabel: 17,
        translateWithId: 18,
        id: 19,
        name: 20,
        ref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment76.name
    });
  }
  get items() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedId() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedId(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte
var file73 = "node_modules/carbon-components-svelte/src/Dropdown/DropdownSkeleton.svelte";
function create_fragment77(ctx) {
  let div1;
  let div0;
  let span;
  let mounted;
  let dispose;
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file73, 19, 4, 464);
      attr_dev(div0, "role", "button");
      toggle_class(div0, "bx--list-box__field", true);
      add_location(div0, file73, 18, 2, 405);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--dropdown-v2", true);
      toggle_class(div1, "bx--list-box", true);
      toggle_class(div1, "bx--form-item", true);
      toggle_class(div1, "bx--list-box--inline", ctx[0]);
      add_location(div1, file73, 6, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, span);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--skeleton", true);
      toggle_class(div1, "bx--dropdown-v2", true);
      toggle_class(div1, "bx--list-box", true);
      toggle_class(div1, "bx--form-item", true);
      toggle_class(div1, "bx--list-box--inline", ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  const omit_props_names = ["inline"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownSkeleton", slots, []);
  let { inline = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inline" in $$new_props)
      $$invalidate(0, inline = $$new_props.inline);
  };
  $$self.$capture_state = () => ({ inline });
  $$self.$inject_state = ($$new_props) => {
    if ("inline" in $$props)
      $$invalidate(0, inline = $$new_props.inline);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inline,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DropdownSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { inline: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownSkeleton",
      options,
      id: create_fragment77.name
    });
  }
  get inline() {
    throw new Error("<DropdownSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<DropdownSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownSkeleton_default = DropdownSkeleton;

// node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte
var file74 = "node_modules/carbon-components-svelte/src/icons/CheckmarkFilled.svelte";
function create_if_block46(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file74, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block46.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block46(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM14,21.5908l-5-5L10.5906,15,14,18.4092,21.41,11l1.5957,1.5859Z");
      add_location(path0, file74, 24, 2, 579);
      attr_dev(path1, "fill", "none");
      attr_dev(path1, "d", "M14 21.591L9 16.591 10.591 15 14 18.409 21.41 11 23.005 12.585 14 21.591z");
      attr_dev(path1, "data-icon-path", "inner-path");
      add_location(path1, file74, 26, 10, 707);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file74, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block46(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckmarkFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CheckmarkFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckmarkFilled",
      options,
      id: create_fragment78.name
    });
  }
  get size() {
    throw new Error("<CheckmarkFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckmarkFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CheckmarkFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CheckmarkFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckmarkFilled_default = CheckmarkFilled;

// node_modules/carbon-components-svelte/src/Loading/Loading.svelte
var file75 = "node_modules/carbon-components-svelte/src/Loading/Loading.svelte";
function create_else_block19(ctx) {
  let div;
  let label;
  let t0;
  let t1;
  let svg;
  let title;
  let t2;
  let circle;
  let div_aria_live_value;
  let if_block = ctx[0] && create_if_block_211(ctx);
  let div_levels = [
    { "aria-atomic": "true" },
    { "aria-labelledby": ctx[4] },
    {
      "aria-live": div_aria_live_value = ctx[1] ? "assertive" : "off"
    },
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      t0 = text(ctx[3]);
      t1 = space();
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text(ctx[3]);
      if (if_block)
        if_block.c();
      circle = svg_element("circle");
      attr_dev(label, "id", ctx[4]);
      toggle_class(label, "bx--visually-hidden", true);
      add_location(label, file75, 63, 4, 1781);
      add_location(title, file75, 65, 6, 1925);
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(circle, "r", ctx[5]);
      toggle_class(circle, "bx--loading__stroke", true);
      add_location(circle, file75, 73, 6, 2133);
      attr_dev(svg, "viewBox", "0 0 100 100");
      toggle_class(svg, "bx--loading__svg", true);
      add_location(svg, file75, 64, 4, 1859);
      set_attributes(div, div_data);
      toggle_class(div, "bx--loading", true);
      toggle_class(div, "bx--loading--small", ctx[0]);
      toggle_class(div, "bx--loading--stop", !ctx[1]);
      add_location(div, file75, 53, 2, 1479);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, label);
      append_dev(label, t0);
      append_dev(div, t1);
      append_dev(div, svg);
      append_dev(svg, title);
      append_dev(title, t2);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, circle);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t0, ctx2[3]);
      if (dirty & 16) {
        attr_dev(label, "id", ctx2[4]);
      }
      if (dirty & 8)
        set_data_dev(t2, ctx2[3]);
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_211(ctx2);
          if_block.c();
          if_block.m(svg, circle);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        attr_dev(circle, "r", ctx2[5]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "aria-atomic": "true" },
        dirty & 16 && { "aria-labelledby": ctx2[4] },
        dirty & 2 && div_aria_live_value !== (div_aria_live_value = ctx2[1] ? "assertive" : "off") && { "aria-live": div_aria_live_value },
        dirty & 64 && ctx2[6]
      ]));
      toggle_class(div, "bx--loading", true);
      toggle_class(div, "bx--loading--small", ctx2[0]);
      toggle_class(div, "bx--loading--stop", !ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(53:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block47(ctx) {
  let div1;
  let div0;
  let label;
  let t0;
  let t1;
  let svg;
  let title;
  let t2;
  let circle;
  let div0_aria_live_value;
  let if_block = ctx[0] && create_if_block_115(ctx);
  let div1_levels = [ctx[6]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text(ctx[3]);
      t1 = space();
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text(ctx[3]);
      if (if_block)
        if_block.c();
      circle = svg_element("circle");
      attr_dev(label, "id", ctx[4]);
      toggle_class(label, "bx--visually-hidden", true);
      add_location(label, file75, 34, 6, 933);
      add_location(title, file75, 36, 8, 1081);
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(circle, "r", ctx[5]);
      toggle_class(circle, "bx--loading__stroke", true);
      add_location(circle, file75, 44, 8, 1305);
      attr_dev(svg, "viewBox", "0 0 100 100");
      toggle_class(svg, "bx--loading__svg", true);
      add_location(svg, file75, 35, 6, 1013);
      attr_dev(div0, "aria-atomic", "true");
      attr_dev(div0, "aria-labelledby", ctx[4]);
      attr_dev(div0, "aria-live", div0_aria_live_value = ctx[1] ? "assertive" : "off");
      toggle_class(div0, "bx--loading", true);
      toggle_class(div0, "bx--loading--small", ctx[0]);
      toggle_class(div0, "bx--loading--stop", !ctx[1]);
      add_location(div0, file75, 25, 4, 634);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--loading-overlay", true);
      toggle_class(div1, "bx--loading-overlay--stop", !ctx[1]);
      add_location(div1, file75, 20, 2, 513);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, label);
      append_dev(label, t0);
      append_dev(div0, t1);
      append_dev(div0, svg);
      append_dev(svg, title);
      append_dev(title, t2);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, circle);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t0, ctx2[3]);
      if (dirty & 16) {
        attr_dev(label, "id", ctx2[4]);
      }
      if (dirty & 8)
        set_data_dev(t2, ctx2[3]);
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_115(ctx2);
          if_block.c();
          if_block.m(svg, circle);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        attr_dev(circle, "r", ctx2[5]);
      }
      if (dirty & 16) {
        attr_dev(div0, "aria-labelledby", ctx2[4]);
      }
      if (dirty & 2 && div0_aria_live_value !== (div0_aria_live_value = ctx2[1] ? "assertive" : "off")) {
        attr_dev(div0, "aria-live", div0_aria_live_value);
      }
      if (dirty & 1) {
        toggle_class(div0, "bx--loading--small", ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(div0, "bx--loading--stop", !ctx2[1]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 64 && ctx2[6]]));
      toggle_class(div1, "bx--loading-overlay", true);
      toggle_class(div1, "bx--loading-overlay--stop", !ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block47.name,
    type: "if",
    source: "(20:0) {#if withOverlay}",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let circle;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(circle, "r", ctx[5]);
      toggle_class(circle, "bx--loading__background", true);
      add_location(circle, file75, 67, 8, 1980);
    },
    m: function mount(target, anchor) {
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32) {
        attr_dev(circle, "r", ctx2[5]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(67:6) {#if small}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let circle;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      attr_dev(circle, "cx", "50%");
      attr_dev(circle, "cy", "50%");
      attr_dev(circle, "r", ctx[5]);
      toggle_class(circle, "bx--loading__background", true);
      add_location(circle, file75, 38, 10, 1140);
    },
    m: function mount(target, anchor) {
      insert_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32) {
        attr_dev(circle, "r", ctx2[5]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(38:8) {#if small}",
    ctx
  });
  return block;
}
function create_fragment79(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block47;
    return create_else_block19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let spinnerRadius;
  const omit_props_names = ["small", "active", "withOverlay", "description", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loading", slots, []);
  let { small = false } = $$props;
  let { active = true } = $$props;
  let { withOverlay = true } = $$props;
  let { description = "Active loading indicator" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("small" in $$new_props)
      $$invalidate(0, small = $$new_props.small);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("withOverlay" in $$new_props)
      $$invalidate(2, withOverlay = $$new_props.withOverlay);
    if ("description" in $$new_props)
      $$invalidate(3, description = $$new_props.description);
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({
    small,
    active,
    withOverlay,
    description,
    id,
    spinnerRadius
  });
  $$self.$inject_state = ($$new_props) => {
    if ("small" in $$props)
      $$invalidate(0, small = $$new_props.small);
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("withOverlay" in $$props)
      $$invalidate(2, withOverlay = $$new_props.withOverlay);
    if ("description" in $$props)
      $$invalidate(3, description = $$new_props.description);
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("spinnerRadius" in $$props)
      $$invalidate(5, spinnerRadius = $$new_props.spinnerRadius);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(5, spinnerRadius = small ? "42" : "44");
    }
  };
  return [small, active, withOverlay, description, id, spinnerRadius, $$restProps];
}
var Loading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {
      small: 0,
      active: 1,
      withOverlay: 2,
      description: 3,
      id: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loading",
      options,
      id: create_fragment79.name
    });
  }
  get small() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withOverlay() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withOverlay(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loading_default = Loading;

// node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte
var file76 = "node_modules/carbon-components-svelte/src/FileUploader/Filename.svelte";
function create_if_block_37(ctx) {
  let loading;
  let current;
  const loading_spread_levels = [
    { description: ctx[1] },
    ctx[3],
    { small: true },
    { withOverlay: false }
  ];
  let loading_props = {};
  for (let i = 0; i < loading_spread_levels.length; i += 1) {
    loading_props = assign(loading_props, loading_spread_levels[i]);
  }
  loading = new Loading_default({ props: loading_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(loading.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loading_changes = dirty & 10 ? get_spread_update(loading_spread_levels, [
        dirty & 2 && { description: ctx2[1] },
        dirty & 8 && get_spread_object(ctx2[3]),
        loading_spread_levels[2],
        loading_spread_levels[3]
      ]) : {};
      loading.$set(loading_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loading, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: '(20:0) {#if status === \\"uploading\\"}',
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let t;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block_212(ctx);
  close = new Close_default({ $$inline: true });
  let button_levels = [
    { "aria-label": ctx[1] },
    { type: "button" },
    { tabindex: "0" },
    ctx[3]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      button = element("button");
      create_component(close.$$.fragment);
      set_attributes(button, button_data);
      toggle_class(button, "bx--file-close", true);
      add_location(button, file76, 32, 2, 790);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, button, anchor);
      mount_component(close, button, null);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[4], false, false, false),
          listen_dev(button, "keydown", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_212(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & 2) && { "aria-label": ctx2[1] },
        { type: "button" },
        { tabindex: "0" },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(button, "bx--file-close", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(button);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: '(29:0) {#if status === \\"edit\\"}',
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--file-invalid" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(30:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block48(ctx) {
  let checkmarkfilled;
  let current;
  const checkmarkfilled_spread_levels = [
    { "aria-label": ctx[1] },
    { title: ctx[1] },
    { class: "bx--file-complete" },
    ctx[3]
  ];
  let checkmarkfilled_props = {};
  for (let i = 0; i < checkmarkfilled_spread_levels.length; i += 1) {
    checkmarkfilled_props = assign(checkmarkfilled_props, checkmarkfilled_spread_levels[i]);
  }
  checkmarkfilled = new CheckmarkFilled_default({
    props: checkmarkfilled_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkfilled_changes = dirty & 10 ? get_spread_update(checkmarkfilled_spread_levels, [
        dirty & 2 && { "aria-label": ctx2[1] },
        dirty & 2 && { title: ctx2[1] },
        checkmarkfilled_spread_levels[2],
        dirty & 8 && get_spread_object(ctx2[3])
      ]) : {};
      checkmarkfilled.$set(checkmarkfilled_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block48.name,
    type: "if",
    source: '(46:0) {#if status === \\"complete\\"}',
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[0] === "uploading" && create_if_block_37(ctx);
  let if_block1 = ctx[0] === "edit" && create_if_block_116(ctx);
  let if_block2 = ctx[0] === "complete" && create_if_block48(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0] === "uploading") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_37(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0] === "edit") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_116(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[0] === "complete") {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block48(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  const omit_props_names = ["status", "iconDescription", "invalid"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Filename", slots, []);
  let { status = "uploading" } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props)
      $$invalidate(0, status = $$new_props.status);
    if ("iconDescription" in $$new_props)
      $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props)
      $$invalidate(2, invalid = $$new_props.invalid);
  };
  $$self.$capture_state = () => ({
    status,
    iconDescription,
    invalid,
    Close: Close_default,
    CheckmarkFilled: CheckmarkFilled_default,
    WarningFilled: WarningFilled_default,
    Loading: Loading_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props)
      $$invalidate(0, status = $$new_props.status);
    if ("iconDescription" in $$props)
      $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props)
      $$invalidate(2, invalid = $$new_props.invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [status, iconDescription, invalid, $$restProps, click_handler, keydown_handler];
}
var Filename = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, {
      status: 0,
      iconDescription: 1,
      invalid: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Filename",
      options,
      id: create_fragment80.name
    });
  }
  get status() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Filename>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Filename>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Filename_default = Filename;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte
var file77 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderButton.svelte";
var get_labelText_slot_changes6 = (dirty) => ({});
var get_labelText_slot_context6 = (ctx) => ({});
function fallback_block16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block16.name,
    type: "fallback",
    source: "(84:27)        ",
    ctx
  });
  return block;
}
function create_fragment81(ctx) {
  let label;
  let span;
  let label_tabindex_value;
  let t;
  let input;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = ctx[15].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[14], get_labelText_slot_context6);
  const labelText_slot_or_fallback = labelText_slot || fallback_block16(ctx);
  let input_levels = [
    { type: "file" },
    { tabindex: "-1" },
    { accept: ctx[3] },
    { disabled: ctx[5] },
    { id: ctx[10] },
    { multiple: ctx[4] },
    { name: ctx[11] },
    ctx[13]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t = space();
      input = element("input");
      attr_dev(span, "role", ctx[8]);
      add_location(span, file77, 82, 2, 1990);
      attr_dev(label, "aria-disabled", ctx[5]);
      attr_dev(label, "for", ctx[10]);
      attr_dev(label, "tabindex", label_tabindex_value = ctx[5] ? "-1" : ctx[9]);
      toggle_class(label, "bx--btn", true);
      toggle_class(label, "bx--btn--sm", true);
      toggle_class(label, "bx--btn--disabled", ctx[5]);
      toggle_class(label, "bx--btn--primary", ctx[7] === "primary");
      toggle_class(label, "bx--btn--secondary", ctx[7] === "secondary");
      toggle_class(label, "bx--btn--tertiary", ctx[7] === "tertiary");
      toggle_class(label, "bx--btn--ghost", ctx[7] === "ghost");
      toggle_class(label, "bx--btn--danger", ctx[7] === "danger");
      add_location(label, file77, 63, 0, 1446);
      set_attributes(input, input_data);
      toggle_class(input, "bx--visually-hidden", true);
      add_location(input, file77, 88, 0, 2088);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, span);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      insert_dev(target, t, anchor);
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[19](input);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(label, "keydown", ctx[17], false, false, false),
          listen_dev(label, "keydown", ctx[18], false, false, false),
          listen_dev(input, "change", stop_propagation(ctx[20]), false, false, true),
          listen_dev(input, "click", ctx[16], false, false, false),
          listen_dev(input, "click", click_handler_1, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(labelText_slot_template, ctx2[14], dirty, get_labelText_slot_changes6),
            get_labelText_slot_context6
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 4)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 256) {
        attr_dev(span, "role", ctx2[8]);
      }
      if (!current || dirty & 32) {
        attr_dev(label, "aria-disabled", ctx2[5]);
      }
      if (!current || dirty & 1024) {
        attr_dev(label, "for", ctx2[10]);
      }
      if (!current || dirty & 544 && label_tabindex_value !== (label_tabindex_value = ctx2[5] ? "-1" : ctx2[9])) {
        attr_dev(label, "tabindex", label_tabindex_value);
      }
      if (!current || dirty & 32) {
        toggle_class(label, "bx--btn--disabled", ctx2[5]);
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--btn--primary", ctx2[7] === "primary");
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--btn--secondary", ctx2[7] === "secondary");
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--btn--tertiary", ctx2[7] === "tertiary");
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--btn--ghost", ctx2[7] === "ghost");
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--btn--danger", ctx2[7] === "danger");
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        { tabindex: "-1" },
        (!current || dirty & 8) && { accept: ctx2[3] },
        (!current || dirty & 32) && { disabled: ctx2[5] },
        (!current || dirty & 1024) && { id: ctx2[10] },
        (!current || dirty & 16) && { multiple: ctx2[4] },
        (!current || dirty & 2048) && { name: ctx2[11] },
        dirty & 8192 && ctx2[13]
      ]));
      toggle_class(input, "bx--visually-hidden", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(input);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler_1 = ({ target }) => {
  target.value = null;
};
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "accept",
    "files",
    "multiple",
    "disabled",
    "disableLabelChanges",
    "kind",
    "labelText",
    "role",
    "tabindex",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderButton", slots, ["labelText"]);
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  let { disabled = false } = $$props;
  let { disableLabelChanges = false } = $$props;
  let { kind = "primary" } = $$props;
  let { labelText = "Add file" } = $$props;
  let { role = "button" } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let initialLabelText = labelText;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      ref.click();
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref), $$invalidate(0, files), $$invalidate(21, initialLabelText);
    });
  }
  const change_handler = ({ target }) => {
    $$invalidate(0, files = [...target.files]);
    if (files && !disableLabelChanges) {
      $$invalidate(2, labelText = files.length > 1 ? `${files.length} files` : files[0].name);
    }
    dispatch("change", files);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("accept" in $$new_props)
      $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("disableLabelChanges" in $$new_props)
      $$invalidate(6, disableLabelChanges = $$new_props.disableLabelChanges);
    if ("kind" in $$new_props)
      $$invalidate(7, kind = $$new_props.kind);
    if ("labelText" in $$new_props)
      $$invalidate(2, labelText = $$new_props.labelText);
    if ("role" in $$new_props)
      $$invalidate(8, role = $$new_props.role);
    if ("tabindex" in $$new_props)
      $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props)
      $$invalidate(10, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(11, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    accept,
    files,
    multiple,
    disabled,
    disableLabelChanges,
    kind,
    labelText,
    role,
    tabindex,
    id,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    initialLabelText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("accept" in $$props)
      $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("disableLabelChanges" in $$props)
      $$invalidate(6, disableLabelChanges = $$new_props.disableLabelChanges);
    if ("kind" in $$props)
      $$invalidate(7, kind = $$new_props.kind);
    if ("labelText" in $$props)
      $$invalidate(2, labelText = $$new_props.labelText);
    if ("role" in $$props)
      $$invalidate(8, role = $$new_props.role);
    if ("tabindex" in $$props)
      $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$props)
      $$invalidate(10, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(11, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("initialLabelText" in $$props)
      $$invalidate(21, initialLabelText = $$new_props.initialLabelText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        if (ref && files.length === 0) {
          $$invalidate(2, labelText = initialLabelText);
          $$invalidate(1, ref.value = null, ref);
        }
    }
  };
  return [
    files,
    ref,
    labelText,
    accept,
    multiple,
    disabled,
    disableLabelChanges,
    kind,
    role,
    tabindex,
    id,
    name,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keydown_handler_12,
    input_binding,
    change_handler
  ];
}
var FileUploaderButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {
      accept: 3,
      files: 0,
      multiple: 4,
      disabled: 5,
      disableLabelChanges: 6,
      kind: 7,
      labelText: 2,
      role: 8,
      tabindex: 9,
      id: 10,
      name: 11,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderButton",
      options,
      id: create_fragment81.name
    });
  }
  get accept() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableLabelChanges() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableLabelChanges(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<FileUploaderButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<FileUploaderButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderButton_default = FileUploaderButton;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte
var file78 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploader.svelte";
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i].name;
  child_ctx[27] = i;
  return child_ctx;
}
function create_each_block10(ctx) {
  let span1;
  let p;
  let t0_value = ctx[10] + "";
  let t0;
  let t1;
  let span0;
  let filename;
  let t2;
  let current;
  function keydown_handler_12(...args) {
    return ctx[20](ctx[27], ...args);
  }
  function click_handler_2() {
    return ctx[22](ctx[27]);
  }
  filename = new Filename_default({
    props: {
      iconDescription: ctx[9],
      status: ctx[1]
    },
    $$inline: true
  });
  filename.$on("keydown", ctx[19]);
  filename.$on("keydown", keydown_handler_12);
  filename.$on("click", ctx[21]);
  filename.$on("click", click_handler_2);
  const block = {
    c: function create() {
      span1 = element("span");
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      span0 = element("span");
      create_component(filename.$$.fragment);
      t2 = space();
      toggle_class(p, "bx--file-filename", true);
      add_location(p, file78, 132, 8, 3174);
      toggle_class(span0, "bx--file__state-container", true);
      add_location(span0, file78, 133, 8, 3229);
      toggle_class(span1, "bx--file__selected-file", true);
      add_location(span1, file78, 131, 6, 3120);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, p);
      append_dev(p, t0);
      append_dev(span1, t1);
      append_dev(span1, span0);
      mount_component(filename, span0, null);
      append_dev(span1, t2);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[10] + ""))
        set_data_dev(t0, t0_value);
      const filename_changes = {};
      if (dirty & 512)
        filename_changes.iconDescription = ctx[9];
      if (dirty & 2)
        filename_changes.status = ctx[1];
      filename.$set(filename_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(filename.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(filename.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(filename);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(131:4) {#each files as { name }",
    ctx
  });
  return block;
}
function create_fragment82(ctx) {
  let div1;
  let p0;
  let t0;
  let t1;
  let p1;
  let t2;
  let t3;
  let fileuploaderbutton;
  let t4;
  let div0;
  let current;
  let mounted;
  let dispose;
  fileuploaderbutton = new FileUploaderButton_default({
    props: {
      disabled: ctx[2],
      disableLabelChanges: true,
      labelText: ctx[8],
      accept: ctx[3],
      name: ctx[10],
      multiple: ctx[4],
      kind: ctx[7]
    },
    $$inline: true
  });
  fileuploaderbutton.$on("change", ctx[17]);
  fileuploaderbutton.$on("change", ctx[18]);
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let div1_levels = [ctx[11]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      p0 = element("p");
      t0 = text(ctx[6]);
      t1 = space();
      p1 = element("p");
      t2 = text(ctx[5]);
      t3 = space();
      create_component(fileuploaderbutton.$$.fragment);
      t4 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      toggle_class(p0, "bx--file--label", true);
      toggle_class(p0, "bx--label-description--disabled", ctx[2]);
      add_location(p0, file78, 104, 2, 2521);
      toggle_class(p1, "bx--label-description", true);
      toggle_class(p1, "bx--label-description--disabled", ctx[2]);
      add_location(p1, file78, 110, 2, 2644);
      toggle_class(div0, "bx--file-container", true);
      add_location(div0, file78, 129, 2, 3041);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file78, 96, 0, 2404);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, p0);
      append_dev(p0, t0);
      append_dev(div1, t1);
      append_dev(div1, p1);
      append_dev(p1, t2);
      append_dev(div1, t3);
      mount_component(fileuploaderbutton, div1, null);
      append_dev(div1, t4);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[13], false, false, false),
          listen_dev(div1, "mouseover", ctx[14], false, false, false),
          listen_dev(div1, "mouseenter", ctx[15], false, false, false),
          listen_dev(div1, "mouseleave", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 64)
        set_data_dev(t0, ctx2[6]);
      if (!current || dirty & 4) {
        toggle_class(p0, "bx--label-description--disabled", ctx2[2]);
      }
      if (!current || dirty & 32)
        set_data_dev(t2, ctx2[5]);
      if (!current || dirty & 4) {
        toggle_class(p1, "bx--label-description--disabled", ctx2[2]);
      }
      const fileuploaderbutton_changes = {};
      if (dirty & 4)
        fileuploaderbutton_changes.disabled = ctx2[2];
      if (dirty & 256)
        fileuploaderbutton_changes.labelText = ctx2[8];
      if (dirty & 8)
        fileuploaderbutton_changes.accept = ctx2[3];
      if (dirty & 1024)
        fileuploaderbutton_changes.name = ctx2[10];
      if (dirty & 16)
        fileuploaderbutton_changes.multiple = ctx2[4];
      if (dirty & 128)
        fileuploaderbutton_changes.kind = ctx2[7];
      fileuploaderbutton.$set(fileuploaderbutton_changes);
      if (dirty & 515) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2048 && ctx2[11]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fileuploaderbutton.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(fileuploaderbutton.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(fileuploaderbutton);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "status",
    "disabled",
    "accept",
    "files",
    "multiple",
    "clearFiles",
    "labelDescription",
    "labelTitle",
    "kind",
    "buttonLabel",
    "iconDescription",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploader", slots, []);
  let { status = "uploading" } = $$props;
  let { disabled = false } = $$props;
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  const clearFiles = () => {
    $$invalidate(0, files = []);
  };
  let { labelDescription = "" } = $$props;
  let { labelTitle = "" } = $$props;
  let { kind = "primary" } = $$props;
  let { buttonLabel = "" } = $$props;
  let { iconDescription = "Provide icon description" } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  let prevFiles = [];
  const getFileId = (file195) => file195.lastModified + file195.name;
  afterUpdate(() => {
    const fileIds = files.map(getFileId);
    const prevFileIds = prevFiles.map(getFileId);
    const addedIds = fileIds.filter((_) => !prevFileIds.includes(_));
    const removedIds = prevFileIds.filter((_) => !fileIds.includes(_));
    if (addedIds.length > 0) {
      dispatch("add", addedIds.map((id) => files.find((file195) => id === getFileId(file195))));
    }
    if (removedIds.length > 0) {
      dispatch("remove", removedIds.map((id) => prevFiles.find((file195) => id === getFileId(file195))));
    }
    prevFiles = [...files];
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = (e) => {
    $$invalidate(0, files = e.detail);
  };
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = (i, { key }) => {
    if (key === " " || key === "Enter") {
      $$invalidate(0, files = files.filter((_, index) => index !== i));
    }
  };
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_2 = (i) => {
    $$invalidate(0, files = files.filter((_, index) => index !== i));
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props)
      $$invalidate(1, status = $$new_props.status);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("accept" in $$new_props)
      $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("labelDescription" in $$new_props)
      $$invalidate(5, labelDescription = $$new_props.labelDescription);
    if ("labelTitle" in $$new_props)
      $$invalidate(6, labelTitle = $$new_props.labelTitle);
    if ("kind" in $$new_props)
      $$invalidate(7, kind = $$new_props.kind);
    if ("buttonLabel" in $$new_props)
      $$invalidate(8, buttonLabel = $$new_props.buttonLabel);
    if ("iconDescription" in $$new_props)
      $$invalidate(9, iconDescription = $$new_props.iconDescription);
    if ("name" in $$new_props)
      $$invalidate(10, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({
    status,
    disabled,
    accept,
    files,
    multiple,
    clearFiles,
    labelDescription,
    labelTitle,
    kind,
    buttonLabel,
    iconDescription,
    name,
    createEventDispatcher,
    afterUpdate,
    Filename: Filename_default,
    FileUploaderButton: FileUploaderButton_default,
    dispatch,
    prevFiles,
    getFileId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props)
      $$invalidate(1, status = $$new_props.status);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("accept" in $$props)
      $$invalidate(3, accept = $$new_props.accept);
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("labelDescription" in $$props)
      $$invalidate(5, labelDescription = $$new_props.labelDescription);
    if ("labelTitle" in $$props)
      $$invalidate(6, labelTitle = $$new_props.labelTitle);
    if ("kind" in $$props)
      $$invalidate(7, kind = $$new_props.kind);
    if ("buttonLabel" in $$props)
      $$invalidate(8, buttonLabel = $$new_props.buttonLabel);
    if ("iconDescription" in $$props)
      $$invalidate(9, iconDescription = $$new_props.iconDescription);
    if ("name" in $$props)
      $$invalidate(10, name = $$new_props.name);
    if ("prevFiles" in $$props)
      prevFiles = $$new_props.prevFiles;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    files,
    status,
    disabled,
    accept,
    multiple,
    labelDescription,
    labelTitle,
    kind,
    buttonLabel,
    iconDescription,
    name,
    $$restProps,
    clearFiles,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    change_handler_1,
    keydown_handler,
    keydown_handler_12,
    click_handler_13,
    click_handler_2
  ];
}
var FileUploader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {
      status: 1,
      disabled: 2,
      accept: 3,
      files: 0,
      multiple: 4,
      clearFiles: 12,
      labelDescription: 5,
      labelTitle: 6,
      kind: 7,
      buttonLabel: 8,
      iconDescription: 9,
      name: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploader",
      options,
      id: create_fragment82.name
    });
  }
  get status() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearFiles() {
    return this.$$.ctx[12];
  }
  set clearFiles(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelDescription() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelDescription(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelTitle() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelTitle(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonLabel() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonLabel(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploader_default = FileUploader;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte
var file79 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderItem.svelte";
function create_if_block49(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let if_block = ctx[5] && create_if_block_117(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(ctx[4]);
      t1 = space();
      if (if_block)
        if_block.c();
      toggle_class(div0, "bx--form-requirement__title", true);
      add_location(div0, file79, 71, 6, 1802);
      toggle_class(div1, "bx--form-requirement", true);
      add_location(div1, file79, 70, 4, 1754);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, t0);
      append_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t0, ctx2[4]);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_117(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block49.name,
    type: "if",
    source: "(70:2) {#if invalid && errorSubject}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(ctx[5]);
      toggle_class(p, "bx--form-requirement__supplement", true);
      add_location(p, file79, 73, 8, 1901);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(73:6) {#if errorBody}",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let span1;
  let p;
  let t0;
  let t1;
  let span0;
  let filename;
  let t2;
  let current;
  let mounted;
  let dispose;
  filename = new Filename_default({
    props: {
      iconDescription: ctx[2],
      status: ctx[0],
      invalid: ctx[3]
    },
    $$inline: true
  });
  filename.$on("keydown", ctx[13]);
  filename.$on("click", ctx[14]);
  let if_block = ctx[3] && ctx[4] && create_if_block49(ctx);
  let span1_levels = [{ id: ctx[6] }, ctx[9]];
  let span1_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span1_data = assign(span1_data, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      p = element("p");
      t0 = text(ctx[7]);
      t1 = space();
      span0 = element("span");
      create_component(filename.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      toggle_class(p, "bx--file-filename", true);
      add_location(p, file79, 53, 2, 1297);
      toggle_class(span0, "bx--file__state-container", true);
      add_location(span0, file79, 54, 2, 1346);
      set_attributes(span1, span1_data);
      toggle_class(span1, "bx--file__selected-file", true);
      toggle_class(span1, "bx--file__selected-file--invalid", ctx[3]);
      toggle_class(span1, "bx--file__selected-file--md", ctx[1] === "field");
      toggle_class(span1, "bx--file__selected-file--sm", ctx[1] === "small");
      add_location(span1, file79, 42, 0, 1001);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, p);
      append_dev(p, t0);
      append_dev(span1, t1);
      append_dev(span1, span0);
      mount_component(filename, span0, null);
      append_dev(span1, t2);
      if (if_block)
        if_block.m(span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(span1, "mouseover", ctx[10], false, false, false),
          listen_dev(span1, "mouseenter", ctx[11], false, false, false),
          listen_dev(span1, "mouseleave", ctx[12], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 128)
        set_data_dev(t0, ctx2[7]);
      const filename_changes = {};
      if (dirty & 4)
        filename_changes.iconDescription = ctx2[2];
      if (dirty & 1)
        filename_changes.status = ctx2[0];
      if (dirty & 8)
        filename_changes.invalid = ctx2[3];
      filename.$set(filename_changes);
      if (ctx2[3] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block49(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(span1, span1_data = get_spread_update(span1_levels, [
        (!current || dirty & 64) && { id: ctx2[6] },
        dirty & 512 && ctx2[9]
      ]));
      toggle_class(span1, "bx--file__selected-file", true);
      toggle_class(span1, "bx--file__selected-file--invalid", ctx2[3]);
      toggle_class(span1, "bx--file__selected-file--md", ctx2[1] === "field");
      toggle_class(span1, "bx--file__selected-file--sm", ctx2[1] === "small");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(filename.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(filename.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span1);
      destroy_component(filename);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "status",
    "size",
    "iconDescription",
    "invalid",
    "errorSubject",
    "errorBody",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderItem", slots, []);
  let { status = "uploading" } = $$props;
  let { size = "default" } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  let { errorSubject = "" } = $$props;
  let { errorBody = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  const dispatch = createEventDispatcher();
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === " " || key === "Enter") {
      dispatch("delete", id);
    }
  };
  const click_handler = () => {
    dispatch("delete", id);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props)
      $$invalidate(0, status = $$new_props.status);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("iconDescription" in $$new_props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props)
      $$invalidate(3, invalid = $$new_props.invalid);
    if ("errorSubject" in $$new_props)
      $$invalidate(4, errorSubject = $$new_props.errorSubject);
    if ("errorBody" in $$new_props)
      $$invalidate(5, errorBody = $$new_props.errorBody);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(7, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({
    status,
    size,
    iconDescription,
    invalid,
    errorSubject,
    errorBody,
    id,
    name,
    createEventDispatcher,
    Filename: Filename_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props)
      $$invalidate(0, status = $$new_props.status);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("iconDescription" in $$props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props)
      $$invalidate(3, invalid = $$new_props.invalid);
    if ("errorSubject" in $$props)
      $$invalidate(4, errorSubject = $$new_props.errorSubject);
    if ("errorBody" in $$props)
      $$invalidate(5, errorBody = $$new_props.errorBody);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(7, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    status,
    size,
    iconDescription,
    invalid,
    errorSubject,
    errorBody,
    id,
    name,
    dispatch,
    $$restProps,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler
  ];
}
var FileUploaderItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      status: 0,
      size: 1,
      iconDescription: 2,
      invalid: 3,
      errorSubject: 4,
      errorBody: 5,
      id: 6,
      name: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderItem",
      options,
      id: create_fragment83.name
    });
  }
  get status() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorSubject() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorSubject(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorBody() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorBody(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderItem_default = FileUploaderItem;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte
var file80 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderDropContainer.svelte";
var get_labelText_slot_changes7 = (dirty) => ({});
var get_labelText_slot_context7 = (ctx) => ({});
function fallback_block17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block17.name,
    type: "fallback",
    source: "(102:29)          ",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let div1;
  let label;
  let div0;
  let t;
  let input;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = ctx[15].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[14], get_labelText_slot_context7);
  const labelText_slot_or_fallback = labelText_slot || fallback_block17(ctx);
  let div1_levels = [ctx[13]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      div0 = element("div");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t = space();
      input = element("input");
      attr_dev(div0, "role", ctx[6]);
      toggle_class(div0, "bx--file__drop-container", true);
      toggle_class(div0, "bx--file__drop-container--drag-over", ctx[11]);
      add_location(div0, file80, 96, 4, 2312);
      attr_dev(label, "for", ctx[9]);
      attr_dev(label, "tabindex", ctx[8]);
      toggle_class(label, "bx--file-browse-btn", true);
      toggle_class(label, "bx--file-browse-btn--disabled", ctx[7]);
      add_location(label, file80, 84, 2, 2036);
      attr_dev(input, "type", "file");
      attr_dev(input, "tabindex", "-1");
      attr_dev(input, "id", ctx[9]);
      input.disabled = ctx[7];
      attr_dev(input, "accept", ctx[2]);
      attr_dev(input, "name", ctx[10]);
      input.multiple = ctx[3];
      toggle_class(input, "bx--file-input", true);
      add_location(input, file80, 106, 2, 2534);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--file", true);
      add_location(div1, file80, 56, 0, 1321);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, label);
      append_dev(label, div0);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(div0, null);
      }
      append_dev(div1, t);
      append_dev(div1, input);
      ctx[22](input);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(label, "keydown", ctx[20], false, false, false),
          listen_dev(label, "keydown", ctx[21], false, false, false),
          listen_dev(input, "change", ctx[23], false, false, false),
          listen_dev(input, "click", ctx[19], false, false, false),
          listen_dev(input, "click", click_handler_12, false, false, false),
          listen_dev(div1, "dragover", ctx[16], false, false, false),
          listen_dev(div1, "dragover", stop_propagation(prevent_default(ctx[24])), false, true, true),
          listen_dev(div1, "dragleave", ctx[17], false, false, false),
          listen_dev(div1, "dragleave", stop_propagation(prevent_default(ctx[25])), false, true, true),
          listen_dev(div1, "drop", ctx[18], false, false, false),
          listen_dev(div1, "drop", stop_propagation(prevent_default(ctx[26])), false, true, true)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(labelText_slot_template, ctx2[14], dirty, get_labelText_slot_changes7),
            get_labelText_slot_context7
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 32)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64) {
        attr_dev(div0, "role", ctx2[6]);
      }
      if (!current || dirty & 2048) {
        toggle_class(div0, "bx--file__drop-container--drag-over", ctx2[11]);
      }
      if (!current || dirty & 512) {
        attr_dev(label, "for", ctx2[9]);
      }
      if (!current || dirty & 256) {
        attr_dev(label, "tabindex", ctx2[8]);
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--file-browse-btn--disabled", ctx2[7]);
      }
      if (!current || dirty & 512) {
        attr_dev(input, "id", ctx2[9]);
      }
      if (!current || dirty & 128) {
        prop_dev(input, "disabled", ctx2[7]);
      }
      if (!current || dirty & 4) {
        attr_dev(input, "accept", ctx2[2]);
      }
      if (!current || dirty & 1024) {
        attr_dev(input, "name", ctx2[10]);
      }
      if (!current || dirty & 8) {
        prop_dev(input, "multiple", ctx2[3]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 8192 && ctx2[13]]));
      toggle_class(div1, "bx--file", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var click_handler_12 = ({ target }) => {
  target.value = null;
};
function instance84($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "accept",
    "files",
    "multiple",
    "validateFiles",
    "labelText",
    "role",
    "disabled",
    "tabindex",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderDropContainer", slots, ["labelText"]);
  let { accept = [] } = $$props;
  let { files = [] } = $$props;
  let { multiple = false } = $$props;
  let { validateFiles = (files2) => files2 } = $$props;
  let { labelText = "Add file" } = $$props;
  let { role = "button" } = $$props;
  let { disabled = false } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let over = false;
  function dragover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function dragleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function drop_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      ref.click();
    }
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = ({ target }) => {
    $$invalidate(0, files = validateFiles([...target.files]));
    dispatch("add", files);
    dispatch("change", files);
  };
  const dragover_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = true);
      dataTransfer.dropEffect = "copy";
    }
  };
  const dragleave_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = false);
      dataTransfer.dropEffect = "move";
    }
  };
  const drop_handler_1 = ({ dataTransfer }) => {
    if (!disabled) {
      $$invalidate(11, over = false);
      $$invalidate(0, files = validateFiles([...dataTransfer.files]));
      dispatch("add", files);
      dispatch("change", files);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("accept" in $$new_props)
      $$invalidate(2, accept = $$new_props.accept);
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$new_props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("validateFiles" in $$new_props)
      $$invalidate(4, validateFiles = $$new_props.validateFiles);
    if ("labelText" in $$new_props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("role" in $$new_props)
      $$invalidate(6, role = $$new_props.role);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("tabindex" in $$new_props)
      $$invalidate(8, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props)
      $$invalidate(9, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(10, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    accept,
    files,
    multiple,
    validateFiles,
    labelText,
    role,
    disabled,
    tabindex,
    id,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    over
  });
  $$self.$inject_state = ($$new_props) => {
    if ("accept" in $$props)
      $$invalidate(2, accept = $$new_props.accept);
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("multiple" in $$props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("validateFiles" in $$props)
      $$invalidate(4, validateFiles = $$new_props.validateFiles);
    if ("labelText" in $$props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("role" in $$props)
      $$invalidate(6, role = $$new_props.role);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("tabindex" in $$props)
      $$invalidate(8, tabindex = $$new_props.tabindex);
    if ("id" in $$props)
      $$invalidate(9, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(10, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("over" in $$props)
      $$invalidate(11, over = $$new_props.over);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    files,
    ref,
    accept,
    multiple,
    validateFiles,
    labelText,
    role,
    disabled,
    tabindex,
    id,
    name,
    over,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    dragover_handler,
    dragleave_handler,
    drop_handler,
    click_handler,
    keydown_handler,
    keydown_handler_12,
    input_binding,
    change_handler,
    dragover_handler_1,
    dragleave_handler_1,
    drop_handler_1
  ];
}
var FileUploaderDropContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {
      accept: 2,
      files: 0,
      multiple: 3,
      validateFiles: 4,
      labelText: 5,
      role: 6,
      disabled: 7,
      tabindex: 8,
      id: 9,
      name: 10,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderDropContainer",
      options,
      id: create_fragment84.name
    });
  }
  get accept() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateFiles() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateFiles(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<FileUploaderDropContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<FileUploaderDropContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUploaderDropContainer_default = FileUploaderDropContainer;

// node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte
var file81 = "node_modules/carbon-components-svelte/src/FileUploader/FileUploaderSkeleton.svelte";
function create_fragment85(ctx) {
  let div;
  let skeletontext0;
  let t0;
  let skeletontext1;
  let t1;
  let buttonskeleton;
  let current;
  let mounted;
  let dispose;
  skeletontext0 = new SkeletonText_default({
    props: { heading: true, width: "100px" },
    $$inline: true
  });
  skeletontext1 = new SkeletonText_default({
    props: {
      width: "225px",
      class: "bx--label-description"
    },
    $$inline: true
  });
  buttonskeleton = new ButtonSkeleton_default({ $$inline: true });
  let div_levels = [ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(skeletontext0.$$.fragment);
      t0 = space();
      create_component(skeletontext1.$$.fragment);
      t1 = space();
      create_component(buttonskeleton.$$.fragment);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file81, 6, 0, 207);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(skeletontext0, div, null);
      append_dev(div, t0);
      mount_component(skeletontext1, div, null);
      append_dev(div, t1);
      mount_component(buttonskeleton, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[1], false, false, false),
          listen_dev(div, "mouseover", ctx[2], false, false, false),
          listen_dev(div, "mouseenter", ctx[3], false, false, false),
          listen_dev(div, "mouseleave", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(buttonskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(buttonskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(buttonskeleton);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUploaderSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({ ButtonSkeleton: ButtonSkeleton_default, SkeletonText: SkeletonText_default });
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FileUploaderSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUploaderSkeleton",
      options,
      id: create_fragment85.name
    });
  }
};
var FileUploaderSkeleton_default = FileUploaderSkeleton;

// node_modules/carbon-components-svelte/src/Form/Form.svelte
var file82 = "node_modules/carbon-components-svelte/src/Form/Form.svelte";
function create_fragment86(ctx) {
  let form;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let form_levels = [ctx[1]];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (default_slot)
        default_slot.c();
      set_attributes(form, form_data);
      toggle_class(form, "bx--form", true);
      add_location(form, file82, 6, 0, 150);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, form, anchor);
      if (default_slot) {
        default_slot.m(form, null);
      }
      ctx[10](form);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(form, "click", ctx[4], false, false, false),
          listen_dev(form, "keydown", ctx[5], false, false, false),
          listen_dev(form, "mouseover", ctx[6], false, false, false),
          listen_dev(form, "mouseenter", ctx[7], false, false, false),
          listen_dev(form, "mouseleave", ctx[8], false, false, false),
          listen_dev(form, "submit", ctx[9], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(form, "bx--form", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function submit_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function form_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ ref });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    submit_handler,
    form_binding
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment86.name
    });
  }
  get ref() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/carbon-components-svelte/src/FluidForm/FluidForm.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: '(8:0) <Form   {...$$restProps}   class=\\"bx--form--fluid {$$restProps.class}\\"   on:click   on:keydown   on:mouseover   on:mouseenter   on:mouseleave   on:submit >',
    ctx
  });
  return block;
}
function create_fragment87(ctx) {
  let form;
  let current;
  const form_spread_levels = [
    ctx[0],
    {
      class: "bx--form--fluid " + ctx[0].class
    }
  ];
  let form_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < form_spread_levels.length; i += 1) {
    form_props = assign(form_props, form_spread_levels[i]);
  }
  form = new Form_default({ props: form_props, $$inline: true });
  form.$on("click", ctx[2]);
  form.$on("keydown", ctx[3]);
  form.$on("mouseover", ctx[4]);
  form.$on("mouseenter", ctx[5]);
  form.$on("mouseleave", ctx[6]);
  form.$on("submit", ctx[7]);
  const block = {
    c: function create() {
      create_component(form.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(form, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const form_changes = dirty & 1 ? get_spread_update(form_spread_levels, [
        get_spread_object(ctx2[0]),
        {
          class: "bx--form--fluid " + ctx2[0].class
        }
      ]) : {};
      if (dirty & 256) {
        form_changes.$$scope = { dirty, ctx: ctx2 };
      }
      form.$set(form_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(form.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(form.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(form, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FluidForm", slots, ["default"]);
  setContext("Form", { isFluid: true });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function submit_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, Form: Form_default });
  return [
    $$restProps,
    slots,
    click_handler,
    keydown_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    submit_handler,
    $$scope
  ];
}
var FluidForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FluidForm",
      options,
      id: create_fragment87.name
    });
  }
};
var FluidForm_default = FluidForm;

// node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte
var file83 = "node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte";
function create_if_block_118(ctx) {
  let legend;
  let t;
  let legend_id_value;
  const block = {
    c: function create() {
      legend = element("legend");
      t = text(ctx[4]);
      attr_dev(legend, "id", legend_id_value = ctx[5] || ctx[6]["aria-labelledby"]);
      toggle_class(legend, "bx--label", true);
      add_location(legend, file83, 33, 4, 826);
    },
    m: function mount(target, anchor) {
      insert_dev(target, legend, anchor);
      append_dev(legend, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
      if (dirty & 96 && legend_id_value !== (legend_id_value = ctx2[5] || ctx2[6]["aria-labelledby"])) {
        attr_dev(legend, "id", legend_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(legend);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(33:2) {#if legendText}",
    ctx
  });
  return block;
}
function create_if_block50(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[3]);
      toggle_class(div, "bx--form__requirement", true);
      add_location(div, file83, 40, 4, 987);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block50.name,
    type: "if",
    source: "(40:2) {#if message}",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let fieldset;
  let t0;
  let t1;
  let fieldset_data_invalid_value;
  let fieldset_aria_labelledby_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[4] && create_if_block_118(ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let if_block1 = ctx[2] && create_if_block50(ctx);
  let fieldset_levels = [
    {
      "data-invalid": fieldset_data_invalid_value = ctx[1] || void 0
    },
    {
      "aria-labelledby": fieldset_aria_labelledby_value = ctx[6]["aria-labelledby"] || ctx[5]
    },
    ctx[6]
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      set_attributes(fieldset, fieldset_data);
      toggle_class(fieldset, "bx--fieldset", true);
      toggle_class(fieldset, "bx--fieldset--no-margin", ctx[0]);
      add_location(fieldset, file83, 21, 0, 534);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, fieldset, anchor);
      if (if_block0)
        if_block0.m(fieldset, null);
      append_dev(fieldset, t0);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      append_dev(fieldset, t1);
      if (if_block1)
        if_block1.m(fieldset, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(fieldset, "click", ctx[9], false, false, false),
          listen_dev(fieldset, "mouseover", ctx[10], false, false, false),
          listen_dev(fieldset, "mouseenter", ctx[11], false, false, false),
          listen_dev(fieldset, "mouseleave", ctx[12], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_118(ctx2);
          if_block0.c();
          if_block0.m(fieldset, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block50(ctx2);
          if_block1.c();
          if_block1.m(fieldset, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        (!current || dirty & 2 && fieldset_data_invalid_value !== (fieldset_data_invalid_value = ctx2[1] || void 0)) && {
          "data-invalid": fieldset_data_invalid_value
        },
        (!current || dirty & 96 && fieldset_aria_labelledby_value !== (fieldset_aria_labelledby_value = ctx2[6]["aria-labelledby"] || ctx2[5])) && {
          "aria-labelledby": fieldset_aria_labelledby_value
        },
        dirty & 64 && ctx2[6]
      ]));
      toggle_class(fieldset, "bx--fieldset", true);
      toggle_class(fieldset, "bx--fieldset--no-margin", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  const omit_props_names = ["noMargin", "invalid", "message", "messageText", "legendText", "legendId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormGroup", slots, ["default"]);
  let { noMargin = false } = $$props;
  let { invalid = false } = $$props;
  let { message = false } = $$props;
  let { messageText = "" } = $$props;
  let { legendText = "" } = $$props;
  let { legendId = "" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("noMargin" in $$new_props)
      $$invalidate(0, noMargin = $$new_props.noMargin);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("message" in $$new_props)
      $$invalidate(2, message = $$new_props.message);
    if ("messageText" in $$new_props)
      $$invalidate(3, messageText = $$new_props.messageText);
    if ("legendText" in $$new_props)
      $$invalidate(4, legendText = $$new_props.legendText);
    if ("legendId" in $$new_props)
      $$invalidate(5, legendId = $$new_props.legendId);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    noMargin,
    invalid,
    message,
    messageText,
    legendText,
    legendId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("noMargin" in $$props)
      $$invalidate(0, noMargin = $$new_props.noMargin);
    if ("invalid" in $$props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("message" in $$props)
      $$invalidate(2, message = $$new_props.message);
    if ("messageText" in $$props)
      $$invalidate(3, messageText = $$new_props.messageText);
    if ("legendText" in $$props)
      $$invalidate(4, legendText = $$new_props.legendText);
    if ("legendId" in $$props)
      $$invalidate(5, legendId = $$new_props.legendId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    noMargin,
    invalid,
    message,
    messageText,
    legendText,
    legendId,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      noMargin: 0,
      invalid: 1,
      message: 2,
      messageText: 3,
      legendText: 4,
      legendId: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormGroup",
      options,
      id: create_fragment88.name
    });
  }
  get noMargin() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noMargin(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get messageText() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set messageText(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendText() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendText(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendId() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendId(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormGroup_default = FormGroup;

// node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte
var file84 = "node_modules/carbon-components-svelte/src/FormItem/FormItem.svelte";
function create_fragment89(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let div_levels = [ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file84, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[3], false, false, false),
          listen_dev(div, "mouseover", ctx[4], false, false, false),
          listen_dev(div, "mouseenter", ctx[5], false, false, false),
          listen_dev(div, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormItem",
      options,
      id: create_fragment89.name
    });
  }
};
var FormItem_default = FormItem;

// node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte
var file85 = "node_modules/carbon-components-svelte/src/FormLabel/FormLabel.svelte";
function create_fragment90(ctx) {
  let label;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let label_levels = [{ for: ctx[0] }, ctx[1]];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
      toggle_class(label, "bx--label", true);
      add_location(label, file85, 6, 0, 183);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(label, "click", ctx[4], false, false, false),
          listen_dev(label, "mouseover", ctx[5], false, false, false),
          listen_dev(label, "mouseenter", ctx[6], false, false, false),
          listen_dev(label, "mouseleave", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 1) && { for: ctx2[0] },
        dirty & 2 && ctx2[1]
      ]));
      toggle_class(label, "bx--label", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormLabel", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ id });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var FormLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormLabel",
      options,
      id: create_fragment90.name
    });
  }
  get id() {
    throw new Error("<FormLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FormLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormLabel_default = FormLabel;

// node_modules/carbon-components-svelte/src/Grid/Grid.svelte
var file86 = "node_modules/carbon-components-svelte/src/Grid/Grid.svelte";
var get_default_slot_changes6 = (dirty) => ({ props: dirty & 2 });
var get_default_slot_context6 = (ctx) => ({ props: ctx[1] });
function create_else_block20(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file86, 54, 2, 1398);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(54:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block51(ctx) {
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], get_default_slot_context6);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, get_default_slot_changes6),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block51.name,
    type: "if",
    source: "(52:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block51, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = [
    "as",
    "condensed",
    "narrow",
    "fullWidth",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { as = false } = $$props;
  let { condensed = false } = $$props;
  let { narrow = false } = $$props;
  let { fullWidth = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$new_props)
      $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$new_props)
      $$invalidate(3, narrow = $$new_props.narrow);
    if ("fullWidth" in $$new_props)
      $$invalidate(4, fullWidth = $$new_props.fullWidth);
    if ("noGutter" in $$new_props)
      $$invalidate(5, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props)
      $$invalidate(6, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props)
      $$invalidate(7, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    condensed,
    narrow,
    fullWidth,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$props)
      $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$props)
      $$invalidate(3, narrow = $$new_props.narrow);
    if ("fullWidth" in $$props)
      $$invalidate(4, fullWidth = $$new_props.fullWidth);
    if ("noGutter" in $$props)
      $$invalidate(5, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props)
      $$invalidate(6, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props)
      $$invalidate(7, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = {
        ...$$restProps,
        class: [
          $$restProps.class,
          "bx--grid",
          condensed && "bx--grid--condensed",
          narrow && "bx--grid--narrow",
          fullWidth && "bx--grid--full-width",
          noGutter && "bx--no-gutter",
          noGutterLeft && "bx--no-gutter--left",
          noGutterRight && "bx--no-gutter--right",
          padding && "bx--row-padding"
        ].filter(Boolean).join(" ")
      });
  };
  return [
    as,
    props,
    condensed,
    narrow,
    fullWidth,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    $$scope,
    slots
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {
      as: 0,
      condensed: 2,
      narrow: 3,
      fullWidth: 4,
      noGutter: 5,
      noGutterLeft: 6,
      noGutterRight: 7,
      padding: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment91.name
    });
  }
  get as() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get narrow() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set narrow(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/carbon-components-svelte/src/Grid/Row.svelte
var file87 = "node_modules/carbon-components-svelte/src/Grid/Row.svelte";
var get_default_slot_changes7 = (dirty) => ({ props: dirty & 2 });
var get_default_slot_context7 = (ctx) => ({ props: ctx[1] });
function create_else_block21(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file87, 50, 2, 1267);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(50:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block52(ctx) {
  let current;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], get_default_slot_context7);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 258)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, get_default_slot_changes7),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block52.name,
    type: "if",
    source: "(48:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block52, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = ["as", "condensed", "narrow", "noGutter", "noGutterLeft", "noGutterRight", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { as = false } = $$props;
  let { condensed = false } = $$props;
  let { narrow = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$new_props)
      $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$new_props)
      $$invalidate(3, narrow = $$new_props.narrow);
    if ("noGutter" in $$new_props)
      $$invalidate(4, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props)
      $$invalidate(5, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props)
      $$invalidate(6, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    condensed,
    narrow,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("condensed" in $$props)
      $$invalidate(2, condensed = $$new_props.condensed);
    if ("narrow" in $$props)
      $$invalidate(3, narrow = $$new_props.narrow);
    if ("noGutter" in $$props)
      $$invalidate(4, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props)
      $$invalidate(5, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props)
      $$invalidate(6, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = {
        ...$$restProps,
        class: [
          $$restProps.class,
          "bx--row",
          condensed && "bx--row--condensed",
          narrow && "bx--row--narrow",
          noGutter && "bx--no-gutter",
          noGutterLeft && "bx--no-gutter--left",
          noGutterRight && "bx--no-gutter--right",
          padding && "bx--row-padding"
        ].filter(Boolean).join(" ")
      });
  };
  return [
    as,
    props,
    condensed,
    narrow,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    $$scope,
    slots
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, {
      as: 0,
      condensed: 2,
      narrow: 3,
      noGutter: 4,
      noGutterLeft: 5,
      noGutterRight: 6,
      padding: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment92.name
    });
  }
  get as() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get narrow() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set narrow(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/carbon-components-svelte/src/Grid/Column.svelte
var file88 = "node_modules/carbon-components-svelte/src/Grid/Column.svelte";
var get_default_slot_changes8 = (dirty) => ({ props: dirty & 2 });
var get_default_slot_context8 = (ctx) => ({ props: ctx[1] });
function create_else_block22(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file88, 115, 2, 2896);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(115:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block53(ctx) {
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], get_default_slot_context8);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8194)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, get_default_slot_changes8),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block53.name,
    type: "if",
    source: "(113:0) {#if as}",
    ctx
  });
  return block;
}
function create_fragment93(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block53, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let columnClass;
  let props;
  const omit_props_names = [
    "as",
    "noGutter",
    "noGutterLeft",
    "noGutterRight",
    "padding",
    "aspectRatio",
    "sm",
    "md",
    "lg",
    "xlg",
    "max"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["default"]);
  let { as = false } = $$props;
  let { noGutter = false } = $$props;
  let { noGutterLeft = false } = $$props;
  let { noGutterRight = false } = $$props;
  let { padding = false } = $$props;
  let { aspectRatio = void 0 } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xlg = void 0 } = $$props;
  let { max = void 0 } = $$props;
  const breakpoints2 = ["sm", "md", "lg", "xlg", "max"];
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("noGutter" in $$new_props)
      $$invalidate(2, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$new_props)
      $$invalidate(3, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$new_props)
      $$invalidate(4, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$new_props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("aspectRatio" in $$new_props)
      $$invalidate(6, aspectRatio = $$new_props.aspectRatio);
    if ("sm" in $$new_props)
      $$invalidate(7, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(8, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(9, lg = $$new_props.lg);
    if ("xlg" in $$new_props)
      $$invalidate(10, xlg = $$new_props.xlg);
    if ("max" in $$new_props)
      $$invalidate(11, max = $$new_props.max);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    as,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    aspectRatio,
    sm,
    md,
    lg,
    xlg,
    max,
    breakpoints: breakpoints2,
    columnClass,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    if ("as" in $$props)
      $$invalidate(0, as = $$new_props.as);
    if ("noGutter" in $$props)
      $$invalidate(2, noGutter = $$new_props.noGutter);
    if ("noGutterLeft" in $$props)
      $$invalidate(3, noGutterLeft = $$new_props.noGutterLeft);
    if ("noGutterRight" in $$props)
      $$invalidate(4, noGutterRight = $$new_props.noGutterRight);
    if ("padding" in $$props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("aspectRatio" in $$props)
      $$invalidate(6, aspectRatio = $$new_props.aspectRatio);
    if ("sm" in $$props)
      $$invalidate(7, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(8, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(9, lg = $$new_props.lg);
    if ("xlg" in $$props)
      $$invalidate(10, xlg = $$new_props.xlg);
    if ("max" in $$props)
      $$invalidate(11, max = $$new_props.max);
    if ("columnClass" in $$props)
      $$invalidate(12, columnClass = $$new_props.columnClass);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3968) {
      $:
        $$invalidate(12, columnClass = [sm, md, lg, xlg, max].map((breakpoint, i) => {
          const name = breakpoints2[i];
          if (breakpoint === true) {
            return `bx--col-${name}`;
          } else if (typeof breakpoint === "number") {
            return `bx--col-${name}-${breakpoint}`;
          } else if (typeof breakpoint === "object") {
            let bp = [];
            if (typeof breakpoint.span === "number") {
              bp = [...bp, `bx--col-${name}-${breakpoint.span}`];
            } else if (breakpoint.span === true) {
              bp = [...bp, `bx--col-${name}`];
            }
            if (typeof breakpoint.offset === "number") {
              bp = [...bp, `bx--offset-${name}-${breakpoint.offset}`];
            }
            return bp.join(" ");
          }
        }).filter(Boolean).join(" "));
    }
    $:
      $$invalidate(1, props = {
        ...$$restProps,
        class: [
          $$restProps.class,
          columnClass,
          !columnClass && "bx--col",
          noGutter && "bx--no-gutter",
          noGutterLeft && "bx--no-gutter--left",
          noGutterRight && "bx--no-gutter--right",
          aspectRatio && `bx--aspect-ratio bx--aspect-ratio--${aspectRatio}`,
          padding && "bx--col-padding"
        ].filter(Boolean).join(" ")
      });
  };
  return [
    as,
    props,
    noGutter,
    noGutterLeft,
    noGutterRight,
    padding,
    aspectRatio,
    sm,
    md,
    lg,
    xlg,
    max,
    columnClass,
    $$scope,
    slots
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {
      as: 0,
      noGutter: 2,
      noGutterLeft: 3,
      noGutterRight: 4,
      padding: 5,
      aspectRatio: 6,
      sm: 7,
      md: 8,
      lg: 9,
      xlg: 10,
      max: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment93.name
    });
  }
  get as() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutter() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutter(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterLeft() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterLeft(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutterRight() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutterRight(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xlg() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xlg(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte
var file89 = "node_modules/carbon-components-svelte/src/ImageLoader/ImageLoader.svelte";
var get_error_slot_changes_1 = (dirty) => ({});
var get_error_slot_context_1 = (ctx) => ({});
var get_loading_slot_changes_1 = (dirty) => ({});
var get_loading_slot_context_1 = (ctx) => ({});
var get_error_slot_changes = (dirty) => ({});
var get_error_slot_context = (ctx) => ({});
var get_loading_slot_changes = (dirty) => ({});
var get_loading_slot_context = (ctx) => ({});
function create_else_block23(ctx) {
  let aspectratio;
  let current;
  aspectratio = new AspectRatio_default({
    props: {
      ratio: ctx[5],
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(aspectratio.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(aspectratio, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const aspectratio_changes = {};
      if (dirty & 32)
        aspectratio_changes.ratio = ctx2[5];
      if (dirty & 1247) {
        aspectratio_changes.$$scope = { dirty, ctx: ctx2 };
      }
      aspectratio.$set(aspectratio_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(aspectratio.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(aspectratio.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(aspectratio, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(95:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block54(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[2] && create_if_block_38(ctx);
  let if_block1 = ctx[0] && create_if_block_213(ctx);
  let if_block2 = ctx[1] && create_if_block_119(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_38(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_213(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_119(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block54.name,
    type: "if",
    source: "(79:0) {#if ratio === undefined}",
    ctx
  });
  return block;
}
function create_if_block_64(ctx) {
  let current;
  const loading_slot_template = ctx[9].loading;
  const loading_slot = create_slot(loading_slot_template, ctx, ctx[10], get_loading_slot_context_1);
  const block = {
    c: function create() {
      if (loading_slot)
        loading_slot.c();
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(loading_slot_template, ctx2[10], dirty, get_loading_slot_changes_1),
            get_loading_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot)
        loading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_64.name,
    type: "if",
    source: "(97:4) {#if loading}",
    ctx
  });
  return block;
}
function create_if_block_55(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  let img_transition;
  let current;
  let img_levels = [
    ctx[7],
    {
      style: img_style_value = "width: 100%;" + ctx[7].style
    },
    { src: img_src_value = ctx[3] },
    { alt: ctx[4] }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file89, 100, 6, 2247);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & 128 && ctx[7],
        (!current || dirty & 128 && img_style_value !== (img_style_value = "width: 100%;" + ctx[7].style)) && { style: img_style_value },
        (!current || dirty & 8 && !src_url_equal(img.src, img_src_value = ctx[3])) && { src: img_src_value },
        (!current || dirty & 16) && { alt: ctx[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!img_transition)
            img_transition = create_bidirectional_transition(img, fade, { duration: ctx[6] ? fast02 : 0 }, true);
          img_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!img_transition)
          img_transition = create_bidirectional_transition(img, fade, { duration: ctx[6] ? fast02 : 0 }, false);
        img_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      if (detaching && img_transition)
        img_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(100:4) {#if loaded}",
    ctx
  });
  return block;
}
function create_if_block_47(ctx) {
  let current;
  const error_slot_template = ctx[9].error;
  const error_slot = create_slot(error_slot_template, ctx, ctx[10], get_error_slot_context_1);
  const block = {
    c: function create() {
      if (error_slot)
        error_slot.c();
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(error_slot_template, ctx2[10], dirty, get_error_slot_changes_1),
            get_error_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot)
        error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_47.name,
    type: "if",
    source: "(109:4) {#if error}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[2] && create_if_block_64(ctx);
  let if_block1 = ctx[0] && create_if_block_55(ctx);
  let if_block2 = ctx[1] && create_if_block_47(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_64(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_55(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_47(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: '(96:2) <AspectRatio ratio=\\"{ratio}\\">',
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let current;
  const loading_slot_template = ctx[9].loading;
  const loading_slot = create_slot(loading_slot_template, ctx, ctx[10], get_loading_slot_context);
  const block = {
    c: function create() {
      if (loading_slot)
        loading_slot.c();
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(loading_slot_template, ctx2[10], dirty, get_loading_slot_changes),
            get_loading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot)
        loading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(80:2) {#if loading}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  let img_transition;
  let current;
  let img_levels = [
    ctx[7],
    {
      style: img_style_value = "width: 100%;" + ctx[7].style
    },
    { src: img_src_value = ctx[3] },
    { alt: ctx[4] }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file89, 83, 4, 1887);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & 128 && ctx[7],
        (!current || dirty & 128 && img_style_value !== (img_style_value = "width: 100%;" + ctx[7].style)) && { style: img_style_value },
        (!current || dirty & 8 && !src_url_equal(img.src, img_src_value = ctx[3])) && { src: img_src_value },
        (!current || dirty & 16) && { alt: ctx[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!img_transition)
            img_transition = create_bidirectional_transition(img, fade, { duration: ctx[6] ? fast02 : 0 }, true);
          img_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (local) {
        if (!img_transition)
          img_transition = create_bidirectional_transition(img, fade, { duration: ctx[6] ? fast02 : 0 }, false);
        img_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      if (detaching && img_transition)
        img_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(83:2) {#if loaded}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let current;
  const error_slot_template = ctx[9].error;
  const error_slot = create_slot(error_slot_template, ctx, ctx[10], get_error_slot_context);
  const block = {
    c: function create() {
      if (error_slot)
        error_slot.c();
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(error_slot_template, ctx2[10], dirty, get_error_slot_changes),
            get_error_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot)
        error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(92:2) {#if error}",
    ctx
  });
  return block;
}
function create_fragment94(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block54, create_else_block23];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5] === void 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var fast02 = 110;
function instance94($$self, $$props, $$invalidate) {
  const omit_props_names = ["src", "alt", "ratio", "loading", "loaded", "error", "fadeIn", "loadImage"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageLoader", slots, ["loading", "error"]);
  let { src = "" } = $$props;
  let { alt = "" } = $$props;
  let { ratio = void 0 } = $$props;
  let { loading = false } = $$props;
  let { loaded = false } = $$props;
  let { error = false } = $$props;
  let { fadeIn = false } = $$props;
  const loadImage = (url) => {
    if (image != null)
      image = null;
    $$invalidate(0, loaded = false);
    $$invalidate(1, error = false);
    image = new Image();
    image.src = url || src;
    image.onload = () => $$invalidate(0, loaded = true);
    image.onerror = () => $$invalidate(1, error = true);
  };
  const dispatch = createEventDispatcher();
  let image = null;
  onMount(() => {
    return () => image = null;
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(4, alt = $$new_props.alt);
    if ("ratio" in $$new_props)
      $$invalidate(5, ratio = $$new_props.ratio);
    if ("loading" in $$new_props)
      $$invalidate(2, loading = $$new_props.loading);
    if ("loaded" in $$new_props)
      $$invalidate(0, loaded = $$new_props.loaded);
    if ("error" in $$new_props)
      $$invalidate(1, error = $$new_props.error);
    if ("fadeIn" in $$new_props)
      $$invalidate(6, fadeIn = $$new_props.fadeIn);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    src,
    alt,
    ratio,
    loading,
    loaded,
    error,
    fadeIn,
    loadImage,
    onMount,
    createEventDispatcher,
    fade,
    AspectRatio: AspectRatio_default,
    dispatch,
    fast02,
    image
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(3, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(4, alt = $$new_props.alt);
    if ("ratio" in $$props)
      $$invalidate(5, ratio = $$new_props.ratio);
    if ("loading" in $$props)
      $$invalidate(2, loading = $$new_props.loading);
    if ("loaded" in $$props)
      $$invalidate(0, loaded = $$new_props.loaded);
    if ("error" in $$props)
      $$invalidate(1, error = $$new_props.error);
    if ("fadeIn" in $$props)
      $$invalidate(6, fadeIn = $$new_props.fadeIn);
    if ("image" in $$props)
      image = $$new_props.image;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        $$invalidate(2, loading = !loaded && !error);
    }
    if ($$self.$$.dirty & 8) {
      $:
        if (src && typeof window !== "undefined")
          loadImage();
    }
    if ($$self.$$.dirty & 1) {
      $:
        if (loaded)
          dispatch("load");
    }
    if ($$self.$$.dirty & 2) {
      $:
        if (error)
          dispatch("error");
    }
  };
  return [
    loaded,
    error,
    loading,
    src,
    alt,
    ratio,
    fadeIn,
    $$restProps,
    loadImage,
    slots,
    $$scope
  ];
}
var ImageLoader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {
      src: 3,
      alt: 4,
      ratio: 5,
      loading: 2,
      loaded: 0,
      error: 1,
      fadeIn: 6,
      loadImage: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageLoader",
      options,
      id: create_fragment94.name
    });
  }
  get src() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ratio() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaded() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaded(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeIn() {
    throw new Error("<ImageLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeIn(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadImage() {
    return this.$$.ctx[8];
  }
  set loadImage(value) {
    throw new Error("<ImageLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageLoader_default = ImageLoader;

// node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte
var file90 = "node_modules/carbon-components-svelte/src/icons/ErrorFilled.svelte";
function create_if_block55(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file90, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block55.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment95(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block55(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M14.9 7.2H17.1V24.799H14.9z");
      attr_dev(path0, "data-icon-path", "inner-path");
      attr_dev(path0, "transform", "rotate(-45 16 16)");
      add_location(path0, file90, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A13.914,13.914,0,0,0,2,16,13.914,13.914,0,0,0,16,30,13.914,13.914,0,0,0,30,16,13.914,13.914,0,0,0,16,2Zm5.4449,21L9,10.5557,10.5557,9,23,21.4448Z");
      add_location(path1, file90, 28, 41, 710);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file90, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block55(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ErrorFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance95, create_fragment95, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorFilled",
      options,
      id: create_fragment95.name
    });
  }
  get size() {
    throw new Error("<ErrorFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ErrorFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ErrorFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ErrorFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ErrorFilled_default = ErrorFilled;

// node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte
var file91 = "node_modules/carbon-components-svelte/src/InlineLoading/InlineLoading.svelte";
function create_if_block_39(ctx) {
  let loading;
  let current;
  loading = new Loading_default({
    props: {
      small: true,
      description: ctx[2],
      withOverlay: false,
      active: ctx[0] === "active"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loading.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const loading_changes = {};
      if (dirty & 4)
        loading_changes.description = ctx2[2];
      if (dirty & 1)
        loading_changes.active = ctx2[0] === "active";
      loading.$set(loading_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loading, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(68:59) ",
    ctx
  });
  return block;
}
function create_if_block_214(ctx) {
  let checkmarkfilled;
  let current;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      class: "bx--inline-loading__checkmark-container",
      title: ctx[2]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkfilled_changes = {};
      if (dirty & 4)
        checkmarkfilled_changes.title = ctx2[2];
      checkmarkfilled.$set(checkmarkfilled_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(63:36) ",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let errorfilled;
  let current;
  errorfilled = new ErrorFilled_default({
    props: {
      class: "bx--inline-loading--error",
      title: ctx[2]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(errorfilled, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const errorfilled_changes = {};
      if (dirty & 4)
        errorfilled_changes.title = ctx2[2];
      errorfilled.$set(errorfilled_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: '(58:4) {#if status === \\"error\\"}',
    ctx
  });
  return block;
}
function create_if_block56(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[1]);
      toggle_class(div, "bx--inline-loading__text", true);
      add_location(div, file91, 77, 4, 1839);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block56.name,
    type: "if",
    source: "(77:2) {#if description}",
    ctx
  });
  return block;
}
function create_fragment96(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_120, create_if_block_214, create_if_block_39];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "error")
      return 0;
    if (ctx2[0] === "finished")
      return 1;
    if (ctx2[0] === "inactive" || ctx2[0] === "active")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[1] && create_if_block56(ctx);
  let div1_levels = [{ "aria-live": "assertive" }, ctx[3]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div0, "bx--inline-loading__animation", true);
      add_location(div0, file91, 56, 2, 1246);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--inline-loading", true);
      add_location(div1, file91, 47, 0, 1100);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_dev(div1, t);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[5], false, false, false),
          listen_dev(div1, "mouseover", ctx[6], false, false, false),
          listen_dev(div1, "mouseenter", ctx[7], false, false, false),
          listen_dev(div1, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block56(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        { "aria-live": "assertive" },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(div1, "bx--inline-loading", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance96($$self, $$props, $$invalidate) {
  const omit_props_names = ["status", "description", "iconDescription", "successDelay"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineLoading", slots, []);
  let { status = "active" } = $$props;
  let { description = void 0 } = $$props;
  let { iconDescription = void 0 } = $$props;
  let { successDelay = 1500 } = $$props;
  const dispatch = createEventDispatcher();
  let timeout = void 0;
  onMount(() => {
    return () => {
      clearTimeout(timeout);
    };
  });
  afterUpdate(() => {
    if (status === "finished") {
      timeout = setTimeout(
        () => {
          dispatch("success");
        },
        successDelay
      );
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("status" in $$new_props)
      $$invalidate(0, status = $$new_props.status);
    if ("description" in $$new_props)
      $$invalidate(1, description = $$new_props.description);
    if ("iconDescription" in $$new_props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("successDelay" in $$new_props)
      $$invalidate(4, successDelay = $$new_props.successDelay);
  };
  $$self.$capture_state = () => ({
    status,
    description,
    iconDescription,
    successDelay,
    createEventDispatcher,
    afterUpdate,
    onMount,
    CheckmarkFilled: CheckmarkFilled_default,
    ErrorFilled: ErrorFilled_default,
    Loading: Loading_default,
    dispatch,
    timeout
  });
  $$self.$inject_state = ($$new_props) => {
    if ("status" in $$props)
      $$invalidate(0, status = $$new_props.status);
    if ("description" in $$props)
      $$invalidate(1, description = $$new_props.description);
    if ("iconDescription" in $$props)
      $$invalidate(2, iconDescription = $$new_props.iconDescription);
    if ("successDelay" in $$props)
      $$invalidate(4, successDelay = $$new_props.successDelay);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    status,
    description,
    iconDescription,
    $$restProps,
    successDelay,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var InlineLoading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, {
      status: 0,
      description: 1,
      iconDescription: 2,
      successDelay: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineLoading",
      options,
      id: create_fragment96.name
    });
  }
  get status() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set status(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get successDelay() {
    throw new Error("<InlineLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set successDelay(value) {
    throw new Error("<InlineLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineLoading_default = InlineLoading;

// node_modules/carbon-components-svelte/src/icons/Launch.svelte
var file92 = "node_modules/carbon-components-svelte/src/icons/Launch.svelte";
function create_if_block57(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file92, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block57.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment97(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block57(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M26,28H6a2.0027,2.0027,0,0,1-2-2V6A2.0027,2.0027,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0027,2.0027,0,0,1,26,28Z");
      add_location(path0, file92, 24, 2, 579);
      attr_dev(path1, "d", "M20 2L20 4 26.586 4 18 12.586 19.414 14 28 5.414 28 12 30 12 30 2 20 2z");
      add_location(path1, file92, 26, 10, 710);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file92, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block57(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Launch", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Launch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Launch",
      options,
      id: create_fragment97.name
    });
  }
  get size() {
    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Launch_default = Launch;

// node_modules/carbon-components-svelte/src/Link/OutboundLink.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: '(8:0) <Link   {...$$restProps}   on:click   on:mouseover   on:mouseenter   on:mouseleave   target=\\"_blank\\"   icon=\\"{Launch}\\" >',
    ctx
  });
  return block;
}
function create_fragment98(ctx) {
  let link;
  let current;
  const link_spread_levels = [ctx[0], { target: "_blank" }, { icon: Launch_default }];
  let link_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  link.$on("click", ctx[2]);
  link.$on("mouseover", ctx[3]);
  link.$on("mouseenter", ctx[4]);
  link.$on("mouseleave", ctx[5]);
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & 1 ? get_spread_update(link_spread_levels, [
        dirty & 1 && get_spread_object(ctx2[0]),
        link_spread_levels[1],
        dirty & 0 && { icon: Launch_default }
      ]) : {};
      if (dirty & 64) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance98($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OutboundLink", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Link: Link_default, Launch: Launch_default });
  return [
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var OutboundLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OutboundLink",
      options,
      id: create_fragment98.name
    });
  }
};
var OutboundLink_default = OutboundLink;

// node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte
var file93 = "node_modules/carbon-components-svelte/src/ListItem/ListItem.svelte";
function create_fragment99(ctx) {
  let li;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let li_levels = [ctx[0]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      toggle_class(li, "bx--list__item", true);
      add_location(li, file93, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", ctx[3], false, false, false),
          listen_dev(li, "mouseover", ctx[4], false, false, false),
          listen_dev(li, "mouseenter", ctx[5], false, false, false),
          listen_dev(li, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(li, "bx--list__item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListItem", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListItem",
      options,
      id: create_fragment99.name
    });
  }
};
var ListItem_default = ListItem;

// node_modules/carbon-components-svelte/src/LocalStorage/LocalStorage.svelte
function create_fragment100(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function clearAll() {
  localStorage.clear();
}
function instance100($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LocalStorage", slots, []);
  let { key = "local-storage-key" } = $$props;
  let { value = "" } = $$props;
  function clearItem() {
    localStorage.removeItem(key);
  }
  const dispatch = createEventDispatcher();
  let prevValue = value;
  function setItem() {
    if (typeof value === "object") {
      localStorage.setItem(key, JSON.stringify(value));
    } else {
      localStorage.setItem(key, value);
    }
  }
  onMount(() => {
    const item = localStorage.getItem(key);
    if (item != null) {
      try {
        $$invalidate(0, value = JSON.parse(item));
      } catch (e) {
        $$invalidate(0, value = item);
      }
    } else {
      setItem(value);
      dispatch("save");
    }
  });
  afterUpdate(() => {
    if (prevValue !== value) {
      setItem(value);
      dispatch("update", { prevValue, value });
    }
    prevValue = value;
  });
  const writable_props = ["key", "value"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<LocalStorage> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    key,
    value,
    clearItem,
    clearAll,
    onMount,
    afterUpdate,
    createEventDispatcher,
    dispatch,
    prevValue,
    setItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("prevValue" in $$props2)
      prevValue = $$props2.prevValue;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, key, clearItem, clearAll];
}
var LocalStorage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, {
      key: 1,
      value: 0,
      clearItem: 2,
      clearAll: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LocalStorage",
      options,
      id: create_fragment100.name
    });
  }
  get key() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearItem() {
    return this.$$.ctx[2];
  }
  set clearItem(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearAll() {
    return clearAll;
  }
  set clearAll(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LocalStorage_default = LocalStorage;

// node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte
var file94 = "node_modules/carbon-components-svelte/src/MultiSelect/MultiSelect.svelte";
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[73] = list[i];
  child_ctx[75] = i;
  return child_ctx;
}
var get_default_slot_changes9 = (dirty) => ({
  item: dirty[0] & 1610616832,
  index: dirty[0] & 1610616832
});
var get_default_slot_context9 = (ctx) => ({
  slot: "labelText",
  item: ctx[73],
  index: ctx[75]
});
function create_if_block_92(ctx) {
  let label_1;
  let t;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(ctx[17]);
      attr_dev(label_1, "for", ctx[26]);
      toggle_class(label_1, "bx--label", true);
      toggle_class(label_1, "bx--label--disabled", ctx[11]);
      toggle_class(label_1, "bx--visually-hidden", ctx[25]);
      add_location(label_1, file94, 296, 4, 7909);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 131072)
        set_data_dev(t, ctx2[17]);
      if (dirty[0] & 67108864) {
        attr_dev(label_1, "for", ctx2[26]);
      }
      if (dirty[0] & 2048) {
        toggle_class(label_1, "bx--label--disabled", ctx2[11]);
      }
      if (dirty[0] & 33554432) {
        toggle_class(label_1, "bx--visually-hidden", ctx2[25]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(296:2) {#if titleText}",
    ctx
  });
  return block;
}
function create_if_block_82(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(323:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_72(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--list-box__invalid-icon bx--list-box__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(326:4) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_65(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      selectionCount: ctx[31].length,
      translateWithId: ctx[16],
      disabled: ctx[11]
    },
    $$inline: true
  });
  listboxselection.$on("clear", ctx[52]);
  listboxselection.$on("clear", ctx[53]);
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[1] & 1)
        listboxselection_changes.selectionCount = ctx2[31].length;
      if (dirty[0] & 65536)
        listboxselection_changes.translateWithId = ctx2[16];
      if (dirty[0] & 2048)
        listboxselection_changes.disabled = ctx2[11];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_65.name,
    type: "if",
    source: "(389:6) {#if checked.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_310(ctx) {
  let input;
  let t0;
  let t1;
  let t2;
  let listboxmenuicon;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[37],
    { role: "combobox" },
    { tabindex: "0" },
    { autocomplete: "off" },
    { "aria-autocomplete": "list" },
    { "aria-expanded": ctx[1] },
    {
      "aria-activedescendant": ctx[6]
    },
    { "aria-disabled": ctx[11] },
    { "aria-controls": ctx[34] },
    { disabled: ctx[11] },
    { placeholder: ctx[14] },
    { id: ctx[26] },
    { name: ctx[27] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = ctx[19] && create_if_block_56(ctx);
  let if_block1 = ctx[0] && create_if_block_48(ctx);
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      style: "pointer-events: " + (ctx[1] ? "auto" : "none"),
      translateWithId: ctx[15],
      open: ctx[1]
    },
    $$inline: true
  });
  listboxmenuicon.$on("click", ctx[58]);
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      create_component(listboxmenuicon.$$.fragment);
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--empty", ctx[0] === "");
      toggle_class(input, "bx--text-input--light", ctx[13]);
      add_location(input, file94, 404, 8, 10881);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[54](input);
      set_input_value(input, ctx[0]);
      insert_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[55]),
          listen_dev(input, "keydown", ctx[46], false, false, false),
          listen_dev(input, "keydown", stop_propagation(ctx[56]), false, false, true),
          listen_dev(input, "keyup", ctx[47], false, false, false),
          listen_dev(input, "focus", ctx[48], false, false, false),
          listen_dev(input, "blur", ctx[49], false, false, false),
          listen_dev(input, "paste", ctx[50], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[1] & 64 && ctx2[37],
        { role: "combobox" },
        { tabindex: "0" },
        { autocomplete: "off" },
        { "aria-autocomplete": "list" },
        (!current || dirty[0] & 2) && { "aria-expanded": ctx2[1] },
        (!current || dirty[0] & 64) && {
          "aria-activedescendant": ctx2[6]
        },
        (!current || dirty[0] & 2048) && { "aria-disabled": ctx2[11] },
        (!current || dirty[1] & 8) && { "aria-controls": ctx2[34] },
        (!current || dirty[0] & 2048) && { disabled: ctx2[11] },
        (!current || dirty[0] & 16384) && { placeholder: ctx2[14] },
        (!current || dirty[0] & 67108864) && { id: ctx2[26] },
        (!current || dirty[0] & 134217728) && { name: ctx2[27] }
      ]));
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--empty", ctx2[0] === "");
      toggle_class(input, "bx--text-input--light", ctx2[13]);
      if (ctx2[19]) {
        if (if_block0) {
          if (dirty[0] & 524288) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_56(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_48(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const listboxmenuicon_changes = {};
      if (dirty[0] & 2)
        listboxmenuicon_changes.style = "pointer-events: " + (ctx2[1] ? "auto" : "none");
      if (dirty[0] & 32768)
        listboxmenuicon_changes.translateWithId = ctx2[15];
      if (dirty[0] & 2)
        listboxmenuicon_changes.open = ctx2[1];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[54](null);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(listboxmenuicon, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(404:6) {#if filterable}",
    ctx
  });
  return block;
}
function create_if_block_56(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--list-box__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_56.name,
    type: "if",
    source: "(454:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_48(ctx) {
  let listboxselection;
  let current;
  listboxselection = new ListBoxSelection_default({
    props: {
      translateWithId: ctx[16],
      disabled: ctx[11],
      open: ctx[1]
    },
    $$inline: true
  });
  listboxselection.$on("clear", ctx[57]);
  const block = {
    c: function create() {
      create_component(listboxselection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxselection, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxselection_changes = {};
      if (dirty[0] & 65536)
        listboxselection_changes.translateWithId = ctx2[16];
      if (dirty[0] & 2048)
        listboxselection_changes.disabled = ctx2[11];
      if (dirty[0] & 2)
        listboxselection_changes.open = ctx2[1];
      listboxselection.$set(listboxselection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxselection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxselection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxselection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_48.name,
    type: "if",
    source: "(457:8) {#if value}",
    ctx
  });
  return block;
}
function create_if_block_215(ctx) {
  let span;
  let t0;
  let t1;
  let listboxmenuicon;
  let current;
  listboxmenuicon = new ListBoxMenuIcon_default({
    props: {
      open: ctx[1],
      translateWithId: ctx[15]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(ctx[24]);
      t1 = space();
      create_component(listboxmenuicon.$$.fragment);
      toggle_class(span, "bx--list-box__label", true);
      add_location(span, file94, 478, 8, 13201);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t0);
      insert_dev(target, t1, anchor);
      mount_component(listboxmenuicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 16777216)
        set_data_dev(t0, ctx2[24]);
      const listboxmenuicon_changes = {};
      if (dirty[0] & 2)
        listboxmenuicon_changes.open = ctx2[1];
      if (dirty[0] & 32768)
        listboxmenuicon_changes.translateWithId = ctx2[15];
      listboxmenuicon.$set(listboxmenuicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (detaching)
        detach_dev(t1);
      destroy_component(listboxmenuicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_215.name,
    type: "if",
    source: "(478:6) {#if !filterable}",
    ctx
  });
  return block;
}
function create_default_slot_33(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[31].length > 0 && create_if_block_65(ctx);
  let if_block1 = ctx[12] && create_if_block_310(ctx);
  let if_block2 = !ctx[12] && create_if_block_215(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[31].length > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_65(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[12]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_310(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[12]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_215(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_33.name,
    type: "slot",
    source: `(331:4) <ListBoxField       role=\\"button\\"       tabindex=\\"0\\"       aria-expanded=\\"{open}\\"       on:click=\\"{() => {         if (disabled) return;         if (filterable) {           open = true;           inputRef.focus();         } else {           open = !open;         }       }}\\"       on:keydown=\\"{(e) => {         if (filterable) {           return;         }         const key = e.key;         if ([' ', 'ArrowUp', 'ArrowDown'].includes(key)) {           e.preventDefault();         }         if (key === ' ') {           open = !open;         } else if (key === 'Tab') {           if (selectionRef && checked.length > 0) {             selectionRef.focus();           } else {             open = false;             fieldRef.blur();           }         } else if (key === 'ArrowDown') {           change(1);         } else if (key === 'ArrowUp') {           change(-1);         } else if (key === 'Enter') {           if (highlightedIndex > -1) {             sortedItems = sortedItems.map((item, i) => {               if (i !== highlightedIndex) return item;               return { ...item, checked: !item.checked };             });           }         } else if (key === 'Escape') {           open = false;         }       }}\\"       on:focus=\\"{() => {         if (filterable) {           open = true;           if (inputRef) inputRef.focus();         }       }}\\"       on:blur=\\"{(e) => {         if (!filterable) dispatch('blur', e);       }}\\"       id=\\"{id}\\"       disabled=\\"{disabled}\\"       translateWithId=\\"{translateWithId}\\"     >`,
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let listboxmenu;
  let current;
  listboxmenu = new ListBoxMenu_default({
    props: {
      "aria-label": ctx[32],
      id: ctx[26],
      "aria-multiselectable": "true",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(listboxmenu.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(listboxmenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const listboxmenu_changes = {};
      if (dirty[1] & 2)
        listboxmenu_changes["aria-label"] = ctx2[32];
      if (dirty[0] & 67108864)
        listboxmenu_changes.id = ctx2[26];
      if (dirty[0] & 1879314834 | dirty[2] & 32) {
        listboxmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxmenu.$set(listboxmenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listboxmenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(483:4) {#if open}",
    ctx
  });
  return block;
}
function fallback_block18(ctx) {
  let t_value = ctx[7](ctx[73]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1610616960 && t_value !== (t_value = ctx2[7](ctx2[73]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block18.name,
    type: "fallback",
    source: "(526:63)                  ",
    ctx
  });
  return block;
}
function create_labelText_slot(ctx) {
  let current;
  const default_slot_template = ctx[45].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[67], get_default_slot_context9);
  const default_slot_or_fallback = default_slot || fallback_block18(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 1610616832 | dirty[2] & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[67],
            !current ? get_all_dirty_from_scope(ctx2[67]) : get_slot_changes(default_slot_template, ctx2[67], dirty, get_default_slot_changes9),
            get_default_slot_context9
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 1610616960)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_labelText_slot.name,
    type: "slot",
    source: "(526:14) ",
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let checkbox;
  let t;
  let current;
  const checkbox_spread_levels = [
    { name: ctx[73].id },
    {
      title: ctx[18] ? ctx[7](ctx[73]) : void 0
    },
    ctx[8](ctx[73]),
    { readonly: true },
    { tabindex: "-1" },
    { id: "checkbox-" + ctx[73].id },
    { checked: ctx[73].checked },
    { disabled: ctx[73].disabled }
  ];
  function blur_handler_2() {
    return ctx[63](ctx[75]);
  }
  let checkbox_props = {
    $$slots: { labelText: [create_labelText_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < checkbox_spread_levels.length; i += 1) {
    checkbox_props = assign(checkbox_props, checkbox_spread_levels[i]);
  }
  checkbox = new Checkbox_default({ props: checkbox_props, $$inline: true });
  checkbox.$on("blur", blur_handler_2);
  const block = {
    c: function create() {
      create_component(checkbox.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      mount_component(checkbox, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const checkbox_changes = dirty[0] & 1610879360 ? get_spread_update(checkbox_spread_levels, [
        dirty[0] & 1610616832 && { name: ctx[73].id },
        dirty[0] & 1610879104 && {
          title: ctx[18] ? ctx[7](ctx[73]) : void 0
        },
        dirty[0] & 1610617088 && get_spread_object(ctx[8](ctx[73])),
        checkbox_spread_levels[3],
        checkbox_spread_levels[4],
        dirty[0] & 1610616832 && { id: "checkbox-" + ctx[73].id },
        dirty[0] & 1610616832 && { checked: ctx[73].checked },
        dirty[0] & 1610616832 && { disabled: ctx[73].disabled }
      ]) : {};
      if (dirty[0] & 1610616960 | dirty[2] & 32) {
        checkbox_changes.$$scope = { dirty, ctx };
      }
      checkbox.$set(checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkbox, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: '(490:10) <ListBoxMenuItem             id=\\"{item.id}\\"             role=\\"option\\"             aria-labelledby=\\"checkbox-{item.id}\\"             aria-selected=\\"{item.checked}\\"             active=\\"{item.checked}\\"             highlighted=\\"{highlightedIndex === i}\\"             disabled=\\"{item.disabled}\\"             on:click=\\"{(e) => {               if (item.disabled) {                 e.stopPropagation();                 return;               }               sortedItems = sortedItems.map((_) =>                 _.id === item.id ? { ..._, checked: !_.checked } : _               );               fieldRef.focus();             }}\\"             on:mouseenter=\\"{() => {               if (item.disabled) return;               highlightedIndex = i;             }}\\"           >',
    ctx
  });
  return block;
}
function create_each_block11(key_1, ctx) {
  let first;
  let listboxmenuitem;
  let current;
  function click_handler_3(...args) {
    return ctx[64](ctx[73], ...args);
  }
  function mouseenter_handler() {
    return ctx[65](ctx[73], ctx[75]);
  }
  listboxmenuitem = new ListBoxMenuItem_default({
    props: {
      id: ctx[73].id,
      role: "option",
      "aria-labelledby": "checkbox-" + ctx[73].id,
      "aria-selected": ctx[73].checked,
      active: ctx[73].checked,
      highlighted: ctx[28] === ctx[75],
      disabled: ctx[73].disabled,
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxmenuitem.$on("click", click_handler_3);
  listboxmenuitem.$on("mouseenter", mouseenter_handler);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(listboxmenuitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(listboxmenuitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const listboxmenuitem_changes = {};
      if (dirty[0] & 1610616832)
        listboxmenuitem_changes.id = ctx[73].id;
      if (dirty[0] & 1610616832)
        listboxmenuitem_changes["aria-labelledby"] = "checkbox-" + ctx[73].id;
      if (dirty[0] & 1610616832)
        listboxmenuitem_changes["aria-selected"] = ctx[73].checked;
      if (dirty[0] & 1610616832)
        listboxmenuitem_changes.active = ctx[73].checked;
      if (dirty[0] & 1879052288)
        listboxmenuitem_changes.highlighted = ctx[28] === ctx[75];
      if (dirty[0] & 1610616832)
        listboxmenuitem_changes.disabled = ctx[73].disabled;
      if (dirty[0] & 1610879362 | dirty[2] & 32) {
        listboxmenuitem_changes.$$scope = { dirty, ctx };
      }
      listboxmenuitem.$set(listboxmenuitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listboxmenuitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listboxmenuitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(listboxmenuitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(489:8) {#each filterable ? filteredItems : sortedItems as item, i (item.id)}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[12] ? ctx[30] : ctx[29];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[73].id;
  validate_each_keys(ctx, each_value, get_each_context11, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context11(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block11(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1879314834 | dirty[2] & 32) {
        each_value = ctx2[12] ? ctx2[30] : ctx2[29];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context11, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block11, each_1_anchor, get_each_context11);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(484:6) <ListBoxMenu         aria-label=\\"{ariaLabel}\\"         id=\\"{id}\\"         aria-multiselectable=\\"true\\"       >',
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let t0;
  let t1;
  let listboxfield;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[19] && create_if_block_82(ctx);
  let if_block1 = !ctx[19] && ctx[21] && create_if_block_72(ctx);
  listboxfield = new ListBoxField_default({
    props: {
      role: "button",
      tabindex: "0",
      "aria-expanded": ctx[1],
      id: ctx[26],
      disabled: ctx[11],
      translateWithId: ctx[15],
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  listboxfield.$on("click", ctx[59]);
  listboxfield.$on("keydown", ctx[60]);
  listboxfield.$on("focus", ctx[61]);
  listboxfield.$on("blur", ctx[62]);
  let if_block2 = ctx[1] && create_if_block_121(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(listboxfield.$$.fragment);
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(listboxfield, target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[19]) {
        if (if_block0) {
          if (dirty[0] & 524288) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_82(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[19] && ctx2[21]) {
        if (if_block1) {
          if (dirty[0] & 2621440) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_72(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const listboxfield_changes = {};
      if (dirty[0] & 2)
        listboxfield_changes["aria-expanded"] = ctx2[1];
      if (dirty[0] & 67108864)
        listboxfield_changes.id = ctx2[26];
      if (dirty[0] & 2048)
        listboxfield_changes.disabled = ctx2[11];
      if (dirty[0] & 32768)
        listboxfield_changes.translateWithId = ctx2[15];
      if (dirty[0] & 755628119 | dirty[1] & 73 | dirty[2] & 32) {
        listboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listboxfield.$set(listboxfield_changes);
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_121(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(listboxfield.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(listboxfield.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(listboxfield, detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: `(306:2) <ListBox     role=\\"{undefined}\\"     disabled=\\"{disabled}\\"     invalid=\\"{invalid}\\"     invalidText=\\"{invalidText}\\"     open=\\"{open}\\"     light=\\"{light}\\"     size=\\"{size}\\"     warn=\\"{warn}\\"     warnText=\\"{warnText}\\"     class=\\"bx--multi-select {direction === 'top' &&       'bx--list-box--up'} {filterable && 'bx--combo-box'}       {filterable && 'bx--multi-select--filterable'}       {invalid && 'bx--multi-select--invalid'}       {inline && 'bx--multi-select--inline'}       {checked.length > 0 && 'bx--multi-select--selected'}\\"   >`,
    ctx
  });
  return block;
}
function create_if_block58(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[23]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[11]);
      add_location(div, file94, 535, 4, 15094);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8388608)
        set_data_dev(t, ctx2[23]);
      if (dirty[0] & 2048) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[11]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block58.name,
    type: "if",
    source: "(535:2) {#if !inline && !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_fragment101(ctx) {
  let div;
  let t0;
  let listbox;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[17] && create_if_block_92(ctx);
  listbox = new ListBox_default({
    props: {
      role: void 0,
      disabled: ctx[11],
      invalid: ctx[19],
      invalidText: ctx[20],
      open: ctx[1],
      light: ctx[13],
      size: ctx[9],
      warn: ctx[21],
      warnText: ctx[22],
      class: "bx--multi-select " + (ctx[10] === "top" && "bx--list-box--up") + " " + (ctx[12] && "bx--combo-box") + "\n      " + (ctx[12] && "bx--multi-select--filterable") + "\n      " + (ctx[19] && "bx--multi-select--invalid") + "\n      " + (ctx[33] && "bx--multi-select--inline") + "\n      " + (ctx[31].length > 0 && "bx--multi-select--selected"),
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block1 = !ctx[33] && !ctx[19] && !ctx[21] && ctx[23] && create_if_block58(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(listbox.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div, "bx--multi-select__wrapper", true);
      toggle_class(div, "bx--list-box__wrapper", true);
      toggle_class(div, "bx--multi-select__wrapper--inline", ctx[33]);
      toggle_class(div, "bx--list-box__wrapper--inline", ctx[33]);
      toggle_class(div, "bx--multi-select__wrapper--inline--invalid", ctx[33] && ctx[19]);
      add_location(div, file94, 287, 0, 7592);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      mount_component(listbox, div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      ctx[66](div);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "click", ctx[51], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[17]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_92(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      const listbox_changes = {};
      if (dirty[0] & 2048)
        listbox_changes.disabled = ctx2[11];
      if (dirty[0] & 524288)
        listbox_changes.invalid = ctx2[19];
      if (dirty[0] & 1048576)
        listbox_changes.invalidText = ctx2[20];
      if (dirty[0] & 2)
        listbox_changes.open = ctx2[1];
      if (dirty[0] & 8192)
        listbox_changes.light = ctx2[13];
      if (dirty[0] & 512)
        listbox_changes.size = ctx2[9];
      if (dirty[0] & 2097152)
        listbox_changes.warn = ctx2[21];
      if (dirty[0] & 4194304)
        listbox_changes.warnText = ctx2[22];
      if (dirty[0] & 529408 | dirty[1] & 5)
        listbox_changes.class = "bx--multi-select " + (ctx2[10] === "top" && "bx--list-box--up") + " " + (ctx2[12] && "bx--combo-box") + "\n      " + (ctx2[12] && "bx--multi-select--filterable") + "\n      " + (ctx2[19] && "bx--multi-select--invalid") + "\n      " + (ctx2[33] && "bx--multi-select--inline") + "\n      " + (ctx2[31].length > 0 && "bx--multi-select--selected");
      if (dirty[0] & 2100165111 | dirty[1] & 75 | dirty[2] & 32) {
        listbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listbox.$set(listbox_changes);
      if (!ctx2[33] && !ctx2[19] && !ctx2[21] && ctx2[23]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block58(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[1] & 4) {
        toggle_class(div, "bx--multi-select__wrapper--inline", ctx2[33]);
      }
      if (!current || dirty[1] & 4) {
        toggle_class(div, "bx--list-box__wrapper--inline", ctx2[33]);
      }
      if (!current || dirty[0] & 524288 | dirty[1] & 4) {
        toggle_class(div, "bx--multi-select__wrapper--inline--invalid", ctx2[33] && ctx2[19]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      destroy_component(listbox);
      if (if_block1)
        if_block1.d();
      ctx[66](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let menuId;
  let inline;
  let ariaLabel;
  let sortedItems;
  let checked;
  let unchecked;
  let filteredItems;
  const omit_props_names = [
    "items",
    "itemToString",
    "itemToInput",
    "selectedIds",
    "value",
    "size",
    "type",
    "direction",
    "selectionFeedback",
    "disabled",
    "filterable",
    "filterItem",
    "open",
    "light",
    "locale",
    "placeholder",
    "sortItem",
    "translateWithId",
    "translateWithIdSelection",
    "titleText",
    "useTitleInItem",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "id",
    "name",
    "inputRef",
    "multiSelectRef",
    "fieldRef",
    "selectionRef",
    "highlightedId"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MultiSelect", slots, ["default"]);
  let { items = [] } = $$props;
  let { itemToString = (item) => item.text || item.id } = $$props;
  let { itemToInput = (item) => {
  } } = $$props;
  let { selectedIds = [] } = $$props;
  let { value = "" } = $$props;
  let { size = void 0 } = $$props;
  let { type = "default" } = $$props;
  let { direction = "bottom" } = $$props;
  let { selectionFeedback = "top-after-reopen" } = $$props;
  let { disabled = false } = $$props;
  let { filterable = false } = $$props;
  let { filterItem = (item, value2) => item.text.toLowerCase().includes(value2.trim().toLowerCase()) } = $$props;
  let { open = false } = $$props;
  let { light = false } = $$props;
  let { locale = "en" } = $$props;
  let { placeholder = "" } = $$props;
  let { sortItem = (a, b) => a.text.localeCompare(b.text, locale, { numeric: true }) } = $$props;
  let { translateWithId = void 0 } = $$props;
  let { translateWithIdSelection = void 0 } = $$props;
  let { titleText = "" } = $$props;
  let { useTitleInItem = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { inputRef = null } = $$props;
  let { multiSelectRef = null } = $$props;
  let { fieldRef = null } = $$props;
  let { selectionRef = null } = $$props;
  let { highlightedId = null } = $$props;
  const dispatch = createEventDispatcher();
  let initialSorted = false;
  let highlightedIndex = -1;
  let prevChecked = [];
  setContext("MultiSelect", {
    declareRef: ({ key, ref }) => {
      switch (key) {
        case "field":
          $$invalidate(4, fieldRef = ref);
          break;
        case "selection":
          $$invalidate(5, selectionRef = ref);
          break;
      }
    }
  });
  function change(direction2) {
    let index = highlightedIndex + direction2;
    const length = filterable ? filteredItems.length : items.length;
    if (length === 0)
      return;
    if (index < 0) {
      index = length - 1;
    } else if (index >= length) {
      index = 0;
    }
    let disabled2 = items[index].disabled;
    while (disabled2) {
      index = index + direction2;
      if (index < 0) {
        index = items.length - 1;
      } else if (index >= items.length) {
        index = 0;
      }
      disabled2 = items[index].disabled;
    }
    $$invalidate(28, highlightedIndex = index);
  }
  function sort() {
    return [
      ...checked.length > 1 ? checked.sort(sortItem) : checked,
      ...unchecked.sort(sortItem)
    ];
  }
  afterUpdate(() => {
    if (checked.length !== prevChecked.length) {
      if (selectionFeedback === "top") {
        $$invalidate(29, sortedItems = sort());
      }
      prevChecked = checked;
      $$invalidate(39, selectedIds = checked.map(({ id: id2 }) => id2));
      dispatch("select", {
        selectedIds,
        selected: checked,
        unselected: unchecked
      });
    }
    if (!open) {
      if (!initialSorted || selectionFeedback !== "fixed") {
        $$invalidate(29, sortedItems = sort());
        initialSorted = true;
      }
      $$invalidate(28, highlightedIndex = -1);
      $$invalidate(0, value = "");
    }
    $$invalidate(38, items = sortedItems);
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler = ({ target }) => {
    if (open && multiSelectRef && !multiSelectRef.contains(target)) {
      $$invalidate(1, open = false);
    }
  };
  function clear_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const clear_handler_1 = () => {
    $$invalidate(29, sortedItems = sortedItems.map((item) => ({ ...item, checked: false })));
    if (fieldRef)
      fieldRef.blur();
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputRef = $$value;
      $$invalidate(2, inputRef);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === "Enter") {
      if (highlightedId) {
        const filteredItemIndex = sortedItems.findIndex((item) => item.id === highlightedId);
        $$invalidate(29, sortedItems = sortedItems.map((item, i) => {
          if (i !== filteredItemIndex)
            return item;
          return { ...item, checked: !item.checked };
        }));
      }
    } else if (key === "Tab") {
      $$invalidate(1, open = false);
      inputRef.blur();
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Escape") {
      $$invalidate(1, open = false);
    } else if (key === " ") {
      if (!open)
        $$invalidate(1, open = true);
    }
  };
  const clear_handler_2 = () => {
    $$invalidate(0, value = "");
    $$invalidate(1, open = false);
  };
  const click_handler_13 = (e) => {
    e.stopPropagation();
    $$invalidate(1, open = !open);
  };
  const click_handler_2 = () => {
    if (disabled)
      return;
    if (filterable) {
      $$invalidate(1, open = true);
      inputRef.focus();
    } else {
      $$invalidate(1, open = !open);
    }
  };
  const keydown_handler_2 = (e) => {
    if (filterable) {
      return;
    }
    const key = e.key;
    if ([" ", "ArrowUp", "ArrowDown"].includes(key)) {
      e.preventDefault();
    }
    if (key === " ") {
      $$invalidate(1, open = !open);
    } else if (key === "Tab") {
      if (selectionRef && checked.length > 0) {
        selectionRef.focus();
      } else {
        $$invalidate(1, open = false);
        fieldRef.blur();
      }
    } else if (key === "ArrowDown") {
      change(1);
    } else if (key === "ArrowUp") {
      change(-1);
    } else if (key === "Enter") {
      if (highlightedIndex > -1) {
        $$invalidate(29, sortedItems = sortedItems.map((item, i) => {
          if (i !== highlightedIndex)
            return item;
          return { ...item, checked: !item.checked };
        }));
      }
    } else if (key === "Escape") {
      $$invalidate(1, open = false);
    }
  };
  const focus_handler_1 = () => {
    if (filterable) {
      $$invalidate(1, open = true);
      if (inputRef)
        inputRef.focus();
    }
  };
  const blur_handler_1 = (e) => {
    if (!filterable)
      dispatch("blur", e);
  };
  const blur_handler_2 = (i) => {
    if (i === filteredItems.length - 1)
      $$invalidate(1, open = false);
  };
  const click_handler_3 = (item, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    $$invalidate(29, sortedItems = sortedItems.map((_) => _.id === item.id ? { ..._, checked: !_.checked } : _));
    fieldRef.focus();
  };
  const mouseenter_handler = (item, i) => {
    if (item.disabled)
      return;
    $$invalidate(28, highlightedIndex = i);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      multiSelectRef = $$value;
      $$invalidate(3, multiSelectRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(72, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(37, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props)
      $$invalidate(38, items = $$new_props.items);
    if ("itemToString" in $$new_props)
      $$invalidate(7, itemToString = $$new_props.itemToString);
    if ("itemToInput" in $$new_props)
      $$invalidate(8, itemToInput = $$new_props.itemToInput);
    if ("selectedIds" in $$new_props)
      $$invalidate(39, selectedIds = $$new_props.selectedIds);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("size" in $$new_props)
      $$invalidate(9, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(40, type = $$new_props.type);
    if ("direction" in $$new_props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("selectionFeedback" in $$new_props)
      $$invalidate(41, selectionFeedback = $$new_props.selectionFeedback);
    if ("disabled" in $$new_props)
      $$invalidate(11, disabled = $$new_props.disabled);
    if ("filterable" in $$new_props)
      $$invalidate(12, filterable = $$new_props.filterable);
    if ("filterItem" in $$new_props)
      $$invalidate(42, filterItem = $$new_props.filterItem);
    if ("open" in $$new_props)
      $$invalidate(1, open = $$new_props.open);
    if ("light" in $$new_props)
      $$invalidate(13, light = $$new_props.light);
    if ("locale" in $$new_props)
      $$invalidate(43, locale = $$new_props.locale);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("sortItem" in $$new_props)
      $$invalidate(44, sortItem = $$new_props.sortItem);
    if ("translateWithId" in $$new_props)
      $$invalidate(15, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$new_props)
      $$invalidate(16, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("titleText" in $$new_props)
      $$invalidate(17, titleText = $$new_props.titleText);
    if ("useTitleInItem" in $$new_props)
      $$invalidate(18, useTitleInItem = $$new_props.useTitleInItem);
    if ("invalid" in $$new_props)
      $$invalidate(19, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(20, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(21, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(22, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props)
      $$invalidate(23, helperText = $$new_props.helperText);
    if ("label" in $$new_props)
      $$invalidate(24, label = $$new_props.label);
    if ("hideLabel" in $$new_props)
      $$invalidate(25, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props)
      $$invalidate(26, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(27, name = $$new_props.name);
    if ("inputRef" in $$new_props)
      $$invalidate(2, inputRef = $$new_props.inputRef);
    if ("multiSelectRef" in $$new_props)
      $$invalidate(3, multiSelectRef = $$new_props.multiSelectRef);
    if ("fieldRef" in $$new_props)
      $$invalidate(4, fieldRef = $$new_props.fieldRef);
    if ("selectionRef" in $$new_props)
      $$invalidate(5, selectionRef = $$new_props.selectionRef);
    if ("highlightedId" in $$new_props)
      $$invalidate(6, highlightedId = $$new_props.highlightedId);
    if ("$$scope" in $$new_props)
      $$invalidate(67, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    items,
    itemToString,
    itemToInput,
    selectedIds,
    value,
    size,
    type,
    direction,
    selectionFeedback,
    disabled,
    filterable,
    filterItem,
    open,
    light,
    locale,
    placeholder,
    sortItem,
    translateWithId,
    translateWithIdSelection,
    titleText,
    useTitleInItem,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    inputRef,
    multiSelectRef,
    fieldRef,
    selectionRef,
    highlightedId,
    afterUpdate,
    createEventDispatcher,
    setContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    Checkbox: Checkbox_default,
    ListBox: ListBox_default,
    ListBoxField: ListBoxField_default,
    ListBoxMenu: ListBoxMenu_default,
    ListBoxMenuIcon: ListBoxMenuIcon_default,
    ListBoxMenuItem: ListBoxMenuItem_default,
    ListBoxSelection: ListBoxSelection_default,
    dispatch,
    initialSorted,
    highlightedIndex,
    prevChecked,
    change,
    sort,
    sortedItems,
    filteredItems,
    unchecked,
    checked,
    ariaLabel,
    inline,
    menuId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(72, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props)
      $$invalidate(38, items = $$new_props.items);
    if ("itemToString" in $$props)
      $$invalidate(7, itemToString = $$new_props.itemToString);
    if ("itemToInput" in $$props)
      $$invalidate(8, itemToInput = $$new_props.itemToInput);
    if ("selectedIds" in $$props)
      $$invalidate(39, selectedIds = $$new_props.selectedIds);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("size" in $$props)
      $$invalidate(9, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(40, type = $$new_props.type);
    if ("direction" in $$props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("selectionFeedback" in $$props)
      $$invalidate(41, selectionFeedback = $$new_props.selectionFeedback);
    if ("disabled" in $$props)
      $$invalidate(11, disabled = $$new_props.disabled);
    if ("filterable" in $$props)
      $$invalidate(12, filterable = $$new_props.filterable);
    if ("filterItem" in $$props)
      $$invalidate(42, filterItem = $$new_props.filterItem);
    if ("open" in $$props)
      $$invalidate(1, open = $$new_props.open);
    if ("light" in $$props)
      $$invalidate(13, light = $$new_props.light);
    if ("locale" in $$props)
      $$invalidate(43, locale = $$new_props.locale);
    if ("placeholder" in $$props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("sortItem" in $$props)
      $$invalidate(44, sortItem = $$new_props.sortItem);
    if ("translateWithId" in $$props)
      $$invalidate(15, translateWithId = $$new_props.translateWithId);
    if ("translateWithIdSelection" in $$props)
      $$invalidate(16, translateWithIdSelection = $$new_props.translateWithIdSelection);
    if ("titleText" in $$props)
      $$invalidate(17, titleText = $$new_props.titleText);
    if ("useTitleInItem" in $$props)
      $$invalidate(18, useTitleInItem = $$new_props.useTitleInItem);
    if ("invalid" in $$props)
      $$invalidate(19, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(20, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(21, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(22, warnText = $$new_props.warnText);
    if ("helperText" in $$props)
      $$invalidate(23, helperText = $$new_props.helperText);
    if ("label" in $$props)
      $$invalidate(24, label = $$new_props.label);
    if ("hideLabel" in $$props)
      $$invalidate(25, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props)
      $$invalidate(26, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(27, name = $$new_props.name);
    if ("inputRef" in $$props)
      $$invalidate(2, inputRef = $$new_props.inputRef);
    if ("multiSelectRef" in $$props)
      $$invalidate(3, multiSelectRef = $$new_props.multiSelectRef);
    if ("fieldRef" in $$props)
      $$invalidate(4, fieldRef = $$new_props.fieldRef);
    if ("selectionRef" in $$props)
      $$invalidate(5, selectionRef = $$new_props.selectionRef);
    if ("highlightedId" in $$props)
      $$invalidate(6, highlightedId = $$new_props.highlightedId);
    if ("initialSorted" in $$props)
      initialSorted = $$new_props.initialSorted;
    if ("highlightedIndex" in $$props)
      $$invalidate(28, highlightedIndex = $$new_props.highlightedIndex);
    if ("prevChecked" in $$props)
      prevChecked = $$new_props.prevChecked;
    if ("sortedItems" in $$props)
      $$invalidate(29, sortedItems = $$new_props.sortedItems);
    if ("filteredItems" in $$props)
      $$invalidate(30, filteredItems = $$new_props.filteredItems);
    if ("unchecked" in $$props)
      unchecked = $$new_props.unchecked;
    if ("checked" in $$props)
      $$invalidate(31, checked = $$new_props.checked);
    if ("ariaLabel" in $$props)
      $$invalidate(32, ariaLabel = $$new_props.ariaLabel);
    if ("inline" in $$props)
      $$invalidate(33, inline = $$new_props.inline);
    if ("menuId" in $$props)
      $$invalidate(34, menuId = $$new_props.menuId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty[0] & 67108864) {
      $:
        $$invalidate(34, menuId = `menu-${id}`);
    }
    if ($$self.$$.dirty[1] & 512) {
      $:
        $$invalidate(33, inline = type === "inline");
    }
    $:
      $$invalidate(32, ariaLabel = $$props["aria-label"] || "Choose an item");
    if ($$self.$$.dirty[1] & 384) {
      $:
        $$invalidate(29, sortedItems = items.map((item) => ({
          ...item,
          checked: selectedIds.includes(item.id)
        })));
    }
    if ($$self.$$.dirty[0] & 536870912) {
      $:
        $$invalidate(31, checked = sortedItems.filter(({ checked: checked2 }) => checked2));
    }
    if ($$self.$$.dirty[0] & 536870912) {
      $:
        unchecked = sortedItems.filter(({ checked: checked2 }) => !checked2);
    }
    if ($$self.$$.dirty[0] & 536870913 | $$self.$$.dirty[1] & 2048) {
      $:
        $$invalidate(30, filteredItems = sortedItems.filter((item) => filterItem(item, value)));
    }
    if ($$self.$$.dirty[0] & 1879052288) {
      $:
        $$invalidate(6, highlightedId = highlightedIndex > -1 ? (_b = (_a = (filterable ? filteredItems : sortedItems)[highlightedIndex]) == null ? void 0 : _a.id) != null ? _b : null : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    open,
    inputRef,
    multiSelectRef,
    fieldRef,
    selectionRef,
    highlightedId,
    itemToString,
    itemToInput,
    size,
    direction,
    disabled,
    filterable,
    light,
    placeholder,
    translateWithId,
    translateWithIdSelection,
    titleText,
    useTitleInItem,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    highlightedIndex,
    sortedItems,
    filteredItems,
    checked,
    ariaLabel,
    inline,
    menuId,
    dispatch,
    change,
    $$restProps,
    items,
    selectedIds,
    type,
    selectionFeedback,
    filterItem,
    locale,
    sortItem,
    slots,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    click_handler,
    clear_handler,
    clear_handler_1,
    input_binding,
    input_input_handler,
    keydown_handler_12,
    clear_handler_2,
    click_handler_13,
    click_handler_2,
    keydown_handler_2,
    focus_handler_1,
    blur_handler_1,
    blur_handler_2,
    click_handler_3,
    mouseenter_handler,
    div_binding,
    $$scope
  ];
}
var MultiSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance101,
      create_fragment101,
      safe_not_equal,
      {
        items: 38,
        itemToString: 7,
        itemToInput: 8,
        selectedIds: 39,
        value: 0,
        size: 9,
        type: 40,
        direction: 10,
        selectionFeedback: 41,
        disabled: 11,
        filterable: 12,
        filterItem: 42,
        open: 1,
        light: 13,
        locale: 43,
        placeholder: 14,
        sortItem: 44,
        translateWithId: 15,
        translateWithIdSelection: 16,
        titleText: 17,
        useTitleInItem: 18,
        invalid: 19,
        invalidText: 20,
        warn: 21,
        warnText: 22,
        helperText: 23,
        label: 24,
        hideLabel: 25,
        id: 26,
        name: 27,
        inputRef: 2,
        multiSelectRef: 3,
        fieldRef: 4,
        selectionRef: 5,
        highlightedId: 6
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MultiSelect",
      options,
      id: create_fragment101.name
    });
  }
  get items() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToString() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToString(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemToInput() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemToInput(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIds() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionFeedback() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionFeedback(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterable() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterable(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithIdSelection() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithIdSelection(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useTitleInItem() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useTitleInItem(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiSelectRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiSelectRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fieldRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fieldRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectionRef() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectionRef(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightedId() {
    throw new Error("<MultiSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightedId(value) {
    throw new Error("<MultiSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MultiSelect_default = MultiSelect;

// node_modules/carbon-components-svelte/src/Modal/Modal.svelte
var file95 = "node_modules/carbon-components-svelte/src/Modal/Modal.svelte";
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  return child_ctx;
}
var get_heading_slot_changes = (dirty) => ({});
var get_heading_slot_context = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block_66(ctx) {
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon",
      "aria-hidden": "true"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(close.$$.fragment);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", ctx[8]);
      toggle_class(button, "bx--modal-close", true);
      add_location(button, file95, 211, 8, 5859);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      mount_component(close, button, null);
      ctx[37](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[38], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 256) {
        attr_dev(button, "aria-label", ctx2[8]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(close);
      ctx[37](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_66.name,
    type: "if",
    source: "(211:6) {#if passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_57(ctx) {
  let h2;
  let current;
  const label_slot_template = ctx[31].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[50], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block_16(ctx);
  const block = {
    c: function create() {
      h2 = element("h2");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr_dev(h2, "id", ctx[25]);
      toggle_class(h2, "bx--modal-header__label", true);
      add_location(h2, file95, 224, 8, 6228);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & 524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[50],
            !current ? get_all_dirty_from_scope(ctx2[50]) : get_slot_changes(label_slot_template, ctx2[50], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & 128)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 33554432) {
        attr_dev(h2, "id", ctx2[25]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_57.name,
    type: "if",
    source: "(224:6) {#if modalLabel}",
    ctx
  });
  return block;
}
function fallback_block_16(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[7]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 128)
        set_data_dev(t, ctx2[7]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_16.name,
    type: "fallback",
    source: "(226:29) {modalLabel}",
    ctx
  });
  return block;
}
function fallback_block19(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[6]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block19.name,
    type: "fallback",
    source: "(230:29) {modalHeading}",
    ctx
  });
  return block;
}
function create_if_block_49(ctx) {
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  close = new Close_default({
    props: {
      size: 20,
      class: "bx--modal-close__icon",
      "aria-hidden": "true"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      button = element("button");
      create_component(close.$$.fragment);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-label", ctx[8]);
      toggle_class(button, "bx--modal-close", true);
      add_location(button, file95, 232, 8, 6538);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      mount_component(close, button, null);
      ctx[39](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[40], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 256) {
        attr_dev(button, "aria-label", ctx2[8]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(close);
      ctx[39](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_49.name,
    type: "if",
    source: "(232:6) {#if !passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_311(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      toggle_class(div, "bx--modal-content--overflow-indicator", true);
      add_location(div, file95, 259, 6, 7450);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_311.name,
    type: "if",
    source: "(259:4) {#if hasScrollingContent}",
    ctx
  });
  return block;
}
function create_if_block59(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let button;
  let current;
  const if_block_creators = [create_if_block_123, create_if_block_216];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[16].length > 0)
      return 0;
    if (ctx2[15])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  button = new Button_default({
    props: {
      kind: ctx[3] ? "danger" : "primary",
      disabled: ctx[12],
      icon: ctx[13],
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[43]);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(button.$$.fragment);
      toggle_class(div, "bx--modal-footer", true);
      toggle_class(div, "bx--modal-footer--three-button", ctx[16].length === 2);
      add_location(div, file95, 262, 6, 7555);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_dev(div, t);
      mount_component(button, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, t);
        } else {
          if_block = null;
        }
      }
      const button_changes = {};
      if (dirty[0] & 8)
        button_changes.kind = ctx2[3] ? "danger" : "primary";
      if (dirty[0] & 4096)
        button_changes.disabled = ctx2[12];
      if (dirty[0] & 8192)
        button_changes.icon = ctx2[13];
      if (dirty[0] & 2048 | dirty[1] & 524288) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (!current || dirty[0] & 65536) {
        toggle_class(div, "bx--modal-footer--three-button", ctx2[16].length === 2);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block59.name,
    type: "if",
    source: "(262:4) {#if !passiveModal}",
    ctx
  });
  return block;
}
function create_if_block_216(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[42]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & 32768 | dirty[1] & 524288) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_216.name,
    type: "if",
    source: "(278:38) ",
    ctx
  });
  return block;
}
function create_if_block_123(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[16];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 67174400) {
        each_value = ctx2[16];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(267:8) {#if secondaryButtons.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[15]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data_dev(t, ctx2[15]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: `(279:10) <Button             kind=\\"secondary\\"             on:click=\\"{() => {               dispatch('click:button--secondary', {                 text: secondaryButtonText,               });             }}\\"           >`,
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t0_value = ctx[55].text + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536 && t0_value !== (t0_value = ctx2[55].text + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: `(269:12) <Button               kind=\\"secondary\\"               on:click=\\"{() => {                 dispatch('click:button--secondary', { text: button.text });               }}\\"             >`,
    ctx
  });
  return block;
}
function create_each_block12(ctx) {
  let button;
  let current;
  function click_handler_3() {
    return ctx[41](ctx[55]);
  }
  button = new Button_default({
    props: {
      kind: "secondary",
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", click_handler_3);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & 65536 | dirty[1] & 524288) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block12.name,
    type: "each",
    source: "(268:10) {#each secondaryButtons as button}",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[11]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: `(290:8) <Button           kind=\\"{danger ? 'danger' : 'primary'}\\"           disabled=\\"{primaryButtonDisabled}\\"           icon=\\"{primaryButtonIcon}\\"           on:click=\\"{() => {             dispatch('submit');             dispatch('click:button--primary');           }}\\"         >`,
    ctx
  });
  return block;
}
function create_fragment102(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let t1;
  let h3;
  let t2;
  let t3;
  let div1;
  let div1_tabindex_value;
  let div1_role_value;
  let div1_aria_label_value;
  let div1_aria_labelledby_value;
  let t4;
  let t5;
  let div2_role_value;
  let div2_aria_describedby_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_66(ctx);
  let if_block1 = ctx[7] && create_if_block_57(ctx);
  const heading_slot_template = ctx[31].heading;
  const heading_slot = create_slot(heading_slot_template, ctx, ctx[50], get_heading_slot_context);
  const heading_slot_or_fallback = heading_slot || fallback_block19(ctx);
  let if_block2 = !ctx[5] && create_if_block_49(ctx);
  const default_slot_template = ctx[31].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[50], null);
  let if_block3 = ctx[10] && create_if_block_311(ctx);
  let if_block4 = !ctx[5] && create_if_block59(ctx);
  let div3_levels = [{ role: "presentation" }, { id: ctx[18] }, ctx[28]];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      h3 = element("h3");
      if (heading_slot_or_fallback)
        heading_slot_or_fallback.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      attr_dev(h3, "id", ctx[24]);
      toggle_class(h3, "bx--modal-header__heading", true);
      add_location(h3, file95, 228, 6, 6373);
      toggle_class(div0, "bx--modal-header", true);
      add_location(div0, file95, 209, 4, 5788);
      attr_dev(div1, "id", ctx[23]);
      attr_dev(div1, "tabindex", div1_tabindex_value = ctx[10] ? "0" : void 0);
      attr_dev(div1, "role", div1_role_value = ctx[10] ? "region" : void 0);
      attr_dev(div1, "aria-label", div1_aria_label_value = ctx[10] ? ctx[22] : void 0);
      attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = ctx[7] ? ctx[25] : ctx[24]);
      toggle_class(div1, "bx--modal-content", true);
      toggle_class(div1, "bx--modal-content--with-form", ctx[9]);
      toggle_class(div1, "bx--modal-scroll-content", ctx[10]);
      add_location(div1, file95, 246, 4, 6950);
      attr_dev(div2, "tabindex", "-1");
      attr_dev(div2, "role", div2_role_value = ctx[4] ? ctx[5] ? "alert" : "alertdialog" : "dialog");
      attr_dev(div2, "aria-describedby", div2_aria_describedby_value = ctx[4] && !ctx[5] ? ctx[23] : void 0);
      attr_dev(div2, "aria-modal", "true");
      attr_dev(div2, "aria-label", ctx[22]);
      toggle_class(div2, "bx--modal-container", true);
      toggle_class(div2, "bx--modal-container--xs", ctx[2] === "xs");
      toggle_class(div2, "bx--modal-container--sm", ctx[2] === "sm");
      toggle_class(div2, "bx--modal-container--lg", ctx[2] === "lg");
      add_location(div2, file95, 194, 2, 5271);
      set_attributes(div3, div3_data);
      toggle_class(div3, "bx--modal", true);
      toggle_class(div3, "bx--modal-tall", !ctx[5]);
      toggle_class(div3, "is-visible", ctx[0]);
      toggle_class(div3, "bx--modal--danger", ctx[3]);
      add_location(div3, file95, 135, 0, 3559);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div2);
      append_dev(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t1);
      append_dev(div0, h3);
      if (heading_slot_or_fallback) {
        heading_slot_or_fallback.m(h3, null);
      }
      append_dev(div0, t2);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div2, t3);
      append_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div2, t4);
      if (if_block3)
        if_block3.m(div2, null);
      append_dev(div2, t5);
      if (if_block4)
        if_block4.m(div2, null);
      ctx[44](div2);
      ctx[46](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "click", ctx[45], false, false, false),
          listen_dev(div3, "keydown", ctx[32], false, false, false),
          listen_dev(div3, "keydown", ctx[47], false, false, false),
          listen_dev(div3, "click", ctx[33], false, false, false),
          listen_dev(div3, "click", ctx[48], false, false, false),
          listen_dev(div3, "mouseover", ctx[34], false, false, false),
          listen_dev(div3, "mouseenter", ctx[35], false, false, false),
          listen_dev(div3, "mouseleave", ctx[36], false, false, false),
          listen_dev(div3, "transitionend", ctx[49], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_66(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_57(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (heading_slot) {
        if (heading_slot.p && (!current || dirty[1] & 524288)) {
          update_slot_base(
            heading_slot,
            heading_slot_template,
            ctx2,
            ctx2[50],
            !current ? get_all_dirty_from_scope(ctx2[50]) : get_slot_changes(heading_slot_template, ctx2[50], dirty, get_heading_slot_changes),
            get_heading_slot_context
          );
        }
      } else {
        if (heading_slot_or_fallback && heading_slot_or_fallback.p && (!current || dirty[0] & 64)) {
          heading_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 16777216) {
        attr_dev(h3, "id", ctx2[24]);
      }
      if (!ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_49(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[50],
            !current ? get_all_dirty_from_scope(ctx2[50]) : get_slot_changes(default_slot_template, ctx2[50], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 8388608) {
        attr_dev(div1, "id", ctx2[23]);
      }
      if (!current || dirty[0] & 1024 && div1_tabindex_value !== (div1_tabindex_value = ctx2[10] ? "0" : void 0)) {
        attr_dev(div1, "tabindex", div1_tabindex_value);
      }
      if (!current || dirty[0] & 1024 && div1_role_value !== (div1_role_value = ctx2[10] ? "region" : void 0)) {
        attr_dev(div1, "role", div1_role_value);
      }
      if (!current || dirty[0] & 4195328 && div1_aria_label_value !== (div1_aria_label_value = ctx2[10] ? ctx2[22] : void 0)) {
        attr_dev(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty[0] & 50331776 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = ctx2[7] ? ctx2[25] : ctx2[24])) {
        attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div1, "bx--modal-content--with-form", ctx2[9]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div1, "bx--modal-scroll-content", ctx2[10]);
      }
      if (ctx2[10]) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block_311(ctx2);
          if_block3.c();
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block59(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 48 && div2_role_value !== (div2_role_value = ctx2[4] ? ctx2[5] ? "alert" : "alertdialog" : "dialog")) {
        attr_dev(div2, "role", div2_role_value);
      }
      if (!current || dirty[0] & 8388656 && div2_aria_describedby_value !== (div2_aria_describedby_value = ctx2[4] && !ctx2[5] ? ctx2[23] : void 0)) {
        attr_dev(div2, "aria-describedby", div2_aria_describedby_value);
      }
      if (!current || dirty[0] & 4194304) {
        attr_dev(div2, "aria-label", ctx2[22]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div2, "bx--modal-container--xs", ctx2[2] === "xs");
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div2, "bx--modal-container--sm", ctx2[2] === "sm");
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div2, "bx--modal-container--lg", ctx2[2] === "lg");
      }
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        { role: "presentation" },
        (!current || dirty[0] & 262144) && { id: ctx2[18] },
        dirty[0] & 268435456 && ctx2[28]
      ]));
      toggle_class(div3, "bx--modal", true);
      toggle_class(div3, "bx--modal-tall", !ctx2[5]);
      toggle_class(div3, "is-visible", ctx2[0]);
      toggle_class(div3, "bx--modal--danger", ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(heading_slot_or_fallback, local);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(heading_slot_or_fallback, local);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (heading_slot_or_fallback)
        heading_slot_or_fallback.d(detaching);
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      ctx[44](null);
      ctx[46](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let modalLabelId;
  let modalHeadingId;
  let modalBodyId;
  let ariaLabel;
  const omit_props_names = [
    "size",
    "open",
    "danger",
    "alert",
    "passiveModal",
    "modalHeading",
    "modalLabel",
    "modalAriaLabel",
    "iconDescription",
    "hasForm",
    "hasScrollingContent",
    "primaryButtonText",
    "primaryButtonDisabled",
    "primaryButtonIcon",
    "shouldSubmitOnEnter",
    "secondaryButtonText",
    "secondaryButtons",
    "selectorPrimaryFocus",
    "preventCloseOnClickOutside",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $openStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["label", "heading", "default"]);
  let { size = void 0 } = $$props;
  let { open = false } = $$props;
  let { danger = false } = $$props;
  let { alert = false } = $$props;
  let { passiveModal = false } = $$props;
  let { modalHeading = void 0 } = $$props;
  let { modalLabel = void 0 } = $$props;
  let { modalAriaLabel = void 0 } = $$props;
  let { iconDescription = "Close the modal" } = $$props;
  let { hasForm = false } = $$props;
  let { hasScrollingContent = false } = $$props;
  let { primaryButtonText = "" } = $$props;
  let { primaryButtonDisabled = false } = $$props;
  let { primaryButtonIcon = void 0 } = $$props;
  let { shouldSubmitOnEnter = true } = $$props;
  let { secondaryButtonText = "" } = $$props;
  let { secondaryButtons = [] } = $$props;
  let { selectorPrimaryFocus = "[data-modal-primary-focus]" } = $$props;
  let { preventCloseOnClickOutside = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let buttonRef = null;
  let innerModal = null;
  let opened = false;
  let didClickInnerModal = false;
  function focus(element2) {
    const node = (element2 || innerModal).querySelector(selectorPrimaryFocus) || buttonRef;
    node.focus();
  }
  const openStore = writable(open);
  validate_store(openStore, "openStore");
  component_subscribe($$self, openStore, (value) => $$invalidate(52, $openStore = value));
  trackModal(openStore);
  afterUpdate(() => {
    if (opened) {
      if (!open) {
        opened = false;
        dispatch("close");
      }
    } else if (open) {
      opened = true;
      focus();
      dispatch("open");
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(19, buttonRef);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, open = false);
  };
  function button_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonRef = $$value;
      $$invalidate(19, buttonRef);
    });
  }
  const click_handler_2 = () => {
    $$invalidate(0, open = false);
  };
  const click_handler_3 = (button) => {
    dispatch("click:button--secondary", { text: button.text });
  };
  const click_handler_4 = () => {
    dispatch("click:button--secondary", { text: secondaryButtonText });
  };
  const click_handler_5 = () => {
    dispatch("submit");
    dispatch("click:button--primary");
  };
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerModal = $$value;
      $$invalidate(20, innerModal);
    });
  }
  const click_handler_6 = () => {
    $$invalidate(21, didClickInnerModal = true);
  };
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (open) {
      if (e.key === "Escape") {
        $$invalidate(0, open = false);
      } else if (e.key === "Tab") {
        const selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
        const tabbable = Array.from(ref.querySelectorAll(selectorTabbable));
        let index = tabbable.indexOf(document.activeElement);
        if (index === -1 && e.shiftKey)
          index = 0;
        index += tabbable.length + (e.shiftKey ? -1 : 1);
        index %= tabbable.length;
        tabbable[index].focus();
        e.preventDefault();
      } else if (shouldSubmitOnEnter && e.key === "Enter" && !primaryButtonDisabled) {
        dispatch("submit");
        dispatch("click:button--primary");
      }
    }
  };
  const click_handler_7 = () => {
    if (!didClickInnerModal && !preventCloseOnClickOutside)
      $$invalidate(0, open = false);
    $$invalidate(21, didClickInnerModal = false);
  };
  const transitionend_handler = (e) => {
    if (e.propertyName === "transform") {
      dispatch("transitionend", { open });
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$new_props)
      $$invalidate(3, danger = $$new_props.danger);
    if ("alert" in $$new_props)
      $$invalidate(4, alert = $$new_props.alert);
    if ("passiveModal" in $$new_props)
      $$invalidate(5, passiveModal = $$new_props.passiveModal);
    if ("modalHeading" in $$new_props)
      $$invalidate(6, modalHeading = $$new_props.modalHeading);
    if ("modalLabel" in $$new_props)
      $$invalidate(7, modalLabel = $$new_props.modalLabel);
    if ("modalAriaLabel" in $$new_props)
      $$invalidate(29, modalAriaLabel = $$new_props.modalAriaLabel);
    if ("iconDescription" in $$new_props)
      $$invalidate(8, iconDescription = $$new_props.iconDescription);
    if ("hasForm" in $$new_props)
      $$invalidate(9, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$new_props)
      $$invalidate(10, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("primaryButtonText" in $$new_props)
      $$invalidate(11, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonDisabled" in $$new_props)
      $$invalidate(12, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryButtonIcon" in $$new_props)
      $$invalidate(13, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("shouldSubmitOnEnter" in $$new_props)
      $$invalidate(14, shouldSubmitOnEnter = $$new_props.shouldSubmitOnEnter);
    if ("secondaryButtonText" in $$new_props)
      $$invalidate(15, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$new_props)
      $$invalidate(16, secondaryButtons = $$new_props.secondaryButtons);
    if ("selectorPrimaryFocus" in $$new_props)
      $$invalidate(30, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("preventCloseOnClickOutside" in $$new_props)
      $$invalidate(17, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("id" in $$new_props)
      $$invalidate(18, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(50, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    open,
    danger,
    alert,
    passiveModal,
    modalHeading,
    modalLabel,
    modalAriaLabel,
    iconDescription,
    hasForm,
    hasScrollingContent,
    primaryButtonText,
    primaryButtonDisabled,
    primaryButtonIcon,
    shouldSubmitOnEnter,
    secondaryButtonText,
    secondaryButtons,
    selectorPrimaryFocus,
    preventCloseOnClickOutside,
    id,
    ref,
    createEventDispatcher,
    afterUpdate,
    Close: Close_default,
    Button: Button_default,
    trackModal,
    writable,
    dispatch,
    buttonRef,
    innerModal,
    opened,
    didClickInnerModal,
    focus,
    openStore,
    ariaLabel,
    modalBodyId,
    modalHeadingId,
    modalLabelId,
    $openStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("danger" in $$props)
      $$invalidate(3, danger = $$new_props.danger);
    if ("alert" in $$props)
      $$invalidate(4, alert = $$new_props.alert);
    if ("passiveModal" in $$props)
      $$invalidate(5, passiveModal = $$new_props.passiveModal);
    if ("modalHeading" in $$props)
      $$invalidate(6, modalHeading = $$new_props.modalHeading);
    if ("modalLabel" in $$props)
      $$invalidate(7, modalLabel = $$new_props.modalLabel);
    if ("modalAriaLabel" in $$props)
      $$invalidate(29, modalAriaLabel = $$new_props.modalAriaLabel);
    if ("iconDescription" in $$props)
      $$invalidate(8, iconDescription = $$new_props.iconDescription);
    if ("hasForm" in $$props)
      $$invalidate(9, hasForm = $$new_props.hasForm);
    if ("hasScrollingContent" in $$props)
      $$invalidate(10, hasScrollingContent = $$new_props.hasScrollingContent);
    if ("primaryButtonText" in $$props)
      $$invalidate(11, primaryButtonText = $$new_props.primaryButtonText);
    if ("primaryButtonDisabled" in $$props)
      $$invalidate(12, primaryButtonDisabled = $$new_props.primaryButtonDisabled);
    if ("primaryButtonIcon" in $$props)
      $$invalidate(13, primaryButtonIcon = $$new_props.primaryButtonIcon);
    if ("shouldSubmitOnEnter" in $$props)
      $$invalidate(14, shouldSubmitOnEnter = $$new_props.shouldSubmitOnEnter);
    if ("secondaryButtonText" in $$props)
      $$invalidate(15, secondaryButtonText = $$new_props.secondaryButtonText);
    if ("secondaryButtons" in $$props)
      $$invalidate(16, secondaryButtons = $$new_props.secondaryButtons);
    if ("selectorPrimaryFocus" in $$props)
      $$invalidate(30, selectorPrimaryFocus = $$new_props.selectorPrimaryFocus);
    if ("preventCloseOnClickOutside" in $$props)
      $$invalidate(17, preventCloseOnClickOutside = $$new_props.preventCloseOnClickOutside);
    if ("id" in $$props)
      $$invalidate(18, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("buttonRef" in $$props)
      $$invalidate(19, buttonRef = $$new_props.buttonRef);
    if ("innerModal" in $$props)
      $$invalidate(20, innerModal = $$new_props.innerModal);
    if ("opened" in $$props)
      opened = $$new_props.opened;
    if ("didClickInnerModal" in $$props)
      $$invalidate(21, didClickInnerModal = $$new_props.didClickInnerModal);
    if ("ariaLabel" in $$props)
      $$invalidate(22, ariaLabel = $$new_props.ariaLabel);
    if ("modalBodyId" in $$props)
      $$invalidate(23, modalBodyId = $$new_props.modalBodyId);
    if ("modalHeadingId" in $$props)
      $$invalidate(24, modalHeadingId = $$new_props.modalHeadingId);
    if ("modalLabelId" in $$props)
      $$invalidate(25, modalLabelId = $$new_props.modalLabelId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $:
        set_store_value(openStore, $openStore = open, $openStore);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        $$invalidate(25, modalLabelId = `bx--modal-header__label--modal-${id}`);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        $$invalidate(24, modalHeadingId = `bx--modal-header__heading--modal-${id}`);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        $$invalidate(23, modalBodyId = `bx--modal-body--${id}`);
    }
    $:
      $$invalidate(22, ariaLabel = modalLabel || $$props["aria-label"] || modalAriaLabel || modalHeading);
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    ref,
    size,
    danger,
    alert,
    passiveModal,
    modalHeading,
    modalLabel,
    iconDescription,
    hasForm,
    hasScrollingContent,
    primaryButtonText,
    primaryButtonDisabled,
    primaryButtonIcon,
    shouldSubmitOnEnter,
    secondaryButtonText,
    secondaryButtons,
    preventCloseOnClickOutside,
    id,
    buttonRef,
    innerModal,
    didClickInnerModal,
    ariaLabel,
    modalBodyId,
    modalHeadingId,
    modalLabelId,
    dispatch,
    openStore,
    $$restProps,
    modalAriaLabel,
    selectorPrimaryFocus,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    button_binding,
    click_handler_13,
    button_binding_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    div2_binding,
    click_handler_6,
    div3_binding,
    keydown_handler_12,
    click_handler_7,
    transitionend_handler,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance102,
      create_fragment102,
      safe_not_equal,
      {
        size: 2,
        open: 0,
        danger: 3,
        alert: 4,
        passiveModal: 5,
        modalHeading: 6,
        modalLabel: 7,
        modalAriaLabel: 29,
        iconDescription: 8,
        hasForm: 9,
        hasScrollingContent: 10,
        primaryButtonText: 11,
        primaryButtonDisabled: 12,
        primaryButtonIcon: 13,
        shouldSubmitOnEnter: 14,
        secondaryButtonText: 15,
        secondaryButtons: 16,
        selectorPrimaryFocus: 30,
        preventCloseOnClickOutside: 17,
        id: 18,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment102.name
    });
  }
  get size() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get danger() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set danger(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alert() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alert(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passiveModal() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passiveModal(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalHeading() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalHeading(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalAriaLabel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalAriaLabel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasForm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasForm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasScrollingContent() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasScrollingContent(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonDisabled() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonDisabled(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryButtonIcon() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryButtonIcon(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldSubmitOnEnter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldSubmitOnEnter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtonText() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtonText(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryButtons() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryButtons(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectorPrimaryFocus() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventCloseOnClickOutside() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventCloseOnClickOutside(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte
var file96 = "node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte";
function create_fragment103(ctx) {
  let button;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    return {
      props: {
        size: 20,
        title: ctx2[2],
        class: (ctx2[0] === "toast" && "bx--toast-notification__close-icon") + " " + (ctx2[0] === "inline" && "bx--inline-notification__close-icon")
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [
    { type: "button" },
    { "aria-label": ctx[3] },
    { title: ctx[3] },
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_attributes(button, button_data);
      toggle_class(button, "bx--toast-notification__close-button", ctx[0] === "toast");
      toggle_class(button, "bx--inline-notification__close-button", ctx[0] === "inline");
      add_location(button, file96, 26, 0, 558);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (switch_instance)
        mount_component(switch_instance, button, null);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[5], false, false, false),
          listen_dev(button, "mouseover", ctx[6], false, false, false),
          listen_dev(button, "mouseenter", ctx[7], false, false, false),
          listen_dev(button, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 4)
        switch_instance_changes.title = ctx2[2];
      if (dirty & 1)
        switch_instance_changes.class = (ctx2[0] === "toast" && "bx--toast-notification__close-icon") + " " + (ctx2[0] === "inline" && "bx--inline-notification__close-icon");
      if (switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & 8) && { "aria-label": ctx2[3] },
        (!current || dirty & 8) && { title: ctx2[3] },
        dirty & 16 && ctx2[4]
      ]));
      toggle_class(button, "bx--toast-notification__close-button", ctx2[0] === "toast");
      toggle_class(button, "bx--inline-notification__close-button", ctx2[0] === "inline");
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment103.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance103($$self, $$props, $$invalidate) {
  const omit_props_names = ["notificationType", "icon", "title", "iconDescription"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationButton", slots, []);
  let { notificationType = "toast" } = $$props;
  let { icon = Close_default } = $$props;
  let { title = void 0 } = $$props;
  let { iconDescription = "Close icon" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("notificationType" in $$new_props)
      $$invalidate(0, notificationType = $$new_props.notificationType);
    if ("icon" in $$new_props)
      $$invalidate(1, icon = $$new_props.icon);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("iconDescription" in $$new_props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
  };
  $$self.$capture_state = () => ({
    notificationType,
    icon,
    title,
    iconDescription,
    Close: Close_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("notificationType" in $$props)
      $$invalidate(0, notificationType = $$new_props.notificationType);
    if ("icon" in $$props)
      $$invalidate(1, icon = $$new_props.icon);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("iconDescription" in $$props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    notificationType,
    icon,
    title,
    iconDescription,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var NotificationButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance103, create_fragment103, safe_not_equal, {
      notificationType: 0,
      icon: 1,
      title: 2,
      iconDescription: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationButton",
      options,
      id: create_fragment103.name
    });
  }
  get notificationType() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notificationType(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationButton_default = NotificationButton;

// node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte
var file97 = "node_modules/carbon-components-svelte/src/icons/InformationFilled.svelte";
function create_if_block60(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file97, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block60.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment104(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block60(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file97, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z");
      add_location(path1, file97, 27, 39, 745);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file97, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block60(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment104.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance104($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InformationFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var InformationFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance104, create_fragment104, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InformationFilled",
      options,
      id: create_fragment104.name
    });
  }
  get size() {
    throw new Error("<InformationFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InformationFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InformationFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InformationFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InformationFilled_default = InformationFilled;

// node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte
var file98 = "node_modules/carbon-components-svelte/src/icons/InformationSquareFilled.svelte";
function create_if_block61(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file98, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block61.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment105(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block61(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file98, 24, 2, 579);
      attr_dev(path1, "d", "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z");
      add_location(path1, file98, 27, 39, 745);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file98, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block61(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment105.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance105($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InformationSquareFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var InformationSquareFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance105, create_fragment105, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InformationSquareFilled",
      options,
      id: create_fragment105.name
    });
  }
  get size() {
    throw new Error("<InformationSquareFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InformationSquareFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InformationSquareFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InformationSquareFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InformationSquareFilled_default = InformationSquareFilled;

// node_modules/carbon-components-svelte/src/Notification/NotificationIcon.svelte
function create_fragment106(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3][ctx[0]];
  function switch_props(ctx2) {
    return {
      props: {
        size: 20,
        title: ctx2[2],
        class: (ctx2[1] === "toast" && "bx--toast-notification__icon") + " " + (ctx2[1] === "inline" && "bx--inline-notification__icon")
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 4)
        switch_instance_changes.title = ctx2[2];
      if (dirty & 2)
        switch_instance_changes.class = (ctx2[1] === "toast" && "bx--toast-notification__icon") + " " + (ctx2[1] === "inline" && "bx--inline-notification__icon");
      if (switch_value !== (switch_value = ctx2[3][ctx2[0]])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment106.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance106($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationIcon", slots, []);
  let { kind = "error" } = $$props;
  let { notificationType = "toast" } = $$props;
  let { iconDescription = "Closes notification" } = $$props;
  const icons = {
    error: ErrorFilled_default,
    "info-square": InformationSquareFilled_default,
    info: InformationFilled_default,
    success: CheckmarkFilled_default,
    warning: WarningFilled_default,
    "warning-alt": WarningAltFilled_default
  };
  const writable_props = ["kind", "notificationType", "iconDescription"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NotificationIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("kind" in $$props2)
      $$invalidate(0, kind = $$props2.kind);
    if ("notificationType" in $$props2)
      $$invalidate(1, notificationType = $$props2.notificationType);
    if ("iconDescription" in $$props2)
      $$invalidate(2, iconDescription = $$props2.iconDescription);
  };
  $$self.$capture_state = () => ({
    kind,
    notificationType,
    iconDescription,
    CheckmarkFilled: CheckmarkFilled_default,
    ErrorFilled: ErrorFilled_default,
    InformationFilled: InformationFilled_default,
    InformationSquareFilled: InformationSquareFilled_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    icons
  });
  $$self.$inject_state = ($$props2) => {
    if ("kind" in $$props2)
      $$invalidate(0, kind = $$props2.kind);
    if ("notificationType" in $$props2)
      $$invalidate(1, notificationType = $$props2.notificationType);
    if ("iconDescription" in $$props2)
      $$invalidate(2, iconDescription = $$props2.iconDescription);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [kind, notificationType, iconDescription, icons];
}
var NotificationIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance106, create_fragment106, safe_not_equal, {
      kind: 0,
      notificationType: 1,
      iconDescription: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationIcon",
      options,
      id: create_fragment106.name
    });
  }
  get kind() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notificationType() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notificationType(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotificationIcon_default = NotificationIcon;

// node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte
var file99 = "node_modules/carbon-components-svelte/src/Notification/ToastNotification.svelte";
var get_caption_slot_changes = (dirty) => ({});
var get_caption_slot_context = (ctx) => ({});
var get_subtitle_slot_changes = (dirty) => ({});
var get_subtitle_slot_context = (ctx) => ({});
var get_title_slot_changes3 = (dirty) => ({});
var get_title_slot_context3 = (ctx) => ({});
function create_if_block62(ctx) {
  let div3;
  let notificationicon;
  let t0;
  let div2;
  let h3;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let t4;
  let div3_style_value;
  let current;
  let mounted;
  let dispose;
  notificationicon = new NotificationIcon_default({
    props: { kind: ctx[0] },
    $$inline: true
  });
  const title_slot_template = ctx[14].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[13], get_title_slot_context3);
  const title_slot_or_fallback = title_slot || fallback_block_24(ctx);
  const subtitle_slot_template = ctx[14].subtitle;
  const subtitle_slot = create_slot(subtitle_slot_template, ctx, ctx[13], get_subtitle_slot_context);
  const subtitle_slot_or_fallback = subtitle_slot || fallback_block_17(ctx);
  const caption_slot_template = ctx[14].caption;
  const caption_slot = create_slot(caption_slot_template, ctx, ctx[13], get_caption_slot_context);
  const caption_slot_or_fallback = caption_slot || fallback_block20(ctx);
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  let if_block = !ctx[7] && create_if_block_124(ctx);
  let div3_levels = [
    { role: ctx[2] },
    { kind: ctx[0] },
    ctx[11],
    {
      style: div3_style_value = "" + ((ctx[8] && "width: 100%;") + ctx[11].style)
    }
  ];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      create_component(notificationicon.$$.fragment);
      t0 = space();
      div2 = element("div");
      h3 = element("h3");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.c();
      t2 = space();
      div1 = element("div");
      if (caption_slot_or_fallback)
        caption_slot_or_fallback.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      t4 = space();
      if (if_block)
        if_block.c();
      toggle_class(h3, "bx--toast-notification__title", true);
      add_location(h3, file99, 94, 6, 2548);
      toggle_class(div0, "bx--toast-notification__subtitle", true);
      add_location(div0, file99, 97, 6, 2658);
      toggle_class(div1, "bx--toast-notification__caption", true);
      add_location(div1, file99, 100, 6, 2779);
      toggle_class(div2, "bx--toast-notification__details", true);
      add_location(div2, file99, 93, 4, 2489);
      set_attributes(div3, div3_data);
      toggle_class(div3, "bx--toast-notification", true);
      toggle_class(div3, "bx--toast-notification--low-contrast", ctx[1]);
      toggle_class(div3, "bx--toast-notification--error", ctx[0] === "error");
      toggle_class(div3, "bx--toast-notification--info", ctx[0] === "info");
      toggle_class(div3, "bx--toast-notification--info-square", ctx[0] === "info-square");
      toggle_class(div3, "bx--toast-notification--success", ctx[0] === "success");
      toggle_class(div3, "bx--toast-notification--warning", ctx[0] === "warning");
      toggle_class(div3, "bx--toast-notification--warning-alt", ctx[0] === "warning-alt");
      add_location(div3, file99, 74, 2, 1752);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      mount_component(notificationicon, div3, null);
      append_dev(div3, t0);
      append_dev(div3, div2);
      append_dev(div2, h3);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h3, null);
      }
      append_dev(div2, t1);
      append_dev(div2, div0);
      if (subtitle_slot_or_fallback) {
        subtitle_slot_or_fallback.m(div0, null);
      }
      append_dev(div2, t2);
      append_dev(div2, div1);
      if (caption_slot_or_fallback) {
        caption_slot_or_fallback.m(div1, null);
      }
      append_dev(div2, t3);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_dev(div3, t4);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div3, "click", ctx[15], false, false, false),
          listen_dev(div3, "mouseover", ctx[16], false, false, false),
          listen_dev(div3, "mouseenter", ctx[17], false, false, false),
          listen_dev(div3, "mouseleave", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const notificationicon_changes = {};
      if (dirty & 1)
        notificationicon_changes.kind = ctx2[0];
      notificationicon.$set(notificationicon_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(title_slot_template, ctx2[13], dirty, get_title_slot_changes3),
            get_title_slot_context3
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 8)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(subtitle_slot_template, ctx2[13], dirty, get_subtitle_slot_changes),
            get_subtitle_slot_context
          );
        }
      } else {
        if (subtitle_slot_or_fallback && subtitle_slot_or_fallback.p && (!current || dirty & 16)) {
          subtitle_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (caption_slot) {
        if (caption_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            caption_slot,
            caption_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(caption_slot_template, ctx2[13], dirty, get_caption_slot_changes),
            get_caption_slot_context
          );
        }
      } else {
        if (caption_slot_or_fallback && caption_slot_or_fallback.p && (!current || dirty & 32)) {
          caption_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_124(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty & 4) && { role: ctx2[2] },
        (!current || dirty & 1) && { kind: ctx2[0] },
        dirty & 2048 && ctx2[11],
        (!current || dirty & 2304 && div3_style_value !== (div3_style_value = "" + ((ctx2[8] && "width: 100%;") + ctx2[11].style))) && { style: div3_style_value }
      ]));
      toggle_class(div3, "bx--toast-notification", true);
      toggle_class(div3, "bx--toast-notification--low-contrast", ctx2[1]);
      toggle_class(div3, "bx--toast-notification--error", ctx2[0] === "error");
      toggle_class(div3, "bx--toast-notification--info", ctx2[0] === "info");
      toggle_class(div3, "bx--toast-notification--info-square", ctx2[0] === "info-square");
      toggle_class(div3, "bx--toast-notification--success", ctx2[0] === "success");
      toggle_class(div3, "bx--toast-notification--warning", ctx2[0] === "warning");
      toggle_class(div3, "bx--toast-notification--warning-alt", ctx2[0] === "warning-alt");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationicon.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(subtitle_slot_or_fallback, local);
      transition_in(caption_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationicon.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(subtitle_slot_or_fallback, local);
      transition_out(caption_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      destroy_component(notificationicon);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.d(detaching);
      if (caption_slot_or_fallback)
        caption_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block62.name,
    type: "if",
    source: "(74:0) {#if open}",
    ctx
  });
  return block;
}
function fallback_block_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_24.name,
    type: "fallback",
    source: "(96:27) {title}",
    ctx
  });
  return block;
}
function fallback_block_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_17.name,
    type: "fallback",
    source: "(99:30) {subtitle}",
    ctx
  });
  return block;
}
function fallback_block20(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block20.name,
    type: "fallback",
    source: "(102:29) {caption}",
    ctx
  });
  return block;
}
function create_if_block_124(ctx) {
  let notificationbutton;
  let current;
  notificationbutton = new NotificationButton_default({
    props: {
      iconDescription: ctx[6]
    },
    $$inline: true
  });
  notificationbutton.$on("click", ctx[10]);
  const block = {
    c: function create() {
      create_component(notificationbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notificationbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notificationbutton_changes = {};
      if (dirty & 64)
        notificationbutton_changes.iconDescription = ctx2[6];
      notificationbutton.$set(notificationbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notificationbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_124.name,
    type: "if",
    source: "(106:4) {#if !hideCloseButton}",
    ctx
  });
  return block;
}
function create_fragment107(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[9] && create_if_block62(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block62(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment107.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance107($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "caption",
    "iconDescription",
    "hideCloseButton",
    "fullWidth"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastNotification", slots, ["title", "subtitle", "caption", "default"]);
  let { kind = "error" } = $$props;
  let { lowContrast = false } = $$props;
  let { timeout = 0 } = $$props;
  let { role = "alert" } = $$props;
  let { title = "" } = $$props;
  let { subtitle = "" } = $$props;
  let { caption = "" } = $$props;
  let { iconDescription = "Closes notification" } = $$props;
  let { hideCloseButton = false } = $$props;
  let { fullWidth = false } = $$props;
  const dispatch = createEventDispatcher();
  let open = true;
  let timeoutId = void 0;
  function close(closeFromTimeout) {
    const shouldContinue = dispatch("close", { timeout: closeFromTimeout === true }, { cancelable: true });
    if (shouldContinue) {
      $$invalidate(9, open = false);
    }
  }
  onMount(() => {
    if (timeout) {
      timeoutId = setTimeout(() => close(true), timeout);
    }
    return () => {
      clearTimeout(timeoutId);
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props)
      $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$new_props)
      $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$new_props)
      $$invalidate(12, timeout = $$new_props.timeout);
    if ("role" in $$new_props)
      $$invalidate(2, role = $$new_props.role);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("caption" in $$new_props)
      $$invalidate(5, caption = $$new_props.caption);
    if ("iconDescription" in $$new_props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("hideCloseButton" in $$new_props)
      $$invalidate(7, hideCloseButton = $$new_props.hideCloseButton);
    if ("fullWidth" in $$new_props)
      $$invalidate(8, fullWidth = $$new_props.fullWidth);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    lowContrast,
    timeout,
    role,
    title,
    subtitle,
    caption,
    iconDescription,
    hideCloseButton,
    fullWidth,
    createEventDispatcher,
    onMount,
    NotificationButton: NotificationButton_default,
    NotificationIcon: NotificationIcon_default,
    dispatch,
    open,
    timeoutId,
    close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props)
      $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$props)
      $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$props)
      $$invalidate(12, timeout = $$new_props.timeout);
    if ("role" in $$props)
      $$invalidate(2, role = $$new_props.role);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("caption" in $$props)
      $$invalidate(5, caption = $$new_props.caption);
    if ("iconDescription" in $$props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("hideCloseButton" in $$props)
      $$invalidate(7, hideCloseButton = $$new_props.hideCloseButton);
    if ("fullWidth" in $$props)
      $$invalidate(8, fullWidth = $$new_props.fullWidth);
    if ("open" in $$props)
      $$invalidate(9, open = $$new_props.open);
    if ("timeoutId" in $$props)
      timeoutId = $$new_props.timeoutId;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    kind,
    lowContrast,
    role,
    title,
    subtitle,
    caption,
    iconDescription,
    hideCloseButton,
    fullWidth,
    open,
    close,
    $$restProps,
    timeout,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ToastNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance107, create_fragment107, safe_not_equal, {
      kind: 0,
      lowContrast: 1,
      timeout: 12,
      role: 2,
      title: 3,
      subtitle: 4,
      caption: 5,
      iconDescription: 6,
      hideCloseButton: 7,
      fullWidth: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastNotification",
      options,
      id: create_fragment107.name
    });
  }
  get kind() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lowContrast() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lowContrast(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeout() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeout(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCloseButton() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCloseButton(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<ToastNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<ToastNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastNotification_default = ToastNotification;

// node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte
var file100 = "node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte";
var get_actions_slot_changes = (dirty) => ({});
var get_actions_slot_context = (ctx) => ({});
var get_subtitle_slot_changes2 = (dirty) => ({});
var get_subtitle_slot_context2 = (ctx) => ({});
var get_title_slot_changes4 = (dirty) => ({});
var get_title_slot_context4 = (ctx) => ({});
function create_if_block63(ctx) {
  let div3;
  let div2;
  let notificationicon;
  let t0;
  let div1;
  let p;
  let t1;
  let div0;
  let t2;
  let t3;
  let t4;
  let current;
  let mounted;
  let dispose;
  notificationicon = new NotificationIcon_default({
    props: {
      notificationType: "inline",
      kind: ctx[0]
    },
    $$inline: true
  });
  const title_slot_template = ctx[12].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[11], get_title_slot_context4);
  const title_slot_or_fallback = title_slot || fallback_block_18(ctx);
  const subtitle_slot_template = ctx[12].subtitle;
  const subtitle_slot = create_slot(subtitle_slot_template, ctx, ctx[11], get_subtitle_slot_context2);
  const subtitle_slot_or_fallback = subtitle_slot || fallback_block21(ctx);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const actions_slot_template = ctx[12].actions;
  const actions_slot = create_slot(actions_slot_template, ctx, ctx[11], get_actions_slot_context);
  let if_block = !ctx[5] && create_if_block_125(ctx);
  let div3_levels = [{ role: ctx[2] }, { kind: ctx[0] }, ctx[9]];
  let div3_data = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div3_data = assign(div3_data, div3_levels[i]);
  }
  const block = {
    c: function create() {
      div3 = element("div");
      div2 = element("div");
      create_component(notificationicon.$$.fragment);
      t0 = space();
      div1 = element("div");
      p = element("p");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (actions_slot)
        actions_slot.c();
      t4 = space();
      if (if_block)
        if_block.c();
      toggle_class(p, "bx--inline-notification__title", true);
      add_location(p, file100, 86, 8, 2462);
      toggle_class(div0, "bx--inline-notification__subtitle", true);
      add_location(div0, file100, 89, 8, 2577);
      toggle_class(div1, "bx--inline-notification__text-wrapper", true);
      add_location(div1, file100, 85, 6, 2395);
      toggle_class(div2, "bx--inline-notification__details", true);
      add_location(div2, file100, 83, 4, 2268);
      set_attributes(div3, div3_data);
      toggle_class(div3, "bx--inline-notification", true);
      toggle_class(div3, "bx--inline-notification--low-contrast", ctx[1]);
      toggle_class(div3, "bx--inline-notification--hide-close-button", ctx[5]);
      toggle_class(div3, "bx--inline-notification--error", ctx[0] === "error");
      toggle_class(div3, "bx--inline-notification--info", ctx[0] === "info");
      toggle_class(div3, "bx--inline-notification--info-square", ctx[0] === "info-square");
      toggle_class(div3, "bx--inline-notification--success", ctx[0] === "success");
      toggle_class(div3, "bx--inline-notification--warning", ctx[0] === "warning");
      toggle_class(div3, "bx--inline-notification--warning-alt", ctx[0] === "warning-alt");
      add_location(div3, file100, 65, 2, 1550);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div2);
      mount_component(notificationicon, div2, null);
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, p);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(p, null);
      }
      append_dev(div1, t1);
      append_dev(div1, div0);
      if (subtitle_slot_or_fallback) {
        subtitle_slot_or_fallback.m(div0, null);
      }
      append_dev(div1, t2);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div3, t3);
      if (actions_slot) {
        actions_slot.m(div3, null);
      }
      append_dev(div3, t4);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div3, "click", ctx[13], false, false, false),
          listen_dev(div3, "mouseover", ctx[14], false, false, false),
          listen_dev(div3, "mouseenter", ctx[15], false, false, false),
          listen_dev(div3, "mouseleave", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const notificationicon_changes = {};
      if (dirty & 1)
        notificationicon_changes.kind = ctx2[0];
      notificationicon.$set(notificationicon_changes);
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(title_slot_template, ctx2[11], dirty, get_title_slot_changes4),
            get_title_slot_context4
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 8)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(subtitle_slot_template, ctx2[11], dirty, get_subtitle_slot_changes2),
            get_subtitle_slot_context2
          );
        }
      } else {
        if (subtitle_slot_or_fallback && subtitle_slot_or_fallback.p && (!current || dirty & 16)) {
          subtitle_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (actions_slot) {
        if (actions_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            actions_slot,
            actions_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(actions_slot_template, ctx2[11], dirty, get_actions_slot_changes),
            get_actions_slot_context
          );
        }
      }
      if (!ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_125(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div3, div3_data = get_spread_update(div3_levels, [
        (!current || dirty & 4) && { role: ctx2[2] },
        (!current || dirty & 1) && { kind: ctx2[0] },
        dirty & 512 && ctx2[9]
      ]));
      toggle_class(div3, "bx--inline-notification", true);
      toggle_class(div3, "bx--inline-notification--low-contrast", ctx2[1]);
      toggle_class(div3, "bx--inline-notification--hide-close-button", ctx2[5]);
      toggle_class(div3, "bx--inline-notification--error", ctx2[0] === "error");
      toggle_class(div3, "bx--inline-notification--info", ctx2[0] === "info");
      toggle_class(div3, "bx--inline-notification--info-square", ctx2[0] === "info-square");
      toggle_class(div3, "bx--inline-notification--success", ctx2[0] === "success");
      toggle_class(div3, "bx--inline-notification--warning", ctx2[0] === "warning");
      toggle_class(div3, "bx--inline-notification--warning-alt", ctx2[0] === "warning-alt");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationicon.$$.fragment, local);
      transition_in(title_slot_or_fallback, local);
      transition_in(subtitle_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(actions_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationicon.$$.fragment, local);
      transition_out(title_slot_or_fallback, local);
      transition_out(subtitle_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(actions_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      destroy_component(notificationicon);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (actions_slot)
        actions_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block63.name,
    type: "if",
    source: "(65:0) {#if open}",
    ctx
  });
  return block;
}
function fallback_block_18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_18.name,
    type: "fallback",
    source: "(88:29) {title}",
    ctx
  });
  return block;
}
function fallback_block21(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block21.name,
    type: "fallback",
    source: "(91:32) {subtitle}",
    ctx
  });
  return block;
}
function create_if_block_125(ctx) {
  let notificationbutton;
  let current;
  notificationbutton = new NotificationButton_default({
    props: {
      iconDescription: ctx[6],
      notificationType: "inline"
    },
    $$inline: true
  });
  notificationbutton.$on("click", ctx[8]);
  const block = {
    c: function create() {
      create_component(notificationbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(notificationbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notificationbutton_changes = {};
      if (dirty & 64)
        notificationbutton_changes.iconDescription = ctx2[6];
      notificationbutton.$set(notificationbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notificationbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notificationbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(notificationbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_125.name,
    type: "if",
    source: "(97:4) {#if !hideCloseButton}",
    ctx
  });
  return block;
}
function create_fragment108(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[7] && create_if_block63(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block63(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment108.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance108($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "kind",
    "lowContrast",
    "timeout",
    "role",
    "title",
    "subtitle",
    "hideCloseButton",
    "iconDescription"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineNotification", slots, ["title", "subtitle", "default", "actions"]);
  let { kind = "error" } = $$props;
  let { lowContrast = false } = $$props;
  let { timeout = 0 } = $$props;
  let { role = "alert" } = $$props;
  let { title = "" } = $$props;
  let { subtitle = "" } = $$props;
  let { hideCloseButton = false } = $$props;
  let { iconDescription = "Closes notification" } = $$props;
  const dispatch = createEventDispatcher();
  let open = true;
  let timeoutId = void 0;
  function close(closeFromTimeout) {
    const shouldContinue = dispatch("close", { timeout: closeFromTimeout === true }, { cancelable: true });
    if (shouldContinue) {
      $$invalidate(7, open = false);
    }
  }
  onMount(() => {
    if (timeout) {
      timeoutId = setTimeout(() => close(true), timeout);
    }
    return () => {
      clearTimeout(timeoutId);
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("kind" in $$new_props)
      $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$new_props)
      $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$new_props)
      $$invalidate(10, timeout = $$new_props.timeout);
    if ("role" in $$new_props)
      $$invalidate(2, role = $$new_props.role);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$new_props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("hideCloseButton" in $$new_props)
      $$invalidate(5, hideCloseButton = $$new_props.hideCloseButton);
    if ("iconDescription" in $$new_props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    kind,
    lowContrast,
    timeout,
    role,
    title,
    subtitle,
    hideCloseButton,
    iconDescription,
    createEventDispatcher,
    onMount,
    NotificationIcon: NotificationIcon_default,
    NotificationButton: NotificationButton_default,
    dispatch,
    open,
    timeoutId,
    close
  });
  $$self.$inject_state = ($$new_props) => {
    if ("kind" in $$props)
      $$invalidate(0, kind = $$new_props.kind);
    if ("lowContrast" in $$props)
      $$invalidate(1, lowContrast = $$new_props.lowContrast);
    if ("timeout" in $$props)
      $$invalidate(10, timeout = $$new_props.timeout);
    if ("role" in $$props)
      $$invalidate(2, role = $$new_props.role);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("subtitle" in $$props)
      $$invalidate(4, subtitle = $$new_props.subtitle);
    if ("hideCloseButton" in $$props)
      $$invalidate(5, hideCloseButton = $$new_props.hideCloseButton);
    if ("iconDescription" in $$props)
      $$invalidate(6, iconDescription = $$new_props.iconDescription);
    if ("open" in $$props)
      $$invalidate(7, open = $$new_props.open);
    if ("timeoutId" in $$props)
      timeoutId = $$new_props.timeoutId;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    kind,
    lowContrast,
    role,
    title,
    subtitle,
    hideCloseButton,
    iconDescription,
    open,
    close,
    $$restProps,
    timeout,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var InlineNotification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance108, create_fragment108, safe_not_equal, {
      kind: 0,
      lowContrast: 1,
      timeout: 10,
      role: 2,
      title: 3,
      subtitle: 4,
      hideCloseButton: 5,
      iconDescription: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineNotification",
      options,
      id: create_fragment108.name
    });
  }
  get kind() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lowContrast() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lowContrast(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeout() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeout(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get subtitle() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set subtitle(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideCloseButton() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideCloseButton(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineNotification_default = InlineNotification;

// node_modules/carbon-components-svelte/src/Notification/NotificationActionButton.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: '(7:0) <Button   kind=\\"ghost\\"   size=\\"small\\"   {...$$restProps}   class=\\"bx--inline-notification__action-button {$$restProps.class}\\"   on:click   on:mouseover   on:mouseenter   on:mouseleave >',
    ctx
  });
  return block;
}
function create_fragment109(ctx) {
  let button;
  let current;
  const button_spread_levels = [
    { kind: "ghost" },
    { size: "small" },
    ctx[0],
    {
      class: "bx--inline-notification__action-button " + ctx[0].class
    }
  ];
  let button_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  button.$on("click", ctx[2]);
  button.$on("mouseover", ctx[3]);
  button.$on("mouseenter", ctx[4]);
  button.$on("mouseleave", ctx[5]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = dirty & 1 ? get_spread_update(button_spread_levels, [
        button_spread_levels[0],
        button_spread_levels[1],
        get_spread_object(ctx2[0]),
        {
          class: "bx--inline-notification__action-button " + ctx2[0].class
        }
      ]) : {};
      if (dirty & 64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment109.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance109($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotificationActionButton", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Button: Button_default });
  return [
    $$restProps,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var NotificationActionButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance109, create_fragment109, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotificationActionButton",
      options,
      id: create_fragment109.name
    });
  }
};
var NotificationActionButton_default = NotificationActionButton;

// node_modules/carbon-components-svelte/src/icons/Add.svelte
var file101 = "node_modules/carbon-components-svelte/src/icons/Add.svelte";
function create_if_block64(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file101, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block64.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment110(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block64(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z");
      add_location(path, file101, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file101, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block64(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment110.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance110($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Add", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Add = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance110, create_fragment110, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Add",
      options,
      id: create_fragment110.name
    });
  }
  get size() {
    throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Add_default = Add;

// node_modules/carbon-components-svelte/src/icons/Subtract.svelte
var file102 = "node_modules/carbon-components-svelte/src/icons/Subtract.svelte";
function create_if_block65(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file102, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block65.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment111(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block65(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M8 15H24V17H8z");
      add_location(path, file102, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file102, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block65(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment111.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance111($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Subtract", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Subtract = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance111, create_fragment111, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Subtract",
      options,
      id: create_fragment111.name
    });
  }
  get size() {
    throw new Error("<Subtract>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Subtract>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Subtract>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Subtract>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Subtract_default = Subtract;

// node_modules/carbon-components-svelte/src/icons/EditOff.svelte
var file103 = "node_modules/carbon-components-svelte/src/icons/EditOff.svelte";
function create_if_block66(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file103, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block66.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment112(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block66(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M30 28.6L3.4 2 2 3.4l10.1 10.1L4 21.6V28h6.4l8.1-8.1L28.6 30 30 28.6zM9.6 26H6v-3.6l7.5-7.5 3.6 3.6L9.6 26zM29.4 6.2L29.4 6.2l-3.6-3.6c-.8-.8-2-.8-2.8 0l0 0 0 0-8 8 1.4 1.4L20 8.4l3.6 3.6L20 15.6l1.4 1.4 8-8C30.2 8.2 30.2 7 29.4 6.2L29.4 6.2zM25 10.6L21.4 7l3-3L28 7.6 25 10.6z");
      add_location(path, file103, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file103, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block66(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment112.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance112($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("EditOff", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var EditOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance112, create_fragment112, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EditOff",
      options,
      id: create_fragment112.name
    });
  }
  get size() {
    throw new Error("<EditOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<EditOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<EditOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<EditOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var EditOff_default = EditOff;

// node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte
var file104 = "node_modules/carbon-components-svelte/src/NumberInput/NumberInput.svelte";
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
function create_if_block_73(ctx) {
  let label_1;
  let current;
  const label_slot_template = ctx[34].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[33], get_label_slot_context2);
  const label_slot_or_fallback = label_slot || fallback_block22(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr_dev(label_1, "for", ctx[18]);
      toggle_class(label_1, "bx--label", true);
      toggle_class(label_1, "bx--label--disabled", ctx[8]);
      toggle_class(label_1, "bx--visually-hidden", ctx[17]);
      add_location(label_1, file104, 175, 6, 4330);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & 4)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[33],
            !current ? get_all_dirty_from_scope(ctx2[33]) : get_slot_changes(label_slot_template, ctx2[33], dirty, get_label_slot_changes2),
            get_label_slot_context2
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & 65536)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 262144) {
        attr_dev(label_1, "for", ctx2[18]);
      }
      if (!current || dirty[0] & 256) {
        toggle_class(label_1, "bx--label--disabled", ctx2[8]);
      }
      if (!current || dirty[0] & 131072) {
        toggle_class(label_1, "bx--visually-hidden", ctx2[17]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_73.name,
    type: "if",
    source: "(175:4) {#if $$slots.label || label}",
    ctx
  });
  return block;
}
function fallback_block22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[16]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536)
        set_data_dev(t, ctx2[16]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block22.name,
    type: "fallback",
    source: "(182:27) {label}",
    ctx
  });
  return block;
}
function create_if_block_67(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--number__invalid" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_67.name,
    type: "if",
    source: "(214:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_58(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--number__invalid bx--number__invalid--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_58.name,
    type: "if",
    source: "(217:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_410(ctx) {
  let editoff;
  let current;
  editoff = new EditOff_default({
    props: { class: "bx--text-input__readonly-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editoff.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(editoff, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(editoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(editoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_410.name,
    type: "if",
    source: "(222:6) {#if readonly}",
    ctx
  });
  return block;
}
function create_if_block_312(ctx) {
  let div2;
  let button0;
  let subtract;
  let button0_title_value;
  let button0_aria_label_value;
  let t0;
  let div0;
  let t1;
  let button1;
  let add;
  let button1_title_value;
  let button1_aria_label_value;
  let t2;
  let div1;
  let current;
  let mounted;
  let dispose;
  subtract = new Subtract_default({
    props: { class: "down-icon" },
    $$inline: true
  });
  add = new Add_default({
    props: { class: "up-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      div2 = element("div");
      button0 = element("button");
      create_component(subtract.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      button1 = element("button");
      create_component(add.$$.fragment);
      t2 = space();
      div1 = element("div");
      attr_dev(button0, "type", "button");
      attr_dev(button0, "tabindex", "-1");
      attr_dev(button0, "title", button0_title_value = ctx[23] || ctx[10]);
      attr_dev(button0, "aria-label", button0_aria_label_value = ctx[23] || ctx[10]);
      button0.disabled = ctx[8];
      toggle_class(button0, "bx--number__control-btn", true);
      toggle_class(button0, "down-icon", true);
      add_location(button0, file104, 226, 10, 5737);
      toggle_class(div0, "bx--number__rule-divider", true);
      add_location(div0, file104, 240, 10, 6202);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "tabindex", "-1");
      attr_dev(button1, "title", button1_title_value = ctx[24] || ctx[10]);
      attr_dev(button1, "aria-label", button1_aria_label_value = ctx[24] || ctx[10]);
      button1.disabled = ctx[8];
      toggle_class(button1, "bx--number__control-btn", true);
      toggle_class(button1, "up-icon", true);
      add_location(button1, file104, 241, 10, 6264);
      toggle_class(div1, "bx--number__rule-divider", true);
      add_location(div1, file104, 255, 10, 6719);
      toggle_class(div2, "bx--number__controls", true);
      add_location(div2, file104, 225, 8, 5685);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, button0);
      mount_component(subtract, button0, null);
      append_dev(div2, t0);
      append_dev(div2, div0);
      append_dev(div2, t1);
      append_dev(div2, button1);
      mount_component(add, button1, null);
      append_dev(div2, t2);
      append_dev(div2, div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[45], false, false, false),
          listen_dev(button1, "click", ctx[46], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 8389632 && button0_title_value !== (button0_title_value = ctx2[23] || ctx2[10])) {
        attr_dev(button0, "title", button0_title_value);
      }
      if (!current || dirty[0] & 8389632 && button0_aria_label_value !== (button0_aria_label_value = ctx2[23] || ctx2[10])) {
        attr_dev(button0, "aria-label", button0_aria_label_value);
      }
      if (!current || dirty[0] & 256) {
        prop_dev(button0, "disabled", ctx2[8]);
      }
      if (!current || dirty[0] & 16778240 && button1_title_value !== (button1_title_value = ctx2[24] || ctx2[10])) {
        attr_dev(button1, "title", button1_title_value);
      }
      if (!current || dirty[0] & 16778240 && button1_aria_label_value !== (button1_aria_label_value = ctx2[24] || ctx2[10])) {
        attr_dev(button1, "aria-label", button1_aria_label_value);
      }
      if (!current || dirty[0] & 256) {
        prop_dev(button1, "disabled", ctx2[8]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtract.$$.fragment, local);
      transition_in(add.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtract.$$.fragment, local);
      transition_out(add.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_component(subtract);
      destroy_component(add);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_312.name,
    type: "if",
    source: "(225:6) {#if !hideSteppers}",
    ctx
  });
  return block;
}
function create_if_block_217(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[15]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[8]);
      add_location(div, file104, 260, 6, 6855);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data_dev(t, ctx2[15]);
      if (dirty[0] & 256) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[8]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_217.name,
    type: "if",
    source: "(260:4) {#if !error && !warn && helperText}",
    ctx
  });
  return block;
}
function create_if_block_126(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[12]);
      attr_dev(div, "id", ctx[21]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file104, 268, 6, 7038);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
      if (dirty[0] & 2097152) {
        attr_dev(div, "id", ctx2[21]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_126.name,
    type: "if",
    source: "(268:4) {#if error}",
    ctx
  });
  return block;
}
function create_if_block67(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[14]);
      attr_dev(div, "id", ctx[21]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file104, 273, 6, 7171);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16384)
        set_data_dev(t, ctx2[14]);
      if (dirty[0] & 2097152) {
        attr_dev(div, "id", ctx2[21]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block67.name,
    type: "if",
    source: "(273:4) {#if !error && warn}",
    ctx
  });
  return block;
}
function create_fragment113(ctx) {
  var _a;
  let div2;
  let div1;
  let t0;
  let div0;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_aria_label_value;
  let input_value_value;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let div1_data_invalid_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[28].label || ctx[16]) && create_if_block_73(ctx);
  let input_levels = [
    { type: "number" },
    { pattern: "[0-9]*" },
    { "aria-describedby": ctx[21] },
    {
      "data-invalid": input_data_invalid_value = ctx[11] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = ctx[11] || void 0
    },
    {
      "aria-label": input_aria_label_value = ctx[16] ? void 0 : ctx[20]
    },
    { disabled: ctx[8] },
    { id: ctx[18] },
    { name: ctx[19] },
    { max: ctx[4] },
    { min: ctx[5] },
    { step: ctx[3] },
    {
      value: input_value_value = (_a = ctx[0]) != null ? _a : ""
    },
    { readOnly: ctx[7] },
    ctx[29]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = ctx[11] && create_if_block_67(ctx);
  let if_block2 = !ctx[11] && ctx[13] && create_if_block_58(ctx);
  let if_block3 = ctx[7] && create_if_block_410(ctx);
  let if_block4 = !ctx[9] && create_if_block_312(ctx);
  let if_block5 = !ctx[22] && !ctx[13] && ctx[15] && create_if_block_217(ctx);
  let if_block6 = ctx[22] && create_if_block_126(ctx);
  let if_block7 = !ctx[22] && ctx[13] && create_if_block67(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      set_attributes(input, input_data);
      add_location(input, file104, 188, 6, 4695);
      toggle_class(div0, "bx--number__input-wrapper", true);
      toggle_class(div0, "bx--number__input-wrapper--warning", !ctx[11] && ctx[13]);
      add_location(div0, file104, 184, 4, 4563);
      attr_dev(div1, "data-invalid", div1_data_invalid_value = ctx[22] || void 0);
      toggle_class(div1, "bx--number", true);
      toggle_class(div1, "bx--number--helpertext", true);
      toggle_class(div1, "bx--number--readonly", ctx[7]);
      toggle_class(div1, "bx--number--light", ctx[6]);
      toggle_class(div1, "bx--number--nolabel", ctx[17]);
      toggle_class(div1, "bx--number--nosteppers", ctx[9]);
      toggle_class(div1, "bx--number--sm", ctx[2] === "sm");
      toggle_class(div1, "bx--number--xl", ctx[2] === "xl");
      add_location(div1, file104, 163, 2, 3908);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file104, 156, 0, 3810);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, div0);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[44](input);
      append_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t2);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t4);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div1, t5);
      if (if_block5)
        if_block5.m(div1, null);
      append_dev(div1, t6);
      if (if_block6)
        if_block6.m(div1, null);
      append_dev(div1, t7);
      if (if_block7)
        if_block7.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[27], false, false, false),
          listen_dev(input, "input", ctx[26], false, false, false),
          listen_dev(input, "keydown", ctx[39], false, false, false),
          listen_dev(input, "keyup", ctx[40], false, false, false),
          listen_dev(input, "focus", ctx[41], false, false, false),
          listen_dev(input, "blur", ctx[42], false, false, false),
          listen_dev(input, "paste", ctx[43], false, false, false),
          listen_dev(div2, "click", ctx[35], false, false, false),
          listen_dev(div2, "mouseover", ctx[36], false, false, false),
          listen_dev(div2, "mouseenter", ctx[37], false, false, false),
          listen_dev(div2, "mouseleave", ctx[38], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (ctx2[28].label || ctx2[16]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 268500992) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_73(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "number" },
        { pattern: "[0-9]*" },
        (!current || dirty[0] & 2097152) && { "aria-describedby": ctx2[21] },
        (!current || dirty[0] & 2048 && input_data_invalid_value !== (input_data_invalid_value = ctx2[11] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & 2048 && input_aria_invalid_value !== (input_aria_invalid_value = ctx2[11] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & 1114112 && input_aria_label_value !== (input_aria_label_value = ctx2[16] ? void 0 : ctx2[20])) && { "aria-label": input_aria_label_value },
        (!current || dirty[0] & 256) && { disabled: ctx2[8] },
        (!current || dirty[0] & 262144) && { id: ctx2[18] },
        (!current || dirty[0] & 524288) && { name: ctx2[19] },
        (!current || dirty[0] & 16) && { max: ctx2[4] },
        (!current || dirty[0] & 32) && { min: ctx2[5] },
        (!current || dirty[0] & 8) && { step: ctx2[3] },
        (!current || dirty[0] & 1 && input_value_value !== (input_value_value = (_a2 = ctx2[0]) != null ? _a2 : "") && input.value !== input_value_value) && { value: input_value_value },
        (!current || dirty[0] & 128) && { readOnly: ctx2[7] },
        dirty[0] & 536870912 && ctx2[29]
      ]));
      if (ctx2[11]) {
        if (if_block1) {
          if (dirty[0] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_67(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[11] && ctx2[13]) {
        if (if_block2) {
          if (dirty[0] & 10240) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_58(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block3) {
          if (dirty[0] & 128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_410(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!ctx2[9]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_312(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 10240) {
        toggle_class(div0, "bx--number__input-wrapper--warning", !ctx2[11] && ctx2[13]);
      }
      if (!ctx2[22] && !ctx2[13] && ctx2[15]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_217(ctx2);
          if_block5.c();
          if_block5.m(div1, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[22]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_126(ctx2);
          if_block6.c();
          if_block6.m(div1, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!ctx2[22] && ctx2[13]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block67(ctx2);
          if_block7.c();
          if_block7.m(div1, null);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (!current || dirty[0] & 4194304 && div1_data_invalid_value !== (div1_data_invalid_value = ctx2[22] || void 0)) {
        attr_dev(div1, "data-invalid", div1_data_invalid_value);
      }
      if (!current || dirty[0] & 128) {
        toggle_class(div1, "bx--number--readonly", ctx2[7]);
      }
      if (!current || dirty[0] & 64) {
        toggle_class(div1, "bx--number--light", ctx2[6]);
      }
      if (!current || dirty[0] & 131072) {
        toggle_class(div1, "bx--number--nolabel", ctx2[17]);
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div1, "bx--number--nosteppers", ctx2[9]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div1, "bx--number--sm", ctx2[2] === "sm");
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div1, "bx--number--xl", ctx2[2] === "xl");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      ctx[44](null);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment113.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function parse(raw) {
  return raw != "" ? Number(raw) : null;
}
function instance113($$self, $$props, $$invalidate) {
  let incrementLabel;
  let decrementLabel;
  let error;
  let errorId;
  let ariaLabel;
  const omit_props_names = [
    "size",
    "value",
    "step",
    "max",
    "min",
    "light",
    "readonly",
    "allowEmpty",
    "disabled",
    "hideSteppers",
    "iconDescription",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "label",
    "hideLabel",
    "translateWithId",
    "translationIds",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberInput", slots, ["label"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = null } = $$props;
  let { step = 1 } = $$props;
  let { max = void 0 } = $$props;
  let { min = void 0 } = $$props;
  let { light = false } = $$props;
  let { readonly = false } = $$props;
  let { allowEmpty = false } = $$props;
  let { disabled = false } = $$props;
  let { hideSteppers = false } = $$props;
  let { iconDescription = "" } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { label = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { translateWithId = (id2) => defaultTranslations[id2] } = $$props;
  const translationIds = {
    increment: "increment",
    decrement: "decrement"
  };
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const defaultTranslations = {
    [translationIds.increment]: "Increment number",
    [translationIds.decrement]: "Decrement number"
  };
  const dispatch = createEventDispatcher();
  function updateValue(isIncrementing) {
    if (isIncrementing) {
      ref.stepUp();
    } else {
      ref.stepDown();
    }
    $$invalidate(0, value = +ref.value);
    dispatch("input", value);
    dispatch("change", value);
  }
  function onInput({ target }) {
    $$invalidate(0, value = parse(target.value));
    dispatch("input", value);
  }
  function onChange({ target }) {
    dispatch("change", parse(target.value));
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    updateValue(false);
  };
  const click_handler_2 = () => {
    updateValue(true);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(49, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("max" in $$new_props)
      $$invalidate(4, max = $$new_props.max);
    if ("min" in $$new_props)
      $$invalidate(5, min = $$new_props.min);
    if ("light" in $$new_props)
      $$invalidate(6, light = $$new_props.light);
    if ("readonly" in $$new_props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("allowEmpty" in $$new_props)
      $$invalidate(30, allowEmpty = $$new_props.allowEmpty);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("hideSteppers" in $$new_props)
      $$invalidate(9, hideSteppers = $$new_props.hideSteppers);
    if ("iconDescription" in $$new_props)
      $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props)
      $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$new_props)
      $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$new_props)
      $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$new_props)
      $$invalidate(31, translateWithId = $$new_props.translateWithId);
    if ("id" in $$new_props)
      $$invalidate(18, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(19, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(33, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    step,
    max,
    min,
    light,
    readonly,
    allowEmpty,
    disabled,
    hideSteppers,
    iconDescription,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    translateWithId,
    translationIds,
    id,
    name,
    ref,
    createEventDispatcher,
    Add: Add_default,
    Subtract: Subtract_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    EditOff: EditOff_default,
    defaultTranslations,
    dispatch,
    updateValue,
    parse,
    onInput,
    onChange,
    ariaLabel,
    errorId,
    error,
    decrementLabel,
    incrementLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(49, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("step" in $$props)
      $$invalidate(3, step = $$new_props.step);
    if ("max" in $$props)
      $$invalidate(4, max = $$new_props.max);
    if ("min" in $$props)
      $$invalidate(5, min = $$new_props.min);
    if ("light" in $$props)
      $$invalidate(6, light = $$new_props.light);
    if ("readonly" in $$props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("allowEmpty" in $$props)
      $$invalidate(30, allowEmpty = $$new_props.allowEmpty);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("hideSteppers" in $$props)
      $$invalidate(9, hideSteppers = $$new_props.hideSteppers);
    if ("iconDescription" in $$props)
      $$invalidate(10, iconDescription = $$new_props.iconDescription);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("helperText" in $$props)
      $$invalidate(15, helperText = $$new_props.helperText);
    if ("label" in $$props)
      $$invalidate(16, label = $$new_props.label);
    if ("hideLabel" in $$props)
      $$invalidate(17, hideLabel = $$new_props.hideLabel);
    if ("translateWithId" in $$props)
      $$invalidate(31, translateWithId = $$new_props.translateWithId);
    if ("id" in $$props)
      $$invalidate(18, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(19, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("ariaLabel" in $$props)
      $$invalidate(20, ariaLabel = $$new_props.ariaLabel);
    if ("errorId" in $$props)
      $$invalidate(21, errorId = $$new_props.errorId);
    if ("error" in $$props)
      $$invalidate(22, error = $$new_props.error);
    if ("decrementLabel" in $$props)
      $$invalidate(23, decrementLabel = $$new_props.decrementLabel);
    if ("incrementLabel" in $$props)
      $$invalidate(24, incrementLabel = $$new_props.incrementLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 1) {
      $:
        $$invalidate(24, incrementLabel = translateWithId("increment"));
    }
    if ($$self.$$.dirty[1] & 1) {
      $:
        $$invalidate(23, decrementLabel = translateWithId("decrement"));
    }
    if ($$self.$$.dirty[0] & 1073743921) {
      $:
        $$invalidate(22, error = invalid || !allowEmpty && value == null || value > max || typeof value === "number" && value < min);
    }
    if ($$self.$$.dirty[0] & 262144) {
      $:
        $$invalidate(21, errorId = `error-${id}`);
    }
    $:
      $$invalidate(20, ariaLabel = $$props["aria-label"] || "Numeric input field with increment and decrement buttons");
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    ref,
    size,
    step,
    max,
    min,
    light,
    readonly,
    disabled,
    hideSteppers,
    iconDescription,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    label,
    hideLabel,
    id,
    name,
    ariaLabel,
    errorId,
    error,
    decrementLabel,
    incrementLabel,
    updateValue,
    onInput,
    onChange,
    $$slots,
    $$restProps,
    allowEmpty,
    translateWithId,
    translationIds,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    click_handler_13,
    click_handler_2
  ];
}
var NumberInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance113,
      create_fragment113,
      safe_not_equal,
      {
        size: 2,
        value: 0,
        step: 3,
        max: 4,
        min: 5,
        light: 6,
        readonly: 7,
        allowEmpty: 30,
        disabled: 8,
        hideSteppers: 9,
        iconDescription: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        helperText: 15,
        label: 16,
        hideLabel: 17,
        translateWithId: 31,
        translationIds: 32,
        id: 18,
        name: 19,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberInput",
      options,
      id: create_fragment113.name
    });
  }
  get size() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowEmpty() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowEmpty(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideSteppers() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideSteppers(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateWithId() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateWithId(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationIds() {
    return this.$$.ctx[32];
  }
  set translationIds(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberInput_default = NumberInput;

// node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte
var file105 = "node_modules/carbon-components-svelte/src/NumberInput/NumberInputSkeleton.svelte";
function create_if_block68(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file105, 15, 4, 293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block68.name,
    type: "if",
    source: "(15:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment114(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !ctx[0] && create_if_block68(ctx);
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      toggle_class(div0, "bx--number", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file105, 17, 2, 370);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file105, 6, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block68(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment114.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance114($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberInputSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var NumberInputSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance114, create_fragment114, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberInputSkeleton",
      options,
      id: create_fragment114.name
    });
  }
  get hideLabel() {
    throw new Error("<NumberInputSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<NumberInputSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberInputSkeleton_default = NumberInputSkeleton;

// node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte
var file106 = "node_modules/carbon-components-svelte/src/OrderedList/OrderedList.svelte";
function create_fragment115(ctx) {
  let ol;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let ol_levels = [ctx[3]];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      set_attributes(ol, ol_data);
      toggle_class(ol, "bx--list--ordered", !ctx[1]);
      toggle_class(ol, "bx--list--ordered--native", ctx[1]);
      toggle_class(ol, "bx--list--nested", ctx[0]);
      toggle_class(ol, "bx--list--expressive", ctx[2]);
      add_location(ol, file106, 12, 0, 330);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ol, "click", ctx[6], false, false, false),
          listen_dev(ol, "mouseover", ctx[7], false, false, false),
          listen_dev(ol, "mouseenter", ctx[8], false, false, false),
          listen_dev(ol, "mouseleave", ctx[9], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [dirty & 8 && ctx2[3]]));
      toggle_class(ol, "bx--list--ordered", !ctx2[1]);
      toggle_class(ol, "bx--list--ordered--native", ctx2[1]);
      toggle_class(ol, "bx--list--nested", ctx2[0]);
      toggle_class(ol, "bx--list--expressive", ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ol);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment115.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance115($$self, $$props, $$invalidate) {
  const omit_props_names = ["nested", "native", "expressive"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrderedList", slots, ["default"]);
  let { nested = false } = $$props;
  let { native = false } = $$props;
  let { expressive = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("nested" in $$new_props)
      $$invalidate(0, nested = $$new_props.nested);
    if ("native" in $$new_props)
      $$invalidate(1, native = $$new_props.native);
    if ("expressive" in $$new_props)
      $$invalidate(2, expressive = $$new_props.expressive);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ nested, native, expressive });
  $$self.$inject_state = ($$new_props) => {
    if ("nested" in $$props)
      $$invalidate(0, nested = $$new_props.nested);
    if ("native" in $$props)
      $$invalidate(1, native = $$new_props.native);
    if ("expressive" in $$props)
      $$invalidate(2, expressive = $$new_props.expressive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nested,
    native,
    expressive,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var OrderedList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance115, create_fragment115, safe_not_equal, { nested: 0, native: 1, expressive: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrderedList",
      options,
      id: create_fragment115.name
    });
  }
  get nested() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get native() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set native(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<OrderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<OrderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrderedList_default = OrderedList;

// node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte
var file107 = "node_modules/carbon-components-svelte/src/icons/CaretLeft.svelte";
function create_if_block69(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file107, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block69.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment116(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block69(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M20 24L10 16 20 8z");
      add_location(path, file107, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file107, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block69(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment116.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance116($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretLeft", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance116, create_fragment116, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretLeft",
      options,
      id: create_fragment116.name
    });
  }
  get size() {
    throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretLeft_default = CaretLeft;

// node_modules/carbon-components-svelte/src/Select/Select.svelte
var file108 = "node_modules/carbon-components-svelte/src/Select/Select.svelte";
var get_labelText_slot_changes8 = (dirty) => ({});
var get_labelText_slot_context8 = (ctx) => ({});
function create_if_block_102(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[26].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[25], get_labelText_slot_context8);
  const labelText_slot_or_fallback = labelText_slot || fallback_block23(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[5]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[14]);
      toggle_class(label, "bx--label--disabled", ctx[4]);
      add_location(label, file108, 136, 6, 3392);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(labelText_slot_template, ctx2[25], dirty, get_labelText_slot_changes8),
            get_labelText_slot_context8
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 8192)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 32) {
        attr_dev(label, "for", ctx2[5]);
      }
      if (!current || dirty[0] & 16384) {
        toggle_class(label, "bx--visually-hidden", ctx2[14]);
      }
      if (!current || dirty[0] & 16) {
        toggle_class(label, "bx--label--disabled", ctx2[4]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(136:4) {#if !noLabel}",
    ctx
  });
  return block;
}
function fallback_block23(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[13]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8192)
        set_data_dev(t, ctx2[13]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block23.name,
    type: "fallback",
    source: "(143:31)            ",
    ctx
  });
  return block;
}
function create_if_block_68(ctx) {
  let div1;
  let div0;
  let select;
  let select_aria_describedby_value;
  let select_aria_invalid_value;
  let select_disabled_value;
  let select_required_value;
  let t0;
  let chevrondown;
  let t1;
  let div0_data_invalid_value;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[26].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = ctx[7] && create_if_block_93(ctx);
  let if_block1 = ctx[7] && create_if_block_83(ctx);
  let if_block2 = ctx[11] && create_if_block_74(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      select = element("select");
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr_dev(select, "aria-describedby", select_aria_describedby_value = ctx[7] ? ctx[16] : void 0);
      attr_dev(select, "aria-invalid", select_aria_invalid_value = ctx[7] || void 0);
      select.disabled = select_disabled_value = ctx[4] || void 0;
      select.required = select_required_value = ctx[15] || void 0;
      attr_dev(select, "id", ctx[5]);
      attr_dev(select, "name", ctx[6]);
      toggle_class(select, "bx--select-input", true);
      toggle_class(select, "bx--select-input--sm", ctx[1] === "sm");
      toggle_class(select, "bx--select-input--xl", ctx[1] === "xl");
      add_location(select, file108, 153, 10, 3859);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = ctx[7] || void 0);
      toggle_class(div0, "bx--select-input__wrapper", true);
      add_location(div0, file108, 149, 8, 3735);
      toggle_class(div1, "bx--select-input--inline__wrapper", true);
      add_location(div1, file108, 148, 6, 3672);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[33](select);
      append_dev(div0, t0);
      mount_component(chevrondown, div0, null);
      append_dev(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      insert_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(select, "change", ctx[21], false, false, false),
          listen_dev(select, "input", ctx[30], false, false, false),
          listen_dev(select, "focus", ctx[31], false, false, false),
          listen_dev(select, "blur", ctx[32], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 65664 && select_aria_describedby_value !== (select_aria_describedby_value = ctx2[7] ? ctx2[16] : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & 128 && select_aria_invalid_value !== (select_aria_invalid_value = ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & 16 && select_disabled_value !== (select_disabled_value = ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & 32768 && select_required_value !== (select_required_value = ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(select, "id", ctx2[5]);
      }
      if (!current || dirty[0] & 64) {
        attr_dev(select, "name", ctx2[6]);
      }
      if (!current || dirty[0] & 2) {
        toggle_class(select, "bx--select-input--sm", ctx2[1] === "sm");
      }
      if (!current || dirty[0] & 2) {
        toggle_class(select, "bx--select-input--xl", ctx2[1] === "xl");
      }
      if (ctx2[7]) {
        if (if_block0) {
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_93(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 128 && div0_data_invalid_value !== (div0_data_invalid_value = ctx2[7] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_83(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_74(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[33](null);
      destroy_component(chevrondown);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach_dev(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_68.name,
    type: "if",
    source: "(148:4) {#if inline}",
    ctx
  });
  return block;
}
function create_if_block_93(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_93.name,
    type: "if",
    source: "(173:10) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_83(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[8]);
      attr_dev(div, "id", ctx[16]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 177, 10, 4666);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data_dev(t, ctx2[8]);
      if (dirty[0] & 65536) {
        attr_dev(div, "id", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_83.name,
    type: "if",
    source: "(177:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_74(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[4]);
      add_location(div, file108, 183, 8, 4824);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
      if (dirty[0] & 16) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[4]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_74.name,
    type: "if",
    source: "(183:6) {#if helperText}",
    ctx
  });
  return block;
}
function create_if_block70(ctx) {
  let div;
  let select;
  let select_aria_describedby_value;
  let select_disabled_value;
  let select_required_value;
  let select_aria_invalid_value;
  let t0;
  let chevrondown;
  let t1;
  let t2;
  let div_data_invalid_value;
  let t3;
  let t4;
  let t5;
  let if_block4_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[26].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = ctx[7] && create_if_block_59(ctx);
  let if_block1 = !ctx[7] && ctx[9] && create_if_block_411(ctx);
  let if_block2 = !ctx[7] && ctx[11] && create_if_block_313(ctx);
  let if_block3 = ctx[7] && create_if_block_218(ctx);
  let if_block4 = !ctx[7] && ctx[9] && create_if_block_127(ctx);
  const block = {
    c: function create() {
      div = element("div");
      select = element("select");
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      attr_dev(select, "id", ctx[5]);
      attr_dev(select, "name", ctx[6]);
      attr_dev(select, "aria-describedby", select_aria_describedby_value = ctx[7] ? ctx[16] : void 0);
      select.disabled = select_disabled_value = ctx[4] || void 0;
      select.required = select_required_value = ctx[15] || void 0;
      attr_dev(select, "aria-invalid", select_aria_invalid_value = ctx[7] || void 0);
      toggle_class(select, "bx--select-input", true);
      toggle_class(select, "bx--select-input--sm", ctx[1] === "sm");
      toggle_class(select, "bx--select-input--xl", ctx[1] === "xl");
      add_location(select, file108, 196, 8, 5147);
      attr_dev(div, "data-invalid", div_data_invalid_value = ctx[7] || void 0);
      toggle_class(div, "bx--select-input__wrapper", true);
      add_location(div, file108, 192, 6, 5031);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[34](select);
      append_dev(div, t0);
      mount_component(chevrondown, div, null);
      append_dev(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      insert_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_dev(target, if_block4_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(select, "change", ctx[21], false, false, false),
          listen_dev(select, "input", ctx[27], false, false, false),
          listen_dev(select, "focus", ctx[28], false, false, false),
          listen_dev(select, "blur", ctx[29], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(default_slot_template, ctx2[25], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 32) {
        attr_dev(select, "id", ctx2[5]);
      }
      if (!current || dirty[0] & 64) {
        attr_dev(select, "name", ctx2[6]);
      }
      if (!current || dirty[0] & 65664 && select_aria_describedby_value !== (select_aria_describedby_value = ctx2[7] ? ctx2[16] : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & 16 && select_disabled_value !== (select_disabled_value = ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & 32768 && select_required_value !== (select_required_value = ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & 128 && select_aria_invalid_value !== (select_aria_invalid_value = ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & 2) {
        toggle_class(select, "bx--select-input--sm", ctx2[1] === "sm");
      }
      if (!current || dirty[0] & 2) {
        toggle_class(select, "bx--select-input--xl", ctx2[1] === "xl");
      }
      if (ctx2[7]) {
        if (if_block0) {
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_59(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[7] && ctx2[9]) {
        if (if_block1) {
          if (dirty[0] & 640) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_411(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 128 && div_data_invalid_value !== (div_data_invalid_value = ctx2[7] || void 0)) {
        attr_dev(div, "data-invalid", div_data_invalid_value);
      }
      if (!ctx2[7] && ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_313(ctx2);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[7]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_218(ctx2);
          if_block3.c();
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!ctx2[7] && ctx2[9]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_127(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[34](null);
      destroy_component(chevrondown);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach_dev(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t4);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach_dev(t5);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach_dev(if_block4_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block70.name,
    type: "if",
    source: "(192:4) {#if !inline}",
    ctx
  });
  return block;
}
function create_if_block_59(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_59.name,
    type: "if",
    source: "(216:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_411(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--select__invalid-icon bx--select__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_411.name,
    type: "if",
    source: "(219:8) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_313(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[4]);
      add_location(div, file108, 225, 8, 6086);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
      if (dirty[0] & 16) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[4]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_313.name,
    type: "if",
    source: "(225:6) {#if !invalid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_218(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[8]);
      attr_dev(div, "id", ctx[16]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 233, 8, 6287);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data_dev(t, ctx2[8]);
      if (dirty[0] & 65536) {
        attr_dev(div, "id", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_218.name,
    type: "if",
    source: "(233:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_127(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[10]);
      attr_dev(div, "id", ctx[16]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file108, 238, 8, 6432);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1024)
        set_data_dev(t, ctx2[10]);
      if (dirty[0] & 65536) {
        attr_dev(div, "id", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_127.name,
    type: "if",
    source: "(238:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment117(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  let if_block0 = !ctx[12] && create_if_block_102(ctx);
  let if_block1 = ctx[2] && create_if_block_68(ctx);
  let if_block2 = !ctx[2] && create_if_block70(ctx);
  let div1_levels = [ctx[22]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      toggle_class(div0, "bx--select", true);
      toggle_class(div0, "bx--select--inline", ctx[2]);
      toggle_class(div0, "bx--select--light", ctx[3]);
      toggle_class(div0, "bx--select--invalid", ctx[7]);
      toggle_class(div0, "bx--select--disabled", ctx[4]);
      toggle_class(div0, "bx--select--warning", ctx[9]);
      add_location(div0, file108, 127, 2, 3125);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file108, 126, 0, 3071);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[12]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_102(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_68(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block70(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4) {
        toggle_class(div0, "bx--select--inline", ctx2[2]);
      }
      if (!current || dirty[0] & 8) {
        toggle_class(div0, "bx--select--light", ctx2[3]);
      }
      if (!current || dirty[0] & 128) {
        toggle_class(div0, "bx--select--invalid", ctx2[7]);
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div0, "bx--select--disabled", ctx2[4]);
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div0, "bx--select--warning", ctx2[9]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty[0] & 4194304 && ctx2[22]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment117.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance117($$self, $$props, $$invalidate) {
  let errorId;
  const omit_props_names = [
    "selected",
    "size",
    "inline",
    "light",
    "disabled",
    "id",
    "name",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "noLabel",
    "labelText",
    "hideLabel",
    "ref",
    "required"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $defaultValue;
  let $selectedValue;
  let $itemTypesByValue;
  let $defaultSelectId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["labelText", "default"]);
  let { selected = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { inline = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { noLabel = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { ref = null } = $$props;
  let { required = false } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(36, $selectedValue = value));
  const defaultSelectId = writable(null);
  validate_store(defaultSelectId, "defaultSelectId");
  component_subscribe($$self, defaultSelectId, (value) => $$invalidate(38, $defaultSelectId = value));
  const defaultValue = writable(null);
  validate_store(defaultValue, "defaultValue");
  component_subscribe($$self, defaultValue, (value) => $$invalidate(24, $defaultValue = value));
  const itemTypesByValue = writable({});
  validate_store(itemTypesByValue, "itemTypesByValue");
  component_subscribe($$self, itemTypesByValue, (value) => $$invalidate(37, $itemTypesByValue = value));
  setContext("Select", {
    selectedValue,
    setDefaultValue: (id2, value) => {
      if ($defaultValue === null) {
        defaultSelectId.set(id2);
        defaultValue.set(value);
      } else {
        if ($defaultSelectId === id2) {
          selectedValue.set(value);
        }
      }
      itemTypesByValue.update((types) => ({ ...types, [value]: typeof value }));
    }
  });
  const handleChange = ({ target }) => {
    let value = target.value;
    if ($itemTypesByValue[value] === "number") {
      value = Number(value);
    }
    selectedValue.set(value);
  };
  let prevSelected = void 0;
  afterUpdate(() => {
    $$invalidate(23, selected = $selectedValue);
    if (prevSelected !== void 0 && selected !== prevSelected) {
      dispatch("change", $selectedValue);
    }
    prevSelected = selected;
  });
  function input_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function select_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$new_props)
      $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$new_props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$new_props)
      $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$new_props)
      $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$new_props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$new_props)
      $$invalidate(15, required = $$new_props.required);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    ref,
    required,
    createEventDispatcher,
    setContext,
    afterUpdate,
    writable,
    ChevronDown: ChevronDown_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    dispatch,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    prevSelected,
    errorId,
    $defaultValue,
    $selectedValue,
    $itemTypesByValue,
    $defaultSelectId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$props)
      $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$props)
      $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$props)
      $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$props)
      $$invalidate(15, required = $$new_props.required);
    if ("prevSelected" in $$props)
      prevSelected = $$new_props.prevSelected;
    if ("errorId" in $$props)
      $$invalidate(16, errorId = $$new_props.errorId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 32) {
      $:
        $$invalidate(16, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & 25165824) {
      $:
        selectedValue.set(selected != null ? selected : $defaultValue);
    }
  };
  return [
    ref,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    required,
    errorId,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    $$restProps,
    selected,
    $defaultValue,
    $$scope,
    slots,
    input_handler_1,
    focus_handler_1,
    blur_handler_1,
    input_handler,
    focus_handler,
    blur_handler,
    select_binding,
    select_binding_1
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance117,
      create_fragment117,
      safe_not_equal,
      {
        selected: 23,
        size: 1,
        inline: 2,
        light: 3,
        disabled: 4,
        id: 5,
        name: 6,
        invalid: 7,
        invalidText: 8,
        warn: 9,
        warnText: 10,
        helperText: 11,
        noLabel: 12,
        labelText: 13,
        hideLabel: 14,
        ref: 0,
        required: 15
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment117.name
    });
  }
  get selected() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/carbon-components-svelte/src/Select/SelectItem.svelte
var file109 = "node_modules/carbon-components-svelte/src/Select/SelectItem.svelte";
function create_fragment118(ctx) {
  let option;
  let t_value = (ctx[1] || ctx[0]) + "";
  let t;
  let option_class_value;
  let option_style_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[0];
      option.value = option.__value;
      option.disabled = ctx[3];
      option.hidden = ctx[2];
      option.selected = ctx[4];
      attr_dev(option, "class", option_class_value = ctx[5].class);
      attr_dev(option, "style", option_style_value = ctx[5].style);
      toggle_class(option, "bx--select-option", true);
      add_location(option, file109, 34, 0, 732);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[1] || ctx2[0]) + ""))
        set_data_dev(t, t_value);
      if (dirty & 1) {
        prop_dev(option, "__value", ctx2[0]);
        option.value = option.__value;
      }
      if (dirty & 8) {
        prop_dev(option, "disabled", ctx2[3]);
      }
      if (dirty & 4) {
        prop_dev(option, "hidden", ctx2[2]);
      }
      if (dirty & 16) {
        prop_dev(option, "selected", ctx2[4]);
      }
      if (dirty & 32 && option_class_value !== (option_class_value = ctx2[5].class)) {
        attr_dev(option, "class", option_class_value);
      }
      if (dirty & 32 && option_style_value !== (option_style_value = ctx2[5].style)) {
        attr_dev(option, "style", option_style_value);
      }
      if (dirty & 32) {
        toggle_class(option, "bx--select-option", true);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment118.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance118($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "text", "hidden", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItem", slots, []);
  let { value = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { hidden = false } = $$props;
  let { disabled = false } = $$props;
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("Select") || getContext("TimePickerSelect");
  let selected = false;
  const unsubscribe = ctx.selectedValue.subscribe((currentValue) => {
    $$invalidate(4, selected = currentValue === value);
  });
  onMount(() => {
    return () => unsubscribe();
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("hidden" in $$new_props)
      $$invalidate(2, hidden = $$new_props.hidden);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
  };
  $$self.$capture_state = () => ({
    value,
    text: text2,
    hidden,
    disabled,
    getContext,
    onMount,
    id,
    ctx,
    selected,
    unsubscribe
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("hidden" in $$props)
      $$invalidate(2, hidden = $$new_props.hidden);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 1) {
      $:
        (_a = ctx == null ? void 0 : ctx.setDefaultValue) == null ? void 0 : _a.call(ctx, id, value);
    }
  };
  return [value, text2, hidden, disabled, selected, $$restProps];
}
var SelectItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance118, create_fragment118, safe_not_equal, {
      value: 0,
      text: 1,
      hidden: 2,
      disabled: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItem",
      options,
      id: create_fragment118.name
    });
  }
  get value() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItem_default = SelectItem;

// node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte
var file110 = "node_modules/carbon-components-svelte/src/Pagination/Pagination.svelte";
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
function create_if_block_314(ctx) {
  let label;
  let t0;
  let label_id_value;
  let label_for_value;
  let t1;
  let select;
  let updating_selected;
  let current;
  function select_selected_binding(value) {
    ctx[22](value);
  }
  let select_props = {
    id: "bx--pagination-select-" + ctx[14],
    class: "bx--select__item-count",
    hideLabel: true,
    noLabel: true,
    inline: true,
    $$slots: { default: [create_default_slot_17] },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    select_props.selected = ctx[1];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selected", select_selected_binding));
  const block = {
    c: function create() {
      label = element("label");
      t0 = text(ctx[5]);
      t1 = space();
      create_component(select.$$.fragment);
      attr_dev(label, "id", label_id_value = "bx--pagination-select-" + ctx[14] + "-count-label");
      attr_dev(label, "for", label_for_value = "bx--pagination-select-" + ctx[14]);
      toggle_class(label, "bx--pagination__text", true);
      add_location(label, file110, 98, 6, 2889);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, t0);
      insert_dev(target, t1, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 32)
        set_data_dev(t0, ctx2[5]);
      if (!current || dirty & 16384 && label_id_value !== (label_id_value = "bx--pagination-select-" + ctx2[14] + "-count-label")) {
        attr_dev(label, "id", label_id_value);
      }
      if (!current || dirty & 16384 && label_for_value !== (label_for_value = "bx--pagination-select-" + ctx2[14])) {
        attr_dev(label, "for", label_for_value);
      }
      const select_changes = {};
      if (dirty & 16384)
        select_changes.id = "bx--pagination-select-" + ctx2[14];
      if (dirty & 1073742848) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty & 2) {
        updating_selected = true;
        select_changes.selected = ctx2[1];
        add_flush_callback(() => updating_selected = false);
      }
      select.$set(select_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (detaching)
        detach_dev(t1);
      destroy_component(select, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_314.name,
    type: "if",
    source: "(98:4) {#if !pageSizeInputDisabled}",
    ctx
  });
  return block;
}
function create_each_block_13(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: ctx[26],
      text: ctx[26].toString()
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty & 1024)
        selectitem_changes.value = ctx[26];
      if (dirty & 1024)
        selectitem_changes.text = ctx[26].toString();
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(114:8) {#each pageSizes as size, i (size)}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[10];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[26];
  validate_each_keys(ctx, each_value_1, get_each_context_13, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_13(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_13(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1024) {
        each_value_1 = ctx2[10];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_13, each_1_anchor, get_each_context_13);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: '(106:6) <Select         id=\\"bx--pagination-select-{id}\\"         class=\\"bx--select__item-count\\"         hideLabel         noLabel         inline         bind:selected=\\"{pageSize}\\"       >',
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let t_value = ctx[7](Math.min(ctx[1] * (ctx[0] - 1) + 1, ctx[2]), Math.min(ctx[0] * ctx[1], ctx[2]), ctx[2]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 135 && t_value !== (t_value = ctx2[7](Math.min(ctx2[1] * (ctx2[0] - 1) + 1, ctx2[2]), Math.min(ctx2[0] * ctx2[1], ctx2[2]), ctx2[2]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(122:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_219(ctx) {
  let t_value = ctx[6](ctx[1] * (ctx[0] - 1) + 1, ctx[0] * ctx[1]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 67 && t_value !== (t_value = ctx2[6](ctx2[1] * (ctx2[0] - 1) + 1, ctx2[0] * ctx2[1]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_219.name,
    type: "if",
    source: "(120:6) {#if pagesUnknown}",
    ctx
  });
  return block;
}
function create_if_block71(ctx) {
  let select;
  let updating_selected;
  let t;
  let span;
  let current;
  function select_selected_binding_1(value) {
    ctx[23](value);
  }
  let select_props = {
    id: "bx--pagination-select-" + (ctx[14] + 2),
    class: "bx--select__page-number",
    labelText: "Page number, of " + ctx[15] + " pages",
    inline: true,
    hideLabel: true,
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    select_props.selected = ctx[0];
  }
  select = new Select_default({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selected", select_selected_binding_1));
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[11])
      return create_if_block_128;
    return create_else_block24;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      create_component(select.$$.fragment);
      t = space();
      span = element("span");
      if_block.c();
      toggle_class(span, "bx--pagination__text", true);
      add_location(span, file110, 144, 6, 4241);
    },
    m: function mount(target, anchor) {
      mount_component(select, target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, span, anchor);
      if_block.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 16384)
        select_changes.id = "bx--pagination-select-" + (ctx2[14] + 2);
      if (dirty & 32768)
        select_changes.labelText = "Page number, of " + ctx2[15] + " pages";
      if (dirty & 1074003968) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        select_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      select.$set(select_changes);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(select, detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(span);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block71.name,
    type: "if",
    source: "(132:4) {#if !pageInputDisabled}",
    ctx
  });
  return block;
}
function create_each_block13(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: ctx[26] + 1,
      text: (ctx[26] + 1).toString()
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty & 262144)
        selectitem_changes.value = ctx[26] + 1;
      if (dirty & 262144)
        selectitem_changes.text = (ctx[26] + 1).toString();
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block13.name,
    type: "each",
    source: "(141:8) {#each selectItems as size, i (size)}",
    ctx
  });
  return block;
}
function create_default_slot17(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[18];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[26];
  validate_each_keys(ctx, each_value, get_each_context13, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context13(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block13(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 262144) {
        each_value = ctx2[18];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context13, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block13, each_1_anchor, get_each_context13);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: '(133:6) <Select         id=\\"bx--pagination-select-{id + 2}\\"         class=\\"bx--select__page-number\\"         labelText=\\"Page number, of {totalPages} pages\\"         inline         hideLabel         bind:selected=\\"{page}\\"       >',
    ctx
  });
  return block;
}
function create_else_block24(ctx) {
  let t_value = ctx[13](ctx[0], ctx[15]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 40961 && t_value !== (t_value = ctx2[13](ctx2[0], ctx2[15]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(148:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_128(ctx) {
  let t_value = ctx[12](ctx[0]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4097 && t_value !== (t_value = ctx2[12](ctx2[0]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_128.name,
    type: "if",
    source: "(146:8) {#if pagesUnknown}",
    ctx
  });
  return block;
}
function create_fragment119(ctx) {
  let div2;
  let div0;
  let t0;
  let span;
  let t1;
  let div1;
  let t2;
  let button0;
  let t3;
  let button1;
  let current;
  let if_block0 = !ctx[9] && create_if_block_314(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[11])
      return create_if_block_219;
    return create_else_block_13;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  let if_block2 = !ctx[8] && create_if_block71(ctx);
  button0 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: "top",
      icon: CaretLeft_default,
      iconDescription: ctx[4],
      disabled: ctx[17],
      class: "bx--pagination__button bx--pagination__button--backward " + (ctx[17] ? "bx--pagination__button--no-index" : "")
    },
    $$inline: true
  });
  button0.$on("click", ctx[24]);
  button1 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "end",
      tooltipPosition: "top",
      icon: CaretRight_default,
      iconDescription: ctx[3],
      disabled: ctx[16],
      class: "bx--pagination__button bx--pagination__button--forward " + (ctx[16] ? "bx--pagination__button--no-index" : "")
    },
    $$inline: true
  });
  button1.$on("click", ctx[25]);
  let div2_levels = [{ id: ctx[14] }, ctx[20]];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if_block1.c();
      t1 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
      toggle_class(span, "bx--pagination__text", !ctx[9]);
      add_location(span, file110, 118, 4, 3423);
      toggle_class(div0, "bx--pagination__left", true);
      add_location(div0, file110, 96, 2, 2808);
      toggle_class(div1, "bx--pagination__right", true);
      add_location(div1, file110, 130, 2, 3785);
      set_attributes(div2, div2_data);
      toggle_class(div2, "bx--pagination", true);
      add_location(div2, file110, 95, 0, 2743);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t0);
      append_dev(div0, span);
      if_block1.m(span, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t2);
      mount_component(button0, div1, null);
      append_dev(div1, t3);
      mount_component(button1, div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_314(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(span, null);
        }
      }
      if (!current || dirty & 512) {
        toggle_class(span, "bx--pagination__text", !ctx2[9]);
      }
      if (!ctx2[8]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block71(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const button0_changes = {};
      if (dirty & 16)
        button0_changes.iconDescription = ctx2[4];
      if (dirty & 131072)
        button0_changes.disabled = ctx2[17];
      if (dirty & 131072)
        button0_changes.class = "bx--pagination__button bx--pagination__button--backward " + (ctx2[17] ? "bx--pagination__button--no-index" : "");
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 8)
        button1_changes.iconDescription = ctx2[3];
      if (dirty & 65536)
        button1_changes.disabled = ctx2[16];
      if (dirty & 65536)
        button1_changes.class = "bx--pagination__button bx--pagination__button--forward " + (ctx2[16] ? "bx--pagination__button--no-index" : "");
      button1.$set(button1_changes);
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & 16384) && { id: ctx2[14] },
        dirty & 1048576 && ctx2[20]
      ]));
      toggle_class(div2, "bx--pagination", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(button0);
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment119.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance119($$self, $$props, $$invalidate) {
  let totalPages;
  let selectItems;
  let backButtonDisabled;
  let forwardButtonDisabled;
  const omit_props_names = [
    "page",
    "totalItems",
    "disabled",
    "forwardText",
    "backwardText",
    "itemsPerPageText",
    "itemText",
    "itemRangeText",
    "pageInputDisabled",
    "pageSizeInputDisabled",
    "pageSize",
    "pageSizes",
    "pagesUnknown",
    "pageText",
    "pageRangeText",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  let { page = 1 } = $$props;
  let { totalItems = 0 } = $$props;
  let { disabled = false } = $$props;
  let { forwardText = "Next page" } = $$props;
  let { backwardText = "Previous page" } = $$props;
  let { itemsPerPageText = "Items per page:" } = $$props;
  let { itemText = (min, max) => `${min}\u2013${max} item${max === 1 ? "" : "s"}` } = $$props;
  let { itemRangeText = (min, max, total) => `${min}\u2013${max} of ${total} item${max === 1 ? "" : "s"}` } = $$props;
  let { pageInputDisabled = false } = $$props;
  let { pageSizeInputDisabled = false } = $$props;
  let { pageSize = 10 } = $$props;
  let { pageSizes = [10] } = $$props;
  let { pagesUnknown = false } = $$props;
  let { pageText = (page2) => `page ${page2}` } = $$props;
  let { pageRangeText = (current, total) => `of ${total} page${total === 1 ? "" : "s"}` } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const dispatch = createEventDispatcher();
  afterUpdate(() => {
    if (page > totalPages) {
      $$invalidate(0, page = totalPages);
    }
  });
  function select_selected_binding(value) {
    pageSize = value;
    $$invalidate(1, pageSize);
  }
  function select_selected_binding_1(value) {
    page = value;
    $$invalidate(0, page);
  }
  const click_handler = () => {
    $$invalidate(0, page--, page);
    dispatch("click:button--previous", { page });
  };
  const click_handler_13 = () => {
    $$invalidate(0, page++, page);
    dispatch("click:button--next", { page });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("page" in $$new_props)
      $$invalidate(0, page = $$new_props.page);
    if ("totalItems" in $$new_props)
      $$invalidate(2, totalItems = $$new_props.totalItems);
    if ("disabled" in $$new_props)
      $$invalidate(21, disabled = $$new_props.disabled);
    if ("forwardText" in $$new_props)
      $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$new_props)
      $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("itemsPerPageText" in $$new_props)
      $$invalidate(5, itemsPerPageText = $$new_props.itemsPerPageText);
    if ("itemText" in $$new_props)
      $$invalidate(6, itemText = $$new_props.itemText);
    if ("itemRangeText" in $$new_props)
      $$invalidate(7, itemRangeText = $$new_props.itemRangeText);
    if ("pageInputDisabled" in $$new_props)
      $$invalidate(8, pageInputDisabled = $$new_props.pageInputDisabled);
    if ("pageSizeInputDisabled" in $$new_props)
      $$invalidate(9, pageSizeInputDisabled = $$new_props.pageSizeInputDisabled);
    if ("pageSize" in $$new_props)
      $$invalidate(1, pageSize = $$new_props.pageSize);
    if ("pageSizes" in $$new_props)
      $$invalidate(10, pageSizes = $$new_props.pageSizes);
    if ("pagesUnknown" in $$new_props)
      $$invalidate(11, pagesUnknown = $$new_props.pagesUnknown);
    if ("pageText" in $$new_props)
      $$invalidate(12, pageText = $$new_props.pageText);
    if ("pageRangeText" in $$new_props)
      $$invalidate(13, pageRangeText = $$new_props.pageRangeText);
    if ("id" in $$new_props)
      $$invalidate(14, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({
    page,
    totalItems,
    disabled,
    forwardText,
    backwardText,
    itemsPerPageText,
    itemText,
    itemRangeText,
    pageInputDisabled,
    pageSizeInputDisabled,
    pageSize,
    pageSizes,
    pagesUnknown,
    pageText,
    pageRangeText,
    id,
    afterUpdate,
    createEventDispatcher,
    CaretLeft: CaretLeft_default,
    CaretRight: CaretRight_default,
    Button: Button_default,
    Select: Select_default,
    SelectItem: SelectItem_default,
    dispatch,
    totalPages,
    forwardButtonDisabled,
    backButtonDisabled,
    selectItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("page" in $$props)
      $$invalidate(0, page = $$new_props.page);
    if ("totalItems" in $$props)
      $$invalidate(2, totalItems = $$new_props.totalItems);
    if ("disabled" in $$props)
      $$invalidate(21, disabled = $$new_props.disabled);
    if ("forwardText" in $$props)
      $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$props)
      $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("itemsPerPageText" in $$props)
      $$invalidate(5, itemsPerPageText = $$new_props.itemsPerPageText);
    if ("itemText" in $$props)
      $$invalidate(6, itemText = $$new_props.itemText);
    if ("itemRangeText" in $$props)
      $$invalidate(7, itemRangeText = $$new_props.itemRangeText);
    if ("pageInputDisabled" in $$props)
      $$invalidate(8, pageInputDisabled = $$new_props.pageInputDisabled);
    if ("pageSizeInputDisabled" in $$props)
      $$invalidate(9, pageSizeInputDisabled = $$new_props.pageSizeInputDisabled);
    if ("pageSize" in $$props)
      $$invalidate(1, pageSize = $$new_props.pageSize);
    if ("pageSizes" in $$props)
      $$invalidate(10, pageSizes = $$new_props.pageSizes);
    if ("pagesUnknown" in $$props)
      $$invalidate(11, pagesUnknown = $$new_props.pagesUnknown);
    if ("pageText" in $$props)
      $$invalidate(12, pageText = $$new_props.pageText);
    if ("pageRangeText" in $$props)
      $$invalidate(13, pageRangeText = $$new_props.pageRangeText);
    if ("id" in $$props)
      $$invalidate(14, id = $$new_props.id);
    if ("totalPages" in $$props)
      $$invalidate(15, totalPages = $$new_props.totalPages);
    if ("forwardButtonDisabled" in $$props)
      $$invalidate(16, forwardButtonDisabled = $$new_props.forwardButtonDisabled);
    if ("backButtonDisabled" in $$props)
      $$invalidate(17, backButtonDisabled = $$new_props.backButtonDisabled);
    if ("selectItems" in $$props)
      $$invalidate(18, selectItems = $$new_props.selectItems);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        dispatch("update", { pageSize, page });
    }
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(15, totalPages = Math.max(Math.ceil(totalItems / pageSize), 1));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(18, selectItems = Array.from({ length: totalPages }, (_, i) => i));
    }
    if ($$self.$$.dirty & 2097153) {
      $:
        $$invalidate(17, backButtonDisabled = disabled || page === 1);
    }
    if ($$self.$$.dirty & 2129921) {
      $:
        $$invalidate(16, forwardButtonDisabled = disabled || page === totalPages);
    }
  };
  return [
    page,
    pageSize,
    totalItems,
    forwardText,
    backwardText,
    itemsPerPageText,
    itemText,
    itemRangeText,
    pageInputDisabled,
    pageSizeInputDisabled,
    pageSizes,
    pagesUnknown,
    pageText,
    pageRangeText,
    id,
    totalPages,
    forwardButtonDisabled,
    backButtonDisabled,
    selectItems,
    dispatch,
    $$restProps,
    disabled,
    select_selected_binding,
    select_selected_binding_1,
    click_handler,
    click_handler_13
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance119, create_fragment119, safe_not_equal, {
      page: 0,
      totalItems: 2,
      disabled: 21,
      forwardText: 3,
      backwardText: 4,
      itemsPerPageText: 5,
      itemText: 6,
      itemRangeText: 7,
      pageInputDisabled: 8,
      pageSizeInputDisabled: 9,
      pageSize: 1,
      pageSizes: 10,
      pagesUnknown: 11,
      pageText: 12,
      pageRangeText: 13,
      id: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment119.name
    });
  }
  get page() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get totalItems() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set totalItems(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backwardText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backwardText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemsPerPageText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemsPerPageText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemRangeText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemRangeText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageInputDisabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageInputDisabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSizeInputDisabled() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSizeInputDisabled(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSize() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSize(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageSizes() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageSizes(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pagesUnknown() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pagesUnknown(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pageRangeText() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pageRangeText(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte
var file111 = "node_modules/carbon-components-svelte/src/Pagination/PaginationSkeleton.svelte";
function create_fragment120(ctx) {
  let div2;
  let div0;
  let skeletontext0;
  let t0;
  let skeletontext1;
  let t1;
  let skeletontext2;
  let t2;
  let div1;
  let skeletontext3;
  let current;
  let mounted;
  let dispose;
  skeletontext0 = new SkeletonText_default({ props: { width: "70px" }, $$inline: true });
  skeletontext1 = new SkeletonText_default({ props: { width: "35px" }, $$inline: true });
  skeletontext2 = new SkeletonText_default({
    props: { width: "105px" },
    $$inline: true
  });
  skeletontext3 = new SkeletonText_default({ props: { width: "70px" }, $$inline: true });
  let div2_levels = [ctx[0]];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      create_component(skeletontext0.$$.fragment);
      t0 = space();
      create_component(skeletontext1.$$.fragment);
      t1 = space();
      create_component(skeletontext2.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(skeletontext3.$$.fragment);
      toggle_class(div0, "bx--pagination__left", true);
      add_location(div0, file111, 14, 2, 291);
      toggle_class(div1, "bx--pagination__right", true);
      toggle_class(div1, "bx--pagination--inline", true);
      add_location(div1, file111, 19, 2, 447);
      set_attributes(div2, div2_data);
      toggle_class(div2, "bx--pagination", true);
      toggle_class(div2, "bx--skeleton", true);
      add_location(div2, file111, 5, 0, 143);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      mount_component(skeletontext0, div0, null);
      append_dev(div0, t0);
      mount_component(skeletontext1, div0, null);
      append_dev(div0, t1);
      mount_component(skeletontext2, div0, null);
      append_dev(div2, t2);
      append_dev(div2, div1);
      mount_component(skeletontext3, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "click", ctx[1], false, false, false),
          listen_dev(div2, "mouseover", ctx[2], false, false, false),
          listen_dev(div2, "mouseenter", ctx[3], false, false, false),
          listen_dev(div2, "mouseleave", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div2, "bx--pagination", true);
      toggle_class(div2, "bx--skeleton", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(skeletontext0.$$.fragment, local);
      transition_in(skeletontext1.$$.fragment, local);
      transition_in(skeletontext2.$$.fragment, local);
      transition_in(skeletontext3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skeletontext0.$$.fragment, local);
      transition_out(skeletontext1.$$.fragment, local);
      transition_out(skeletontext2.$$.fragment, local);
      transition_out(skeletontext3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_component(skeletontext0);
      destroy_component(skeletontext1);
      destroy_component(skeletontext2);
      destroy_component(skeletontext3);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment120.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance120($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  $$self.$capture_state = () => ({ SkeletonText: SkeletonText_default });
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var PaginationSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance120, create_fragment120, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationSkeleton",
      options,
      id: create_fragment120.name
    });
  }
};
var PaginationSkeleton_default = PaginationSkeleton;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte
var file112 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationItem.svelte";
function create_fragment121(ctx) {
  let li;
  let button;
  let span;
  let t0;
  let t1;
  let button_aria_current_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      span = element("span");
      if (default_slot)
        default_slot.c();
      t0 = space();
      t1 = text(ctx[0]);
      toggle_class(span, "bx--pagination-nav__accessibility-label", true);
      add_location(span, file112, 16, 4, 411);
      attr_dev(button, "data-page", ctx[0]);
      attr_dev(button, "aria-current", button_aria_current_value = ctx[1] ? "page" : void 0);
      toggle_class(button, "bx--pagination-nav__page", true);
      toggle_class(button, "bx--pagination-nav__page--active", ctx[1]);
      add_location(button, file112, 9, 2, 212);
      toggle_class(li, "bx--pagination-nav__list-item", true);
      add_location(li, file112, 8, 0, 160);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, button);
      append_dev(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_dev(button, t0);
      append_dev(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1)
        set_data_dev(t1, ctx2[0]);
      if (!current || dirty & 1) {
        attr_dev(button, "data-page", ctx2[0]);
      }
      if (!current || dirty & 2 && button_aria_current_value !== (button_aria_current_value = ctx2[1] ? "page" : void 0)) {
        attr_dev(button, "aria-current", button_aria_current_value);
      }
      if (!current || dirty & 2) {
        toggle_class(button, "bx--pagination-nav__page--active", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment121.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance121($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationItem", slots, ["default"]);
  let { page = 0 } = $$props;
  let { active = false } = $$props;
  const writable_props = ["page", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PaginationItem> was created with unknown prop '${key}'`);
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(0, page = $$props2.page);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ page, active });
  $$self.$inject_state = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(0, page = $$props2.page);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [page, active, $$scope, slots, click_handler];
}
var PaginationItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance121, create_fragment121, safe_not_equal, { page: 0, active: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationItem",
      options,
      id: create_fragment121.name
    });
  }
  get page() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationItem_default = PaginationItem;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte
var file113 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationOverflow.svelte";
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block_129(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: ctx[0] + 1,
      $$slots: { default: [create_default_slot18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on("click", ctx[5]);
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & 1)
        paginationitem_changes.page = ctx2[0] + 1;
      if (dirty & 512) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_129.name,
    type: "if",
    source: "(47:22) ",
    ctx
  });
  return block;
}
function create_if_block72(ctx) {
  let li;
  let div1;
  let select;
  let option;
  let t;
  let div0;
  let overflowmenuhorizontal;
  let current;
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[1] }, func5);
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block14(get_each_context14(ctx, each_value, i));
  }
  overflowmenuhorizontal = new OverflowMenuHorizontal_default({
    props: { class: "bx--pagination-nav__select-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      li = element("li");
      div1 = element("div");
      select = element("select");
      option = element("option");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div0 = element("div");
      create_component(overflowmenuhorizontal.$$.fragment);
      option.__value = "";
      option.value = option.__value;
      option.hidden = true;
      add_location(option, file113, 34, 8, 951);
      attr_dev(select, "aria-label", "Select Page number");
      toggle_class(select, "bx--pagination-nav__page", true);
      toggle_class(select, "bx--pagination-nav__page--select", true);
      add_location(select, file113, 24, 6, 624);
      toggle_class(div0, "bx--pagination-nav__select-icon-wrapper", true);
      add_location(div0, file113, 41, 6, 1214);
      toggle_class(div1, "bx--pagination-nav__select", true);
      add_location(div1, file113, 22, 4, 524);
      toggle_class(li, "bx--pagination-nav__list-item", true);
      add_location(li, file113, 21, 2, 470);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div1);
      append_dev(div1, select);
      append_dev(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[2]);
      append_dev(div1, t);
      append_dev(div1, div0);
      mount_component(overflowmenuhorizontal, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(select, "change", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3) {
        each_value = Array.from({ length: ctx2[1] }, func5);
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block14(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 7) {
        select_option(select, ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(overflowmenuhorizontal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(overflowmenuhorizontal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_each(each_blocks, detaching);
      destroy_component(overflowmenuhorizontal);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block72.name,
    type: "if",
    source: "(21:0) {#if count > 1}",
    ctx
  });
  return block;
}
function create_default_slot18(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Page");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: `(48:2) <PaginationItem     page=\\"{fromIndex + 1}\\"     on:click=\\"{() => {       dispatch('select', { index: fromIndex });     }}\\"   >`,
    ctx
  });
  return block;
}
function create_each_block14(ctx) {
  let option;
  let t0_value = ctx[0] + ctx[6] + 1 + "";
  let t0;
  let t1;
  let option_value_value;
  let option_data_page_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[0] + ctx[6];
      option.value = option.__value;
      attr_dev(option, "data-page", option_data_page_value = ctx[0] + ctx[6] + 1);
      add_location(option, file113, 36, 10, 1059);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t0);
      append_dev(option, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t0_value !== (t0_value = ctx2[0] + ctx2[6] + 1 + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 3 && option_value_value !== (option_value_value = ctx2[0] + ctx2[6])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (dirty & 3 && option_data_page_value !== (option_data_page_value = ctx2[0] + ctx2[6] + 1)) {
        attr_dev(option, "data-page", option_data_page_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block14.name,
    type: "each",
    source: "(36:8) {#each Array.from({ length: count }, (_, i) => i) as i}",
    ctx
  });
  return block;
}
function create_fragment122(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block72, create_if_block_129];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] > 1)
      return 0;
    if (ctx2[1] === 1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment122.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func5 = (_, i) => i;
function instance122($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationOverflow", slots, []);
  let { fromIndex = 0 } = $$props;
  let { count = 0 } = $$props;
  const dispatch = createEventDispatcher();
  let value = "";
  const writable_props = ["fromIndex", "count"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PaginationOverflow> was created with unknown prop '${key}'`);
  });
  const change_handler = ({ target }) => {
    $$invalidate(2, value = "");
    dispatch("select", { index: Number(target.value) });
  };
  const click_handler = () => {
    dispatch("select", { index: fromIndex });
  };
  $$self.$$set = ($$props2) => {
    if ("fromIndex" in $$props2)
      $$invalidate(0, fromIndex = $$props2.fromIndex);
    if ("count" in $$props2)
      $$invalidate(1, count = $$props2.count);
  };
  $$self.$capture_state = () => ({
    fromIndex,
    count,
    createEventDispatcher,
    OverflowMenuHorizontal: OverflowMenuHorizontal_default,
    PaginationItem: PaginationItem_default,
    dispatch,
    value
  });
  $$self.$inject_state = ($$props2) => {
    if ("fromIndex" in $$props2)
      $$invalidate(0, fromIndex = $$props2.fromIndex);
    if ("count" in $$props2)
      $$invalidate(1, count = $$props2.count);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [fromIndex, count, value, dispatch, change_handler, click_handler];
}
var PaginationOverflow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance122, create_fragment122, safe_not_equal, { fromIndex: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationOverflow",
      options,
      id: create_fragment122.name
    });
  }
  get fromIndex() {
    throw new Error("<PaginationOverflow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fromIndex(value) {
    throw new Error("<PaginationOverflow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<PaginationOverflow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<PaginationOverflow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationOverflow_default = PaginationOverflow;

// node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte
var file114 = "node_modules/carbon-components-svelte/src/PaginationNav/PaginationNav.svelte";
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block_130(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: 1,
      active: ctx[0] === 0,
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on("click", ctx[14]);
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & 1)
        paginationitem_changes.active = ctx2[0] === 0;
      if (dirty & 8388609) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_130.name,
    type: "if",
    source: "(90:4) {#if fit > MIN || (fit <= MIN && page <= 1)}",
    ctx
  });
  return block;
}
function create_default_slot_27(ctx) {
  let t_value = ctx[0] === 0 ? "Active, Page" : "Page";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0] === 0 ? "Active, Page" : "Page"))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_27.name,
    type: "slot",
    source: '(91:6) <PaginationItem         page=\\"{1}\\"         active=\\"{page === 0}\\"         on:click=\\"{() => (page = 0)}\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_18(ctx) {
  let t_value = ctx[0] === ctx[20] ? "Active, Page" : "Page";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 513 && t_value !== (t_value = ctx2[0] === ctx2[20] ? "Active, Page" : "Page"))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: '(105:6) <PaginationItem         page=\\"{item + 1}\\"         active=\\"{page === item}\\"         on:click=\\"{() => (page = item)}\\"       >',
    ctx
  });
  return block;
}
function create_each_block15(ctx) {
  let paginationitem;
  let current;
  function click_handler_2() {
    return ctx[16](ctx[20]);
  }
  paginationitem = new PaginationItem_default({
    props: {
      page: ctx[20] + 1,
      active: ctx[0] === ctx[20],
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on("click", click_handler_2);
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const paginationitem_changes = {};
      if (dirty & 512)
        paginationitem_changes.page = ctx[20] + 1;
      if (dirty & 513)
        paginationitem_changes.active = ctx[0] === ctx[20];
      if (dirty & 8389121) {
        paginationitem_changes.$$scope = { dirty, ctx };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block15.name,
    type: "each",
    source: "(104:4) {#each items as item}",
    ctx
  });
  return block;
}
function create_if_block73(ctx) {
  let paginationitem;
  let current;
  paginationitem = new PaginationItem_default({
    props: {
      page: ctx[1],
      active: ctx[0] === ctx[1] - 1,
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  paginationitem.$on("click", ctx[18]);
  const block = {
    c: function create() {
      create_component(paginationitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(paginationitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const paginationitem_changes = {};
      if (dirty & 2)
        paginationitem_changes.page = ctx2[1];
      if (dirty & 3)
        paginationitem_changes.active = ctx2[0] === ctx2[1] - 1;
      if (dirty & 8388611) {
        paginationitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      paginationitem.$set(paginationitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paginationitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paginationitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paginationitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block73.name,
    type: "if",
    source: "(120:4) {#if total > 1}",
    ctx
  });
  return block;
}
function create_default_slot19(ctx) {
  let t_value = ctx[0] === ctx[1] - 1 ? "Active, Page" : "Page";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = ctx2[0] === ctx2[1] - 1 ? "Active, Page" : "Page"))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: '(121:6) <PaginationItem         page=\\"{total}\\"         active=\\"{page === total - 1}\\"         on:click=\\"{() => (page = total - 1)}\\"       >',
    ctx
  });
  return block;
}
function create_fragment123(ctx) {
  let nav;
  let ul;
  let li0;
  let button0;
  let t0;
  let t1;
  let paginationoverflow0;
  let t2;
  let t3;
  let paginationoverflow1;
  let t4;
  let t5;
  let li1;
  let button1;
  let t6;
  let div;
  let t7;
  let t8_value = ctx[0] + 1 + "";
  let t8;
  let t9;
  let t10;
  let current;
  button0 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: "bottom",
      iconDescription: ctx[4],
      disabled: !ctx[2] && ctx[0] === 0,
      icon: CaretLeft_default
    },
    $$inline: true
  });
  button0.$on("click", ctx[13]);
  let if_block0 = (ctx[8] > MIN || ctx[8] <= MIN && ctx[0] <= 1) && create_if_block_130(ctx);
  paginationoverflow0 = new PaginationOverflow_default({
    props: {
      fromIndex: ctx[7],
      count: ctx[5]
    },
    $$inline: true
  });
  paginationoverflow0.$on("select", ctx[15]);
  let each_value = ctx[9];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block15(get_each_context15(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  paginationoverflow1 = new PaginationOverflow_default({
    props: {
      fromIndex: ctx[1] - ctx[6] - 1,
      count: ctx[6]
    },
    $$inline: true
  });
  paginationoverflow1.$on("select", ctx[17]);
  let if_block1 = ctx[1] > 1 && create_if_block73(ctx);
  button1 = new Button_default({
    props: {
      kind: "ghost",
      tooltipAlignment: "center",
      tooltipPosition: "bottom",
      iconDescription: ctx[3],
      disabled: !ctx[2] && ctx[0] === ctx[1] - 1,
      icon: CaretRight_default
    },
    $$inline: true
  });
  button1.$on("click", ctx[19]);
  let nav_levels = [{ "aria-label": "pagination" }, ctx[11]];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      li0 = element("li");
      create_component(button0.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(paginationoverflow0.$$.fragment);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      create_component(paginationoverflow1.$$.fragment);
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      li1 = element("li");
      create_component(button1.$$.fragment);
      t6 = space();
      div = element("div");
      t7 = text("Page\n    ");
      t8 = text(t8_value);
      t9 = text("\n    of\n    ");
      t10 = text(ctx[1]);
      toggle_class(li0, "bx--pagination-nav__list-item", true);
      add_location(li0, file114, 71, 4, 1865);
      toggle_class(li1, "bx--pagination-nav__list-item", true);
      add_location(li1, file114, 128, 4, 3407);
      toggle_class(ul, "bx--pagination-nav__list", true);
      add_location(ul, file114, 70, 2, 1816);
      attr_dev(div, "aria-live", "polite");
      attr_dev(div, "aria-atomic", "true");
      toggle_class(div, "bx--pagination-nav__accessibility-label", true);
      add_location(div, file114, 147, 2, 3914);
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--pagination-nav", true);
      add_location(nav, file114, 69, 0, 1733);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ul);
      append_dev(ul, li0);
      mount_component(button0, li0, null);
      append_dev(ul, t0);
      if (if_block0)
        if_block0.m(ul, null);
      append_dev(ul, t1);
      mount_component(paginationoverflow0, ul, null);
      append_dev(ul, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      append_dev(ul, t3);
      mount_component(paginationoverflow1, ul, null);
      append_dev(ul, t4);
      if (if_block1)
        if_block1.m(ul, null);
      append_dev(ul, t5);
      append_dev(ul, li1);
      mount_component(button1, li1, null);
      append_dev(nav, t6);
      append_dev(nav, div);
      append_dev(div, t7);
      append_dev(div, t8);
      append_dev(div, t9);
      append_dev(div, t10);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & 16)
        button0_changes.iconDescription = ctx2[4];
      if (dirty & 5)
        button0_changes.disabled = !ctx2[2] && ctx2[0] === 0;
      button0.$set(button0_changes);
      if (ctx2[8] > MIN || ctx2[8] <= MIN && ctx2[0] <= 1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 257) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_130(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(ul, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const paginationoverflow0_changes = {};
      if (dirty & 128)
        paginationoverflow0_changes.fromIndex = ctx2[7];
      if (dirty & 32)
        paginationoverflow0_changes.count = ctx2[5];
      paginationoverflow0.$set(paginationoverflow0_changes);
      if (dirty & 513) {
        each_value = ctx2[9];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block15(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, t3);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const paginationoverflow1_changes = {};
      if (dirty & 66)
        paginationoverflow1_changes.fromIndex = ctx2[1] - ctx2[6] - 1;
      if (dirty & 64)
        paginationoverflow1_changes.count = ctx2[6];
      paginationoverflow1.$set(paginationoverflow1_changes);
      if (ctx2[1] > 1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block73(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(ul, t5);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const button1_changes = {};
      if (dirty & 8)
        button1_changes.iconDescription = ctx2[3];
      if (dirty & 7)
        button1_changes.disabled = !ctx2[2] && ctx2[0] === ctx2[1] - 1;
      button1.$set(button1_changes);
      if ((!current || dirty & 1) && t8_value !== (t8_value = ctx2[0] + 1 + ""))
        set_data_dev(t8, t8_value);
      if (!current || dirty & 2)
        set_data_dev(t10, ctx2[1]);
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        { "aria-label": "pagination" },
        dirty & 2048 && ctx2[11]
      ]));
      toggle_class(nav, "bx--pagination-nav", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(paginationoverflow0.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(paginationoverflow1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(paginationoverflow0.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(paginationoverflow1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      destroy_component(button0);
      if (if_block0)
        if_block0.d();
      destroy_component(paginationoverflow0);
      destroy_each(each_blocks, detaching);
      destroy_component(paginationoverflow1);
      if (if_block1)
        if_block1.d();
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment123.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var MIN = 4;
function instance123($$self, $$props, $$invalidate) {
  let fit;
  let startOffset;
  let items;
  const omit_props_names = ["page", "total", "shown", "loop", "forwardText", "backwardText"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationNav", slots, []);
  let { page = 0 } = $$props;
  let { total = 10 } = $$props;
  let { shown = 10 } = $$props;
  let { loop = false } = $$props;
  let { forwardText = "Next page" } = $$props;
  let { backwardText = "Previous page" } = $$props;
  const dispatch = createEventDispatcher();
  afterUpdate(() => {
    dispatch("change", { page });
  });
  let front = 0;
  let back = 0;
  const click_handler = () => {
    if (page - 1 < 0) {
      if (loop)
        $$invalidate(0, page = total - 1);
    } else {
      $$invalidate(0, page--, page);
    }
    dispatch("click:button--previous", { page });
  };
  const click_handler_13 = () => $$invalidate(0, page = 0);
  const select_handler = ({ detail }) => $$invalidate(0, page = detail.index);
  const click_handler_2 = (item) => $$invalidate(0, page = item);
  const select_handler_1 = ({ detail }) => {
    $$invalidate(0, page = detail.index);
  };
  const click_handler_3 = () => $$invalidate(0, page = total - 1);
  const click_handler_4 = () => {
    if (page + 1 >= total) {
      if (loop)
        $$invalidate(0, page = 0);
    } else {
      $$invalidate(0, page++, page);
    }
    dispatch("click:button--next", { page });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("page" in $$new_props)
      $$invalidate(0, page = $$new_props.page);
    if ("total" in $$new_props)
      $$invalidate(1, total = $$new_props.total);
    if ("shown" in $$new_props)
      $$invalidate(12, shown = $$new_props.shown);
    if ("loop" in $$new_props)
      $$invalidate(2, loop = $$new_props.loop);
    if ("forwardText" in $$new_props)
      $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$new_props)
      $$invalidate(4, backwardText = $$new_props.backwardText);
  };
  $$self.$capture_state = () => ({
    page,
    total,
    shown,
    loop,
    forwardText,
    backwardText,
    afterUpdate,
    createEventDispatcher,
    CaretLeft: CaretLeft_default,
    CaretRight: CaretRight_default,
    PaginationItem: PaginationItem_default,
    PaginationOverflow: PaginationOverflow_default,
    Button: Button_default,
    dispatch,
    MIN,
    front,
    back,
    startOffset,
    items,
    fit
  });
  $$self.$inject_state = ($$new_props) => {
    if ("page" in $$props)
      $$invalidate(0, page = $$new_props.page);
    if ("total" in $$props)
      $$invalidate(1, total = $$new_props.total);
    if ("shown" in $$props)
      $$invalidate(12, shown = $$new_props.shown);
    if ("loop" in $$props)
      $$invalidate(2, loop = $$new_props.loop);
    if ("forwardText" in $$props)
      $$invalidate(3, forwardText = $$new_props.forwardText);
    if ("backwardText" in $$props)
      $$invalidate(4, backwardText = $$new_props.backwardText);
    if ("front" in $$props)
      $$invalidate(5, front = $$new_props.front);
    if ("back" in $$props)
      $$invalidate(6, back = $$new_props.back);
    if ("startOffset" in $$props)
      $$invalidate(7, startOffset = $$new_props.startOffset);
    if ("items" in $$props)
      $$invalidate(9, items = $$new_props.items);
    if ("fit" in $$props)
      $$invalidate(8, fit = $$new_props.fit);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(8, fit = shown >= MIN ? shown : MIN);
    }
    if ($$self.$$.dirty & 257) {
      $:
        $$invalidate(7, startOffset = fit <= MIN && page > 1 ? 0 : 1);
    }
    if ($$self.$$.dirty & 258) {
      $:
        if (fit >= total) {
          $$invalidate(5, front = 0);
          $$invalidate(6, back = 0);
        }
    }
    if ($$self.$$.dirty & 355) {
      $:
        if (fit < total) {
          const split = Math.ceil(fit / 2) - 1;
          $$invalidate(5, front = page - split + 1);
          $$invalidate(6, back = total - page - (fit - split) + 1);
          if (front <= 1) {
            $$invalidate(6, back -= front <= 0 ? Math.abs(front) + 1 : 0);
            $$invalidate(5, front = 0);
          }
          if (back <= 1) {
            $$invalidate(5, front -= back <= 0 ? Math.abs(back) + 1 : 0);
            $$invalidate(6, back = 0);
          }
        }
    }
    if ($$self.$$.dirty & 226) {
      $:
        $$invalidate(9, items = Array.from({ length: total }).map((e, i) => i).slice(startOffset + front, (back + 1) * -1));
    }
  };
  return [
    page,
    total,
    loop,
    forwardText,
    backwardText,
    front,
    back,
    startOffset,
    fit,
    items,
    dispatch,
    $$restProps,
    shown,
    click_handler,
    click_handler_13,
    select_handler,
    click_handler_2,
    select_handler_1,
    click_handler_3,
    click_handler_4
  ];
}
var PaginationNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance123, create_fragment123, safe_not_equal, {
      page: 0,
      total: 1,
      shown: 12,
      loop: 2,
      forwardText: 3,
      backwardText: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationNav",
      options,
      id: create_fragment123.name
    });
  }
  get page() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set page(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get total() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set total(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shown() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shown(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardText() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardText(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backwardText() {
    throw new Error("<PaginationNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backwardText(value) {
    throw new Error("<PaginationNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationNav_default = PaginationNav;

// node_modules/carbon-components-svelte/src/Popover/Popover.svelte
var file115 = "node_modules/carbon-components-svelte/src/Popover/Popover.svelte";
function create_fragment124(ctx) {
  let div1;
  let div0;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let div1_levels = [
    ctx[9],
    {
      style: div1_style_value = ctx[9].style + "; " + (ctx[6] && "position: relative")
    }
  ];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div0, "bx--popover-contents", true);
      add_location(div0, file115, 69, 2, 2177);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--popover", true);
      toggle_class(div1, "bx--popover--caret", ctx[2]);
      toggle_class(div1, "bx--popover--light", ctx[4]);
      toggle_class(div1, "bx--popover--high-contrast", ctx[5]);
      toggle_class(div1, "bx--popover--top", ctx[3] === "top");
      toggle_class(div1, "bx--popover--top-left", ctx[3] === "top-left");
      toggle_class(div1, "bx--popover--top-right", ctx[3] === "top-right");
      toggle_class(div1, "bx--popover--bottom", ctx[3] === "bottom");
      toggle_class(div1, "bx--popover--bottom-left", ctx[3] === "bottom-left");
      toggle_class(div1, "bx--popover--bottom-right", ctx[3] === "bottom-right");
      toggle_class(div1, "bx--popover--left", ctx[3] === "left");
      toggle_class(div1, "bx--popover--left-bottom", ctx[3] === "left-bottom");
      toggle_class(div1, "bx--popover--left-top", ctx[3] === "left-top");
      toggle_class(div1, "bx--popover--right", ctx[3] === "right");
      toggle_class(div1, "bx--popover--right-bottom", ctx[3] === "right-bottom");
      toggle_class(div1, "bx--popover--right-top", ctx[3] === "right-top");
      toggle_class(div1, "bx--popover--open", ctx[0]);
      toggle_class(div1, "bx--popover--relative", ctx[6]);
      add_location(div1, file115, 46, 0, 1166);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[13](div1);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "click", ctx[12], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 576 && div1_style_value !== (div1_style_value = ctx2[9].style + "; " + (ctx2[6] && "position: relative"))) && { style: div1_style_value }
      ]));
      toggle_class(div1, "bx--popover", true);
      toggle_class(div1, "bx--popover--caret", ctx2[2]);
      toggle_class(div1, "bx--popover--light", ctx2[4]);
      toggle_class(div1, "bx--popover--high-contrast", ctx2[5]);
      toggle_class(div1, "bx--popover--top", ctx2[3] === "top");
      toggle_class(div1, "bx--popover--top-left", ctx2[3] === "top-left");
      toggle_class(div1, "bx--popover--top-right", ctx2[3] === "top-right");
      toggle_class(div1, "bx--popover--bottom", ctx2[3] === "bottom");
      toggle_class(div1, "bx--popover--bottom-left", ctx2[3] === "bottom-left");
      toggle_class(div1, "bx--popover--bottom-right", ctx2[3] === "bottom-right");
      toggle_class(div1, "bx--popover--left", ctx2[3] === "left");
      toggle_class(div1, "bx--popover--left-bottom", ctx2[3] === "left-bottom");
      toggle_class(div1, "bx--popover--left-top", ctx2[3] === "left-top");
      toggle_class(div1, "bx--popover--right", ctx2[3] === "right");
      toggle_class(div1, "bx--popover--right-bottom", ctx2[3] === "right-bottom");
      toggle_class(div1, "bx--popover--right-top", ctx2[3] === "right-top");
      toggle_class(div1, "bx--popover--open", ctx2[0]);
      toggle_class(div1, "bx--popover--relative", ctx2[6]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment124.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance124($$self, $$props, $$invalidate) {
  const omit_props_names = ["open", "closeOnOutsideClick", "caret", "align", "light", "highContrast", "relative"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default"]);
  let { open = false } = $$props;
  let { closeOnOutsideClick = false } = $$props;
  let { caret = false } = $$props;
  let { align = "top" } = $$props;
  let { light = false } = $$props;
  let { highContrast = false } = $$props;
  let { relative = false } = $$props;
  const dispatch = createEventDispatcher();
  let ref = null;
  const click_handler = (e) => {
    if (!open)
      return;
    if (!ref.contains(e.target)) {
      dispatch("click:outside", { target: e.target });
      if (closeOnOutsideClick)
        $$invalidate(0, open = false);
    }
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(7, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("closeOnOutsideClick" in $$new_props)
      $$invalidate(1, closeOnOutsideClick = $$new_props.closeOnOutsideClick);
    if ("caret" in $$new_props)
      $$invalidate(2, caret = $$new_props.caret);
    if ("align" in $$new_props)
      $$invalidate(3, align = $$new_props.align);
    if ("light" in $$new_props)
      $$invalidate(4, light = $$new_props.light);
    if ("highContrast" in $$new_props)
      $$invalidate(5, highContrast = $$new_props.highContrast);
    if ("relative" in $$new_props)
      $$invalidate(6, relative = $$new_props.relative);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    open,
    closeOnOutsideClick,
    caret,
    align,
    light,
    highContrast,
    relative,
    createEventDispatcher,
    dispatch,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("closeOnOutsideClick" in $$props)
      $$invalidate(1, closeOnOutsideClick = $$new_props.closeOnOutsideClick);
    if ("caret" in $$props)
      $$invalidate(2, caret = $$new_props.caret);
    if ("align" in $$props)
      $$invalidate(3, align = $$new_props.align);
    if ("light" in $$props)
      $$invalidate(4, light = $$new_props.light);
    if ("highContrast" in $$props)
      $$invalidate(5, highContrast = $$new_props.highContrast);
    if ("relative" in $$props)
      $$invalidate(6, relative = $$new_props.relative);
    if ("ref" in $$props)
      $$invalidate(7, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    open,
    closeOnOutsideClick,
    caret,
    align,
    light,
    highContrast,
    relative,
    ref,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    div1_binding
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance124, create_fragment124, safe_not_equal, {
      open: 0,
      closeOnOutsideClick: 1,
      caret: 2,
      align: 3,
      light: 4,
      highContrast: 5,
      relative: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment124.name
    });
  }
  get open() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnOutsideClick() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnOutsideClick(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caret() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caret(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highContrast() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highContrast(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get relative() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set relative(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte
var file116 = "node_modules/carbon-components-svelte/src/ProgressBar/ProgressBar.svelte";
var get_labelText_slot_changes9 = (dirty) => ({});
var get_labelText_slot_context9 = (ctx) => ({});
function fallback_block24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block24.name,
    type: "fallback",
    source: "(55:27)        ",
    ctx
  });
  return block;
}
function create_if_block74(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[5]);
      attr_dev(div, "id", ctx[9]);
      toggle_class(div, "bx--progress-bar__helper-text", true);
      add_location(div, file116, 73, 4, 1829);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block74.name,
    type: "if",
    source: "(73:2) {#if helperText}",
    ctx
  });
  return block;
}
function create_fragment125(ctx) {
  let div2;
  let label;
  let t0;
  let div1;
  let div0;
  let div1_aria_valuemin_value;
  let div1_aria_valuemax_value;
  let div1_aria_valuenow_value;
  let div1_aria_describedby_value;
  let t1;
  let current;
  const labelText_slot_template = ctx[13].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[12], get_labelText_slot_context9);
  const labelText_slot_or_fallback = labelText_slot || fallback_block24(ctx);
  let if_block = ctx[5] && create_if_block74(ctx);
  let div2_levels = [ctx[10]];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      attr_dev(label, "for", ctx[6]);
      toggle_class(label, "bx--progress-bar__label", true);
      toggle_class(label, "bx--visually-hidden", ctx[4]);
      add_location(label, file116, 49, 2, 1195);
      set_style(div0, "transform", "scaleX(" + ctx[7] / ctx[0] + ")");
      toggle_class(div0, "bx--progress-bar__bar", true);
      add_location(div0, file116, 67, 4, 1689);
      attr_dev(div1, "role", "progressbar");
      attr_dev(div1, "id", ctx[6]);
      attr_dev(div1, "aria-valuemin", div1_aria_valuemin_value = ctx[8] ? void 0 : 0);
      attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value = ctx[8] ? void 0 : ctx[0]);
      attr_dev(div1, "aria-valuenow", div1_aria_valuenow_value = ctx[8] ? void 0 : ctx[7]);
      attr_dev(div1, "aria-describedby", div1_aria_describedby_value = ctx[5] ? ctx[9] : null);
      toggle_class(div1, "bx--progress-bar__track", true);
      add_location(div1, file116, 58, 2, 1379);
      set_attributes(div2, div2_data);
      toggle_class(div2, "bx--progress-bar", true);
      toggle_class(div2, "bx--progress-bar--indeterminate", ctx[8]);
      toggle_class(div2, "bx--progress-bar--big", ctx[2] === "md");
      toggle_class(div2, "bx--progress-bar--small", ctx[2] === "sm");
      toggle_class(div2, "bx--progress-bar--inline", ctx[1] === "inline");
      toggle_class(div2, "bx--progress-bar--indented", ctx[1] === "indented");
      add_location(div2, file116, 40, 0, 863);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, div0);
      append_dev(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(labelText_slot_template, ctx2[12], dirty, get_labelText_slot_changes9),
            get_labelText_slot_context9
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 8)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64) {
        attr_dev(label, "for", ctx2[6]);
      }
      if (!current || dirty & 16) {
        toggle_class(label, "bx--visually-hidden", ctx2[4]);
      }
      if (!current || dirty & 129) {
        set_style(div0, "transform", "scaleX(" + ctx2[7] / ctx2[0] + ")");
      }
      if (!current || dirty & 64) {
        attr_dev(div1, "id", ctx2[6]);
      }
      if (!current || dirty & 256 && div1_aria_valuemin_value !== (div1_aria_valuemin_value = ctx2[8] ? void 0 : 0)) {
        attr_dev(div1, "aria-valuemin", div1_aria_valuemin_value);
      }
      if (!current || dirty & 257 && div1_aria_valuemax_value !== (div1_aria_valuemax_value = ctx2[8] ? void 0 : ctx2[0])) {
        attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value);
      }
      if (!current || dirty & 384 && div1_aria_valuenow_value !== (div1_aria_valuenow_value = ctx2[8] ? void 0 : ctx2[7])) {
        attr_dev(div1, "aria-valuenow", div1_aria_valuenow_value);
      }
      if (!current || dirty & 32 && div1_aria_describedby_value !== (div1_aria_describedby_value = ctx2[5] ? ctx2[9] : null)) {
        attr_dev(div1, "aria-describedby", div1_aria_describedby_value);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block74(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [dirty & 1024 && ctx2[10]]));
      toggle_class(div2, "bx--progress-bar", true);
      toggle_class(div2, "bx--progress-bar--indeterminate", ctx2[8]);
      toggle_class(div2, "bx--progress-bar--big", ctx2[2] === "md");
      toggle_class(div2, "bx--progress-bar--small", ctx2[2] === "sm");
      toggle_class(div2, "bx--progress-bar--inline", ctx2[1] === "inline");
      toggle_class(div2, "bx--progress-bar--indented", ctx2[1] === "indented");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment125.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance125($$self, $$props, $$invalidate) {
  let indeterminate;
  let capped;
  const omit_props_names = ["value", "max", "kind", "size", "labelText", "hideLabel", "helperText", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, ["labelText"]);
  let { value = void 0 } = $$props;
  let { max = 100 } = $$props;
  let { kind = "default" } = $$props;
  let { size = "md" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { helperText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let helperId = "ccs-" + Math.random().toString(36);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(11, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(0, max = $$new_props.max);
    if ("kind" in $$new_props)
      $$invalidate(1, kind = $$new_props.kind);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$new_props)
      $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("helperText" in $$new_props)
      $$invalidate(5, helperText = $$new_props.helperText);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    max,
    kind,
    size,
    labelText,
    hideLabel,
    helperText,
    id,
    helperId,
    capped,
    indeterminate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(11, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(0, max = $$new_props.max);
    if ("kind" in $$props)
      $$invalidate(1, kind = $$new_props.kind);
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$props)
      $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("helperText" in $$props)
      $$invalidate(5, helperText = $$new_props.helperText);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("helperId" in $$props)
      $$invalidate(9, helperId = $$new_props.helperId);
    if ("capped" in $$props)
      $$invalidate(7, capped = $$new_props.capped);
    if ("indeterminate" in $$props)
      $$invalidate(8, indeterminate = $$new_props.indeterminate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(8, indeterminate = value === void 0);
    }
    if ($$self.$$.dirty & 2049) {
      $:
        $$invalidate(7, capped = value > max ? max : value < 0 ? 0 : value);
    }
  };
  return [
    max,
    kind,
    size,
    labelText,
    hideLabel,
    helperText,
    id,
    capped,
    indeterminate,
    helperId,
    $$restProps,
    value,
    $$scope,
    slots
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance125, create_fragment125, safe_not_equal, {
      value: 11,
      max: 0,
      kind: 1,
      size: 2,
      labelText: 3,
      hideLabel: 4,
      helperText: 5,
      id: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment125.name
    });
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte
var file117 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicator.svelte";
function create_fragment126(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let ul_levels = [ctx[3]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--progress", true);
      toggle_class(ul, "bx--progress--vertical", ctx[0]);
      toggle_class(ul, "bx--progress--space-equal", ctx[1] && !ctx[0]);
      add_location(ul, file117, 66, 0, 1785);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ul, "click", ctx[8], false, false, false),
          listen_dev(ul, "mouseover", ctx[9], false, false, false),
          listen_dev(ul, "mouseenter", ctx[10], false, false, false),
          listen_dev(ul, "mouseleave", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 8 && ctx2[3]]));
      toggle_class(ul, "bx--progress", true);
      toggle_class(ul, "bx--progress--vertical", ctx2[0]);
      toggle_class(ul, "bx--progress--space-equal", ctx2[1] && !ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment126.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance126($$self, $$props, $$invalidate) {
  const omit_props_names = ["currentIndex", "vertical", "spaceEqually", "preventChangeOnClick"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $stepsById;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressIndicator", slots, ["default"]);
  let { currentIndex = 0 } = $$props;
  let { vertical = false } = $$props;
  let { spaceEqually = false } = $$props;
  let { preventChangeOnClick = false } = $$props;
  const dispatch = createEventDispatcher();
  const steps = writable([]);
  const stepsById = derived(steps, ($) => $.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  validate_store(stepsById, "stepsById");
  component_subscribe($$self, stepsById, (value) => $$invalidate(12, $stepsById = value));
  const preventChangeOnClickStore = writable(preventChangeOnClick);
  setContext("ProgressIndicator", {
    steps,
    stepsById,
    preventChangeOnClick: {
      subscribe: preventChangeOnClickStore.subscribe
    },
    add: (step) => {
      steps.update((_) => {
        if (step.id in $stepsById) {
          return _.map((_step) => {
            if (_step.id === step.id)
              return { ..._step, ...step };
            return _step;
          });
        }
        return [
          ..._,
          {
            ...step,
            index: _.length,
            current: _.length === currentIndex,
            complete: step.complete
          }
        ];
      });
    },
    change: (index) => {
      if (preventChangeOnClick)
        return;
      $$invalidate(4, currentIndex = index);
      dispatch("change", index);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("currentIndex" in $$new_props)
      $$invalidate(4, currentIndex = $$new_props.currentIndex);
    if ("vertical" in $$new_props)
      $$invalidate(0, vertical = $$new_props.vertical);
    if ("spaceEqually" in $$new_props)
      $$invalidate(1, spaceEqually = $$new_props.spaceEqually);
    if ("preventChangeOnClick" in $$new_props)
      $$invalidate(5, preventChangeOnClick = $$new_props.preventChangeOnClick);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    currentIndex,
    vertical,
    spaceEqually,
    preventChangeOnClick,
    createEventDispatcher,
    setContext,
    writable,
    derived,
    dispatch,
    steps,
    stepsById,
    preventChangeOnClickStore,
    $stepsById
  });
  $$self.$inject_state = ($$new_props) => {
    if ("currentIndex" in $$props)
      $$invalidate(4, currentIndex = $$new_props.currentIndex);
    if ("vertical" in $$props)
      $$invalidate(0, vertical = $$new_props.vertical);
    if ("spaceEqually" in $$props)
      $$invalidate(1, spaceEqually = $$new_props.spaceEqually);
    if ("preventChangeOnClick" in $$props)
      $$invalidate(5, preventChangeOnClick = $$new_props.preventChangeOnClick);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        steps.update((_) => _.map((step, i) => ({ ...step, current: i === currentIndex })));
    }
    if ($$self.$$.dirty & 32) {
      $:
        preventChangeOnClickStore.set(preventChangeOnClick);
    }
  };
  return [
    vertical,
    spaceEqually,
    stepsById,
    $$restProps,
    currentIndex,
    preventChangeOnClick,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ProgressIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance126, create_fragment126, safe_not_equal, {
      currentIndex: 4,
      vertical: 0,
      spaceEqually: 1,
      preventChangeOnClick: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressIndicator",
      options,
      id: create_fragment126.name
    });
  }
  get currentIndex() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentIndex(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spaceEqually() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spaceEqually(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preventChangeOnClick() {
    throw new Error("<ProgressIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preventChangeOnClick(value) {
    throw new Error("<ProgressIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressIndicator_default = ProgressIndicator;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte
var file118 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressIndicatorSkeleton.svelte";
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block16(key_1, ctx) {
  let li;
  let div;
  let svg;
  let path;
  let t0;
  let p;
  let t1;
  let span;
  let t2;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      div = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t0 = space();
      p = element("p");
      t1 = space();
      span = element("span");
      t2 = space();
      attr_dev(path, "d", "M 7, 7 m -7, 0 a 7,7 0 1,0 14,0 a 7,7 0 1,0 -14,0");
      add_location(path, file118, 29, 10, 745);
      add_location(svg, file118, 28, 8, 729);
      toggle_class(p, "bx--progress-label", true);
      add_location(p, file118, 31, 8, 836);
      toggle_class(span, "bx--progress-line", true);
      add_location(span, file118, 32, 8, 886);
      toggle_class(div, "bx--progress-step-button", true);
      toggle_class(div, "bx--progress-step-button--unclickable", true);
      add_location(div, file118, 24, 6, 599);
      toggle_class(li, "bx--progress-step", true);
      toggle_class(li, "bx--progress-step--incomplete", true);
      add_location(li, file118, 20, 4, 493);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div);
      append_dev(div, svg);
      append_dev(svg, path);
      append_dev(div, t0);
      append_dev(div, p);
      append_dev(div, t1);
      append_dev(div, span);
      append_dev(li, t2);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block16.name,
    type: "each",
    source: "(20:2) {#each Array.from({ length: count }, (_, i) => i) as item, i (item)}",
    ctx
  });
  return block;
}
function create_fragment127(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[1] }, func6);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[7];
  validate_each_keys(ctx, each_value, get_each_context16, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context16(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block16(key, child_ctx));
  }
  let ul_levels = [ctx[2]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--progress", true);
      toggle_class(ul, "bx--progress--vertical", ctx[0]);
      toggle_class(ul, "bx--skeleton", true);
      add_location(ul, file118, 9, 0, 231);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(ul, "click", ctx[3], false, false, false),
          listen_dev(ul, "mouseover", ctx[4], false, false, false),
          listen_dev(ul, "mouseenter", ctx[5], false, false, false),
          listen_dev(ul, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = Array.from({ length: ctx2[1] }, func6);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context16, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block16, null, get_each_context16);
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(ul, "bx--progress", true);
      toggle_class(ul, "bx--progress--vertical", ctx2[0]);
      toggle_class(ul, "bx--skeleton", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment127.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func6 = (_, i) => i;
function instance127($$self, $$props, $$invalidate) {
  const omit_props_names = ["vertical", "count"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressIndicatorSkeleton", slots, []);
  let { vertical = false } = $$props;
  let { count = 4 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("vertical" in $$new_props)
      $$invalidate(0, vertical = $$new_props.vertical);
    if ("count" in $$new_props)
      $$invalidate(1, count = $$new_props.count);
  };
  $$self.$capture_state = () => ({ vertical, count });
  $$self.$inject_state = ($$new_props) => {
    if ("vertical" in $$props)
      $$invalidate(0, vertical = $$new_props.vertical);
    if ("count" in $$props)
      $$invalidate(1, count = $$new_props.count);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    vertical,
    count,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ProgressIndicatorSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance127, create_fragment127, safe_not_equal, { vertical: 0, count: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressIndicatorSkeleton",
      options,
      id: create_fragment127.name
    });
  }
  get vertical() {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<ProgressIndicatorSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressIndicatorSkeleton_default = ProgressIndicatorSkeleton;

// node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte
var file119 = "node_modules/carbon-components-svelte/src/icons/CheckmarkOutline.svelte";
function create_if_block75(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file119, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block75.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment128(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block75(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z");
      add_location(path0, file119, 24, 2, 579);
      attr_dev(path1, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z");
      add_location(path1, file119, 26, 10, 674);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file119, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block75(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment128.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance128($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckmarkOutline", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CheckmarkOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance128, create_fragment128, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckmarkOutline",
      options,
      id: create_fragment128.name
    });
  }
  get size() {
    throw new Error("<CheckmarkOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckmarkOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CheckmarkOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CheckmarkOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckmarkOutline_default = CheckmarkOutline;

// node_modules/carbon-components-svelte/src/icons/Warning.svelte
var file120 = "node_modules/carbon-components-svelte/src/icons/Warning.svelte";
function create_if_block76(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file120, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block76.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment129(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block76(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z");
      add_location(path0, file120, 24, 2, 579);
      attr_dev(path1, "d", "M15 8H17V19H15zM16 22a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 22z");
      add_location(path1, file120, 26, 10, 687);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file120, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block76(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment129.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance129($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Warning", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Warning = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance129, create_fragment129, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Warning",
      options,
      id: create_fragment129.name
    });
  }
  get size() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Warning_default = Warning;

// node_modules/carbon-components-svelte/src/icons/CircleDash.svelte
var file121 = "node_modules/carbon-components-svelte/src/icons/CircleDash.svelte";
function create_if_block77(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file121, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block77.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment130(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block77(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z");
      add_location(path, file121, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file121, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block77(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment130.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance130($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CircleDash", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CircleDash = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance130, create_fragment130, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CircleDash",
      options,
      id: create_fragment130.name
    });
  }
  get size() {
    throw new Error("<CircleDash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CircleDash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CircleDash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CircleDash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CircleDash_default = CircleDash;

// node_modules/carbon-components-svelte/src/icons/Incomplete.svelte
var file122 = "node_modules/carbon-components-svelte/src/icons/Incomplete.svelte";
function create_if_block78(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file122, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block78.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment131(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block78(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z");
      add_location(path, file122, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file122, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block78(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment131.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance131($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Incomplete", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Incomplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance131, create_fragment131, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Incomplete",
      options,
      id: create_fragment131.name
    });
  }
  get size() {
    throw new Error("<Incomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Incomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Incomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Incomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Incomplete_default = Incomplete;

// node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte
var file123 = "node_modules/carbon-components-svelte/src/ProgressIndicator/ProgressStep.svelte";
var get_default_slot_changes10 = (dirty) => ({});
var get_default_slot_context10 = (ctx) => ({ props: { class: "bx--progress-label" } });
function create_else_block25(ctx) {
  let circledash;
  let current;
  circledash = new CircleDash_default({
    props: { title: ctx[4] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(circledash.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(circledash, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const circledash_changes = {};
      if (dirty & 16)
        circledash_changes.title = ctx2[4];
      circledash.$set(circledash_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(circledash.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circledash.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(circledash, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(95:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_315(ctx) {
  let checkmarkoutline;
  let current;
  checkmarkoutline = new CheckmarkOutline_default({
    props: { title: ctx[4] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkoutline.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmarkoutline_changes = {};
      if (dirty & 16)
        checkmarkoutline_changes.title = ctx2[4];
      checkmarkoutline.$set(checkmarkoutline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_315.name,
    type: "if",
    source: "(93:23) ",
    ctx
  });
  return block;
}
function create_if_block_220(ctx) {
  let incomplete;
  let current;
  incomplete = new Incomplete_default({
    props: { title: ctx[4] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(incomplete.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(incomplete, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const incomplete_changes = {};
      if (dirty & 16)
        incomplete_changes.title = ctx2[4];
      incomplete.$set(incomplete_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(incomplete.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(incomplete.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(incomplete, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_220.name,
    type: "if",
    source: "(91:22) ",
    ctx
  });
  return block;
}
function create_if_block_131(ctx) {
  let warning;
  let current;
  warning = new Warning_default({
    props: {
      class: "bx--progress__warning",
      title: ctx[4]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warning.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warning, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const warning_changes = {};
      if (dirty & 16)
        warning_changes.title = ctx2[4];
      warning.$set(warning_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warning, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_131.name,
    type: "if",
    source: "(89:4) {#if invalid}",
    ctx
  });
  return block;
}
function fallback_block25(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(ctx[5]);
      toggle_class(p, "bx--progress-label", true);
      add_location(p, file123, 99, 8, 2694);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block25.name,
    type: "fallback",
    source: "(99:54)          ",
    ctx
  });
  return block;
}
function create_if_block79(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(ctx[6]);
      toggle_class(p, "bx--progress-optional", true);
      add_location(p, file123, 102, 8, 2792);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block79.name,
    type: "if",
    source: "(102:6) {#if secondaryLabel}",
    ctx
  });
  return block;
}
function create_fragment132(ctx) {
  let li;
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div;
  let t1;
  let t2;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_131, create_if_block_220, create_if_block_315, create_else_block25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    if (ctx2[1])
      return 1;
    if (ctx2[0])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], get_default_slot_context10);
  const default_slot_or_fallback = default_slot || fallback_block25(ctx);
  let if_block1 = ctx[6] && create_if_block79(ctx);
  let li_levels = [
    { "aria-disabled": ctx[2] },
    { id: ctx[7] },
    ctx[12]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      if_block0.c();
      t0 = space();
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      span = element("span");
      toggle_class(div, "bx--progress-text", true);
      add_location(div, file123, 97, 4, 2592);
      toggle_class(span, "bx--progress-line", true);
      add_location(span, file123, 105, 4, 2880);
      attr_dev(button, "type", "button");
      button.disabled = ctx[2];
      attr_dev(button, "aria-disabled", ctx[2]);
      attr_dev(button, "tabindex", button_tabindex_value = !ctx[1] && !ctx[2] ? "0" : "-1");
      toggle_class(button, "bx--progress-step-button", true);
      toggle_class(button, "bx--progress-step-button--unclickable", ctx[1] || ctx[9]);
      add_location(button, file123, 64, 2, 1698);
      set_attributes(li, li_data);
      toggle_class(li, "bx--progress-step", true);
      toggle_class(li, "bx--progress-step--current", ctx[1]);
      toggle_class(li, "bx--progress-step--complete", ctx[0]);
      toggle_class(li, "bx--progress-step--incomplete", !ctx[0] && !ctx[1]);
      toggle_class(li, "bx--progress-step--disabled", ctx[2]);
      add_location(li, file123, 54, 0, 1386);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, button);
      if_blocks[current_block_type_index].m(button, null);
      append_dev(button, t0);
      append_dev(button, div);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(button, t2);
      append_dev(button, span);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[15], false, false, false),
          listen_dev(button, "click", ctx[20], false, false, false),
          listen_dev(button, "mouseover", ctx[16], false, false, false),
          listen_dev(button, "mouseenter", ctx[17], false, false, false),
          listen_dev(button, "mouseleave", ctx[18], false, false, false),
          listen_dev(button, "keydown", ctx[19], false, false, false),
          listen_dev(button, "keydown", ctx[21], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, t0);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, get_default_slot_changes10),
            get_default_slot_context10
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 32)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block79(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 4) {
        prop_dev(button, "disabled", ctx2[2]);
      }
      if (!current || dirty & 4) {
        attr_dev(button, "aria-disabled", ctx2[2]);
      }
      if (!current || dirty & 6 && button_tabindex_value !== (button_tabindex_value = !ctx2[1] && !ctx2[2] ? "0" : "-1")) {
        attr_dev(button, "tabindex", button_tabindex_value);
      }
      if (!current || dirty & 514) {
        toggle_class(button, "bx--progress-step-button--unclickable", ctx2[1] || ctx2[9]);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & 4) && { "aria-disabled": ctx2[2] },
        (!current || dirty & 128) && { id: ctx2[7] },
        dirty & 4096 && ctx2[12]
      ]));
      toggle_class(li, "bx--progress-step", true);
      toggle_class(li, "bx--progress-step--current", ctx2[1]);
      toggle_class(li, "bx--progress-step--complete", ctx2[0]);
      toggle_class(li, "bx--progress-step--incomplete", !ctx2[0] && !ctx2[1]);
      toggle_class(li, "bx--progress-step--disabled", ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment132.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance132($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "complete",
    "current",
    "disabled",
    "invalid",
    "description",
    "label",
    "secondaryLabel",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $preventChangeOnClick;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressStep", slots, ["default"]);
  let { complete = false } = $$props;
  let { current = false } = $$props;
  let { disabled = false } = $$props;
  let { invalid = false } = $$props;
  let { description = "" } = $$props;
  let { label = "" } = $$props;
  let { secondaryLabel = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let step = {};
  const { stepsById, add, change, preventChangeOnClick } = getContext("ProgressIndicator");
  validate_store(preventChangeOnClick, "preventChangeOnClick");
  component_subscribe($$self, preventChangeOnClick, (value) => $$invalidate(9, $preventChangeOnClick = value));
  const unsubscribe = stepsById.subscribe((value) => {
    if (value[id]) {
      $$invalidate(8, step = value[id]);
      $$invalidate(1, current = step.current);
      $$invalidate(0, complete = step.complete);
    }
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    if (!step.complete)
      return;
    change(step.index);
  };
  const keydown_handler_12 = (e) => {
    if (!step.complete)
      return;
    if (e.key === " " || e.key === "Enter") {
      change(step.index);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("complete" in $$new_props)
      $$invalidate(0, complete = $$new_props.complete);
    if ("current" in $$new_props)
      $$invalidate(1, current = $$new_props.current);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("invalid" in $$new_props)
      $$invalidate(3, invalid = $$new_props.invalid);
    if ("description" in $$new_props)
      $$invalidate(4, description = $$new_props.description);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("secondaryLabel" in $$new_props)
      $$invalidate(6, secondaryLabel = $$new_props.secondaryLabel);
    if ("id" in $$new_props)
      $$invalidate(7, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    complete,
    current,
    disabled,
    invalid,
    description,
    label,
    secondaryLabel,
    id,
    onMount,
    getContext,
    CheckmarkOutline: CheckmarkOutline_default,
    Warning: Warning_default,
    CircleDash: CircleDash_default,
    Incomplete: Incomplete_default,
    step,
    stepsById,
    add,
    change,
    preventChangeOnClick,
    unsubscribe,
    $preventChangeOnClick
  });
  $$self.$inject_state = ($$new_props) => {
    if ("complete" in $$props)
      $$invalidate(0, complete = $$new_props.complete);
    if ("current" in $$props)
      $$invalidate(1, current = $$new_props.current);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("invalid" in $$props)
      $$invalidate(3, invalid = $$new_props.invalid);
    if ("description" in $$props)
      $$invalidate(4, description = $$new_props.description);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("secondaryLabel" in $$props)
      $$invalidate(6, secondaryLabel = $$new_props.secondaryLabel);
    if ("id" in $$props)
      $$invalidate(7, id = $$new_props.id);
    if ("step" in $$props)
      $$invalidate(8, step = $$new_props.step);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 133) {
      $:
        add({ id, complete, disabled });
    }
  };
  return [
    complete,
    current,
    disabled,
    invalid,
    description,
    label,
    secondaryLabel,
    id,
    step,
    $preventChangeOnClick,
    change,
    preventChangeOnClick,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    keydown_handler_12
  ];
}
var ProgressStep = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance132, create_fragment132, safe_not_equal, {
      complete: 0,
      current: 1,
      disabled: 2,
      invalid: 3,
      description: 4,
      label: 5,
      secondaryLabel: 6,
      id: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressStep",
      options,
      id: create_fragment132.name
    });
  }
  get complete() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set complete(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get current() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set current(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryLabel() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryLabel(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ProgressStep>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ProgressStep>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressStep_default = ProgressStep;

// node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte
var file124 = "node_modules/carbon-components-svelte/src/RadioButton/RadioButtonSkeleton.svelte";
function create_fragment133(ctx) {
  let div1;
  let div0;
  let t;
  let span;
  let mounted;
  let dispose;
  let div1_levels = [ctx[0]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      span = element("span");
      toggle_class(div0, "bx--radio-button", true);
      toggle_class(div0, "bx--skeleton", true);
      add_location(div0, file124, 9, 2, 185);
      toggle_class(span, "bx--radio-button__label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file124, 10, 2, 259);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--radio-button-wrapper", true);
      add_location(div1, file124, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div1, t);
      append_dev(div1, span);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[1], false, false, false),
          listen_dev(div1, "mouseover", ctx[2], false, false, false),
          listen_dev(div1, "mouseenter", ctx[3], false, false, false),
          listen_dev(div1, "mouseleave", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div1, "bx--radio-button-wrapper", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment133.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance133($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtonSkeleton", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var RadioButtonSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance133, create_fragment133, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtonSkeleton",
      options,
      id: create_fragment133.name
    });
  }
};
var RadioButtonSkeleton_default = RadioButtonSkeleton;

// node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte
var file125 = "node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte";
var get_legendText_slot_changes = (dirty) => ({});
var get_legendText_slot_context = (ctx) => ({});
function create_if_block80(ctx) {
  let legend;
  let current;
  const legendText_slot_template = ctx[11].legendText;
  const legendText_slot = create_slot(legendText_slot_template, ctx, ctx[10], get_legendText_slot_context);
  const legendText_slot_or_fallback = legendText_slot || fallback_block26(ctx);
  const block = {
    c: function create() {
      legend = element("legend");
      if (legendText_slot_or_fallback)
        legendText_slot_or_fallback.c();
      toggle_class(legend, "bx--label", true);
      toggle_class(legend, "bx--visually-hidden", ctx[2]);
      add_location(legend, file125, 89, 6, 1940);
    },
    m: function mount(target, anchor) {
      insert_dev(target, legend, anchor);
      if (legendText_slot_or_fallback) {
        legendText_slot_or_fallback.m(legend, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (legendText_slot) {
        if (legendText_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            legendText_slot,
            legendText_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(legendText_slot_template, ctx2[10], dirty, get_legendText_slot_changes),
            get_legendText_slot_context
          );
        }
      } else {
        if (legendText_slot_or_fallback && legendText_slot_or_fallback.p && (!current || dirty & 2)) {
          legendText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 4) {
        toggle_class(legend, "bx--visually-hidden", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(legendText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(legendText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(legend);
      if (legendText_slot_or_fallback)
        legendText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block80.name,
    type: "if",
    source: "(89:4) {#if legendText || $$slots.legendText}",
    ctx
  });
  return block;
}
function fallback_block26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block26.name,
    type: "fallback",
    source: "(91:32) {legendText}",
    ctx
  });
  return block;
}
function create_fragment134(ctx) {
  let div;
  let fieldset;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[1] || ctx[8].legendText) && create_if_block80(ctx);
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let div_levels = [{ id: ctx[5] }, ctx[7]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      fieldset = element("fieldset");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      fieldset.disabled = ctx[0];
      toggle_class(fieldset, "bx--radio-button-group", true);
      toggle_class(fieldset, "bx--radio-button-group--vertical", ctx[4] === "vertical");
      toggle_class(fieldset, "bx--radio-button-group--label-left", ctx[3] === "left");
      toggle_class(fieldset, "bx--radio-button-group--label-right", ctx[3] === "right");
      add_location(fieldset, file125, 81, 2, 1585);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file125, 72, 0, 1456);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, fieldset);
      if (if_block)
        if_block.m(fieldset, null);
      append_dev(fieldset, t);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[12], false, false, false),
          listen_dev(div, "mouseover", ctx[13], false, false, false),
          listen_dev(div, "mouseenter", ctx[14], false, false, false),
          listen_dev(div, "mouseleave", ctx[15], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1] || ctx2[8].legendText) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 258) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block80(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        prop_dev(fieldset, "disabled", ctx2[0]);
      }
      if (!current || dirty & 16) {
        toggle_class(fieldset, "bx--radio-button-group--vertical", ctx2[4] === "vertical");
      }
      if (!current || dirty & 8) {
        toggle_class(fieldset, "bx--radio-button-group--label-left", ctx2[3] === "left");
      }
      if (!current || dirty & 8) {
        toggle_class(fieldset, "bx--radio-button-group--label-right", ctx2[3] === "right");
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 32) && { id: ctx2[5] },
        dirty & 128 && ctx2[7]
      ]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment134.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance134($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "disabled",
    "legendText",
    "hideLegend",
    "labelPosition",
    "orientation",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtonGroup", slots, ["legendText", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { legendText = "" } = $$props;
  let { hideLegend = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { orientation = "horizontal" } = $$props;
  let { id = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(16, $selectedValue = value));
  setContext("RadioButtonGroup", {
    selectedValue,
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      $$invalidate(9, selected = value);
    }
  });
  onMount(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  beforeUpdate(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  selectedValue.subscribe((value) => {
    $$invalidate(9, selected = value);
    dispatch("change", value);
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(9, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legendText" in $$new_props)
      $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$new_props)
      $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$new_props)
      $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$new_props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    beforeUpdate,
    createEventDispatcher,
    onMount,
    setContext,
    writable,
    dispatch,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(9, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legendText" in $$props)
      $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$props)
      $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$props)
      $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    disabled,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    selectedValue,
    $$restProps,
    $$slots,
    selected,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var RadioButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance134, create_fragment134, safe_not_equal, {
      selected: 9,
      disabled: 0,
      legendText: 1,
      hideLegend: 2,
      labelPosition: 3,
      orientation: 4,
      id: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtonGroup",
      options,
      id: create_fragment134.name
    });
  }
  get selected() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendText() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendText(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLegend() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLegend(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButtonGroup_default = RadioButtonGroup;

// node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte
var file126 = "node_modules/carbon-components-svelte/src/UnorderedList/UnorderedList.svelte";
function create_fragment135(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let ul_levels = [ctx[2]];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--list--unordered", true);
      toggle_class(ul, "bx--list--nested", ctx[0]);
      toggle_class(ul, "bx--list--expressive", ctx[1]);
      add_location(ul, file126, 9, 0, 251);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ul, "click", ctx[5], false, false, false),
          listen_dev(ul, "mouseover", ctx[6], false, false, false),
          listen_dev(ul, "mouseenter", ctx[7], false, false, false),
          listen_dev(ul, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(ul, "bx--list--unordered", true);
      toggle_class(ul, "bx--list--nested", ctx2[0]);
      toggle_class(ul, "bx--list--expressive", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment135.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance135($$self, $$props, $$invalidate) {
  const omit_props_names = ["nested", "expressive"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnorderedList", slots, ["default"]);
  let { nested = false } = $$props;
  let { expressive = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("nested" in $$new_props)
      $$invalidate(0, nested = $$new_props.nested);
    if ("expressive" in $$new_props)
      $$invalidate(1, expressive = $$new_props.expressive);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ nested, expressive });
  $$self.$inject_state = ($$new_props) => {
    if ("nested" in $$props)
      $$invalidate(0, nested = $$new_props.nested);
    if ("expressive" in $$props)
      $$invalidate(1, expressive = $$new_props.expressive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nested,
    expressive,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var UnorderedList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance135, create_fragment135, safe_not_equal, { nested: 0, expressive: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnorderedList",
      options,
      id: create_fragment135.name
    });
  }
  get nested() {
    throw new Error("<UnorderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nested(value) {
    throw new Error("<UnorderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expressive() {
    throw new Error("<UnorderedList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expressive(value) {
    throw new Error("<UnorderedList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UnorderedList_default = UnorderedList;

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte
var file127 = "node_modules/carbon-components-svelte/src/RecursiveList/RecursiveListItem.svelte";
function create_if_block_221(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_221.name,
    type: "if",
    source: "(15:2) {#if text && !href}",
    ctx
  });
  return block;
}
function create_if_block_133(ctx) {
  let a;
  let t_value = (ctx[0] || ctx[1]) + "";
  let t;
  const block = {
    c: function create() {
      a = element("a");
      t = text(t_value);
      attr_dev(a, "href", ctx[1]);
      toggle_class(a, "bx--link", true);
      add_location(a, file127, 15, 12, 315);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[0] || ctx2[1]) + ""))
        set_data_dev(t, t_value);
      if (dirty & 2) {
        attr_dev(a, "href", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_133.name,
    type: "if",
    source: "(16:2) {#if href}",
    ctx
  });
  return block;
}
function create_if_block81(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(ctx[2], target, anchor);
      insert_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        html_tag.p(ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block81.name,
    type: "if",
    source: "(17:2) {#if !text && html}",
    ctx
  });
  return block;
}
function create_default_slot20(ctx) {
  let t0;
  let t1;
  let t2;
  let current;
  let if_block0 = ctx[0] && !ctx[1] && create_if_block_221(ctx);
  let if_block1 = ctx[1] && create_if_block_133(ctx);
  let if_block2 = !ctx[0] && ctx[2] && create_if_block81(ctx);
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[0] && !ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_221(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_133(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!ctx2[0] && ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block81(ctx2);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(14:0) <ListItem>",
    ctx
  });
  return block;
}
function create_fragment136(ctx) {
  let listitem;
  let current;
  listitem = new ListItem_default({
    props: {
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(listitem.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(listitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const listitem_changes = {};
      if (dirty & 23) {
        listitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      listitem.$set(listitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(listitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(listitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(listitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment136.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance136($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveListItem", slots, ["default"]);
  let { text: text2 = "" } = $$props;
  let { href = "" } = $$props;
  let { html = "" } = $$props;
  const writable_props = ["text", "href", "html"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RecursiveListItem> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("href" in $$props2)
      $$invalidate(1, href = $$props2.href);
    if ("html" in $$props2)
      $$invalidate(2, html = $$props2.html);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ text: text2, href, html, ListItem: ListItem_default });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("href" in $$props2)
      $$invalidate(1, href = $$props2.href);
    if ("html" in $$props2)
      $$invalidate(2, html = $$props2.html);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [text2, href, html, slots, $$scope];
}
var RecursiveListItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance136, create_fragment136, safe_not_equal, { text: 0, href: 1, html: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveListItem",
      options,
      id: create_fragment136.name
    });
  }
  get text() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get html() {
    throw new Error("<RecursiveListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set html(value) {
    throw new Error("<RecursiveListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveListItem_default = RecursiveListItem;

// node_modules/carbon-components-svelte/src/RecursiveList/RecursiveList.svelte
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_else_block26(ctx) {
  let recursivelistitem;
  let current;
  const recursivelistitem_spread_levels = [ctx[3]];
  let recursivelistitem_props = {};
  for (let i = 0; i < recursivelistitem_spread_levels.length; i += 1) {
    recursivelistitem_props = assign(recursivelistitem_props, recursivelistitem_spread_levels[i]);
  }
  recursivelistitem = new RecursiveListItem_default({
    props: recursivelistitem_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelistitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(recursivelistitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelistitem_changes = dirty & 1 ? get_spread_update(recursivelistitem_spread_levels, [get_spread_object(ctx2[3])]) : {};
      recursivelistitem.$set(recursivelistitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(recursivelistitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelistitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivelistitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(34:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block82(ctx) {
  let recursivelistitem;
  let current;
  const recursivelistitem_spread_levels = [ctx[3]];
  let recursivelistitem_props = {
    $$slots: { default: [create_default_slot_19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < recursivelistitem_spread_levels.length; i += 1) {
    recursivelistitem_props = assign(recursivelistitem_props, recursivelistitem_spread_levels[i]);
  }
  recursivelistitem = new RecursiveListItem_default({
    props: recursivelistitem_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelistitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(recursivelistitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelistitem_changes = dirty & 1 ? get_spread_update(recursivelistitem_spread_levels, [get_spread_object(ctx2[3])]) : {};
      if (dirty & 67) {
        recursivelistitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recursivelistitem.$set(recursivelistitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(recursivelistitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelistitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivelistitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block82.name,
    type: "if",
    source: "(30:4) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function create_default_slot_19(ctx) {
  let recursivelist;
  let t;
  let current;
  const recursivelist_spread_levels = [ctx[3], { type: ctx[1] }, { nested: true }];
  let recursivelist_props = {};
  for (let i = 0; i < recursivelist_spread_levels.length; i += 1) {
    recursivelist_props = assign(recursivelist_props, recursivelist_spread_levels[i]);
  }
  recursivelist = new RecursiveList({
    props: recursivelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(recursivelist.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      mount_component(recursivelist, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivelist_changes = dirty & 3 ? get_spread_update(recursivelist_spread_levels, [
        dirty & 1 && get_spread_object(ctx2[3]),
        dirty & 2 && { type: ctx2[1] },
        recursivelist_spread_levels[2]
      ]) : {};
      recursivelist.$set(recursivelist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(recursivelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivelist, detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(31:6) <RecursiveListItem {...child}>",
    ctx
  });
  return block;
}
function create_each_block17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block82, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[3].children);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block17.name,
    type: "each",
    source: "(29:2) {#each children as child}",
    ctx
  });
  return block;
}
function create_default_slot21(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block17(get_each_context17(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context17(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block17(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: `(24:0) <svelte:component   this=\\"{type === 'unordered' ? UnorderedList : OrderedList}\\"   native=\\"{type === 'ordered-native'}\\"   {...$$restProps} >`,
    ctx
  });
  return block;
}
function create_fragment137(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      native: ctx[1] === "ordered-native"
    },
    ctx[2]
  ];
  var switch_value = ctx[1] === "unordered" ? UnorderedList_default : OrderedList_default;
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 6 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 2 && {
          native: ctx2[1] === "ordered-native"
        },
        dirty & 4 && get_spread_object(ctx2[2])
      ]) : {};
      if (dirty & 67) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[1] === "unordered" ? UnorderedList_default : OrderedList_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment137.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance137($$self, $$props, $$invalidate) {
  const omit_props_names = ["children", "type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveList", slots, []);
  let { children = [] } = $$props;
  let { type = "unordered" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("children" in $$new_props)
      $$invalidate(0, children = $$new_props.children);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({
    children,
    type,
    UnorderedList: UnorderedList_default,
    OrderedList: OrderedList_default,
    RecursiveListItem: RecursiveListItem_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("children" in $$props)
      $$invalidate(0, children = $$new_props.children);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [children, type, $$restProps];
}
var RecursiveList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance137, create_fragment137, safe_not_equal, { children: 0, type: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveList",
      options,
      id: create_fragment137.name
    });
  }
  get children() {
    throw new Error("<RecursiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<RecursiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<RecursiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<RecursiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveList_default = RecursiveList;

// node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte
var file128 = "node_modules/carbon-components-svelte/src/Select/SelectSkeleton.svelte";
function create_if_block83(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file128, 15, 4, 293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block83.name,
    type: "if",
    source: "(15:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment138(ctx) {
  let div2;
  let t;
  let div1;
  let div0;
  let mounted;
  let dispose;
  let if_block = !ctx[0] && create_if_block83(ctx);
  let div2_levels = [ctx[1]];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div1 = element("div");
      div0 = element("div");
      toggle_class(div0, "bx--select-input", true);
      add_location(div0, file128, 18, 4, 434);
      toggle_class(div1, "bx--select", true);
      toggle_class(div1, "bx--skeleton", true);
      add_location(div1, file128, 17, 2, 370);
      set_attributes(div2, div2_data);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file128, 6, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append_dev(div2, t);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(div2, "click", ctx[2], false, false, false),
          listen_dev(div2, "mouseover", ctx[3], false, false, false),
          listen_dev(div2, "mouseenter", ctx[4], false, false, false),
          listen_dev(div2, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block83(ctx2);
          if_block.c();
          if_block.m(div2, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div2, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment138.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance138($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SelectSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance138, create_fragment138, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectSkeleton",
      options,
      id: create_fragment138.name
    });
  }
  get hideLabel() {
    throw new Error("<SelectSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<SelectSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectSkeleton_default = SelectSkeleton;

// node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte
var file129 = "node_modules/carbon-components-svelte/src/Select/SelectItemGroup.svelte";
function create_fragment139(ctx) {
  let optgroup;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let optgroup_levels = [
    { label: ctx[1] },
    { disabled: ctx[0] },
    ctx[2]
  ];
  let optgroup_data = {};
  for (let i = 0; i < optgroup_levels.length; i += 1) {
    optgroup_data = assign(optgroup_data, optgroup_levels[i]);
  }
  const block = {
    c: function create() {
      optgroup = element("optgroup");
      if (default_slot)
        default_slot.c();
      set_attributes(optgroup, optgroup_data);
      toggle_class(optgroup, "bx--select-optgroup", true);
      add_location(optgroup, file129, 8, 0, 206);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, optgroup, anchor);
      if (default_slot) {
        default_slot.m(optgroup, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(optgroup, optgroup_data = get_spread_update(optgroup_levels, [
        (!current || dirty & 2) && { label: ctx2[1] },
        (!current || dirty & 1) && { disabled: ctx2[0] },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(optgroup, "bx--select-optgroup", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(optgroup);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment139.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance139($$self, $$props, $$invalidate) {
  const omit_props_names = ["disabled", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItemGroup", slots, ["default"]);
  let { disabled = false } = $$props;
  let { label = "Provide label" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ disabled, label });
  $$self.$inject_state = ($$new_props) => {
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [disabled, label, $$restProps, $$scope, slots];
}
var SelectItemGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance139, create_fragment139, safe_not_equal, { disabled: 0, label: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItemGroup",
      options,
      id: create_fragment139.name
    });
  }
  get disabled() {
    throw new Error("<SelectItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SelectItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SelectItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItemGroup_default = SelectItemGroup;

// node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte
var file130 = "node_modules/carbon-components-svelte/src/SkeletonPlaceholder/SkeletonPlaceholder.svelte";
function create_fragment140(ctx) {
  let div;
  let mounted;
  let dispose;
  let div_levels = [ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(div, "bx--skeleton__placeholder", true);
      add_location(div, file130, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[1], false, false, false),
          listen_dev(div, "mouseover", ctx[2], false, false, false),
          listen_dev(div, "mouseenter", ctx[3], false, false, false),
          listen_dev(div, "mouseleave", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--skeleton__placeholder", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment140.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance140($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkeletonPlaceholder", slots, []);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SkeletonPlaceholder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance140, create_fragment140, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkeletonPlaceholder",
      options,
      id: create_fragment140.name
    });
  }
};
var SkeletonPlaceholder_default = SkeletonPlaceholder;

// node_modules/carbon-components-svelte/src/Slider/Slider.svelte
var file131 = "node_modules/carbon-components-svelte/src/Slider/Slider.svelte";
var get_labelText_slot_changes10 = (dirty) => ({});
var get_labelText_slot_context10 = (ctx) => ({});
function fallback_block27(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[16]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 65536)
        set_data_dev(t, ctx2[16]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block27.name,
    type: "fallback",
    source: "(148:27)        ",
    ctx
  });
  return block;
}
function create_fragment141(ctx) {
  let div5;
  let label;
  let t0;
  let div4;
  let span0;
  let t1_value = (ctx[5] || ctx[4]) + "";
  let t1;
  let t2;
  let div3;
  let div0;
  let t3;
  let div1;
  let t4;
  let div2;
  let t5;
  let input0;
  let div3_style_value;
  let t6;
  let span1;
  let t7_value = (ctx[3] || ctx[2]) + "";
  let t7;
  let t8;
  let input1;
  let input1_type_value;
  let input1_style_value;
  let input1_id_value;
  let input1_aria_labelledby_value;
  let input1_aria_label_value;
  let input1_data_invalid_value;
  let input1_aria_invalid_value;
  let div4_style_value;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = ctx[31].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[30], get_labelText_slot_context10);
  const labelText_slot_or_fallback = labelText_slot || fallback_block27(ctx);
  let div5_levels = [ctx[26]];
  let div5_data = {};
  for (let i = 0; i < div5_levels.length; i += 1) {
    div5_data = assign(div5_data, div5_levels[i]);
  }
  const block = {
    c: function create() {
      div5 = element("div");
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t0 = space();
      div4 = element("div");
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      div3 = element("div");
      div0 = element("div");
      t3 = space();
      div1 = element("div");
      t4 = space();
      div2 = element("div");
      t5 = space();
      input0 = element("input");
      t6 = space();
      span1 = element("span");
      t7 = text(t7_value);
      t8 = space();
      input1 = element("input");
      attr_dev(label, "for", ctx[14]);
      attr_dev(label, "id", ctx[21]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--label--disabled", ctx[10]);
      add_location(label, file131, 141, 2, 2933);
      toggle_class(span0, "bx--slider__range-label", true);
      add_location(span0, file131, 155, 4, 3226);
      attr_dev(div0, "role", "slider");
      attr_dev(div0, "tabindex", "0");
      set_style(div0, "left", ctx[20] + "%");
      attr_dev(div0, "aria-valuemax", ctx[2]);
      attr_dev(div0, "aria-valuemin", ctx[4]);
      attr_dev(div0, "aria-valuenow", ctx[0]);
      attr_dev(div0, "aria-labelledby", ctx[21]);
      attr_dev(div0, "id", ctx[14]);
      toggle_class(div0, "bx--slider__thumb", true);
      add_location(div0, file131, 179, 6, 3951);
      toggle_class(div1, "bx--slider__track", true);
      add_location(div1, file131, 190, 6, 4236);
      set_style(div2, "transform", "translate(0, -50%) scaleX(" + ctx[20] / 100 + ")");
      toggle_class(div2, "bx--slider__filled-track", true);
      add_location(div2, file131, 191, 6, 4310);
      attr_dev(input0, "type", "hidden");
      attr_dev(input0, "name", ctx[17]);
      input0.value = ctx[0];
      input0.required = ctx[8];
      attr_dev(input0, "min", ctx[4]);
      attr_dev(input0, "max", ctx[2]);
      attr_dev(input0, "step", ctx[6]);
      toggle_class(input0, "bx--slider__input", true);
      add_location(input0, file131, 195, 6, 4450);
      attr_dev(div3, "role", "presentation");
      attr_dev(div3, "tabindex", "-1");
      attr_dev(div3, "style", div3_style_value = ctx[13] ? "max-width: none" : void 0);
      toggle_class(div3, "bx--slider", true);
      toggle_class(div3, "bx--slider--disabled", ctx[10]);
      add_location(div3, file131, 156, 4, 3300);
      toggle_class(span1, "bx--slider__range-label", true);
      add_location(span1, file131, 206, 4, 4682);
      attr_dev(input1, "type", input1_type_value = ctx[12] ? "hidden" : ctx[9]);
      attr_dev(input1, "style", input1_style_value = ctx[12] ? "display: none" : void 0);
      attr_dev(input1, "id", input1_id_value = "input-" + ctx[14]);
      attr_dev(input1, "name", ctx[17]);
      input1.value = ctx[0];
      attr_dev(input1, "aria-labelledby", input1_aria_labelledby_value = ctx[27]["aria-label"] ? void 0 : ctx[21]);
      attr_dev(input1, "aria-label", input1_aria_label_value = ctx[27]["aria-label"] || "Slider number input");
      input1.disabled = ctx[10];
      input1.required = ctx[8];
      attr_dev(input1, "min", ctx[4]);
      attr_dev(input1, "max", ctx[2]);
      attr_dev(input1, "step", ctx[6]);
      attr_dev(input1, "data-invalid", input1_data_invalid_value = ctx[15] || null);
      attr_dev(input1, "aria-invalid", input1_aria_invalid_value = ctx[15] || null);
      toggle_class(input1, "bx--text-input", true);
      toggle_class(input1, "bx--slider-text-input", true);
      toggle_class(input1, "bx--text-input--light", ctx[11]);
      toggle_class(input1, "bx--text-input--invalid", ctx[15]);
      add_location(input1, file131, 207, 4, 4756);
      attr_dev(div4, "style", div4_style_value = ctx[13] ? "width: 100%" : void 0);
      toggle_class(div4, "bx--slider-container", true);
      add_location(div4, file131, 151, 2, 3121);
      set_attributes(div5, div5_data);
      toggle_class(div5, "bx--form-item", true);
      add_location(div5, file131, 133, 0, 2816);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div5, anchor);
      append_dev(div5, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_dev(div5, t0);
      append_dev(div5, div4);
      append_dev(div4, span0);
      append_dev(span0, t1);
      append_dev(div4, t2);
      append_dev(div4, div3);
      append_dev(div3, div0);
      append_dev(div3, t3);
      append_dev(div3, div1);
      ctx[36](div1);
      append_dev(div3, t4);
      append_dev(div3, div2);
      append_dev(div3, t5);
      append_dev(div3, input0);
      ctx[37](div3);
      append_dev(div4, t6);
      append_dev(div4, span1);
      append_dev(span1, t7);
      append_dev(div4, t8);
      append_dev(div4, input1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "mousemove", ctx[25], false, false, false),
          listen_dev(window, "touchmove", ctx[25], false, false, false),
          listen_dev(window, "mouseup", ctx[24], false, false, false),
          listen_dev(window, "touchend", ctx[24], false, false, false),
          listen_dev(window, "touchcancel", ctx[24], false, false, false),
          listen_dev(div3, "mousedown", ctx[22], false, false, false),
          listen_dev(div3, "mousedown", ctx[23], false, false, false),
          listen_dev(div3, "touchstart", ctx[23], { passive: true }, false, false),
          listen_dev(div3, "keydown", ctx[38], false, false, false),
          listen_dev(input1, "change", ctx[39], false, false, false),
          listen_dev(div5, "click", ctx[32], false, false, false),
          listen_dev(div5, "mouseover", ctx[33], false, false, false),
          listen_dev(div5, "mouseenter", ctx[34], false, false, false),
          listen_dev(div5, "mouseleave", ctx[35], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 1073741824)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[30],
            !current ? get_all_dirty_from_scope(ctx2[30]) : get_slot_changes(labelText_slot_template, ctx2[30], dirty, get_labelText_slot_changes10),
            get_labelText_slot_context10
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 65536)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 16384) {
        attr_dev(label, "for", ctx2[14]);
      }
      if (!current || dirty[0] & 2097152) {
        attr_dev(label, "id", ctx2[21]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--label--disabled", ctx2[10]);
      }
      if ((!current || dirty[0] & 48) && t1_value !== (t1_value = (ctx2[5] || ctx2[4]) + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty[0] & 1048576) {
        set_style(div0, "left", ctx2[20] + "%");
      }
      if (!current || dirty[0] & 4) {
        attr_dev(div0, "aria-valuemax", ctx2[2]);
      }
      if (!current || dirty[0] & 16) {
        attr_dev(div0, "aria-valuemin", ctx2[4]);
      }
      if (!current || dirty[0] & 1) {
        attr_dev(div0, "aria-valuenow", ctx2[0]);
      }
      if (!current || dirty[0] & 2097152) {
        attr_dev(div0, "aria-labelledby", ctx2[21]);
      }
      if (!current || dirty[0] & 16384) {
        attr_dev(div0, "id", ctx2[14]);
      }
      if (!current || dirty[0] & 1048576) {
        set_style(div2, "transform", "translate(0, -50%) scaleX(" + ctx2[20] / 100 + ")");
      }
      if (!current || dirty[0] & 131072) {
        attr_dev(input0, "name", ctx2[17]);
      }
      if (!current || dirty[0] & 1) {
        prop_dev(input0, "value", ctx2[0]);
      }
      if (!current || dirty[0] & 256) {
        prop_dev(input0, "required", ctx2[8]);
      }
      if (!current || dirty[0] & 16) {
        attr_dev(input0, "min", ctx2[4]);
      }
      if (!current || dirty[0] & 4) {
        attr_dev(input0, "max", ctx2[2]);
      }
      if (!current || dirty[0] & 64) {
        attr_dev(input0, "step", ctx2[6]);
      }
      if (!current || dirty[0] & 8192 && div3_style_value !== (div3_style_value = ctx2[13] ? "max-width: none" : void 0)) {
        attr_dev(div3, "style", div3_style_value);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(div3, "bx--slider--disabled", ctx2[10]);
      }
      if ((!current || dirty[0] & 12) && t7_value !== (t7_value = (ctx2[3] || ctx2[2]) + ""))
        set_data_dev(t7, t7_value);
      if (!current || dirty[0] & 4608 && input1_type_value !== (input1_type_value = ctx2[12] ? "hidden" : ctx2[9])) {
        attr_dev(input1, "type", input1_type_value);
      }
      if (!current || dirty[0] & 4096 && input1_style_value !== (input1_style_value = ctx2[12] ? "display: none" : void 0)) {
        attr_dev(input1, "style", input1_style_value);
      }
      if (!current || dirty[0] & 16384 && input1_id_value !== (input1_id_value = "input-" + ctx2[14])) {
        attr_dev(input1, "id", input1_id_value);
      }
      if (!current || dirty[0] & 131072) {
        attr_dev(input1, "name", ctx2[17]);
      }
      if (!current || dirty[0] & 1 && input1.value !== ctx2[0]) {
        prop_dev(input1, "value", ctx2[0]);
      }
      if (!current || dirty[0] & 136314880 && input1_aria_labelledby_value !== (input1_aria_labelledby_value = ctx2[27]["aria-label"] ? void 0 : ctx2[21])) {
        attr_dev(input1, "aria-labelledby", input1_aria_labelledby_value);
      }
      if (!current || dirty[0] & 134217728 && input1_aria_label_value !== (input1_aria_label_value = ctx2[27]["aria-label"] || "Slider number input")) {
        attr_dev(input1, "aria-label", input1_aria_label_value);
      }
      if (!current || dirty[0] & 1024) {
        prop_dev(input1, "disabled", ctx2[10]);
      }
      if (!current || dirty[0] & 256) {
        prop_dev(input1, "required", ctx2[8]);
      }
      if (!current || dirty[0] & 16) {
        attr_dev(input1, "min", ctx2[4]);
      }
      if (!current || dirty[0] & 4) {
        attr_dev(input1, "max", ctx2[2]);
      }
      if (!current || dirty[0] & 64) {
        attr_dev(input1, "step", ctx2[6]);
      }
      if (!current || dirty[0] & 32768 && input1_data_invalid_value !== (input1_data_invalid_value = ctx2[15] || null)) {
        attr_dev(input1, "data-invalid", input1_data_invalid_value);
      }
      if (!current || dirty[0] & 32768 && input1_aria_invalid_value !== (input1_aria_invalid_value = ctx2[15] || null)) {
        attr_dev(input1, "aria-invalid", input1_aria_invalid_value);
      }
      if (!current || dirty[0] & 2048) {
        toggle_class(input1, "bx--text-input--light", ctx2[11]);
      }
      if (!current || dirty[0] & 32768) {
        toggle_class(input1, "bx--text-input--invalid", ctx2[15]);
      }
      if (!current || dirty[0] & 8192 && div4_style_value !== (div4_style_value = ctx2[13] ? "width: 100%" : void 0)) {
        attr_dev(div4, "style", div4_style_value);
      }
      set_attributes(div5, div5_data = get_spread_update(div5_levels, [dirty[0] & 67108864 && ctx2[26]]));
      toggle_class(div5, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      ctx[36](null);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment141.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance141($$self, $$props, $$invalidate) {
  let labelId;
  let range;
  let left;
  const omit_props_names = [
    "value",
    "max",
    "maxLabel",
    "min",
    "minLabel",
    "step",
    "stepMultiplier",
    "required",
    "inputType",
    "disabled",
    "light",
    "hideTextInput",
    "fullWidth",
    "id",
    "invalid",
    "labelText",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, ["labelText"]);
  let { value = 0 } = $$props;
  let { max = 100 } = $$props;
  let { maxLabel = "" } = $$props;
  let { min = 0 } = $$props;
  let { minLabel = "" } = $$props;
  let { step = 1 } = $$props;
  let { stepMultiplier = 4 } = $$props;
  let { required = false } = $$props;
  let { inputType = "number" } = $$props;
  let { disabled = false } = $$props;
  let { light = false } = $$props;
  let { hideTextInput = false } = $$props;
  let { fullWidth = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { invalid = false } = $$props;
  let { labelText = "" } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  let trackRef = null;
  let dragging = false;
  let holding = false;
  function startDragging() {
    $$invalidate(28, dragging = true);
  }
  function startHolding() {
    $$invalidate(29, holding = true);
  }
  function stopHolding() {
    $$invalidate(29, holding = false);
    $$invalidate(28, dragging = false);
  }
  function move() {
    if (holding) {
      startDragging();
    }
  }
  function calcValue(e) {
    if (disabled)
      return;
    const offsetX = e.touches ? e.touches[0].clientX : e.clientX;
    const { left: left2, width } = trackRef.getBoundingClientRect();
    let nextValue = min + Math.round((max - min) * ((offsetX - left2) / width) / step) * step;
    if (nextValue <= min) {
      nextValue = min;
    } else if (nextValue >= max) {
      nextValue = max;
    }
    $$invalidate(0, value = nextValue);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      trackRef = $$value;
      $$invalidate(19, trackRef);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler = ({ shiftKey, key }) => {
    const keys = {
      ArrowDown: -1,
      ArrowLeft: -1,
      ArrowRight: 1,
      ArrowUp: 1
    };
    if (keys[key]) {
      $$invalidate(0, value += step * (shiftKey ? range / step / stepMultiplier : 1) * keys[key]);
    }
  };
  const change_handler = ({ target }) => {
    $$invalidate(0, value = Number(target.value));
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("maxLabel" in $$new_props)
      $$invalidate(3, maxLabel = $$new_props.maxLabel);
    if ("min" in $$new_props)
      $$invalidate(4, min = $$new_props.min);
    if ("minLabel" in $$new_props)
      $$invalidate(5, minLabel = $$new_props.minLabel);
    if ("step" in $$new_props)
      $$invalidate(6, step = $$new_props.step);
    if ("stepMultiplier" in $$new_props)
      $$invalidate(7, stepMultiplier = $$new_props.stepMultiplier);
    if ("required" in $$new_props)
      $$invalidate(8, required = $$new_props.required);
    if ("inputType" in $$new_props)
      $$invalidate(9, inputType = $$new_props.inputType);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("light" in $$new_props)
      $$invalidate(11, light = $$new_props.light);
    if ("hideTextInput" in $$new_props)
      $$invalidate(12, hideTextInput = $$new_props.hideTextInput);
    if ("fullWidth" in $$new_props)
      $$invalidate(13, fullWidth = $$new_props.fullWidth);
    if ("id" in $$new_props)
      $$invalidate(14, id = $$new_props.id);
    if ("invalid" in $$new_props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("labelText" in $$new_props)
      $$invalidate(16, labelText = $$new_props.labelText);
    if ("name" in $$new_props)
      $$invalidate(17, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(30, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    max,
    maxLabel,
    min,
    minLabel,
    step,
    stepMultiplier,
    required,
    inputType,
    disabled,
    light,
    hideTextInput,
    fullWidth,
    id,
    invalid,
    labelText,
    name,
    ref,
    createEventDispatcher,
    dispatch,
    trackRef,
    dragging,
    holding,
    startDragging,
    startHolding,
    stopHolding,
    move,
    calcValue,
    range,
    left,
    labelId
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("maxLabel" in $$props)
      $$invalidate(3, maxLabel = $$new_props.maxLabel);
    if ("min" in $$props)
      $$invalidate(4, min = $$new_props.min);
    if ("minLabel" in $$props)
      $$invalidate(5, minLabel = $$new_props.minLabel);
    if ("step" in $$props)
      $$invalidate(6, step = $$new_props.step);
    if ("stepMultiplier" in $$props)
      $$invalidate(7, stepMultiplier = $$new_props.stepMultiplier);
    if ("required" in $$props)
      $$invalidate(8, required = $$new_props.required);
    if ("inputType" in $$props)
      $$invalidate(9, inputType = $$new_props.inputType);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("light" in $$props)
      $$invalidate(11, light = $$new_props.light);
    if ("hideTextInput" in $$props)
      $$invalidate(12, hideTextInput = $$new_props.hideTextInput);
    if ("fullWidth" in $$props)
      $$invalidate(13, fullWidth = $$new_props.fullWidth);
    if ("id" in $$props)
      $$invalidate(14, id = $$new_props.id);
    if ("invalid" in $$props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("labelText" in $$props)
      $$invalidate(16, labelText = $$new_props.labelText);
    if ("name" in $$props)
      $$invalidate(17, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("trackRef" in $$props)
      $$invalidate(19, trackRef = $$new_props.trackRef);
    if ("dragging" in $$props)
      $$invalidate(28, dragging = $$new_props.dragging);
    if ("holding" in $$props)
      $$invalidate(29, holding = $$new_props.holding);
    if ("range" in $$props)
      $$invalidate(18, range = $$new_props.range);
    if ("left" in $$props)
      $$invalidate(20, left = $$new_props.left);
    if ("labelId" in $$props)
      $$invalidate(21, labelId = $$new_props.labelId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16384) {
      $:
        $$invalidate(21, labelId = `label-${id}`);
    }
    if ($$self.$$.dirty[0] & 20) {
      $:
        $$invalidate(18, range = max - min);
    }
    if ($$self.$$.dirty[0] & 805307413) {
      $: {
        if (value <= min) {
          $$invalidate(0, value = min);
        } else if (value >= max) {
          $$invalidate(0, value = max);
        }
        if (dragging) {
          calcValue(event);
          $$invalidate(28, dragging = false);
        }
        if (!holding && !disabled) {
          dispatch("change", value);
        }
      }
    }
    if ($$self.$$.dirty[0] & 262161) {
      $:
        $$invalidate(20, left = (value - min) / range * 100);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    ref,
    max,
    maxLabel,
    min,
    minLabel,
    step,
    stepMultiplier,
    required,
    inputType,
    disabled,
    light,
    hideTextInput,
    fullWidth,
    id,
    invalid,
    labelText,
    name,
    range,
    trackRef,
    left,
    labelId,
    startDragging,
    startHolding,
    stopHolding,
    move,
    $$restProps,
    $$props,
    dragging,
    holding,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div1_binding,
    div3_binding,
    keydown_handler,
    change_handler
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance141,
      create_fragment141,
      safe_not_equal,
      {
        value: 0,
        max: 2,
        maxLabel: 3,
        min: 4,
        minLabel: 5,
        step: 6,
        stepMultiplier: 7,
        required: 8,
        inputType: 9,
        disabled: 10,
        light: 11,
        hideTextInput: 12,
        fullWidth: 13,
        id: 14,
        invalid: 15,
        labelText: 16,
        name: 17,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment141.name
    });
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxLabel() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxLabel(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minLabel() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minLabel(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepMultiplier() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepMultiplier(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputType() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputType(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideTextInput() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideTextInput(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte
var file132 = "node_modules/carbon-components-svelte/src/Slider/SliderSkeleton.svelte";
function create_if_block84(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file132, 15, 4, 293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block84.name,
    type: "if",
    source: "(15:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment142(ctx) {
  let div5;
  let t0;
  let div4;
  let span0;
  let t1;
  let div3;
  let div0;
  let t2;
  let div1;
  let t3;
  let div2;
  let t4;
  let span1;
  let mounted;
  let dispose;
  let if_block = !ctx[0] && create_if_block84(ctx);
  let div5_levels = [ctx[1]];
  let div5_data = {};
  for (let i = 0; i < div5_levels.length; i += 1) {
    div5_data = assign(div5_data, div5_levels[i]);
  }
  const block = {
    c: function create() {
      div5 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div4 = element("div");
      span0 = element("span");
      t1 = space();
      div3 = element("div");
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      t3 = space();
      div2 = element("div");
      t4 = space();
      span1 = element("span");
      toggle_class(span0, "bx--slider__range-label", true);
      add_location(span0, file132, 18, 4, 444);
      toggle_class(div0, "bx--slider__track", true);
      add_location(div0, file132, 20, 6, 539);
      toggle_class(div1, "bx--slider__filled-track", true);
      add_location(div1, file132, 21, 6, 590);
      toggle_class(div2, "bx--slider__thumb", true);
      add_location(div2, file132, 22, 6, 648);
      toggle_class(div3, "bx--slider", true);
      add_location(div3, file132, 19, 4, 501);
      toggle_class(span1, "bx--slider__range-label", true);
      add_location(span1, file132, 24, 4, 708);
      toggle_class(div4, "bx--slider-container", true);
      toggle_class(div4, "bx--skeleton", true);
      add_location(div4, file132, 17, 2, 370);
      set_attributes(div5, div5_data);
      toggle_class(div5, "bx--form-item", true);
      add_location(div5, file132, 6, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div5, anchor);
      if (if_block)
        if_block.m(div5, null);
      append_dev(div5, t0);
      append_dev(div5, div4);
      append_dev(div4, span0);
      append_dev(div4, t1);
      append_dev(div4, div3);
      append_dev(div3, div0);
      append_dev(div3, t2);
      append_dev(div3, div1);
      append_dev(div3, t3);
      append_dev(div3, div2);
      append_dev(div4, t4);
      append_dev(div4, span1);
      if (!mounted) {
        dispose = [
          listen_dev(div5, "click", ctx[2], false, false, false),
          listen_dev(div5, "mouseover", ctx[3], false, false, false),
          listen_dev(div5, "mouseenter", ctx[4], false, false, false),
          listen_dev(div5, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block84(ctx2);
          if_block.c();
          if_block.m(div5, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div5, div5_data = get_spread_update(div5_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div5, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment142.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance142($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliderSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var SliderSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance142, create_fragment142, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliderSkeleton",
      options,
      id: create_fragment142.name
    });
  }
  get hideLabel() {
    throw new Error("<SliderSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<SliderSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliderSkeleton_default = SliderSkeleton;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte
var file133 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredList.svelte";
function create_fragment143(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let div_levels = [{ role: "table" }, ctx[4]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list", true);
      toggle_class(div, "bx--structured-list--selection", ctx[2]);
      toggle_class(div, "bx--structured-list--condensed", ctx[0]);
      toggle_class(div, "bx--structured-list--flush", ctx[1]);
      add_location(div, file133, 34, 0, 835);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[9], false, false, false),
          listen_dev(div, "mouseover", ctx[10], false, false, false),
          listen_dev(div, "mouseenter", ctx[11], false, false, false),
          listen_dev(div, "mouseleave", ctx[12], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "table" }, dirty & 16 && ctx2[4]]));
      toggle_class(div, "bx--structured-list", true);
      toggle_class(div, "bx--structured-list--selection", ctx2[2]);
      toggle_class(div, "bx--structured-list--condensed", ctx2[0]);
      toggle_class(div, "bx--structured-list--flush", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment143.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance143($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "condensed", "flush", "selection"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredList", slots, ["default"]);
  let { selected = void 0 } = $$props;
  let { condensed = false } = $$props;
  let { flush = false } = $$props;
  let { selection = false } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(6, $selectedValue = value));
  setContext("StructuredListWrapper", {
    selectedValue,
    update: (value) => {
      selectedValue.set(value);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("condensed" in $$new_props)
      $$invalidate(0, condensed = $$new_props.condensed);
    if ("flush" in $$new_props)
      $$invalidate(1, flush = $$new_props.flush);
    if ("selection" in $$new_props)
      $$invalidate(2, selection = $$new_props.selection);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    condensed,
    flush,
    selection,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("condensed" in $$props)
      $$invalidate(0, condensed = $$new_props.condensed);
    if ("flush" in $$props)
      $$invalidate(1, flush = $$new_props.flush);
    if ("selection" in $$props)
      $$invalidate(2, selection = $$new_props.selection);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(5, selected = $selectedValue);
    }
    if ($$self.$$.dirty & 64) {
      $:
        dispatch("change", $selectedValue);
    }
  };
  return [
    condensed,
    flush,
    selection,
    selectedValue,
    $$restProps,
    selected,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance143, create_fragment143, safe_not_equal, {
      selected: 5,
      condensed: 0,
      flush: 1,
      selection: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredList",
      options,
      id: create_fragment143.name
    });
  }
  get selected() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get condensed() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set condensed(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<StructuredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<StructuredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredList_default = StructuredList;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte
var file134 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListSkeleton.svelte";
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block18(key_1, ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      toggle_class(div0, "bx--structured-list-td", true);
      add_location(div0, file134, 28, 8, 858);
      toggle_class(div1, "bx--structured-list-td", true);
      add_location(div1, file134, 29, 8, 916);
      toggle_class(div2, "bx--structured-list-td", true);
      add_location(div2, file134, 30, 8, 974);
      toggle_class(div3, "bx--structured-list-row", true);
      add_location(div3, file134, 27, 6, 805);
      this.first = div3;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div0);
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div3, t1);
      append_dev(div3, div2);
      append_dev(div3, t2);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block18.name,
    type: "each",
    source: "(27:4) {#each Array.from({ length: rows }, (_, i) => i) as row, i (row)}",
    ctx
  });
  return block;
}
function create_fragment144(ctx) {
  let div6;
  let div4;
  let div3;
  let div0;
  let span0;
  let t0;
  let div1;
  let span1;
  let t1;
  let div2;
  let span2;
  let t2;
  let div5;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[0] }, func7);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[6];
  validate_each_keys(ctx, each_value, get_each_context18, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context18(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block18(key, child_ctx));
  }
  let div6_levels = [ctx[1]];
  let div6_data = {};
  for (let i = 0; i < div6_levels.length; i += 1) {
    div6_data = assign(div6_data, div6_levels[i]);
  }
  const block = {
    c: function create() {
      div6 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = space();
      div1 = element("div");
      span1 = element("span");
      t1 = space();
      div2 = element("div");
      span2 = element("span");
      t2 = space();
      div5 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      add_location(span0, file134, 20, 49, 502);
      toggle_class(div0, "bx--structured-list-th", true);
      add_location(div0, file134, 20, 6, 459);
      add_location(span1, file134, 21, 49, 571);
      toggle_class(div1, "bx--structured-list-th", true);
      add_location(div1, file134, 21, 6, 528);
      add_location(span2, file134, 22, 49, 640);
      toggle_class(div2, "bx--structured-list-th", true);
      add_location(div2, file134, 22, 6, 597);
      toggle_class(div3, "bx--structured-list-row", true);
      toggle_class(div3, "bx--structured-list-row--header-row", true);
      add_location(div3, file134, 16, 4, 340);
      toggle_class(div4, "bx--structured-list-thead", true);
      add_location(div4, file134, 15, 2, 289);
      toggle_class(div5, "bx--structured-list-tbody", true);
      add_location(div5, file134, 25, 2, 682);
      set_attributes(div6, div6_data);
      toggle_class(div6, "bx--skeleton", true);
      toggle_class(div6, "bx--structured-list", true);
      add_location(div6, file134, 6, 0, 136);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div6, anchor);
      append_dev(div6, div4);
      append_dev(div4, div3);
      append_dev(div3, div0);
      append_dev(div0, span0);
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div1, span1);
      append_dev(div3, t1);
      append_dev(div3, div2);
      append_dev(div2, span2);
      append_dev(div6, t2);
      append_dev(div6, div5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div5, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(div6, "click", ctx[2], false, false, false),
          listen_dev(div6, "mouseover", ctx[3], false, false, false),
          listen_dev(div6, "mouseenter", ctx[4], false, false, false),
          listen_dev(div6, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = Array.from({ length: ctx2[0] }, func7);
        validate_each_argument(each_value);
        validate_each_keys(ctx2, each_value, get_each_context18, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div5, destroy_block, create_each_block18, null, get_each_context18);
      }
      set_attributes(div6, div6_data = get_spread_update(div6_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div6, "bx--skeleton", true);
      toggle_class(div6, "bx--structured-list", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment144.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func7 = (_, i) => i;
function instance144($$self, $$props, $$invalidate) {
  const omit_props_names = ["rows"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListSkeleton", slots, []);
  let { rows = 5 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("rows" in $$new_props)
      $$invalidate(0, rows = $$new_props.rows);
  };
  $$self.$capture_state = () => ({ rows });
  $$self.$inject_state = ($$new_props) => {
    if ("rows" in $$props)
      $$invalidate(0, rows = $$new_props.rows);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    rows,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance144, create_fragment144, safe_not_equal, { rows: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListSkeleton",
      options,
      id: create_fragment144.name
    });
  }
  get rows() {
    throw new Error("<StructuredListSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<StructuredListSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListSkeleton_default = StructuredListSkeleton;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte
var file135 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListBody.svelte";
function create_fragment145(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let div_levels = [{ role: "rowgroup" }, ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-tbody", true);
      add_location(div, file135, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[3], false, false, false),
          listen_dev(div, "mouseover", ctx[4], false, false, false),
          listen_dev(div, "mouseenter", ctx[5], false, false, false),
          listen_dev(div, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "rowgroup" }, dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--structured-list-tbody", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment145.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance145($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListBody", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance145, create_fragment145, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListBody",
      options,
      id: create_fragment145.name
    });
  }
};
var StructuredListBody_default = StructuredListBody;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte
var file136 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListHead.svelte";
function create_fragment146(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let div_levels = [{ role: "rowgroup" }, ctx[0]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-thead", true);
      add_location(div, file136, 1, 0, 57);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[3], false, false, false),
          listen_dev(div, "mouseover", ctx[4], false, false, false),
          listen_dev(div, "mouseenter", ctx[5], false, false, false),
          listen_dev(div, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "rowgroup" }, dirty & 1 && ctx2[0]]));
      toggle_class(div, "bx--structured-list-thead", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment146.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance146($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListHead", slots, ["default"]);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance146, create_fragment146, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListHead",
      options,
      id: create_fragment146.name
    });
  }
};
var StructuredListHead_default = StructuredListHead;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte
var file137 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListCell.svelte";
function create_fragment147(ctx) {
  let div;
  let div_role_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [
    {
      role: div_role_value = ctx[0] ? "columnheader" : "cell"
    },
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-th", ctx[0]);
      toggle_class(div, "bx--structured-list-td", !ctx[0]);
      toggle_class(div, "bx--structured-list-content--nowrap", ctx[1]);
      add_location(div, file137, 9, 0, 219);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[5], false, false, false),
          listen_dev(div, "mouseover", ctx[6], false, false, false),
          listen_dev(div, "mouseenter", ctx[7], false, false, false),
          listen_dev(div, "mouseleave", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 1 && div_role_value !== (div_role_value = ctx2[0] ? "columnheader" : "cell")) && { role: div_role_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(div, "bx--structured-list-th", ctx2[0]);
      toggle_class(div, "bx--structured-list-td", !ctx2[0]);
      toggle_class(div, "bx--structured-list-content--nowrap", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment147.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance147($$self, $$props, $$invalidate) {
  const omit_props_names = ["head", "noWrap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListCell", slots, ["default"]);
  let { head = false } = $$props;
  let { noWrap = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("head" in $$new_props)
      $$invalidate(0, head = $$new_props.head);
    if ("noWrap" in $$new_props)
      $$invalidate(1, noWrap = $$new_props.noWrap);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ head, noWrap });
  $$self.$inject_state = ($$new_props) => {
    if ("head" in $$props)
      $$invalidate(0, head = $$new_props.head);
    if ("noWrap" in $$props)
      $$invalidate(1, noWrap = $$new_props.noWrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    head,
    noWrap,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var StructuredListCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance147, create_fragment147, safe_not_equal, { head: 0, noWrap: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListCell",
      options,
      id: create_fragment147.name
    });
  }
  get head() {
    throw new Error("<StructuredListCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set head(value) {
    throw new Error("<StructuredListCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noWrap() {
    throw new Error("<StructuredListCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noWrap(value) {
    throw new Error("<StructuredListCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListCell_default = StructuredListCell;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte
var file138 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListRow.svelte";
function create_else_block27(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let div_levels = [{ role: "row" }, ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--structured-list-row", true);
      toggle_class(div, "bx--structured-list-row--header-row", ctx[0]);
      add_location(div, file138, 29, 2, 682);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[11], false, false, false),
          listen_dev(div, "mouseover", ctx[12], false, false, false),
          listen_dev(div, "mouseenter", ctx[13], false, false, false),
          listen_dev(div, "mouseleave", ctx[14], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ role: "row" }, dirty & 8 && ctx2[3]]));
      toggle_class(div, "bx--structured-list-row", true);
      toggle_class(div, "bx--structured-list-row--header-row", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(29:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block85(ctx) {
  let label_1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let label_1_levels = [{ tabindex: ctx[2] }, ctx[3]];
  let label_1_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_1_data = assign(label_1_data, label_1_levels[i]);
  }
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label_1, label_1_data);
      toggle_class(label_1, "bx--structured-list-row", true);
      toggle_class(label_1, "bx--structured-list-row--header-row", ctx[0]);
      add_location(label_1, file138, 15, 2, 411);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(label_1, "click", ctx[6], false, false, false),
          listen_dev(label_1, "mouseover", ctx[7], false, false, false),
          listen_dev(label_1, "mouseenter", ctx[8], false, false, false),
          listen_dev(label_1, "mouseleave", ctx[9], false, false, false),
          listen_dev(label_1, "keydown", ctx[10], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
        (!current || dirty & 4) && { tabindex: ctx2[2] },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(label_1, "bx--structured-list-row", true);
      toggle_class(label_1, "bx--structured-list-row--header-row", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block85.name,
    type: "if",
    source: "(13:0) {#if label}",
    ctx
  });
  return block;
}
function create_fragment148(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block85, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment148.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance148($$self, $$props, $$invalidate) {
  const omit_props_names = ["head", "label", "tabindex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListRow", slots, ["default"]);
  let { head = false } = $$props;
  let { label = false } = $$props;
  let { tabindex = "0" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("head" in $$new_props)
      $$invalidate(0, head = $$new_props.head);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("tabindex" in $$new_props)
      $$invalidate(2, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ head, label, tabindex });
  $$self.$inject_state = ($$new_props) => {
    if ("head" in $$props)
      $$invalidate(0, head = $$new_props.head);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("tabindex" in $$props)
      $$invalidate(2, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    head,
    label,
    tabindex,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1
  ];
}
var StructuredListRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance148, create_fragment148, safe_not_equal, { head: 0, label: 1, tabindex: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListRow",
      options,
      id: create_fragment148.name
    });
  }
  get head() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set head(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<StructuredListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<StructuredListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListRow_default = StructuredListRow;

// node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte
var file139 = "node_modules/carbon-components-svelte/src/StructuredList/StructuredListInput.svelte";
function create_fragment149(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { tabindex: "-1" },
    { checked: ctx[0] },
    { id: ctx[4] },
    { name: ctx[5] },
    { title: ctx[2] },
    { value: ctx[3] },
    ctx[8]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "bx--structured-list-input", true);
      add_location(input, file139, 30, 0, 681);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[10](input);
      if (!mounted) {
        dispose = listen_dev(input, "change", ctx[11], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        { tabindex: "-1" },
        dirty & 1 && { checked: ctx2[0] },
        dirty & 16 && { id: ctx2[4] },
        dirty & 32 && { name: ctx2[5] },
        dirty & 4 && { title: ctx2[2] },
        dirty & 8 && { value: ctx2[3] },
        dirty & 256 && ctx2[8]
      ]));
      toggle_class(input, "bx--structured-list-input", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment149.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance149($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "title", "value", "id", "name", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StructuredListInput", slots, []);
  let { checked = false } = $$props;
  let { title = "title" } = $$props;
  let { value = "value" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const { selectedValue, update } = getContext("StructuredListWrapper");
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(9, $selectedValue = value2));
  if (checked) {
    update(value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = () => {
    update(value);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    checked,
    title,
    value,
    id,
    name,
    ref,
    getContext,
    selectedValue,
    update,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 520) {
      $:
        $$invalidate(0, checked = $selectedValue === value);
    }
  };
  return [
    checked,
    ref,
    title,
    value,
    id,
    name,
    selectedValue,
    update,
    $$restProps,
    $selectedValue,
    input_binding,
    change_handler
  ];
}
var StructuredListInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance149, create_fragment149, safe_not_equal, {
      checked: 0,
      title: 2,
      value: 3,
      id: 4,
      name: 5,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StructuredListInput",
      options,
      id: create_fragment149.name
    });
  }
  get checked() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<StructuredListInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<StructuredListInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StructuredListInput_default = StructuredListInput;

// node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte
var file140 = "node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte";
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
function create_if_block86(ctx) {
  let t_value = ctx[3].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8 && t_value !== (t_value = ctx2[3].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block86.name,
    type: "if",
    source: "(150:6) {#if currentTab}",
    ctx
  });
  return block;
}
function create_fragment150(ctx) {
  let div1;
  let div0;
  let a;
  let t0;
  let chevrondown;
  let div0_aria_label_value;
  let t1;
  let ul;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block86(ctx);
  chevrondown = new ChevronDown_default({
    props: {
      "aria-hidden": "true",
      title: ctx[1]
    },
    $$inline: true
  });
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], null);
  let div1_levels = [{ role: "navigation" }, ctx[10]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const content_slot_template = ctx[20].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[19], get_content_slot_context);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (content_slot)
        content_slot.c();
      attr_dev(a, "tabindex", "-1");
      attr_dev(a, "href", ctx[2]);
      toggle_class(a, "bx--tabs-trigger-text", true);
      add_location(a, file140, 140, 4, 3297);
      attr_dev(div0, "role", "listbox");
      attr_dev(div0, "tabindex", "0");
      attr_dev(div0, "aria-label", div0_aria_label_value = ctx[11]["aria-label"] || "listbox");
      toggle_class(div0, "bx--tabs-trigger", true);
      add_location(div0, file140, 127, 2, 2997);
      attr_dev(ul, "role", "tablist");
      toggle_class(ul, "bx--tabs__nav", true);
      toggle_class(ul, "bx--tabs__nav--hidden", ctx[5]);
      add_location(ul, file140, 153, 2, 3665);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--tabs", true);
      toggle_class(div1, "bx--tabs--container", ctx[0] === "container");
      add_location(div1, file140, 121, 0, 2870);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, a);
      if (if_block)
        if_block.m(a, null);
      append_dev(div0, t0);
      mount_component(chevrondown, div0, null);
      append_dev(div1, t1);
      append_dev(div1, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[26](ul);
      insert_dev(target, t2, anchor);
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", prevent_default(ctx[22]), false, true, false),
          listen_dev(a, "click", stop_propagation(prevent_default(ctx[23])), false, true, true),
          listen_dev(div0, "click", ctx[24], false, false, false),
          listen_dev(div0, "keypress", ctx[21], false, false, false),
          listen_dev(div0, "keypress", ctx[25], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block86(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & 4) {
        attr_dev(a, "href", ctx2[2]);
      }
      const chevrondown_changes = {};
      if (dirty[0] & 2)
        chevrondown_changes.title = ctx2[1];
      chevrondown.$set(chevrondown_changes);
      if (!current || dirty[0] & 2048 && div0_aria_label_value !== (div0_aria_label_value = ctx2[11]["aria-label"] || "listbox")) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 32) {
        toggle_class(ul, "bx--tabs__nav--hidden", ctx2[5]);
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        { role: "navigation" },
        dirty[0] & 1024 && ctx2[10]
      ]));
      toggle_class(div1, "bx--tabs", true);
      toggle_class(div1, "bx--tabs--container", ctx2[0] === "container");
      if (content_slot) {
        if (content_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(content_slot_template, ctx2[19], dirty, get_content_slot_changes),
            get_content_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(content_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(content_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      destroy_component(chevrondown);
      if (default_slot)
        default_slot.d(detaching);
      ctx[26](null);
      if (detaching)
        detach_dev(t2);
      if (content_slot)
        content_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment150.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance150($$self, $$props, $$invalidate) {
  let currentTab;
  let currentContent;
  const omit_props_names = ["selected", "type", "autoWidth", "iconDescription", "triggerHref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTab;
  let $content;
  let $tabs;
  let $tabsById;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default", "content"]);
  let { selected = 0 } = $$props;
  let { type = "default" } = $$props;
  let { autoWidth = false } = $$props;
  let { iconDescription = "Show menu options" } = $$props;
  let { triggerHref = "#" } = $$props;
  const dispatch = createEventDispatcher();
  const tabs = writable([]);
  validate_store(tabs, "tabs");
  component_subscribe($$self, tabs, (value) => $$invalidate(18, $tabs = value));
  const tabsById = derived(tabs, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  validate_store(tabsById, "tabsById");
  component_subscribe($$self, tabsById, (value) => $$invalidate(28, $tabsById = value));
  const useAutoWidth = writable(autoWidth);
  const selectedTab = writable(void 0);
  validate_store(selectedTab, "selectedTab");
  component_subscribe($$self, selectedTab, (value) => $$invalidate(16, $selectedTab = value));
  const content = writable([]);
  validate_store(content, "content");
  component_subscribe($$self, content, (value) => $$invalidate(17, $content = value));
  const contentById = derived(content, (_) => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
  const selectedContent = writable(void 0);
  let refTabList = null;
  setContext("Tabs", {
    tabs,
    contentById,
    selectedTab,
    selectedContent,
    useAutoWidth,
    add: (data) => {
      tabs.update((_) => [..._, { ...data, index: _.length }]);
    },
    addContent: (data) => {
      content.update((_) => [..._, { ...data, index: _.length }]);
    },
    update: (id) => {
      $$invalidate(14, currentIndex = $tabsById[id].index);
    },
    change: async (direction) => {
      let index = currentIndex + direction;
      if (index < 0) {
        index = $tabs.length - 1;
      } else if (index >= $tabs.length) {
        index = 0;
      }
      let disabled = $tabs[index].disabled;
      while (disabled) {
        index = index + direction;
        if (index < 0) {
          index = $tabs.length - 1;
        } else if (index >= $tabs.length) {
          index = 0;
        }
        disabled = $tabs[index].disabled;
      }
      $$invalidate(14, currentIndex = index);
      await tick();
      const activeTab = refTabList == null ? void 0 : refTabList.querySelectorAll("[role='tab']")[currentIndex];
      activeTab == null ? void 0 : activeTab.focus();
    }
  });
  afterUpdate(() => {
    $$invalidate(12, selected = currentIndex);
    if (prevIndex > -1 && prevIndex !== currentIndex) {
      dispatch("change", currentIndex);
    }
    prevIndex = currentIndex;
  });
  let dropdownHidden = true;
  let currentIndex = selected;
  let prevIndex = -1;
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  const click_handler_2 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  const keypress_handler_1 = () => {
    $$invalidate(5, dropdownHidden = !dropdownHidden);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTabList = $$value;
      $$invalidate(4, refTabList);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(12, selected = $$new_props.selected);
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("autoWidth" in $$new_props)
      $$invalidate(13, autoWidth = $$new_props.autoWidth);
    if ("iconDescription" in $$new_props)
      $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("triggerHref" in $$new_props)
      $$invalidate(2, triggerHref = $$new_props.triggerHref);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    type,
    autoWidth,
    iconDescription,
    triggerHref,
    createEventDispatcher,
    afterUpdate,
    setContext,
    tick,
    writable,
    derived,
    ChevronDown: ChevronDown_default,
    dispatch,
    tabs,
    tabsById,
    useAutoWidth,
    selectedTab,
    content,
    contentById,
    selectedContent,
    refTabList,
    dropdownHidden,
    currentIndex,
    prevIndex,
    currentContent,
    currentTab,
    $selectedTab,
    $content,
    $tabs,
    $tabsById
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(12, selected = $$new_props.selected);
    if ("type" in $$props)
      $$invalidate(0, type = $$new_props.type);
    if ("autoWidth" in $$props)
      $$invalidate(13, autoWidth = $$new_props.autoWidth);
    if ("iconDescription" in $$props)
      $$invalidate(1, iconDescription = $$new_props.iconDescription);
    if ("triggerHref" in $$props)
      $$invalidate(2, triggerHref = $$new_props.triggerHref);
    if ("refTabList" in $$props)
      $$invalidate(4, refTabList = $$new_props.refTabList);
    if ("dropdownHidden" in $$props)
      $$invalidate(5, dropdownHidden = $$new_props.dropdownHidden);
    if ("currentIndex" in $$props)
      $$invalidate(14, currentIndex = $$new_props.currentIndex);
    if ("prevIndex" in $$props)
      prevIndex = $$new_props.prevIndex;
    if ("currentContent" in $$props)
      $$invalidate(15, currentContent = $$new_props.currentContent);
    if ("currentTab" in $$props)
      $$invalidate(3, currentTab = $$new_props.currentTab);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4096) {
      $:
        $$invalidate(14, currentIndex = selected);
    }
    if ($$self.$$.dirty[0] & 278528) {
      $:
        $$invalidate(3, currentTab = $tabs[currentIndex] || void 0);
    }
    if ($$self.$$.dirty[0] & 147456) {
      $:
        $$invalidate(15, currentContent = $content[currentIndex] || void 0);
    }
    if ($$self.$$.dirty[0] & 32776) {
      $: {
        if (currentTab) {
          selectedTab.set(currentTab.id);
        }
        if (currentContent) {
          selectedContent.set(currentContent.id);
        }
      }
    }
    if ($$self.$$.dirty[0] & 65536) {
      $:
        if ($selectedTab) {
          $$invalidate(5, dropdownHidden = true);
        }
    }
    if ($$self.$$.dirty[0] & 8192) {
      $:
        useAutoWidth.set(autoWidth);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    type,
    iconDescription,
    triggerHref,
    currentTab,
    refTabList,
    dropdownHidden,
    tabs,
    tabsById,
    selectedTab,
    content,
    $$restProps,
    $$props,
    selected,
    autoWidth,
    currentIndex,
    currentContent,
    $selectedTab,
    $content,
    $tabs,
    $$scope,
    slots,
    keypress_handler,
    click_handler,
    click_handler_13,
    click_handler_2,
    keypress_handler_1,
    ul_binding
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance150,
      create_fragment150,
      safe_not_equal,
      {
        selected: 12,
        type: 0,
        autoWidth: 13,
        iconDescription: 1,
        triggerHref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment150.name
    });
  }
  get selected() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoWidth() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoWidth(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerHref() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerHref(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabs_default = Tabs;

// node_modules/carbon-components-svelte/src/Tabs/Tab.svelte
var file141 = "node_modules/carbon-components-svelte/src/Tabs/Tab.svelte";
function fallback_block28(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block28.name,
    type: "fallback",
    source: "(72:10) {label}",
    ctx
  });
  return block;
}
function create_fragment151(ctx) {
  let li;
  let a;
  let a_tabindex_value;
  let a_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  const default_slot_or_fallback = default_slot || fallback_block28(ctx);
  let li_levels = [{ tabindex: "-1" }, { role: "presentation" }, ctx[12]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr_dev(a, "role", "tab");
      attr_dev(a, "tabindex", a_tabindex_value = ctx[3] ? "-1" : ctx[4]);
      attr_dev(a, "aria-selected", ctx[6]);
      attr_dev(a, "aria-disabled", ctx[3]);
      attr_dev(a, "id", ctx[5]);
      attr_dev(a, "href", ctx[2]);
      attr_dev(a, "style", a_style_value = ctx[7] ? "width: auto" : void 0);
      toggle_class(a, "bx--tabs__nav-link", true);
      add_location(a, file141, 60, 2, 1407);
      set_attributes(li, li_data);
      toggle_class(li, "bx--tabs__nav-item", true);
      toggle_class(li, "bx--tabs__nav-item--disabled", ctx[3]);
      toggle_class(li, "bx--tabs__nav-item--selected", ctx[6]);
      add_location(li, file141, 32, 0, 791);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", prevent_default(ctx[16]), false, true, false),
          listen_dev(li, "click", prevent_default(ctx[21]), false, true, false),
          listen_dev(li, "mouseover", ctx[17], false, false, false),
          listen_dev(li, "mouseenter", ctx[18], false, false, false),
          listen_dev(li, "mouseleave", ctx[19], false, false, false),
          listen_dev(li, "keydown", ctx[22], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 24 && a_tabindex_value !== (a_tabindex_value = ctx2[3] ? "-1" : ctx2[4])) {
        attr_dev(a, "tabindex", a_tabindex_value);
      }
      if (!current || dirty & 64) {
        attr_dev(a, "aria-selected", ctx2[6]);
      }
      if (!current || dirty & 8) {
        attr_dev(a, "aria-disabled", ctx2[3]);
      }
      if (!current || dirty & 32) {
        attr_dev(a, "id", ctx2[5]);
      }
      if (!current || dirty & 4) {
        attr_dev(a, "href", ctx2[2]);
      }
      if (!current || dirty & 128 && a_style_value !== (a_style_value = ctx2[7] ? "width: auto" : void 0)) {
        attr_dev(a, "style", a_style_value);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        { tabindex: "-1" },
        { role: "presentation" },
        dirty & 4096 && ctx2[12]
      ]));
      toggle_class(li, "bx--tabs__nav-item", true);
      toggle_class(li, "bx--tabs__nav-item--disabled", ctx2[3]);
      toggle_class(li, "bx--tabs__nav-item--selected", ctx2[6]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment151.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance151($$self, $$props, $$invalidate) {
  let selected;
  const omit_props_names = ["label", "href", "disabled", "tabindex", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTab;
  let $useAutoWidth;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  let { label = "" } = $$props;
  let { href = "#" } = $$props;
  let { disabled = false } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const { selectedTab, useAutoWidth, add, update, change } = getContext("Tabs");
  validate_store(selectedTab, "selectedTab");
  component_subscribe($$self, selectedTab, (value) => $$invalidate(13, $selectedTab = value));
  validate_store(useAutoWidth, "useAutoWidth");
  component_subscribe($$self, useAutoWidth, (value) => $$invalidate(7, $useAutoWidth = value));
  add({ id, label, disabled });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const click_handler_13 = () => {
    if (!disabled) {
      update(id);
    }
  };
  const keydown_handler = ({ key }) => {
    if (!disabled) {
      if (key === "ArrowRight") {
        change(1);
      } else if (key === "ArrowLeft") {
        change(-1);
      } else if (key === " " || key === "Enter") {
        update(id);
      }
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("tabindex" in $$new_props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    label,
    href,
    disabled,
    tabindex,
    id,
    ref,
    getContext,
    selectedTab,
    useAutoWidth,
    add,
    update,
    change,
    selected,
    $selectedTab,
    $useAutoWidth
  });
  $$self.$inject_state = ($$new_props) => {
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("tabindex" in $$props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("selected" in $$props)
      $$invalidate(6, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8224) {
      $:
        $$invalidate(6, selected = $selectedTab === id);
    }
  };
  return [
    ref,
    label,
    href,
    disabled,
    tabindex,
    id,
    selected,
    $useAutoWidth,
    selectedTab,
    useAutoWidth,
    update,
    change,
    $$restProps,
    $selectedTab,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    a_binding,
    click_handler_13,
    keydown_handler
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance151, create_fragment151, safe_not_equal, {
      label: 1,
      href: 2,
      disabled: 3,
      tabindex: 4,
      id: 5,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment151.name
    });
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte
var file142 = "node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte";
function create_fragment152(ctx) {
  let div;
  let div_aria_hidden_value;
  let div_hidden_value;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let div_levels = [
    { role: "tabpanel" },
    { "aria-labelledby": ctx[1] },
    {
      "aria-hidden": div_aria_hidden_value = !ctx[2]
    },
    {
      hidden: div_hidden_value = ctx[2] ? void 0 : ""
    },
    { id: ctx[0] },
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--tab-content", true);
      add_location(div, file142, 15, 0, 374);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "tabpanel" },
        (!current || dirty & 2) && { "aria-labelledby": ctx2[1] },
        (!current || dirty & 4 && div_aria_hidden_value !== (div_aria_hidden_value = !ctx2[2])) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & 4 && div_hidden_value !== (div_hidden_value = ctx2[2] ? void 0 : "")) && { hidden: div_hidden_value },
        (!current || dirty & 1) && { id: ctx2[0] },
        dirty & 64 && ctx2[6]
      ]));
      toggle_class(div, "bx--tab-content", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment152.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance152($$self, $$props, $$invalidate) {
  let selected;
  let index;
  let tabId;
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $tabs;
  let $contentById;
  let $selectedContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabContent", slots, ["default"]);
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const { selectedContent, addContent, tabs, contentById } = getContext("Tabs");
  validate_store(selectedContent, "selectedContent");
  component_subscribe($$self, selectedContent, (value) => $$invalidate(10, $selectedContent = value));
  validate_store(tabs, "tabs");
  component_subscribe($$self, tabs, (value) => $$invalidate(8, $tabs = value));
  validate_store(contentById, "contentById");
  component_subscribe($$self, contentById, (value) => $$invalidate(9, $contentById = value));
  addContent({ id });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    getContext,
    selectedContent,
    addContent,
    tabs,
    contentById,
    index,
    tabId,
    selected,
    $tabs,
    $contentById,
    $selectedContent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("index" in $$props)
      $$invalidate(7, index = $$new_props.index);
    if ("tabId" in $$props)
      $$invalidate(1, tabId = $$new_props.tabId);
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1025) {
      $:
        $$invalidate(2, selected = $selectedContent === id);
    }
    if ($$self.$$.dirty & 513) {
      $:
        $$invalidate(7, index = $contentById[id].index);
    }
    if ($$self.$$.dirty & 384) {
      $:
        $$invalidate(1, tabId = $tabs[index].id);
    }
  };
  return [
    id,
    tabId,
    selected,
    selectedContent,
    tabs,
    contentById,
    $$restProps,
    index,
    $tabs,
    $contentById,
    $selectedContent,
    $$scope,
    slots
  ];
}
var TabContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance152, create_fragment152, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabContent",
      options,
      id: create_fragment152.name
    });
  }
  get id() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabContent_default = TabContent;

// node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte
var file143 = "node_modules/carbon-components-svelte/src/Tabs/TabsSkeleton.svelte";
function get_each_context19(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block19(ctx) {
  let li;
  let div;
  let span;
  let t;
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      span = element("span");
      t = space();
      add_location(span, file143, 27, 10, 727);
      toggle_class(div, "bx--tabs__nav-link", true);
      add_location(div, file143, 26, 8, 677);
      toggle_class(li, "bx--tabs--scrollable__nav-item", true);
      add_location(li, file143, 25, 6, 618);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div);
      append_dev(div, span);
      append_dev(li, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block19.name,
    type: "each",
    source: "(25:4) {#each Array.from({ length: count }, (_, i) => i) as item}",
    ctx
  });
  return block;
}
function create_fragment153(ctx) {
  let div;
  let ul;
  let mounted;
  let dispose;
  let each_value = Array.from({ length: ctx[0] }, func8);
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block19(get_each_context19(ctx, each_value, i));
  }
  let div_levels = [ctx[2]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      toggle_class(ul, "bx--tabs--scrollable__nav", true);
      add_location(ul, file143, 23, 2, 503);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tabs", true);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--tabs--scrollable", true);
      toggle_class(div, "bx--tabs--scrollable--container", ctx[1] === "container");
      add_location(div, file143, 12, 0, 258);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[3], false, false, false),
          listen_dev(div, "mouseover", ctx[4], false, false, false),
          listen_dev(div, "mouseenter", ctx[5], false, false, false),
          listen_dev(div, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = Array.from({ length: ctx2[0] }, func8);
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context19(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block19(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 4 && ctx2[2]]));
      toggle_class(div, "bx--tabs", true);
      toggle_class(div, "bx--skeleton", true);
      toggle_class(div, "bx--tabs--scrollable", true);
      toggle_class(div, "bx--tabs--scrollable--container", ctx2[1] === "container");
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment153.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func8 = (_, i) => i;
function instance153($$self, $$props, $$invalidate) {
  const omit_props_names = ["count", "type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsSkeleton", slots, []);
  let { count = 4 } = $$props;
  let { type = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("count" in $$new_props)
      $$invalidate(0, count = $$new_props.count);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
  };
  $$self.$capture_state = () => ({ count, type });
  $$self.$inject_state = ($$new_props) => {
    if ("count" in $$props)
      $$invalidate(0, count = $$new_props.count);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    count,
    type,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TabsSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance153, create_fragment153, safe_not_equal, { count: 0, type: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsSkeleton",
      options,
      id: create_fragment153.name
    });
  }
  get count() {
    throw new Error("<TabsSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<TabsSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<TabsSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TabsSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabsSkeleton_default = TabsSkeleton;

// node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte
var file144 = "node_modules/carbon-components-svelte/src/Tag/TagSkeleton.svelte";
function create_fragment154(ctx) {
  let span;
  let mounted;
  let dispose;
  let span_levels = [ctx[1]];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      set_attributes(span, span_data);
      toggle_class(span, "bx--tag", true);
      toggle_class(span, "bx--tag--sm", ctx[0] === "sm");
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file144, 6, 0, 142);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(span, "click", ctx[2], false, false, false),
          listen_dev(span, "mouseover", ctx[3], false, false, false),
          listen_dev(span, "mouseenter", ctx[4], false, false, false),
          listen_dev(span, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(span, "bx--tag", true);
      toggle_class(span, "bx--tag--sm", ctx2[0] === "sm");
      toggle_class(span, "bx--skeleton", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment154.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance154($$self, $$props, $$invalidate) {
  const omit_props_names = ["size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TagSkeleton", slots, []);
  let { size = "default" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
  };
  $$self.$capture_state = () => ({ size });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    size,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TagSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance154, create_fragment154, safe_not_equal, { size: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TagSkeleton",
      options,
      id: create_fragment154.name
    });
  }
  get size() {
    throw new Error("<TagSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TagSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TagSkeleton_default = TagSkeleton;

// node_modules/carbon-components-svelte/src/Tag/Tag.svelte
var file145 = "node_modules/carbon-components-svelte/src/Tag/Tag.svelte";
var get_icon_slot_changes_13 = (dirty) => ({});
var get_icon_slot_context_13 = (ctx) => ({});
var get_icon_slot_changes3 = (dirty) => ({});
var get_icon_slot_context3 = (ctx) => ({ props: { class: "bx--tag__label" } });
var get_default_slot_changes11 = (dirty) => ({});
var get_default_slot_context11 = (ctx) => ({ props: { class: "bx--tag__label" } });
function create_else_block28(ctx) {
  let div;
  let t;
  let span;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[11].icon || ctx[7]) && create_if_block_412(ctx);
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  let div_levels = [{ id: ctx[8] }, ctx[10]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      add_location(span, file145, 166, 4, 4938);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tag", true);
      toggle_class(div, "bx--tag--disabled", ctx[3]);
      toggle_class(div, "bx--tag--sm", ctx[1] === "sm");
      toggle_class(div, "bx--tag--red", ctx[0] === "red");
      toggle_class(div, "bx--tag--magenta", ctx[0] === "magenta");
      toggle_class(div, "bx--tag--purple", ctx[0] === "purple");
      toggle_class(div, "bx--tag--blue", ctx[0] === "blue");
      toggle_class(div, "bx--tag--cyan", ctx[0] === "cyan");
      toggle_class(div, "bx--tag--teal", ctx[0] === "teal");
      toggle_class(div, "bx--tag--green", ctx[0] === "green");
      toggle_class(div, "bx--tag--gray", ctx[0] === "gray");
      toggle_class(div, "bx--tag--cool-gray", ctx[0] === "cool-gray");
      toggle_class(div, "bx--tag--warm-gray", ctx[0] === "warm-gray");
      toggle_class(div, "bx--tag--high-contrast", ctx[0] === "high-contrast");
      toggle_class(div, "bx--tag--outline", ctx[0] === "outline");
      add_location(div, file145, 136, 2, 3944);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t);
      append_dev(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[22], false, false, false),
          listen_dev(div, "mouseover", ctx[23], false, false, false),
          listen_dev(div, "mouseenter", ctx[24], false, false, false),
          listen_dev(div, "mouseleave", ctx[25], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[11].icon || ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2176) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_412(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 256) && { id: ctx2[8] },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(div, "bx--tag", true);
      toggle_class(div, "bx--tag--disabled", ctx2[3]);
      toggle_class(div, "bx--tag--sm", ctx2[1] === "sm");
      toggle_class(div, "bx--tag--red", ctx2[0] === "red");
      toggle_class(div, "bx--tag--magenta", ctx2[0] === "magenta");
      toggle_class(div, "bx--tag--purple", ctx2[0] === "purple");
      toggle_class(div, "bx--tag--blue", ctx2[0] === "blue");
      toggle_class(div, "bx--tag--cyan", ctx2[0] === "cyan");
      toggle_class(div, "bx--tag--teal", ctx2[0] === "teal");
      toggle_class(div, "bx--tag--green", ctx2[0] === "green");
      toggle_class(div, "bx--tag--gray", ctx2[0] === "gray");
      toggle_class(div, "bx--tag--cool-gray", ctx2[0] === "cool-gray");
      toggle_class(div, "bx--tag--warm-gray", ctx2[0] === "warm-gray");
      toggle_class(div, "bx--tag--high-contrast", ctx2[0] === "high-contrast");
      toggle_class(div, "bx--tag--outline", ctx2[0] === "outline");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(136:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_222(ctx) {
  let button;
  let t;
  let span;
  let button_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[11].icon || ctx[7]) && create_if_block_316(ctx);
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  let button_levels = [
    { type: "button" },
    { id: ctx[8] },
    { disabled: ctx[3] },
    { "aria-disabled": ctx[3] },
    {
      tabindex: button_tabindex_value = ctx[3] ? "-1" : void 0
    },
    ctx[10]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      add_location(span, file145, 131, 4, 3888);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tag", true);
      toggle_class(button, "bx--tag--interactive", true);
      toggle_class(button, "bx--tag--disabled", ctx[3]);
      toggle_class(button, "bx--tag--sm", ctx[1] === "sm");
      toggle_class(button, "bx--tag--red", ctx[0] === "red");
      toggle_class(button, "bx--tag--magenta", ctx[0] === "magenta");
      toggle_class(button, "bx--tag--purple", ctx[0] === "purple");
      toggle_class(button, "bx--tag--blue", ctx[0] === "blue");
      toggle_class(button, "bx--tag--cyan", ctx[0] === "cyan");
      toggle_class(button, "bx--tag--teal", ctx[0] === "teal");
      toggle_class(button, "bx--tag--green", ctx[0] === "green");
      toggle_class(button, "bx--tag--gray", ctx[0] === "gray");
      toggle_class(button, "bx--tag--cool-gray", ctx[0] === "cool-gray");
      toggle_class(button, "bx--tag--warm-gray", ctx[0] === "warm-gray");
      toggle_class(button, "bx--tag--high-contrast", ctx[0] === "high-contrast");
      toggle_class(button, "bx--tag--outline", ctx[0] === "outline");
      add_location(button, file145, 96, 2, 2731);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_dev(button, t);
      append_dev(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[18], false, false, false),
          listen_dev(button, "mouseover", ctx[19], false, false, false),
          listen_dev(button, "mouseenter", ctx[20], false, false, false),
          listen_dev(button, "mouseleave", ctx[21], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[11].icon || ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2176) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_316(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & 256) && { id: ctx2[8] },
        (!current || dirty & 8) && { disabled: ctx2[3] },
        (!current || dirty & 8) && { "aria-disabled": ctx2[3] },
        (!current || dirty & 8 && button_tabindex_value !== (button_tabindex_value = ctx2[3] ? "-1" : void 0)) && { tabindex: button_tabindex_value },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(button, "bx--tag", true);
      toggle_class(button, "bx--tag--interactive", true);
      toggle_class(button, "bx--tag--disabled", ctx2[3]);
      toggle_class(button, "bx--tag--sm", ctx2[1] === "sm");
      toggle_class(button, "bx--tag--red", ctx2[0] === "red");
      toggle_class(button, "bx--tag--magenta", ctx2[0] === "magenta");
      toggle_class(button, "bx--tag--purple", ctx2[0] === "purple");
      toggle_class(button, "bx--tag--blue", ctx2[0] === "blue");
      toggle_class(button, "bx--tag--cyan", ctx2[0] === "cyan");
      toggle_class(button, "bx--tag--teal", ctx2[0] === "teal");
      toggle_class(button, "bx--tag--green", ctx2[0] === "green");
      toggle_class(button, "bx--tag--gray", ctx2[0] === "gray");
      toggle_class(button, "bx--tag--cool-gray", ctx2[0] === "cool-gray");
      toggle_class(button, "bx--tag--warm-gray", ctx2[0] === "warm-gray");
      toggle_class(button, "bx--tag--high-contrast", ctx2[0] === "high-contrast");
      toggle_class(button, "bx--tag--outline", ctx2[0] === "outline");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(96:22) ",
    ctx
  });
  return block;
}
function create_if_block_134(ctx) {
  let div;
  let t;
  let button;
  let close;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context11);
  const default_slot_or_fallback = default_slot || fallback_block29(ctx);
  close = new Close_default({ $$inline: true });
  let div_levels = [
    { "aria-label": ctx[6] },
    { id: ctx[8] },
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      button = element("button");
      create_component(close.$$.fragment);
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-labelledby", ctx[8]);
      button.disabled = ctx[3];
      attr_dev(button, "title", ctx[6]);
      toggle_class(button, "bx--tag__close-icon", true);
      add_location(button, file145, 78, 4, 2345);
      set_attributes(div, div_data);
      toggle_class(div, "bx--tag", true);
      toggle_class(div, "bx--tag--disabled", ctx[3]);
      toggle_class(div, "bx--tag--filter", ctx[2]);
      toggle_class(div, "bx--tag--sm", ctx[1] === "sm");
      toggle_class(div, "bx--tag--red", ctx[0] === "red");
      toggle_class(div, "bx--tag--magenta", ctx[0] === "magenta");
      toggle_class(div, "bx--tag--purple", ctx[0] === "purple");
      toggle_class(div, "bx--tag--blue", ctx[0] === "blue");
      toggle_class(div, "bx--tag--cyan", ctx[0] === "cyan");
      toggle_class(div, "bx--tag--teal", ctx[0] === "teal");
      toggle_class(div, "bx--tag--green", ctx[0] === "green");
      toggle_class(div, "bx--tag--gray", ctx[0] === "gray");
      toggle_class(div, "bx--tag--cool-gray", ctx[0] === "cool-gray");
      toggle_class(div, "bx--tag--warm-gray", ctx[0] === "warm-gray");
      toggle_class(div, "bx--tag--high-contrast", ctx[0] === "high-contrast");
      toggle_class(div, "bx--tag--outline", ctx[0] === "outline");
      add_location(div, file145, 54, 2, 1428);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_dev(div, t);
      append_dev(div, button);
      mount_component(close, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", stop_propagation(ctx[14]), false, false, true),
          listen_dev(button, "click", stop_propagation(ctx[30]), false, false, true),
          listen_dev(button, "mouseover", ctx[15], false, false, false),
          listen_dev(button, "mouseenter", ctx[16], false, false, false),
          listen_dev(button, "mouseleave", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, get_default_slot_changes11),
            get_default_slot_context11
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 256) {
        attr_dev(button, "aria-labelledby", ctx2[8]);
      }
      if (!current || dirty & 8) {
        prop_dev(button, "disabled", ctx2[3]);
      }
      if (!current || dirty & 64) {
        attr_dev(button, "title", ctx2[6]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 64) && { "aria-label": ctx2[6] },
        (!current || dirty & 256) && { id: ctx2[8] },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(div, "bx--tag", true);
      toggle_class(div, "bx--tag--disabled", ctx2[3]);
      toggle_class(div, "bx--tag--filter", ctx2[2]);
      toggle_class(div, "bx--tag--sm", ctx2[1] === "sm");
      toggle_class(div, "bx--tag--red", ctx2[0] === "red");
      toggle_class(div, "bx--tag--magenta", ctx2[0] === "magenta");
      toggle_class(div, "bx--tag--purple", ctx2[0] === "purple");
      toggle_class(div, "bx--tag--blue", ctx2[0] === "blue");
      toggle_class(div, "bx--tag--cyan", ctx2[0] === "cyan");
      toggle_class(div, "bx--tag--teal", ctx2[0] === "teal");
      toggle_class(div, "bx--tag--green", ctx2[0] === "green");
      toggle_class(div, "bx--tag--gray", ctx2[0] === "gray");
      toggle_class(div, "bx--tag--cool-gray", ctx2[0] === "cool-gray");
      toggle_class(div, "bx--tag--warm-gray", ctx2[0] === "warm-gray");
      toggle_class(div, "bx--tag--high-contrast", ctx2[0] === "high-contrast");
      toggle_class(div, "bx--tag--outline", ctx2[0] === "outline");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      destroy_component(close);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_134.name,
    type: "if",
    source: "(54:17) ",
    ctx
  });
  return block;
}
function create_if_block87(ctx) {
  let tagskeleton;
  let current;
  const tagskeleton_spread_levels = [{ size: ctx[1] }, ctx[10]];
  let tagskeleton_props = {};
  for (let i = 0; i < tagskeleton_spread_levels.length; i += 1) {
    tagskeleton_props = assign(tagskeleton_props, tagskeleton_spread_levels[i]);
  }
  tagskeleton = new TagSkeleton_default({ props: tagskeleton_props, $$inline: true });
  tagskeleton.$on("click", ctx[26]);
  tagskeleton.$on("mouseover", ctx[27]);
  tagskeleton.$on("mouseenter", ctx[28]);
  tagskeleton.$on("mouseleave", ctx[29]);
  const block = {
    c: function create() {
      create_component(tagskeleton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tagskeleton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tagskeleton_changes = dirty & 1026 ? get_spread_update(tagskeleton_spread_levels, [
        dirty & 2 && { size: ctx2[1] },
        dirty & 1024 && get_spread_object(ctx2[10])
      ]) : {};
      tagskeleton.$set(tagskeleton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tagskeleton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tagskeleton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tagskeleton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block87.name,
    type: "if",
    source: "(45:0) {#if skeleton}",
    ctx
  });
  return block;
}
function create_if_block_412(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[13].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context_13);
  const icon_slot_or_fallback = icon_slot || fallback_block_25(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--tag__custom-icon", true);
      add_location(div, file145, 160, 6, 4781);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes_13),
            get_icon_slot_context_13
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 128)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_412.name,
    type: "if",
    source: "(160:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_25(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_25.name,
    type: "fallback",
    source: "(162:26)            ",
    ctx
  });
  return block;
}
function create_if_block_316(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[13].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context3);
  const icon_slot_or_fallback = icon_slot || fallback_block_19(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--tag__custom-icon", true);
      add_location(div, file145, 125, 6, 3731);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes3),
            get_icon_slot_context3
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 128)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_316.name,
    type: "if",
    source: "(125:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_19(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_19.name,
    type: "fallback",
    source: "(127:26)            ",
    ctx
  });
  return block;
}
function fallback_block29(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(ctx[0]);
      toggle_class(span, "bx--tag__label", true);
      add_location(span, file145, 76, 6, 2279);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block29.name,
    type: "fallback",
    source: "(76:48)        ",
    ctx
  });
  return block;
}
function create_fragment155(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block87, create_if_block_134, create_if_block_222, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    if (ctx2[2])
      return 1;
    if (ctx2[4])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment155.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance155($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "size", "filter", "disabled", "interactive", "skeleton", "title", "icon", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tag", slots, ["default", "icon"]);
  const $$slots = compute_slots(slots);
  let { type = void 0 } = $$props;
  let { size = "default" } = $$props;
  let { filter = false } = $$props;
  let { disabled = false } = $$props;
  let { interactive = false } = $$props;
  let { skeleton = false } = $$props;
  let { title = "Clear filter" } = $$props;
  let { icon = void 0 } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler_13(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_4 = () => {
    dispatch("close");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("filter" in $$new_props)
      $$invalidate(2, filter = $$new_props.filter);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("interactive" in $$new_props)
      $$invalidate(4, interactive = $$new_props.interactive);
    if ("skeleton" in $$new_props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("title" in $$new_props)
      $$invalidate(6, title = $$new_props.title);
    if ("icon" in $$new_props)
      $$invalidate(7, icon = $$new_props.icon);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    type,
    size,
    filter,
    disabled,
    interactive,
    skeleton,
    title,
    icon,
    id,
    createEventDispatcher,
    Close: Close_default,
    TagSkeleton: TagSkeleton_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("type" in $$props)
      $$invalidate(0, type = $$new_props.type);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("filter" in $$props)
      $$invalidate(2, filter = $$new_props.filter);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("interactive" in $$props)
      $$invalidate(4, interactive = $$new_props.interactive);
    if ("skeleton" in $$props)
      $$invalidate(5, skeleton = $$new_props.skeleton);
    if ("title" in $$props)
      $$invalidate(6, title = $$new_props.title);
    if ("icon" in $$props)
      $$invalidate(7, icon = $$new_props.icon);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    size,
    filter,
    disabled,
    interactive,
    skeleton,
    title,
    icon,
    id,
    dispatch,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler_13,
    mouseover_handler_1,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler_2,
    mouseover_handler_2,
    mouseenter_handler_2,
    mouseleave_handler_2,
    click_handler_3,
    mouseover_handler_3,
    mouseenter_handler_3,
    mouseleave_handler_3,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler_4
  ];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance155, create_fragment155, safe_not_equal, {
      type: 0,
      size: 1,
      filter: 2,
      disabled: 3,
      interactive: 4,
      skeleton: 5,
      title: 6,
      icon: 7,
      id: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment155.name
    });
  }
  get type() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skeleton() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skeleton(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;

// node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte
var file146 = "node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte";
var get_labelText_slot_changes11 = (dirty) => ({});
var get_labelText_slot_context11 = (ctx) => ({});
function create_if_block_317(ctx) {
  let div;
  let label;
  let t;
  let current;
  const labelText_slot_template = ctx[20].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[19], get_labelText_slot_context11);
  const labelText_slot_or_fallback = labelText_slot || fallback_block30(ctx);
  let if_block = ctx[5] && create_if_block_413(ctx);
  const block = {
    c: function create() {
      div = element("div");
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t = space();
      if (if_block)
        if_block.c();
      attr_dev(label, "for", ctx[14]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[11]);
      toggle_class(label, "bx--label--disabled", ctx[7]);
      add_location(label, file146, 71, 6, 1703);
      toggle_class(div, "bx--text-area__label-wrapper", true);
      add_location(div, file146, 70, 4, 1647);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, label);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(labelText_slot_template, ctx2[19], dirty, get_labelText_slot_changes11),
            get_labelText_slot_context11
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 1024)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 16384) {
        attr_dev(label, "for", ctx2[14]);
      }
      if (!current || dirty[0] & 2048) {
        toggle_class(label, "bx--visually-hidden", ctx2[11]);
      }
      if (!current || dirty[0] & 128) {
        toggle_class(label, "bx--label--disabled", ctx2[7]);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_413(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_317.name,
    type: "if",
    source: "(70:2) {#if (labelText || $$slots.labelText) && !hideLabel}",
    ctx
  });
  return block;
}
function fallback_block30(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[10]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1024)
        set_data_dev(t, ctx2[10]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block30.name,
    type: "fallback",
    source: "(78:31)            ",
    ctx
  });
  return block;
}
function create_if_block_413(ctx) {
  let div;
  let t0_value = ctx[0].length + "";
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = text("/");
      t2 = text(ctx[5]);
      toggle_class(div, "bx--label", true);
      toggle_class(div, "bx--label--disabled", ctx[7]);
      add_location(div, file146, 82, 8, 1979);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t0);
      append_dev(div, t1);
      append_dev(div, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1 && t0_value !== (t0_value = ctx2[0].length + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & 32)
        set_data_dev(t2, ctx2[5]);
      if (dirty[0] & 128) {
        toggle_class(div, "bx--label--disabled", ctx2[7]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_413.name,
    type: "if",
    source: "(82:6) {#if maxCount}",
    ctx
  });
  return block;
}
function create_if_block_223(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-area__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_223.name,
    type: "if",
    source: "(93:4) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_135(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[9]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[7]);
      add_location(div, file146, 121, 4, 2989);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
      if (dirty[0] & 128) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[7]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_135.name,
    type: "if",
    source: "(121:2) {#if !invalid && helperText}",
    ctx
  });
  return block;
}
function create_if_block88(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[13]);
      attr_dev(div, "id", ctx[16]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file146, 129, 4, 3158);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8192)
        set_data_dev(t, ctx2[13]);
      if (dirty[0] & 65536) {
        attr_dev(div, "id", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block88.name,
    type: "if",
    source: "(129:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_fragment156(ctx) {
  var _a;
  let div1;
  let t0;
  let div0;
  let t1;
  let textarea;
  let textarea_aria_invalid_value;
  let textarea_aria_describedby_value;
  let textarea_maxlength_value;
  let div0_data_invalid_value;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[10] || ctx[17].labelText) && !ctx[11] && create_if_block_317(ctx);
  let if_block1 = ctx[12] && create_if_block_223(ctx);
  let textarea_levels = [
    {
      "aria-invalid": textarea_aria_invalid_value = ctx[12] || void 0
    },
    {
      "aria-describedby": textarea_aria_describedby_value = ctx[12] ? ctx[16] : void 0
    },
    { disabled: ctx[7] },
    { id: ctx[14] },
    { name: ctx[15] },
    { cols: ctx[3] },
    { rows: ctx[4] },
    { placeholder: ctx[2] },
    { readOnly: ctx[8] },
    {
      maxlength: textarea_maxlength_value = (_a = ctx[5]) != null ? _a : void 0
    },
    ctx[18]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  let if_block2 = !ctx[12] && ctx[9] && create_if_block_135(ctx);
  let if_block3 = ctx[12] && create_if_block88(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      textarea = element("textarea");
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "bx--text-area", true);
      toggle_class(textarea, "bx--text-area--light", ctx[6]);
      toggle_class(textarea, "bx--text-area--invalid", ctx[12]);
      add_location(textarea, file146, 95, 4, 2318);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = ctx[12] || void 0);
      toggle_class(div0, "bx--text-area__wrapper", true);
      add_location(div0, file146, 88, 2, 2133);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file146, 62, 0, 1492);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_dev(div1, t0);
      append_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_dev(div0, t1);
      append_dev(div0, textarea);
      if (textarea.autofocus)
        textarea.focus();
      ctx[32](textarea);
      set_input_value(textarea, ctx[0]);
      append_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      append_dev(div1, t3);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(textarea, "input", ctx[33]),
          listen_dev(textarea, "change", ctx[25], false, false, false),
          listen_dev(textarea, "input", ctx[26], false, false, false),
          listen_dev(textarea, "keydown", ctx[27], false, false, false),
          listen_dev(textarea, "keyup", ctx[28], false, false, false),
          listen_dev(textarea, "focus", ctx[29], false, false, false),
          listen_dev(textarea, "blur", ctx[30], false, false, false),
          listen_dev(textarea, "paste", ctx[31], false, false, false),
          listen_dev(div1, "click", ctx[21], false, false, false),
          listen_dev(div1, "mouseover", ctx[22], false, false, false),
          listen_dev(div1, "mouseenter", ctx[23], false, false, false),
          listen_dev(div1, "mouseleave", ctx[24], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if ((ctx2[10] || ctx2[17].labelText) && !ctx2[11]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 134144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_317(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[12]) {
        if (if_block1) {
          if (dirty[0] & 4096) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_223(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        (!current || dirty[0] & 4096 && textarea_aria_invalid_value !== (textarea_aria_invalid_value = ctx2[12] || void 0)) && {
          "aria-invalid": textarea_aria_invalid_value
        },
        (!current || dirty[0] & 69632 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = ctx2[12] ? ctx2[16] : void 0)) && {
          "aria-describedby": textarea_aria_describedby_value
        },
        (!current || dirty[0] & 128) && { disabled: ctx2[7] },
        (!current || dirty[0] & 16384) && { id: ctx2[14] },
        (!current || dirty[0] & 32768) && { name: ctx2[15] },
        (!current || dirty[0] & 8) && { cols: ctx2[3] },
        (!current || dirty[0] & 16) && { rows: ctx2[4] },
        (!current || dirty[0] & 4) && { placeholder: ctx2[2] },
        (!current || dirty[0] & 256) && { readOnly: ctx2[8] },
        (!current || dirty[0] & 32 && textarea_maxlength_value !== (textarea_maxlength_value = (_a2 = ctx2[5]) != null ? _a2 : void 0)) && { maxlength: textarea_maxlength_value },
        dirty[0] & 262144 && ctx2[18]
      ]));
      if (dirty[0] & 1) {
        set_input_value(textarea, ctx2[0]);
      }
      toggle_class(textarea, "bx--text-area", true);
      toggle_class(textarea, "bx--text-area--light", ctx2[6]);
      toggle_class(textarea, "bx--text-area--invalid", ctx2[12]);
      if (!current || dirty[0] & 4096 && div0_data_invalid_value !== (div0_data_invalid_value = ctx2[12] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!ctx2[12] && ctx2[9]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_135(ctx2);
          if_block2.c();
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[12]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block88(ctx2);
          if_block3.c();
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[32](null);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment156.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance156($$self, $$props, $$invalidate) {
  let errorId;
  const omit_props_names = [
    "value",
    "placeholder",
    "cols",
    "rows",
    "maxCount",
    "light",
    "disabled",
    "readonly",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextArea", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { cols = 50 } = $$props;
  let { rows = 4 } = $$props;
  let { maxCount = void 0 } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { helperText = "" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("cols" in $$new_props)
      $$invalidate(3, cols = $$new_props.cols);
    if ("rows" in $$new_props)
      $$invalidate(4, rows = $$new_props.rows);
    if ("maxCount" in $$new_props)
      $$invalidate(5, maxCount = $$new_props.maxCount);
    if ("light" in $$new_props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("helperText" in $$new_props)
      $$invalidate(9, helperText = $$new_props.helperText);
    if ("labelText" in $$new_props)
      $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props)
      $$invalidate(12, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(13, invalidText = $$new_props.invalidText);
    if ("id" in $$new_props)
      $$invalidate(14, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    placeholder,
    cols,
    rows,
    maxCount,
    light,
    disabled,
    readonly,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    ref,
    WarningFilled: WarningFilled_default,
    errorId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
    if ("cols" in $$props)
      $$invalidate(3, cols = $$new_props.cols);
    if ("rows" in $$props)
      $$invalidate(4, rows = $$new_props.rows);
    if ("maxCount" in $$props)
      $$invalidate(5, maxCount = $$new_props.maxCount);
    if ("light" in $$props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("readonly" in $$props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("helperText" in $$props)
      $$invalidate(9, helperText = $$new_props.helperText);
    if ("labelText" in $$props)
      $$invalidate(10, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(11, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props)
      $$invalidate(12, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(13, invalidText = $$new_props.invalidText);
    if ("id" in $$props)
      $$invalidate(14, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(15, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("errorId" in $$props)
      $$invalidate(16, errorId = $$new_props.errorId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 16384) {
      $:
        $$invalidate(16, errorId = `error-${id}`);
    }
  };
  return [
    value,
    ref,
    placeholder,
    cols,
    rows,
    maxCount,
    light,
    disabled,
    readonly,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    errorId,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    textarea_binding,
    textarea_input_handler
  ];
}
var TextArea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance156,
      create_fragment156,
      safe_not_equal,
      {
        value: 0,
        placeholder: 2,
        cols: 3,
        rows: 4,
        maxCount: 5,
        light: 6,
        disabled: 7,
        readonly: 8,
        helperText: 9,
        labelText: 10,
        hideLabel: 11,
        invalid: 12,
        invalidText: 13,
        id: 14,
        name: 15,
        ref: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextArea",
      options,
      id: create_fragment156.name
    });
  }
  get value() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxCount() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxCount(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextArea_default = TextArea;

// node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte
var file147 = "node_modules/carbon-components-svelte/src/TextArea/TextAreaSkeleton.svelte";
function create_if_block89(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file147, 15, 4, 302);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block89.name,
    type: "if",
    source: "(15:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment157(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !ctx[0] && create_if_block89(ctx);
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--text-area", true);
      add_location(div0, file147, 17, 2, 379);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file147, 6, 0, 164);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block89(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment157.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance157($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextAreaSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TextAreaSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance157, create_fragment157, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextAreaSkeleton",
      options,
      id: create_fragment157.name
    });
  }
  get hideLabel() {
    throw new Error("<TextAreaSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextAreaSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextAreaSkeleton_default = TextAreaSkeleton;

// node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte
var file148 = "node_modules/carbon-components-svelte/src/TextInput/TextInput.svelte";
var get_labelText_slot_changes_12 = (dirty) => ({});
var get_labelText_slot_context_12 = (ctx) => ({});
var get_labelText_slot_changes12 = (dirty) => ({});
var get_labelText_slot_context12 = (ctx) => ({});
function create_if_block_103(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = ctx[9] && create_if_block_1210(ctx);
  let if_block1 = !ctx[20] && ctx[6] && create_if_block_1110(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      toggle_class(div, "bx--text-input__label-helper-wrapper", true);
      add_location(div, file148, 115, 4, 2896);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1210(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[20] && ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1110(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_103.name,
    type: "if",
    source: "(115:2) {#if inline}",
    ctx
  });
  return block;
}
function create_if_block_1210(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[26].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[25], get_labelText_slot_context12);
  const labelText_slot_or_fallback = labelText_slot || fallback_block_110(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[7]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[10]);
      toggle_class(label, "bx--label--disabled", ctx[5]);
      toggle_class(label, "bx--label--inline", ctx[16]);
      toggle_class(label, "bx--label--inline--sm", ctx[2] === "sm");
      toggle_class(label, "bx--label--inline--xl", ctx[2] === "xl");
      add_location(label, file148, 117, 8, 2984);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(labelText_slot_template, ctx2[25], dirty, get_labelText_slot_changes12),
            get_labelText_slot_context12
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 128) {
        attr_dev(label, "for", ctx2[7]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--visually-hidden", ctx2[10]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(label, "bx--label--disabled", ctx2[5]);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(label, "bx--label--inline", ctx2[16]);
      }
      if (!current || dirty[0] & 4) {
        toggle_class(label, "bx--label--inline--sm", ctx2[2] === "sm");
      }
      if (!current || dirty[0] & 4) {
        toggle_class(label, "bx--label--inline--xl", ctx2[2] === "xl");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1210.name,
    type: "if",
    source: "(117:6) {#if labelText}",
    ctx
  });
  return block;
}
function fallback_block_110(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[9]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_110.name,
    type: "fallback",
    source: "(127:33)              ",
    ctx
  });
  return block;
}
function create_if_block_1110(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[6]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[5]);
      toggle_class(div, "bx--form__helper-text--inline", ctx[16]);
      add_location(div, file148, 132, 8, 3461);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
      if (dirty[0] & 32) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[5]);
      }
      if (dirty[0] & 65536) {
        toggle_class(div, "bx--form__helper-text--inline", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1110.name,
    type: "if",
    source: "(132:6) {#if !isFluid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_94(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[26].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[25], get_labelText_slot_context_12);
  const labelText_slot_or_fallback = labelText_slot || fallback_block31(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[7]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[10]);
      toggle_class(label, "bx--label--disabled", ctx[5]);
      toggle_class(label, "bx--label--inline", ctx[16]);
      toggle_class(label, "bx--label--inline-sm", ctx[16] && ctx[2] === "sm");
      toggle_class(label, "bx--label--inline-xl", ctx[16] && ctx[2] === "xl");
      add_location(label, file148, 143, 4, 3766);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(labelText_slot_template, ctx2[25], dirty, get_labelText_slot_changes_12),
            get_labelText_slot_context_12
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 512)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 128) {
        attr_dev(label, "for", ctx2[7]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--visually-hidden", ctx2[10]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(label, "bx--label--disabled", ctx2[5]);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(label, "bx--label--inline", ctx2[16]);
      }
      if (!current || dirty[0] & 65540) {
        toggle_class(label, "bx--label--inline-sm", ctx2[16] && ctx2[2] === "sm");
      }
      if (!current || dirty[0] & 65540) {
        toggle_class(label, "bx--label--inline-xl", ctx2[16] && ctx2[2] === "xl");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_94.name,
    type: "if",
    source: "(143:2) {#if !inline && (labelText || $$slots.labelText)}",
    ctx
  });
  return block;
}
function fallback_block31(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[9]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block31.name,
    type: "fallback",
    source: "(153:29)          ",
    ctx
  });
  return block;
}
function create_if_block_84(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-input__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_84.name,
    type: "if",
    source: "(168:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_75(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_75.name,
    type: "if",
    source: "(171:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_69(ctx) {
  let editoff;
  let current;
  editoff = new EditOff_default({
    props: { class: "bx--text-input__readonly-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(editoff.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(editoff, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(editoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(editoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(editoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_69.name,
    type: "if",
    source: "(177:6) {#if readonly}",
    ctx
  });
  return block;
}
function create_if_block_510(ctx) {
  let hr;
  const block = {
    c: function create() {
      hr = element("hr");
      toggle_class(hr, "bx--text-input__divider", true);
      add_location(hr, file148, 208, 8, 5797);
    },
    m: function mount(target, anchor) {
      insert_dev(target, hr, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_510.name,
    type: "if",
    source: "(208:6) {#if isFluid}",
    ctx
  });
  return block;
}
function create_if_block_414(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[12]);
      attr_dev(div, "id", ctx[19]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 211, 8, 5905);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
      if (dirty[0] & 524288) {
        attr_dev(div, "id", ctx2[19]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_414.name,
    type: "if",
    source: "(211:6) {#if isFluid && !inline && invalid}",
    ctx
  });
  return block;
}
function create_if_block_318(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[14]);
      attr_dev(div, "id", ctx[18]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 216, 8, 6060);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16384)
        set_data_dev(t, ctx2[14]);
      if (dirty[0] & 262144) {
        attr_dev(div, "id", ctx2[18]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_318.name,
    type: "if",
    source: "(216:6) {#if isFluid && !inline && warn}",
    ctx
  });
  return block;
}
function create_if_block_224(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[6]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[5]);
      toggle_class(div, "bx--form__helper-text--inline", ctx[16]);
      add_location(div, file148, 220, 6, 6226);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
      if (dirty[0] & 32) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[5]);
      }
      if (dirty[0] & 65536) {
        toggle_class(div, "bx--form__helper-text--inline", ctx2[16]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_224.name,
    type: "if",
    source: "(220:4) {#if !invalid && !warn && !isFluid && !inline && helperText}",
    ctx
  });
  return block;
}
function create_if_block_136(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[12]);
      attr_dev(div, "id", ctx[19]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 229, 6, 6478);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
      if (dirty[0] & 524288) {
        attr_dev(div, "id", ctx2[19]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_136.name,
    type: "if",
    source: "(229:4) {#if !isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block90(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[14]);
      attr_dev(div, "id", ctx[18]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file148, 234, 6, 6625);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16384)
        set_data_dev(t, ctx2[14]);
      if (dirty[0] & 262144) {
        attr_dev(div, "id", ctx2[18]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block90.name,
    type: "if",
    source: "(234:4) {#if !isFluid && !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment158(ctx) {
  let div2;
  let t0;
  let t1;
  let div1;
  let div0;
  let t2;
  let t3;
  let t4;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_data_warn_value;
  let input_aria_describedby_value;
  let t5;
  let t6;
  let t7;
  let div0_data_invalid_value;
  let div0_data_warn_value;
  let t8;
  let t9;
  let t10;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[16] && create_if_block_103(ctx);
  let if_block1 = !ctx[16] && (ctx[9] || ctx[24].labelText) && create_if_block_94(ctx);
  let if_block2 = ctx[11] && create_if_block_84(ctx);
  let if_block3 = !ctx[11] && ctx[13] && create_if_block_75(ctx);
  let if_block4 = ctx[17] && create_if_block_69(ctx);
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = ctx[11] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = ctx[11] || void 0
    },
    {
      "data-warn": input_data_warn_value = ctx[13] || void 0
    },
    {
      "aria-describedby": input_aria_describedby_value = ctx[11] ? ctx[19] : ctx[13] ? ctx[18] : void 0
    },
    { disabled: ctx[5] },
    { id: ctx[7] },
    { name: ctx[8] },
    { placeholder: ctx[3] },
    { required: ctx[15] },
    { readOnly: ctx[17] },
    ctx[23]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block5 = ctx[20] && create_if_block_510(ctx);
  let if_block6 = ctx[20] && !ctx[16] && ctx[11] && create_if_block_414(ctx);
  let if_block7 = ctx[20] && !ctx[16] && ctx[13] && create_if_block_318(ctx);
  let if_block8 = !ctx[11] && !ctx[13] && !ctx[20] && !ctx[16] && ctx[6] && create_if_block_224(ctx);
  let if_block9 = !ctx[20] && ctx[11] && create_if_block_136(ctx);
  let if_block10 = !ctx[20] && !ctx[11] && ctx[13] && create_if_block90(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      input = element("input");
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      t10 = space();
      if (if_block10)
        if_block10.c();
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx[4]);
      toggle_class(input, "bx--text-input--invalid", ctx[11]);
      toggle_class(input, "bx--text-input--warn", ctx[13]);
      toggle_class(input, "bx--text-input--sm", ctx[2] === "sm");
      toggle_class(input, "bx--text-input--xl", ctx[2] === "xl");
      add_location(input, file148, 179, 6, 4884);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = ctx[11] || void 0);
      attr_dev(div0, "data-warn", div0_data_warn_value = ctx[13] || void 0);
      toggle_class(div0, "bx--text-input__field-wrapper", true);
      toggle_class(div0, "bx--text-input__field-wrapper--warning", !ctx[11] && ctx[13]);
      add_location(div0, file148, 161, 4, 4301);
      toggle_class(div1, "bx--text-input__field-outer-wrapper", true);
      toggle_class(div1, "bx--text-input__field-outer-wrapper--inline", ctx[16]);
      add_location(div1, file148, 157, 2, 4168);
      toggle_class(div2, "bx--form-item", true);
      toggle_class(div2, "bx--text-input-wrapper", true);
      toggle_class(div2, "bx--text-input-wrapper--inline", ctx[16]);
      toggle_class(div2, "bx--text-input-wrapper--light", ctx[4]);
      toggle_class(div2, "bx--text-input-wrapper--readonly", ctx[17]);
      add_location(div2, file148, 103, 0, 2589);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t3);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div0, t4);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[36](input);
      set_input_value(input, ctx[0]);
      append_dev(div0, t5);
      if (if_block5)
        if_block5.m(div0, null);
      append_dev(div0, t6);
      if (if_block6)
        if_block6.m(div0, null);
      append_dev(div0, t7);
      if (if_block7)
        if_block7.m(div0, null);
      append_dev(div1, t8);
      if (if_block8)
        if_block8.m(div1, null);
      append_dev(div1, t9);
      if (if_block9)
        if_block9.m(div1, null);
      append_dev(div1, t10);
      if (if_block10)
        if_block10.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[37]),
          listen_dev(input, "change", ctx[22], false, false, false),
          listen_dev(input, "input", ctx[21], false, false, false),
          listen_dev(input, "keydown", ctx[31], false, false, false),
          listen_dev(input, "keyup", ctx[32], false, false, false),
          listen_dev(input, "focus", ctx[33], false, false, false),
          listen_dev(input, "blur", ctx[34], false, false, false),
          listen_dev(input, "paste", ctx[35], false, false, false),
          listen_dev(div2, "click", ctx[27], false, false, false),
          listen_dev(div2, "mouseover", ctx[28], false, false, false),
          listen_dev(div2, "mouseenter", ctx[29], false, false, false),
          listen_dev(div2, "mouseleave", ctx[30], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[16]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_103(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[16] && (ctx2[9] || ctx2[24].labelText)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16843264) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_94(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[11]) {
        if (if_block2) {
          if (dirty[0] & 2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_84(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!ctx2[11] && ctx2[13]) {
        if (if_block3) {
          if (dirty[0] & 10240) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_75(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[17]) {
        if (if_block4) {
          if (dirty[0] & 131072) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_69(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & 2048 && input_data_invalid_value !== (input_data_invalid_value = ctx2[11] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & 2048 && input_aria_invalid_value !== (input_aria_invalid_value = ctx2[11] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & 8192 && input_data_warn_value !== (input_data_warn_value = ctx2[13] || void 0)) && { "data-warn": input_data_warn_value },
        (!current || dirty[0] & 796672 && input_aria_describedby_value !== (input_aria_describedby_value = ctx2[11] ? ctx2[19] : ctx2[13] ? ctx2[18] : void 0)) && {
          "aria-describedby": input_aria_describedby_value
        },
        (!current || dirty[0] & 32) && { disabled: ctx2[5] },
        (!current || dirty[0] & 128) && { id: ctx2[7] },
        (!current || dirty[0] & 256) && { name: ctx2[8] },
        (!current || dirty[0] & 8) && { placeholder: ctx2[3] },
        (!current || dirty[0] & 32768) && { required: ctx2[15] },
        (!current || dirty[0] & 131072) && { readOnly: ctx2[17] },
        dirty[0] & 8388608 && ctx2[23]
      ]));
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx2[4]);
      toggle_class(input, "bx--text-input--invalid", ctx2[11]);
      toggle_class(input, "bx--text-input--warn", ctx2[13]);
      toggle_class(input, "bx--text-input--sm", ctx2[2] === "sm");
      toggle_class(input, "bx--text-input--xl", ctx2[2] === "xl");
      if (ctx2[20]) {
        if (if_block5) {
        } else {
          if_block5 = create_if_block_510(ctx2);
          if_block5.c();
          if_block5.m(div0, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[20] && !ctx2[16] && ctx2[11]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_414(ctx2);
          if_block6.c();
          if_block6.m(div0, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (ctx2[20] && !ctx2[16] && ctx2[13]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block_318(ctx2);
          if_block7.c();
          if_block7.m(div0, null);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (!current || dirty[0] & 2048 && div0_data_invalid_value !== (div0_data_invalid_value = ctx2[11] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!current || dirty[0] & 8192 && div0_data_warn_value !== (div0_data_warn_value = ctx2[13] || void 0)) {
        attr_dev(div0, "data-warn", div0_data_warn_value);
      }
      if (!current || dirty[0] & 10240) {
        toggle_class(div0, "bx--text-input__field-wrapper--warning", !ctx2[11] && ctx2[13]);
      }
      if (!ctx2[11] && !ctx2[13] && !ctx2[20] && !ctx2[16] && ctx2[6]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block_224(ctx2);
          if_block8.c();
          if_block8.m(div1, t9);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (!ctx2[20] && ctx2[11]) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
        } else {
          if_block9 = create_if_block_136(ctx2);
          if_block9.c();
          if_block9.m(div1, t10);
        }
      } else if (if_block9) {
        if_block9.d(1);
        if_block9 = null;
      }
      if (!ctx2[20] && !ctx2[11] && ctx2[13]) {
        if (if_block10) {
          if_block10.p(ctx2, dirty);
        } else {
          if_block10 = create_if_block90(ctx2);
          if_block10.c();
          if_block10.m(div1, null);
        }
      } else if (if_block10) {
        if_block10.d(1);
        if_block10 = null;
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(div1, "bx--text-input__field-outer-wrapper--inline", ctx2[16]);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(div2, "bx--text-input-wrapper--inline", ctx2[16]);
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div2, "bx--text-input-wrapper--light", ctx2[4]);
      }
      if (!current || dirty[0] & 131072) {
        toggle_class(div2, "bx--text-input-wrapper--readonly", ctx2[17]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      ctx[36](null);
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      if (if_block10)
        if_block10.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment158.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance158($$self, $$props, $$invalidate) {
  let isFluid;
  let errorId;
  let warnId;
  const omit_props_names = [
    "size",
    "value",
    "placeholder",
    "light",
    "disabled",
    "helperText",
    "id",
    "name",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "ref",
    "required",
    "inline",
    "readonly"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { ref = null } = $$props;
  let { required = false } = $$props;
  let { inline = false } = $$props;
  let { readonly = false } = $$props;
  const ctx = getContext("Form");
  const dispatch = createEventDispatcher();
  function parse2(raw) {
    if ($$restProps.type !== "number")
      return raw;
    return raw != "" ? Number(raw) : null;
  }
  const onInput = (e) => {
    $$invalidate(0, value = parse2(e.target.value));
    dispatch("input", value);
  };
  const onChange = (e) => {
    dispatch("change", parse2(e.target.value));
  };
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("light" in $$new_props)
      $$invalidate(4, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props)
      $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$new_props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("labelText" in $$new_props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("required" in $$new_props)
      $$invalidate(15, required = $$new_props.required);
    if ("inline" in $$new_props)
      $$invalidate(16, inline = $$new_props.inline);
    if ("readonly" in $$new_props)
      $$invalidate(17, readonly = $$new_props.readonly);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    placeholder,
    light,
    disabled,
    helperText,
    id,
    name,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    ref,
    required,
    inline,
    readonly,
    createEventDispatcher,
    getContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    EditOff: EditOff_default,
    ctx,
    dispatch,
    parse: parse2,
    onInput,
    onChange,
    warnId,
    errorId,
    isFluid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("light" in $$props)
      $$invalidate(4, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("helperText" in $$props)
      $$invalidate(6, helperText = $$new_props.helperText);
    if ("id" in $$props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
    if ("labelText" in $$props)
      $$invalidate(9, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(10, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(12, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(13, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(14, warnText = $$new_props.warnText);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("required" in $$props)
      $$invalidate(15, required = $$new_props.required);
    if ("inline" in $$props)
      $$invalidate(16, inline = $$new_props.inline);
    if ("readonly" in $$props)
      $$invalidate(17, readonly = $$new_props.readonly);
    if ("warnId" in $$props)
      $$invalidate(18, warnId = $$new_props.warnId);
    if ("errorId" in $$props)
      $$invalidate(19, errorId = $$new_props.errorId);
    if ("isFluid" in $$props)
      $$invalidate(20, isFluid = $$new_props.isFluid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 128) {
      $:
        $$invalidate(19, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & 128) {
      $:
        $$invalidate(18, warnId = `warn-${id}`);
    }
  };
  $:
    $$invalidate(20, isFluid = !!ctx && ctx.isFluid);
  return [
    value,
    ref,
    size,
    placeholder,
    light,
    disabled,
    helperText,
    id,
    name,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    required,
    inline,
    readonly,
    warnId,
    errorId,
    isFluid,
    onInput,
    onChange,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_input_handler
  ];
}
var TextInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance158,
      create_fragment158,
      safe_not_equal,
      {
        size: 2,
        value: 0,
        placeholder: 3,
        light: 4,
        disabled: 5,
        helperText: 6,
        id: 7,
        name: 8,
        labelText: 9,
        hideLabel: 10,
        invalid: 11,
        invalidText: 12,
        warn: 13,
        warnText: 14,
        ref: 1,
        required: 15,
        inline: 16,
        readonly: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInput",
      options,
      id: create_fragment158.name
    });
  }
  get size() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInput_default = TextInput;

// node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte
var file149 = "node_modules/carbon-components-svelte/src/TextInput/TextInputSkeleton.svelte";
function create_if_block91(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      toggle_class(span, "bx--label", true);
      toggle_class(span, "bx--skeleton", true);
      add_location(span, file149, 15, 4, 293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block91.name,
    type: "if",
    source: "(15:2) {#if !hideLabel}",
    ctx
  });
  return block;
}
function create_fragment159(ctx) {
  let div1;
  let t;
  let div0;
  let mounted;
  let dispose;
  let if_block = !ctx[0] && create_if_block91(ctx);
  let div1_levels = [ctx[1]];
  let div1_data = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div1_data = assign(div1_data, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      toggle_class(div0, "bx--skeleton", true);
      toggle_class(div0, "bx--text-input", true);
      add_location(div0, file149, 17, 2, 370);
      set_attributes(div1, div1_data);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file149, 6, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[2], false, false, false),
          listen_dev(div1, "mouseover", ctx[3], false, false, false),
          listen_dev(div1, "mouseenter", ctx[4], false, false, false),
          listen_dev(div1, "mouseleave", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block91(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment159.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance159($$self, $$props, $$invalidate) {
  const omit_props_names = ["hideLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInputSkeleton", slots, []);
  let { hideLabel = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("hideLabel" in $$new_props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  $$self.$capture_state = () => ({ hideLabel });
  $$self.$inject_state = ($$new_props) => {
    if ("hideLabel" in $$props)
      $$invalidate(0, hideLabel = $$new_props.hideLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hideLabel,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var TextInputSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance159, create_fragment159, safe_not_equal, { hideLabel: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInputSkeleton",
      options,
      id: create_fragment159.name
    });
  }
  get hideLabel() {
    throw new Error("<TextInputSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TextInputSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInputSkeleton_default = TextInputSkeleton;

// node_modules/carbon-components-svelte/src/icons/View.svelte
var file150 = "node_modules/carbon-components-svelte/src/icons/View.svelte";
function create_if_block92(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file150, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block92.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment160(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block92(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M30.94,15.66A16.69,16.69,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16.69,16.69,0,0,0,16,27,16.69,16.69,0,0,0,30.94,16.34,1,1,0,0,0,30.94,15.66ZM16,25c-5.3,0-10.9-3.93-12.93-9C5.1,10.93,10.7,7,16,7s10.9,3.93,12.93,9C26.9,21.07,21.3,25,16,25Z");
      add_location(path0, file150, 24, 2, 579);
      attr_dev(path1, "d", "M16,10a6,6,0,1,0,6,6A6,6,0,0,0,16,10Zm0,10a4,4,0,1,1,4-4A4,4,0,0,1,16,20Z");
      add_location(path1, file150, 26, 10, 858);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file150, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block92(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment160.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance160($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance160, create_fragment160, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment160.name
    });
  }
  get size() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var View_default = View;

// node_modules/carbon-components-svelte/src/icons/ViewOff.svelte
var file151 = "node_modules/carbon-components-svelte/src/icons/ViewOff.svelte";
function create_if_block93(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file151, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block93.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment161(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block93(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M5.24,22.51l1.43-1.42A14.06,14.06,0,0,1,3.07,16C5.1,10.93,10.7,7,16,7a12.38,12.38,0,0,1,4,.72l1.55-1.56A14.72,14.72,0,0,0,16,5,16.69,16.69,0,0,0,1.06,15.66a1,1,0,0,0,0,.68A16,16,0,0,0,5.24,22.51Z");
      add_location(path0, file151, 24, 2, 579);
      attr_dev(path1, "d", "M12 15.73a4 4 0 013.7-3.7l1.81-1.82a6 6 0 00-7.33 7.33zM30.94 15.66A16.4 16.4 0 0025.2 8.22L30 3.41 28.59 2 2 28.59 3.41 30l5.1-5.1A15.29 15.29 0 0016 27 16.69 16.69 0 0030.94 16.34 1 1 0 0030.94 15.66zM20 16a4 4 0 01-6 3.44L19.44 14A4 4 0 0120 16zm-4 9a13.05 13.05 0 01-6-1.58l2.54-2.54a6 6 0 008.35-8.35l2.87-2.87A14.54 14.54 0 0128.93 16C26.9 21.07 21.3 25 16 25z");
      add_location(path1, file151, 26, 10, 799);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file151, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block93(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment161.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance161($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewOff", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var ViewOff = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance161, create_fragment161, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewOff",
      options,
      id: create_fragment161.name
    });
  }
  get size() {
    throw new Error("<ViewOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ViewOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ViewOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ViewOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ViewOff_default = ViewOff;

// node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte
var file152 = "node_modules/carbon-components-svelte/src/TextInput/PasswordInput.svelte";
var get_labelText_slot_changes_13 = (dirty) => ({});
var get_labelText_slot_context_13 = (ctx) => ({});
var get_labelText_slot_changes13 = (dirty) => ({});
var get_labelText_slot_context13 = (ctx) => ({});
function create_if_block_1111(ctx) {
  let label;
  let t;
  let if_block_anchor;
  let current;
  const labelText_slot_template = ctx[27].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[26], get_labelText_slot_context13);
  const labelText_slot_or_fallback = labelText_slot || fallback_block_111(ctx);
  let if_block = !ctx[23] && ctx[11] && create_if_block_1211(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr_dev(label, "for", ctx[19]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[13]);
      toggle_class(label, "bx--label--disabled", ctx[10]);
      toggle_class(label, "bx--label--inline", ctx[18]);
      toggle_class(label, "bx--label--inline--sm", ctx[18] && ctx[3] === "sm");
      toggle_class(label, "bx--label--inline--xl", ctx[18] && ctx[3] === "xl");
      add_location(label, file152, 109, 4, 2775);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(labelText_slot_template, ctx2[26], dirty, get_labelText_slot_changes13),
            get_labelText_slot_context13
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 4096)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 524288) {
        attr_dev(label, "for", ctx2[19]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(label, "bx--visually-hidden", ctx2[13]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--label--disabled", ctx2[10]);
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(label, "bx--label--inline", ctx2[18]);
      }
      if (!current || dirty[0] & 262152) {
        toggle_class(label, "bx--label--inline--sm", ctx2[18] && ctx2[3] === "sm");
      }
      if (!current || dirty[0] & 262152) {
        toggle_class(label, "bx--label--inline--xl", ctx2[18] && ctx2[3] === "xl");
      }
      if (!ctx2[23] && ctx2[11]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1211(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1111.name,
    type: "if",
    source: "(109:2) {#if inline}",
    ctx
  });
  return block;
}
function fallback_block_111(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[12]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_111.name,
    type: "fallback",
    source: "(119:29)          ",
    ctx
  });
  return block;
}
function create_if_block_1211(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[10]);
      toggle_class(div, "bx--form__helper-text--inline", ctx[18]);
      add_location(div, file152, 123, 6, 3208);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
      if (dirty[0] & 1024) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[10]);
      }
      if (dirty[0] & 262144) {
        toggle_class(div, "bx--form__helper-text--inline", ctx2[18]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1211.name,
    type: "if",
    source: "(123:4) {#if !isFluid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_104(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[27].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[26], get_labelText_slot_context_13);
  const labelText_slot_or_fallback = labelText_slot || fallback_block32(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[19]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[13]);
      toggle_class(label, "bx--label--disabled", ctx[10]);
      toggle_class(label, "bx--label--inline", ctx[18]);
      toggle_class(label, "bx--label--inline--sm", ctx[18] && ctx[3] === "sm");
      toggle_class(label, "bx--label--inline--xl", ctx[18] && ctx[3] === "xl");
      add_location(label, file152, 133, 4, 3488);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & 67108864)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[26],
            !current ? get_all_dirty_from_scope(ctx2[26]) : get_slot_changes(labelText_slot_template, ctx2[26], dirty, get_labelText_slot_changes_13),
            get_labelText_slot_context_13
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & 4096)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 524288) {
        attr_dev(label, "for", ctx2[19]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(label, "bx--visually-hidden", ctx2[13]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(label, "bx--label--disabled", ctx2[10]);
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(label, "bx--label--inline", ctx2[18]);
      }
      if (!current || dirty[0] & 262152) {
        toggle_class(label, "bx--label--inline--sm", ctx2[18] && ctx2[3] === "sm");
      }
      if (!current || dirty[0] & 262152) {
        toggle_class(label, "bx--label--inline--xl", ctx2[18] && ctx2[3] === "xl");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_104.name,
    type: "if",
    source: "(133:2) {#if !inline && (labelText || $$slots.labelText)}",
    ctx
  });
  return block;
}
function fallback_block32(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[12]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data_dev(t, ctx2[12]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block32.name,
    type: "fallback",
    source: "(143:29)          ",
    ctx
  });
  return block;
}
function create_if_block_95(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--text-input__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_95.name,
    type: "if",
    source: "(157:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_85(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--text-input__invalid-icon\n            bx--text-input__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_85.name,
    type: "if",
    source: "(160:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_76(ctx) {
  let hr;
  let t0;
  let div;
  let t1;
  const block = {
    c: function create() {
      hr = element("hr");
      t0 = space();
      div = element("div");
      t1 = text(ctx[15]);
      attr_dev(hr, "class", "bx--text-input__divider");
      add_location(hr, file152, 196, 8, 5425);
      attr_dev(div, "class", "bx--form-requirement");
      attr_dev(div, "id", ctx[22]);
      add_location(div, file152, 197, 8, 5472);
    },
    m: function mount(target, anchor) {
      insert_dev(target, hr, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      append_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data_dev(t1, ctx2[15]);
      if (dirty[0] & 4194304) {
        attr_dev(div, "id", ctx2[22]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_76.name,
    type: "if",
    source: "(196:6) {#if isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block_319(ctx) {
  let button;
  let t;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[10] && create_if_block_511(ctx);
  const if_block_creators = [create_if_block_415, create_else_block29];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1] === "text")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      attr_dev(button, "type", "button");
      button.disabled = ctx[10];
      toggle_class(button, "bx--text-input--password__visibility__toggle", true);
      toggle_class(button, "bx--btn", true);
      toggle_class(button, "bx--btn--icon-only", true);
      toggle_class(button, "bx--btn--disabled", ctx[10]);
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(button, "bx--tooltip--top", ctx[8] === "top");
      toggle_class(button, "bx--tooltip--right", ctx[8] === "right");
      toggle_class(button, "bx--tooltip--bottom", ctx[8] === "bottom");
      toggle_class(button, "bx--tooltip--left", ctx[8] === "left");
      toggle_class(button, "bx--tooltip--align-start", ctx[7] === "start");
      toggle_class(button, "bx--tooltip--align-center", ctx[7] === "center");
      toggle_class(button, "bx--tooltip--align-end", ctx[7] === "end");
      add_location(button, file152, 202, 8, 5615);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (if_block0)
        if_block0.m(button, null);
      append_dev(button, t);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[41], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[10]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_511(ctx2);
          if_block0.c();
          if_block0.m(button, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
        }
        transition_in(if_block1, 1);
        if_block1.m(button, null);
      }
      if (!current || dirty[0] & 1024) {
        prop_dev(button, "disabled", ctx2[10]);
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(button, "bx--btn--disabled", ctx2[10]);
      }
      if (!current || dirty[0] & 256) {
        toggle_class(button, "bx--tooltip--top", ctx2[8] === "top");
      }
      if (!current || dirty[0] & 256) {
        toggle_class(button, "bx--tooltip--right", ctx2[8] === "right");
      }
      if (!current || dirty[0] & 256) {
        toggle_class(button, "bx--tooltip--bottom", ctx2[8] === "bottom");
      }
      if (!current || dirty[0] & 256) {
        toggle_class(button, "bx--tooltip--left", ctx2[8] === "left");
      }
      if (!current || dirty[0] & 128) {
        toggle_class(button, "bx--tooltip--align-start", ctx2[7] === "start");
      }
      if (!current || dirty[0] & 128) {
        toggle_class(button, "bx--tooltip--align-center", ctx2[7] === "center");
      }
      if (!current || dirty[0] & 128) {
        toggle_class(button, "bx--tooltip--align-end", ctx2[7] === "end");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_319.name,
    type: "if",
    source: "(202:6) {#if !(isFluid && invalid)}",
    ctx
  });
  return block;
}
function create_if_block_511(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "text")
      return create_if_block_610;
    return create_else_block_14;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file152, 223, 12, 6599);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if_block.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_511.name,
    type: "if",
    source: "(223:10) {#if !disabled}",
    ctx
  });
  return block;
}
function create_else_block_14(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[6]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data_dev(t, ctx2[6]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(227:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_610(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_610.name,
    type: "if",
    source: '(225:14) {#if type === \\"text\\"}',
    ctx
  });
  return block;
}
function create_else_block29(ctx) {
  let view;
  let current;
  view = new View_default({
    props: { class: "bx--icon-visibility-on" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(view.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(view, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(view.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(view, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(232:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_415(ctx) {
  let viewoff;
  let current;
  viewoff = new ViewOff_default({
    props: { class: "bx--icon-visibility-off" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(viewoff.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(viewoff, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(viewoff.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewoff.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(viewoff, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_415.name,
    type: "if",
    source: '(230:10) {#if type === \\"text\\"}',
    ctx
  });
  return block;
}
function create_if_block_225(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[15]);
      attr_dev(div, "id", ctx[22]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file152, 238, 6, 7045);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32768)
        set_data_dev(t, ctx2[15]);
      if (dirty[0] & 4194304) {
        attr_dev(div, "id", ctx2[22]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_225.name,
    type: "if",
    source: "(238:4) {#if !isFluid && invalid}",
    ctx
  });
  return block;
}
function create_if_block_137(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(div, "bx--form__helper-text--disabled", ctx[10]);
      toggle_class(div, "bx--form__helper-text--inline", ctx[18]);
      add_location(div, file152, 243, 6, 7204);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
      if (dirty[0] & 1024) {
        toggle_class(div, "bx--form__helper-text--disabled", ctx2[10]);
      }
      if (dirty[0] & 262144) {
        toggle_class(div, "bx--form__helper-text--inline", ctx2[18]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_137.name,
    type: "if",
    source: "(243:4) {#if !invalid && !warn && !isFluid && !inline}",
    ctx
  });
  return block;
}
function create_if_block94(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[17]);
      attr_dev(div, "id", ctx[21]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file152, 252, 6, 7465);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 131072)
        set_data_dev(t, ctx2[17]);
      if (dirty[0] & 2097152) {
        attr_dev(div, "id", ctx2[21]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block94.name,
    type: "if",
    source: "(252:4) {#if !isFluid && !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment162(ctx) {
  var _a;
  let div2;
  let t0;
  let t1;
  let div1;
  let div0;
  let t2;
  let t3;
  let input;
  let input_data_invalid_value;
  let input_aria_invalid_value;
  let input_aria_describedby_value;
  let input_value_value;
  let t4;
  let t5;
  let div0_data_invalid_value;
  let t6;
  let t7;
  let t8;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[18] && create_if_block_1111(ctx);
  let if_block1 = !ctx[18] && (ctx[12] || ctx[24].labelText) && create_if_block_104(ctx);
  let if_block2 = ctx[14] && create_if_block_95(ctx);
  let if_block3 = !ctx[14] && ctx[16] && create_if_block_85(ctx);
  let input_levels = [
    {
      "data-invalid": input_data_invalid_value = ctx[14] || void 0
    },
    {
      "aria-invalid": input_aria_invalid_value = ctx[14] || void 0
    },
    {
      "aria-describedby": input_aria_describedby_value = ctx[14] ? ctx[22] : ctx[16] ? ctx[21] : void 0
    },
    { id: ctx[19] },
    { name: ctx[20] },
    { placeholder: ctx[4] },
    { type: ctx[1] },
    {
      value: input_value_value = (_a = ctx[0]) != null ? _a : ""
    },
    { disabled: ctx[10] },
    ctx[25]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block4 = ctx[23] && ctx[14] && create_if_block_76(ctx);
  let if_block5 = !(ctx[23] && ctx[14]) && create_if_block_319(ctx);
  let if_block6 = !ctx[23] && ctx[14] && create_if_block_225(ctx);
  let if_block7 = !ctx[14] && !ctx[16] && !ctx[23] && !ctx[18] && create_if_block_137(ctx);
  let if_block8 = !ctx[23] && !ctx[14] && ctx[16] && create_if_block94(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      input = element("input");
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      set_attributes(input, input_data);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--password-input", true);
      toggle_class(input, "bx--text-input--light", ctx[9]);
      toggle_class(input, "bx--text-input--invalid", ctx[14]);
      toggle_class(input, "bx--text-input--warning", ctx[16]);
      toggle_class(input, "bx--text-input--sm", ctx[3] === "sm");
      toggle_class(input, "bx--text-input--xl", ctx[3] === "xl");
      add_location(input, file152, 165, 6, 4467);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = ctx[14] || void 0);
      toggle_class(div0, "bx--text-input__field-wrapper", true);
      toggle_class(div0, "bx--text-input__field-wrapper--warning", ctx[16]);
      add_location(div0, file152, 151, 4, 4025);
      toggle_class(div1, "bx--text-input__field-outer-wrapper", true);
      toggle_class(div1, "bx--text-input__field-outer-wrapper--inline", ctx[18]);
      add_location(div1, file152, 147, 2, 3892);
      toggle_class(div2, "bx--form-item", true);
      toggle_class(div2, "bx--text-input-wrapper", true);
      toggle_class(div2, "bx--password-input-wrapper", !ctx[23]);
      toggle_class(div2, "bx--text-input-wrapper--light", ctx[9]);
      toggle_class(div2, "bx--text-input-wrapper--inline", ctx[18]);
      add_location(div2, file152, 97, 0, 2474);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_dev(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append_dev(div2, t1);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_dev(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      append_dev(div0, t3);
      append_dev(div0, input);
      input.value = input_data.value;
      if (input.autofocus)
        input.focus();
      ctx[39](input);
      append_dev(div0, t4);
      if (if_block4)
        if_block4.m(div0, null);
      append_dev(div0, t5);
      if (if_block5)
        if_block5.m(div0, null);
      append_dev(div1, t6);
      if (if_block6)
        if_block6.m(div1, null);
      append_dev(div1, t7);
      if (if_block7)
        if_block7.m(div1, null);
      append_dev(div1, t8);
      if (if_block8)
        if_block8.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[32], false, false, false),
          listen_dev(input, "input", ctx[33], false, false, false),
          listen_dev(input, "input", ctx[40], false, false, false),
          listen_dev(input, "keydown", ctx[34], false, false, false),
          listen_dev(input, "keyup", ctx[35], false, false, false),
          listen_dev(input, "focus", ctx[36], false, false, false),
          listen_dev(input, "blur", ctx[37], false, false, false),
          listen_dev(input, "paste", ctx[38], false, false, false),
          listen_dev(div2, "click", ctx[28], false, false, false),
          listen_dev(div2, "mouseover", ctx[29], false, false, false),
          listen_dev(div2, "mouseenter", ctx[30], false, false, false),
          listen_dev(div2, "mouseleave", ctx[31], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (ctx2[18]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 262144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1111(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[18] && (ctx2[12] || ctx2[24].labelText)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 17043456) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_104(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block2) {
          if (dirty[0] & 16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_95(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!ctx2[14] && ctx2[16]) {
        if (if_block3) {
          if (dirty[0] & 81920) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_85(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        (!current || dirty[0] & 16384 && input_data_invalid_value !== (input_data_invalid_value = ctx2[14] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty[0] & 16384 && input_aria_invalid_value !== (input_aria_invalid_value = ctx2[14] || void 0)) && { "aria-invalid": input_aria_invalid_value },
        (!current || dirty[0] & 6373376 && input_aria_describedby_value !== (input_aria_describedby_value = ctx2[14] ? ctx2[22] : ctx2[16] ? ctx2[21] : void 0)) && {
          "aria-describedby": input_aria_describedby_value
        },
        (!current || dirty[0] & 524288) && { id: ctx2[19] },
        (!current || dirty[0] & 1048576) && { name: ctx2[20] },
        (!current || dirty[0] & 16) && { placeholder: ctx2[4] },
        (!current || dirty[0] & 2) && { type: ctx2[1] },
        (!current || dirty[0] & 1 && input_value_value !== (input_value_value = (_a2 = ctx2[0]) != null ? _a2 : "") && input.value !== input_value_value) && { value: input_value_value },
        (!current || dirty[0] & 1024) && { disabled: ctx2[10] },
        dirty[0] & 33554432 && ctx2[25]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--password-input", true);
      toggle_class(input, "bx--text-input--light", ctx2[9]);
      toggle_class(input, "bx--text-input--invalid", ctx2[14]);
      toggle_class(input, "bx--text-input--warning", ctx2[16]);
      toggle_class(input, "bx--text-input--sm", ctx2[3] === "sm");
      toggle_class(input, "bx--text-input--xl", ctx2[3] === "xl");
      if (ctx2[23] && ctx2[14]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_76(ctx2);
          if_block4.c();
          if_block4.m(div0, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (!(ctx2[23] && ctx2[14])) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & 8404992) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_319(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div0, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 16384 && div0_data_invalid_value !== (div0_data_invalid_value = ctx2[14] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(div0, "bx--text-input__field-wrapper--warning", ctx2[16]);
      }
      if (!ctx2[23] && ctx2[14]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_225(ctx2);
          if_block6.c();
          if_block6.m(div1, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (!ctx2[14] && !ctx2[16] && !ctx2[23] && !ctx2[18]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block_137(ctx2);
          if_block7.c();
          if_block7.m(div1, t8);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (!ctx2[23] && !ctx2[14] && ctx2[16]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block94(ctx2);
          if_block8.c();
          if_block8.m(div1, null);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(div1, "bx--text-input__field-outer-wrapper--inline", ctx2[18]);
      }
      if (!current || dirty[0] & 8388608) {
        toggle_class(div2, "bx--password-input-wrapper", !ctx2[23]);
      }
      if (!current || dirty[0] & 512) {
        toggle_class(div2, "bx--text-input-wrapper--light", ctx2[9]);
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(div2, "bx--text-input-wrapper--inline", ctx2[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[39](null);
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment162.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance162($$self, $$props, $$invalidate) {
  let isFluid;
  let errorId;
  let warnId;
  const omit_props_names = [
    "size",
    "value",
    "type",
    "placeholder",
    "hidePasswordLabel",
    "showPasswordLabel",
    "tooltipAlignment",
    "tooltipPosition",
    "light",
    "disabled",
    "helperText",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "inline",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PasswordInput", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { type = "password" } = $$props;
  let { placeholder = "" } = $$props;
  let { hidePasswordLabel = "Hide password" } = $$props;
  let { showPasswordLabel = "Show password" } = $$props;
  let { tooltipAlignment = "center" } = $$props;
  let { tooltipPosition = "bottom" } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { helperText = "" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { inline = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("Form");
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const input_handler_1 = ({ target }) => {
    $$invalidate(0, value = target.value);
  };
  const click_handler_13 = () => {
    $$invalidate(1, type = type === "password" ? "text" : "password");
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("hidePasswordLabel" in $$new_props)
      $$invalidate(5, hidePasswordLabel = $$new_props.hidePasswordLabel);
    if ("showPasswordLabel" in $$new_props)
      $$invalidate(6, showPasswordLabel = $$new_props.showPasswordLabel);
    if ("tooltipAlignment" in $$new_props)
      $$invalidate(7, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$new_props)
      $$invalidate(8, tooltipPosition = $$new_props.tooltipPosition);
    if ("light" in $$new_props)
      $$invalidate(9, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("helperText" in $$new_props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("labelText" in $$new_props)
      $$invalidate(12, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(13, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(15, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(16, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(17, warnText = $$new_props.warnText);
    if ("inline" in $$new_props)
      $$invalidate(18, inline = $$new_props.inline);
    if ("id" in $$new_props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    type,
    placeholder,
    hidePasswordLabel,
    showPasswordLabel,
    tooltipAlignment,
    tooltipPosition,
    light,
    disabled,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    inline,
    id,
    name,
    ref,
    getContext,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    View: View_default,
    ViewOff: ViewOff_default,
    ctx,
    warnId,
    errorId,
    isFluid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("type" in $$props)
      $$invalidate(1, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("hidePasswordLabel" in $$props)
      $$invalidate(5, hidePasswordLabel = $$new_props.hidePasswordLabel);
    if ("showPasswordLabel" in $$props)
      $$invalidate(6, showPasswordLabel = $$new_props.showPasswordLabel);
    if ("tooltipAlignment" in $$props)
      $$invalidate(7, tooltipAlignment = $$new_props.tooltipAlignment);
    if ("tooltipPosition" in $$props)
      $$invalidate(8, tooltipPosition = $$new_props.tooltipPosition);
    if ("light" in $$props)
      $$invalidate(9, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("helperText" in $$props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("labelText" in $$props)
      $$invalidate(12, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(13, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(15, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(16, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(17, warnText = $$new_props.warnText);
    if ("inline" in $$props)
      $$invalidate(18, inline = $$new_props.inline);
    if ("id" in $$props)
      $$invalidate(19, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(20, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("warnId" in $$props)
      $$invalidate(21, warnId = $$new_props.warnId);
    if ("errorId" in $$props)
      $$invalidate(22, errorId = $$new_props.errorId);
    if ("isFluid" in $$props)
      $$invalidate(23, isFluid = $$new_props.isFluid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 524288) {
      $:
        $$invalidate(22, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & 524288) {
      $:
        $$invalidate(21, warnId = `warn-${id}`);
    }
  };
  $:
    $$invalidate(23, isFluid = !!ctx && ctx.isFluid);
  return [
    value,
    type,
    ref,
    size,
    placeholder,
    hidePasswordLabel,
    showPasswordLabel,
    tooltipAlignment,
    tooltipPosition,
    light,
    disabled,
    helperText,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    warn,
    warnText,
    inline,
    id,
    name,
    warnId,
    errorId,
    isFluid,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_handler_1,
    click_handler_13
  ];
}
var PasswordInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance162,
      create_fragment162,
      safe_not_equal,
      {
        size: 3,
        value: 0,
        type: 1,
        placeholder: 4,
        hidePasswordLabel: 5,
        showPasswordLabel: 6,
        tooltipAlignment: 7,
        tooltipPosition: 8,
        light: 9,
        disabled: 10,
        helperText: 11,
        labelText: 12,
        hideLabel: 13,
        invalid: 14,
        invalidText: 15,
        warn: 16,
        warnText: 17,
        inline: 18,
        id: 19,
        name: 20,
        ref: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PasswordInput",
      options,
      id: create_fragment162.name
    });
  }
  get size() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidePasswordLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidePasswordLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showPasswordLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showPasswordLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipAlignment() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipAlignment(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipPosition() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipPosition(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PasswordInput_default = PasswordInput;

// node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte
var file153 = "node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte";
var get_labelB_slot_changes = (dirty) => ({});
var get_labelB_slot_context = (ctx) => ({});
var get_labelA_slot_changes = (dirty) => ({});
var get_labelA_slot_context = (ctx) => ({});
var get_labelText_slot_changes14 = (dirty) => ({});
var get_labelText_slot_context14 = (ctx) => ({});
function fallback_block_26(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_26.name,
    type: "fallback",
    source: "(86:29)          ",
    ctx
  });
  return block;
}
function fallback_block_112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_112.name,
    type: "fallback",
    source: "(95:28)            ",
    ctx
  });
  return block;
}
function fallback_block33(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block33.name,
    type: "fallback",
    source: "(100:28)            ",
    ctx
  });
  return block;
}
function create_fragment163(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let span0;
  let t1;
  let span3;
  let span1;
  let t2;
  let span2;
  let span3_style_value;
  let label_aria_label_value;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = ctx[12].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[11], get_labelText_slot_context14);
  const labelText_slot_or_fallback = labelText_slot || fallback_block_26(ctx);
  const labelA_slot_template = ctx[12].labelA;
  const labelA_slot = create_slot(labelA_slot_template, ctx, ctx[11], get_labelA_slot_context);
  const labelA_slot_or_fallback = labelA_slot || fallback_block_112(ctx);
  const labelB_slot_template = ctx[12].labelB;
  const labelB_slot = create_slot(labelB_slot_template, ctx, ctx[11], get_labelB_slot_context);
  const labelB_slot_or_fallback = labelB_slot || fallback_block33(ctx);
  let div_levels = [
    ctx[9],
    {
      style: div_style_value = ctx[9]["style"] + "; user-select: none"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t1 = space();
      span3 = element("span");
      span1 = element("span");
      if (labelA_slot_or_fallback)
        labelA_slot_or_fallback.c();
      t2 = space();
      span2 = element("span");
      if (labelB_slot_or_fallback)
        labelB_slot_or_fallback.c();
      attr_dev(input, "role", "switch");
      attr_dev(input, "type", "checkbox");
      input.checked = ctx[0];
      input.disabled = ctx[2];
      attr_dev(input, "id", ctx[7]);
      attr_dev(input, "name", ctx[8]);
      toggle_class(input, "bx--toggle-input", true);
      toggle_class(input, "bx--toggle-input--small", ctx[1] === "sm");
      add_location(input, file153, 56, 2, 1285);
      toggle_class(span0, "bx--visually-hidden", ctx[6]);
      add_location(span0, file153, 84, 4, 1911);
      attr_dev(span1, "aria-hidden", "true");
      toggle_class(span1, "bx--toggle__text--off", true);
      add_location(span1, file153, 93, 6, 2141);
      attr_dev(span2, "aria-hidden", "true");
      toggle_class(span2, "bx--toggle__text--on", true);
      add_location(span2, file153, 98, 6, 2288);
      attr_dev(span3, "style", span3_style_value = ctx[6] && "margin-top: 0");
      toggle_class(span3, "bx--toggle__switch", true);
      add_location(span3, file153, 89, 4, 2038);
      attr_dev(label, "aria-label", label_aria_label_value = ctx[5] ? void 0 : ctx[10]["aria-label"] || "Toggle");
      attr_dev(label, "for", ctx[7]);
      toggle_class(label, "bx--toggle-input__label", true);
      add_location(label, file153, 79, 2, 1761);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file153, 46, 0, 1057);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      append_dev(div, t0);
      append_dev(div, label);
      append_dev(label, span0);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span0, null);
      }
      append_dev(label, t1);
      append_dev(label, span3);
      append_dev(span3, span1);
      if (labelA_slot_or_fallback) {
        labelA_slot_or_fallback.m(span1, null);
      }
      append_dev(span3, t2);
      append_dev(span3, span2);
      if (labelB_slot_or_fallback) {
        labelB_slot_or_fallback.m(span2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[21], false, false, false),
          listen_dev(input, "change", ctx[17], false, false, false),
          listen_dev(input, "keyup", ctx[22], false, false, false),
          listen_dev(input, "keyup", ctx[18], false, false, false),
          listen_dev(input, "focus", ctx[19], false, false, false),
          listen_dev(input, "blur", ctx[20], false, false, false),
          listen_dev(div, "click", ctx[13], false, false, false),
          listen_dev(div, "mouseover", ctx[14], false, false, false),
          listen_dev(div, "mouseenter", ctx[15], false, false, false),
          listen_dev(div, "mouseleave", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        prop_dev(input, "checked", ctx2[0]);
      }
      if (!current || dirty & 4) {
        prop_dev(input, "disabled", ctx2[2]);
      }
      if (!current || dirty & 128) {
        attr_dev(input, "id", ctx2[7]);
      }
      if (!current || dirty & 256) {
        attr_dev(input, "name", ctx2[8]);
      }
      if (!current || dirty & 2) {
        toggle_class(input, "bx--toggle-input--small", ctx2[1] === "sm");
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(labelText_slot_template, ctx2[11], dirty, get_labelText_slot_changes14),
            get_labelText_slot_context14
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 32)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64) {
        toggle_class(span0, "bx--visually-hidden", ctx2[6]);
      }
      if (labelA_slot) {
        if (labelA_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            labelA_slot,
            labelA_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(labelA_slot_template, ctx2[11], dirty, get_labelA_slot_changes),
            get_labelA_slot_context
          );
        }
      } else {
        if (labelA_slot_or_fallback && labelA_slot_or_fallback.p && (!current || dirty & 8)) {
          labelA_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (labelB_slot) {
        if (labelB_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            labelB_slot,
            labelB_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(labelB_slot_template, ctx2[11], dirty, get_labelB_slot_changes),
            get_labelB_slot_context
          );
        }
      } else {
        if (labelB_slot_or_fallback && labelB_slot_or_fallback.p && (!current || dirty & 16)) {
          labelB_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64 && span3_style_value !== (span3_style_value = ctx2[6] && "margin-top: 0")) {
        attr_dev(span3, "style", span3_style_value);
      }
      if (!current || dirty & 1056 && label_aria_label_value !== (label_aria_label_value = ctx2[5] ? void 0 : ctx2[10]["aria-label"] || "Toggle")) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
      if (!current || dirty & 128) {
        attr_dev(label, "for", ctx2[7]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 512 && div_style_value !== (div_style_value = ctx2[9]["style"] + "; user-select: none")) && { style: div_style_value }
      ]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      transition_in(labelA_slot_or_fallback, local);
      transition_in(labelB_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      transition_out(labelA_slot_or_fallback, local);
      transition_out(labelB_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (labelA_slot_or_fallback)
        labelA_slot_or_fallback.d(detaching);
      if (labelB_slot_or_fallback)
        labelB_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment163.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance163($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "toggled",
    "disabled",
    "labelA",
    "labelB",
    "labelText",
    "hideLabel",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, ["labelText", "labelA", "labelB"]);
  let { size = "default" } = $$props;
  let { toggled = false } = $$props;
  let { disabled = false } = $$props;
  let { labelA = "Off" } = $$props;
  let { labelB = "On" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = () => {
    $$invalidate(0, toggled = !toggled);
  };
  const keyup_handler_1 = (e) => {
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      $$invalidate(0, toggled = !toggled);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$new_props)
      $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$new_props)
      $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$new_props)
      $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$new_props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    toggled,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    createEventDispatcher,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$props)
      $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$props)
      $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$props)
      $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("toggle", { toggled });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    toggled,
    size,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    $$restProps,
    $$props,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    change_handler_1,
    keyup_handler_1
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance163, create_fragment163, safe_not_equal, {
      size: 1,
      toggled: 0,
      disabled: 2,
      labelA: 3,
      labelB: 4,
      labelText: 5,
      hideLabel: 6,
      id: 7,
      name: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment163.name
    });
  }
  get size() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelA() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelA(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelB() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelB(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;

// node_modules/carbon-components-svelte/src/Theme/Theme.svelte
var { Object: Object_1, console: console_12 } = globals;
var get_default_slot_changes12 = (dirty) => ({ theme: dirty & 1 });
var get_default_slot_context12 = (ctx) => ({ theme: ctx[0] });
function get_each_context20(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block_226(ctx) {
  let localstorage;
  let updating_value;
  let current;
  function localstorage_value_binding(value) {
    ctx[9](value);
  }
  let localstorage_props = { key: ctx[2] };
  if (ctx[0] !== void 0) {
    localstorage_props.value = ctx[0];
  }
  localstorage = new LocalStorage_default({
    props: localstorage_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(localstorage, "value", localstorage_value_binding));
  const block = {
    c: function create() {
      create_component(localstorage.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(localstorage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const localstorage_changes = {};
      if (dirty & 4)
        localstorage_changes.key = ctx2[2];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        localstorage_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      localstorage.$set(localstorage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(localstorage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(localstorage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(localstorage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_226.name,
    type: "if",
    source: "(98:0) {#if persist}",
    ctx
  });
  return block;
}
function create_if_block_138(ctx) {
  let select_1;
  let updating_selected;
  let current;
  const select_1_spread_levels = [ctx[5]];
  function select_1_selected_binding(value) {
    ctx[11](value);
  }
  let select_1_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < select_1_spread_levels.length; i += 1) {
    select_1_props = assign(select_1_props, select_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    select_1_props.selected = ctx[0];
  }
  select_1 = new Select_default({ props: select_1_props, $$inline: true });
  binding_callbacks.push(() => bind(select_1, "selected", select_1_selected_binding));
  const block = {
    c: function create() {
      create_component(select_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_1_changes = dirty & 32 ? get_spread_update(select_1_spread_levels, [get_spread_object(ctx2[5])]) : {};
      if (dirty & 4128) {
        select_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        select_1_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      select_1.$set(select_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(select_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_138.name,
    type: "if",
    source: "(110:30) ",
    ctx
  });
  return block;
}
function create_if_block95(ctx) {
  let toggle_1;
  let current;
  const toggle_1_spread_levels = [
    ctx[4],
    {
      toggled: ctx[0] === ctx[4].themes[1]
    }
  ];
  let toggle_1_props = {};
  for (let i = 0; i < toggle_1_spread_levels.length; i += 1) {
    toggle_1_props = assign(toggle_1_props, toggle_1_spread_levels[i]);
  }
  toggle_1 = new Toggle_default({ props: toggle_1_props, $$inline: true });
  toggle_1.$on("toggle", ctx[10]);
  const block = {
    c: function create() {
      create_component(toggle_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toggle_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toggle_1_changes = dirty & 17 ? get_spread_update(toggle_1_spread_levels, [
        dirty & 16 && get_spread_object(ctx2[4]),
        {
          toggled: ctx2[0] === ctx2[4].themes[1]
        }
      ]) : {};
      toggle_1.$set(toggle_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block95.name,
    type: "if",
    source: '(102:0) {#if render === \\"toggle\\"}',
    ctx
  });
  return block;
}
function create_each_block20(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: ctx[0],
      text: ctx[6][ctx[0]]
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty & 32)
        selectitem_changes.value = ctx[0];
      if (dirty & 32)
        selectitem_changes.text = ctx[6][ctx[0]];
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block20.name,
    type: "each",
    source: "(112:4) {#each select.themes as theme (theme)}",
    ctx
  });
  return block;
}
function create_default_slot22(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[5].themes;
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[0];
  validate_each_keys(ctx, each_value, get_each_context20, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context20(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block20(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 96) {
        each_value = ctx2[5].themes;
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context20, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block20, each_1_anchor, get_each_context20);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: '(111:2) <Select {...select} bind:selected=\\"{theme}\\">',
    ctx
  });
  return block;
}
function create_fragment164(ctx) {
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current;
  let if_block0 = ctx[1] && create_if_block_226(ctx);
  const if_block_creators = [create_if_block95, create_if_block_138];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] === "toggle")
      return 0;
    if (ctx2[3] === "select")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context12);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_226(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4097)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, get_default_slot_changes12),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment164.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance164($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Theme", slots, ["default"]);
  let { theme = "white" } = $$props;
  let { tokens = {} } = $$props;
  let { persist = false } = $$props;
  let { persistKey = "theme" } = $$props;
  let { render = void 0 } = $$props;
  let { toggle = {
    themes: ["white", "g100"],
    labelA: "",
    labelB: "",
    labelText: "Dark mode",
    hideLabel: false
  } } = $$props;
  const themes = {
    white: "White",
    g10: "Gray 10",
    g80: "Gray 80",
    g90: "Gray 90",
    g100: "Gray 100"
  };
  const themeKeys = Object.keys(themes);
  let { select = {
    themes: themeKeys,
    labelText: "Themes",
    hideLabel: false
  } } = $$props;
  const dispatch = createEventDispatcher();
  const writable_props = ["theme", "tokens", "persist", "persistKey", "render", "toggle", "select"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<Theme> was created with unknown prop '${key}'`);
  });
  function localstorage_value_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  const toggle_handler = ({ detail }) => {
    $$invalidate(0, theme = detail.toggled ? toggle.themes[1] : toggle.themes[0]);
  };
  function select_1_selected_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2)
      $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2)
      $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2)
      $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2)
      $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2)
      $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2)
      $$invalidate(5, select = $$props2.select);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    theme,
    tokens,
    persist,
    persistKey,
    render,
    toggle,
    themes,
    themeKeys,
    select,
    createEventDispatcher,
    Toggle: Toggle_default,
    Select: Select_default,
    SelectItem: SelectItem_default,
    LocalStorage: LocalStorage_default,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2)
      $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2)
      $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2)
      $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2)
      $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2)
      $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2)
      $$invalidate(5, select = $$props2.select);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 129) {
      $:
        if (typeof window !== "undefined") {
          Object.entries(tokens).forEach(([token, value]) => {
            document.documentElement.style.setProperty(`--cds-${token}`, value);
          });
          if (theme in themes) {
            document.documentElement.setAttribute("theme", theme);
            dispatch("update", { theme });
          } else {
            console.warn(`[Theme.svelte] invalid theme "${theme}". Value must be one of: ${JSON.stringify(Object.keys(themes))}`);
          }
        }
    }
  };
  return [
    theme,
    persist,
    persistKey,
    render,
    toggle,
    select,
    themes,
    tokens,
    slots,
    localstorage_value_binding,
    toggle_handler,
    select_1_selected_binding,
    $$scope
  ];
}
var Theme = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance164, create_fragment164, safe_not_equal, {
      theme: 0,
      tokens: 7,
      persist: 1,
      persistKey: 2,
      render: 3,
      toggle: 4,
      select: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Theme",
      options,
      id: create_fragment164.name
    });
  }
  get theme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tokens() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tokens(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persist() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persist(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistKey() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistKey(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get render() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set render(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Theme_default = Theme;

// node_modules/carbon-components-svelte/src/Tile/Tile.svelte
var file154 = "node_modules/carbon-components-svelte/src/Tile/Tile.svelte";
function create_fragment165(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "bx--tile", true);
      toggle_class(div, "bx--tile--light", ctx[0]);
      add_location(div, file154, 6, 0, 156);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[4], false, false, false),
          listen_dev(div, "mouseover", ctx[5], false, false, false),
          listen_dev(div, "mouseenter", ctx[6], false, false, false),
          listen_dev(div, "mouseleave", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(div, "bx--tile", true);
      toggle_class(div, "bx--tile--light", ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment165.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance165($$self, $$props, $$invalidate) {
  const omit_props_names = ["light"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tile", slots, ["default"]);
  let { light = false } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("light" in $$new_props)
      $$invalidate(0, light = $$new_props.light);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ light });
  $$self.$inject_state = ($$new_props) => {
    if ("light" in $$props)
      $$invalidate(0, light = $$new_props.light);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    light,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Tile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance165, create_fragment165, safe_not_equal, { light: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tile",
      options,
      id: create_fragment165.name
    });
  }
  get light() {
    throw new Error("<Tile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Tile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tile_default = Tile;

// node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: `(22:0) <Link   {...$$restProps}   disabled=\\"{disabled}\\"   class=\\"bx--tile bx--tile--clickable {clicked &&     'bx--tile--is-clicked'} {light && 'bx--tile--light'} {$$restProps.class}\\"   href=\\"{href}\\"   on:click   on:click=\\"{() => {     clicked = !clicked;   }}\\"   on:keydown   on:keydown=\\"{({ key }) => {     if (key === ' ' || key === 'Enter') {       clicked = !clicked;     }   }}\\"   on:mouseover   on:mouseenter   on:mouseleave >`,
    ctx
  });
  return block;
}
function create_fragment166(ctx) {
  let link;
  let current;
  const link_spread_levels = [
    ctx[4],
    { disabled: ctx[2] },
    {
      class: "bx--tile bx--tile--clickable " + (ctx[0] && "bx--tile--is-clicked") + " " + (ctx[1] && "bx--tile--light") + " " + ctx[4].class
    },
    { href: ctx[3] }
  ];
  let link_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < link_spread_levels.length; i += 1) {
    link_props = assign(link_props, link_spread_levels[i]);
  }
  link = new Link_default({ props: link_props, $$inline: true });
  link.$on("click", ctx[6]);
  link.$on("click", ctx[7]);
  link.$on("keydown", ctx[8]);
  link.$on("keydown", ctx[9]);
  link.$on("mouseover", ctx[10]);
  link.$on("mouseenter", ctx[11]);
  link.$on("mouseleave", ctx[12]);
  const block = {
    c: function create() {
      create_component(link.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(link, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const link_changes = dirty & 31 ? get_spread_update(link_spread_levels, [
        dirty & 16 && get_spread_object(ctx2[4]),
        dirty & 4 && { disabled: ctx2[2] },
        dirty & 19 && {
          class: "bx--tile bx--tile--clickable " + (ctx2[0] && "bx--tile--is-clicked") + " " + (ctx2[1] && "bx--tile--light") + " " + ctx2[4].class
        },
        dirty & 8 && { href: ctx2[3] }
      ]) : {};
      if (dirty & 8192) {
        link_changes.$$scope = { dirty, ctx: ctx2 };
      }
      link.$set(link_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(link.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(link.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(link, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment166.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance166($$self, $$props, $$invalidate) {
  const omit_props_names = ["clicked", "light", "disabled", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClickableTile", slots, ["default"]);
  let { clicked = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { href = void 0 } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = () => {
    $$invalidate(0, clicked = !clicked);
  };
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler_12 = ({ key }) => {
    if (key === " " || key === "Enter") {
      $$invalidate(0, clicked = !clicked);
    }
  };
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("clicked" in $$new_props)
      $$invalidate(0, clicked = $$new_props.clicked);
    if ("light" in $$new_props)
      $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ clicked, light, disabled, href, Link: Link_default });
  $$self.$inject_state = ($$new_props) => {
    if ("clicked" in $$props)
      $$invalidate(0, clicked = $$new_props.clicked);
    if ("light" in $$props)
      $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    clicked,
    light,
    disabled,
    href,
    $$restProps,
    slots,
    click_handler,
    click_handler_13,
    keydown_handler,
    keydown_handler_12,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
var ClickableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance166, create_fragment166, safe_not_equal, {
      clicked: 0,
      light: 1,
      disabled: 2,
      href: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClickableTile",
      options,
      id: create_fragment166.name
    });
  }
  get clicked() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clicked(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClickableTile_default = ClickableTile;

// node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte
var file155 = "node_modules/carbon-components-svelte/src/Tile/ExpandableTile.svelte";
var get_below_slot_changes = (dirty) => ({});
var get_below_slot_context = (ctx) => ({});
var get_above_slot_changes = (dirty) => ({});
var get_above_slot_context = (ctx) => ({});
function create_fragment167(ctx) {
  let button;
  let div3;
  let div0;
  let span0;
  let t0;
  let div1;
  let span1;
  let t1_value = (ctx[0] ? ctx[7] : ctx[8]) + "";
  let t1;
  let t2;
  let chevrondown;
  let t3;
  let div2;
  let span2;
  let button_title_value;
  let button_style_value;
  let current;
  let mounted;
  let dispose;
  const above_slot_template = ctx[14].above;
  const above_slot = create_slot(above_slot_template, ctx, ctx[13], get_above_slot_context);
  chevrondown = new ChevronDown_default({ $$inline: true });
  const below_slot_template = ctx[14].below;
  const below_slot = create_slot(below_slot_template, ctx, ctx[13], get_below_slot_context);
  let button_levels = [
    { type: "button" },
    { id: ctx[10] },
    { "aria-expanded": ctx[0] },
    { tabindex: ctx[9] },
    {
      title: button_title_value = ctx[0] ? ctx[6] : ctx[5]
    },
    ctx[12],
    {
      style: button_style_value = ctx[0] ? ctx[12].style : `${ctx[12].style}; max-height: ${ctx[1] + ctx[2]}px`
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      div3 = element("div");
      div0 = element("div");
      span0 = element("span");
      if (above_slot)
        above_slot.c();
      t0 = space();
      div1 = element("div");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(chevrondown.$$.fragment);
      t3 = space();
      div2 = element("div");
      span2 = element("span");
      if (below_slot)
        below_slot.c();
      toggle_class(span0, "bx--tile-content__above-the-fold", true);
      add_location(span0, file155, 79, 6, 2179);
      toggle_class(div0, "bx--tile-content", true);
      add_location(div0, file155, 78, 4, 2112);
      add_location(span1, file155, 84, 6, 2338);
      toggle_class(div1, "bx--tile__chevron", true);
      add_location(div1, file155, 83, 4, 2293);
      toggle_class(span2, "bx--tile-content__below-the-fold", true);
      add_location(span2, file155, 88, 6, 2484);
      toggle_class(div2, "bx--tile-content", true);
      add_location(div2, file155, 87, 4, 2440);
      add_location(div3, file155, 77, 2, 2102);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tile", true);
      toggle_class(button, "bx--tile--expandable", true);
      toggle_class(button, "bx--tile--is-expanded", ctx[0]);
      toggle_class(button, "bx--tile--light", ctx[4]);
      add_location(button, file155, 53, 0, 1516);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, div3);
      append_dev(div3, div0);
      append_dev(div0, span0);
      if (above_slot) {
        above_slot.m(span0, null);
      }
      ctx[20](div0);
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div1, span1);
      append_dev(span1, t1);
      append_dev(div1, t2);
      mount_component(chevrondown, div1, null);
      append_dev(div3, t3);
      append_dev(div3, div2);
      append_dev(div2, span2);
      if (below_slot) {
        below_slot.m(span2, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[21](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[15], false, false, false),
          listen_dev(button, "click", ctx[22], false, false, false),
          listen_dev(button, "keypress", ctx[16], false, false, false),
          listen_dev(button, "mouseover", ctx[17], false, false, false),
          listen_dev(button, "mouseenter", ctx[18], false, false, false),
          listen_dev(button, "mouseleave", ctx[19], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (above_slot) {
        if (above_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            above_slot,
            above_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(above_slot_template, ctx2[13], dirty, get_above_slot_changes),
            get_above_slot_context
          );
        }
      }
      if ((!current || dirty & 385) && t1_value !== (t1_value = (ctx2[0] ? ctx2[7] : ctx2[8]) + ""))
        set_data_dev(t1, t1_value);
      if (below_slot) {
        if (below_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            below_slot,
            below_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(below_slot_template, ctx2[13], dirty, get_below_slot_changes),
            get_below_slot_context
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & 1024) && { id: ctx2[10] },
        (!current || dirty & 1) && { "aria-expanded": ctx2[0] },
        (!current || dirty & 512) && { tabindex: ctx2[9] },
        (!current || dirty & 97 && button_title_value !== (button_title_value = ctx2[0] ? ctx2[6] : ctx2[5])) && { title: button_title_value },
        dirty & 4096 && ctx2[12],
        (!current || dirty & 4103 && button_style_value !== (button_style_value = ctx2[0] ? ctx2[12].style : `${ctx2[12].style}; max-height: ${ctx2[1] + ctx2[2]}px`)) && { style: button_style_value }
      ]));
      toggle_class(button, "bx--tile", true);
      toggle_class(button, "bx--tile--expandable", true);
      toggle_class(button, "bx--tile--is-expanded", ctx2[0]);
      toggle_class(button, "bx--tile--light", ctx2[4]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(above_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(below_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(above_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(below_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (above_slot)
        above_slot.d(detaching);
      ctx[20](null);
      destroy_component(chevrondown);
      if (below_slot)
        below_slot.d(detaching);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment167.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance167($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "expanded",
    "light",
    "tileMaxHeight",
    "tilePadding",
    "tileCollapsedIconText",
    "tileExpandedIconText",
    "tileExpandedLabel",
    "tileCollapsedLabel",
    "tabindex",
    "id",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ExpandableTile", slots, ["above", "below"]);
  let { expanded = false } = $$props;
  let { light = false } = $$props;
  let { tileMaxHeight = 0 } = $$props;
  let { tilePadding = 0 } = $$props;
  let { tileCollapsedIconText = "Interact to expand Tile" } = $$props;
  let { tileExpandedIconText = "Interact to collapse Tile" } = $$props;
  let { tileExpandedLabel = "" } = $$props;
  let { tileCollapsedLabel = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  let refAbove = null;
  afterUpdate(() => {
    if (tileMaxHeight === 0) {
      $$invalidate(1, tileMaxHeight = refAbove.getBoundingClientRect().height);
    }
    const style = getComputedStyle(ref);
    $$invalidate(2, tilePadding = parseInt(style.getPropertyValue("padding-top"), 10) + parseInt(style.getPropertyValue("padding-bottom"), 10));
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keypress_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refAbove = $$value;
      $$invalidate(11, refAbove);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("light" in $$new_props)
      $$invalidate(4, light = $$new_props.light);
    if ("tileMaxHeight" in $$new_props)
      $$invalidate(1, tileMaxHeight = $$new_props.tileMaxHeight);
    if ("tilePadding" in $$new_props)
      $$invalidate(2, tilePadding = $$new_props.tilePadding);
    if ("tileCollapsedIconText" in $$new_props)
      $$invalidate(5, tileCollapsedIconText = $$new_props.tileCollapsedIconText);
    if ("tileExpandedIconText" in $$new_props)
      $$invalidate(6, tileExpandedIconText = $$new_props.tileExpandedIconText);
    if ("tileExpandedLabel" in $$new_props)
      $$invalidate(7, tileExpandedLabel = $$new_props.tileExpandedLabel);
    if ("tileCollapsedLabel" in $$new_props)
      $$invalidate(8, tileCollapsedLabel = $$new_props.tileCollapsedLabel);
    if ("tabindex" in $$new_props)
      $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$new_props)
      $$invalidate(10, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expanded,
    light,
    tileMaxHeight,
    tilePadding,
    tileCollapsedIconText,
    tileExpandedIconText,
    tileExpandedLabel,
    tileCollapsedLabel,
    tabindex,
    id,
    ref,
    afterUpdate,
    ChevronDown: ChevronDown_default,
    refAbove
  });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("light" in $$props)
      $$invalidate(4, light = $$new_props.light);
    if ("tileMaxHeight" in $$props)
      $$invalidate(1, tileMaxHeight = $$new_props.tileMaxHeight);
    if ("tilePadding" in $$props)
      $$invalidate(2, tilePadding = $$new_props.tilePadding);
    if ("tileCollapsedIconText" in $$props)
      $$invalidate(5, tileCollapsedIconText = $$new_props.tileCollapsedIconText);
    if ("tileExpandedIconText" in $$props)
      $$invalidate(6, tileExpandedIconText = $$new_props.tileExpandedIconText);
    if ("tileExpandedLabel" in $$props)
      $$invalidate(7, tileExpandedLabel = $$new_props.tileExpandedLabel);
    if ("tileCollapsedLabel" in $$props)
      $$invalidate(8, tileCollapsedLabel = $$new_props.tileCollapsedLabel);
    if ("tabindex" in $$props)
      $$invalidate(9, tabindex = $$new_props.tabindex);
    if ("id" in $$props)
      $$invalidate(10, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(3, ref = $$new_props.ref);
    if ("refAbove" in $$props)
      $$invalidate(11, refAbove = $$new_props.refAbove);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    expanded,
    tileMaxHeight,
    tilePadding,
    ref,
    light,
    tileCollapsedIconText,
    tileExpandedIconText,
    tileExpandedLabel,
    tileCollapsedLabel,
    tabindex,
    id,
    refAbove,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    keypress_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    div0_binding,
    button_binding,
    click_handler_13
  ];
}
var ExpandableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance167, create_fragment167, safe_not_equal, {
      expanded: 0,
      light: 4,
      tileMaxHeight: 1,
      tilePadding: 2,
      tileCollapsedIconText: 5,
      tileExpandedIconText: 6,
      tileExpandedLabel: 7,
      tileCollapsedLabel: 8,
      tabindex: 9,
      id: 10,
      ref: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ExpandableTile",
      options,
      id: create_fragment167.name
    });
  }
  get expanded() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileMaxHeight() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileMaxHeight(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tilePadding() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tilePadding(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileCollapsedIconText() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileCollapsedIconText(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileExpandedIconText() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileExpandedIconText(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileExpandedLabel() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileExpandedLabel(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileCollapsedLabel() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileCollapsedLabel(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ExpandableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ExpandableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ExpandableTile_default = ExpandableTile;

// node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte
var file156 = "node_modules/carbon-components-svelte/src/Tile/SelectableTile.svelte";
function create_fragment168(ctx) {
  let input;
  let t0;
  let label;
  let span0;
  let checkmarkfilled;
  let t1;
  let span1;
  let label_tabindex_value;
  let current;
  let mounted;
  let dispose;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      "aria-label": ctx[7],
      title: ctx[7]
    },
    $$inline: true
  });
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let label_levels = [
    { for: ctx[8] },
    {
      tabindex: label_tabindex_value = ctx[3] ? void 0 : ctx[6]
    },
    ctx[10]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      create_component(checkmarkfilled.$$.fragment);
      t1 = space();
      span1 = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "tabindex", "-1");
      input.checked = ctx[0];
      attr_dev(input, "id", ctx[8]);
      input.value = ctx[5];
      attr_dev(input, "name", ctx[9]);
      attr_dev(input, "title", ctx[4]);
      input.disabled = ctx[3];
      toggle_class(input, "bx--tile-input", true);
      add_location(input, file156, 42, 0, 1099);
      toggle_class(span0, "bx--tile__checkmark", true);
      add_location(span0, file156, 82, 2, 2016);
      toggle_class(span1, "bx--tile-content", true);
      add_location(span1, file156, 85, 2, 2151);
      set_attributes(label, label_data);
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(label, "bx--tile--is-selected", ctx[0]);
      toggle_class(label, "bx--tile--light", ctx[2]);
      toggle_class(label, "bx--tile--disabled", ctx[3]);
      add_location(label, file156, 56, 0, 1418);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      ctx[18](input);
      insert_dev(target, t0, anchor);
      insert_dev(target, label, anchor);
      append_dev(label, span0);
      mount_component(checkmarkfilled, span0, null);
      append_dev(label, t1);
      append_dev(label, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(label, "click", ctx[13], false, false, false),
          listen_dev(label, "click", prevent_default(ctx[19]), false, true, false),
          listen_dev(label, "mouseover", ctx[14], false, false, false),
          listen_dev(label, "mouseenter", ctx[15], false, false, false),
          listen_dev(label, "mouseleave", ctx[16], false, false, false),
          listen_dev(label, "keydown", ctx[17], false, false, false),
          listen_dev(label, "keydown", ctx[20], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        prop_dev(input, "checked", ctx2[0]);
      }
      if (!current || dirty & 256) {
        attr_dev(input, "id", ctx2[8]);
      }
      if (!current || dirty & 32) {
        prop_dev(input, "value", ctx2[5]);
      }
      if (!current || dirty & 512) {
        attr_dev(input, "name", ctx2[9]);
      }
      if (!current || dirty & 16) {
        attr_dev(input, "title", ctx2[4]);
      }
      if (!current || dirty & 8) {
        prop_dev(input, "disabled", ctx2[3]);
      }
      const checkmarkfilled_changes = {};
      if (dirty & 128)
        checkmarkfilled_changes["aria-label"] = ctx2[7];
      if (dirty & 128)
        checkmarkfilled_changes.title = ctx2[7];
      checkmarkfilled.$set(checkmarkfilled_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 256) && { for: ctx2[8] },
        (!current || dirty & 72 && label_tabindex_value !== (label_tabindex_value = ctx2[3] ? void 0 : ctx2[6])) && { tabindex: label_tabindex_value },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(label, "bx--tile--is-selected", ctx2[0]);
      toggle_class(label, "bx--tile--light", ctx2[2]);
      toggle_class(label, "bx--tile--disabled", ctx2[3]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkfilled.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[18](null);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(label);
      destroy_component(checkmarkfilled);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment168.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance168($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "light",
    "disabled",
    "title",
    "value",
    "tabindex",
    "iconDescription",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectableTile", slots, ["default"]);
  let { selected = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { title = "title" } = $$props;
  let { value = "value" } = $$props;
  let { tabindex = "0" } = $$props;
  let { iconDescription = "Tile checkmark" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    if (disabled)
      return;
    $$invalidate(0, selected = !selected);
  };
  const keydown_handler_12 = (e) => {
    if (disabled)
      return;
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      $$invalidate(0, selected = !selected);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("light" in $$new_props)
      $$invalidate(2, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("title" in $$new_props)
      $$invalidate(4, title = $$new_props.title);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("tabindex" in $$new_props)
      $$invalidate(6, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$new_props)
      $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    light,
    disabled,
    title,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    ref,
    createEventDispatcher,
    CheckmarkFilled: CheckmarkFilled_default,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("light" in $$props)
      $$invalidate(2, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
    if ("tabindex" in $$props)
      $$invalidate(6, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$props)
      $$invalidate(7, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 265) {
      $:
        if (!disabled)
          dispatch(selected ? "select" : "deselect", id);
    }
  };
  return [
    selected,
    ref,
    light,
    disabled,
    title,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    input_binding,
    click_handler_13,
    keydown_handler_12
  ];
}
var SelectableTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance168, create_fragment168, safe_not_equal, {
      selected: 0,
      light: 2,
      disabled: 3,
      title: 4,
      value: 5,
      tabindex: 6,
      iconDescription: 7,
      id: 8,
      name: 9,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectableTile",
      options,
      id: create_fragment168.name
    });
  }
  get selected() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SelectableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SelectableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectableTile_default = SelectableTile;

// node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte
var file157 = "node_modules/carbon-components-svelte/src/Tile/RadioTile.svelte";
function create_fragment169(ctx) {
  let input;
  let input_tabindex_value;
  let t0;
  let label;
  let span0;
  let checkmarkfilled;
  let t1;
  let span1;
  let current;
  let mounted;
  let dispose;
  checkmarkfilled = new CheckmarkFilled_default({
    props: {
      "aria-label": ctx[5],
      title: ctx[5]
    },
    $$inline: true
  });
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  let label_levels = [{ for: ctx[6] }, ctx[10]];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      create_component(checkmarkfilled.$$.fragment);
      t1 = space();
      span1 = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(input, "type", "radio");
      attr_dev(input, "id", ctx[6]);
      attr_dev(input, "name", ctx[7]);
      input.value = ctx[3];
      input.checked = ctx[0];
      attr_dev(input, "tabindex", input_tabindex_value = ctx[2] ? void 0 : ctx[4]);
      input.disabled = ctx[2];
      toggle_class(input, "bx--tile-input", true);
      add_location(input, file157, 35, 0, 906);
      toggle_class(span0, "bx--tile__checkmark", true);
      add_location(span0, file157, 72, 2, 1693);
      toggle_class(span1, "bx--tile-content", true);
      add_location(span1, file157, 75, 2, 1828);
      set_attributes(label, label_data);
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(label, "bx--tile--is-selected", ctx[0]);
      toggle_class(label, "bx--tile--light", ctx[1]);
      toggle_class(label, "bx--tile--disabled", ctx[2]);
      add_location(label, file157, 59, 0, 1412);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, label, anchor);
      append_dev(label, span0);
      mount_component(checkmarkfilled, span0, null);
      append_dev(label, t1);
      append_dev(label, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[18], false, false, false),
          listen_dev(input, "change", ctx[20], false, false, false),
          listen_dev(input, "keydown", ctx[19], false, false, false),
          listen_dev(input, "keydown", ctx[21], false, false, false),
          listen_dev(label, "click", ctx[14], false, false, false),
          listen_dev(label, "mouseover", ctx[15], false, false, false),
          listen_dev(label, "mouseenter", ctx[16], false, false, false),
          listen_dev(label, "mouseleave", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 64) {
        attr_dev(input, "id", ctx2[6]);
      }
      if (!current || dirty & 128) {
        attr_dev(input, "name", ctx2[7]);
      }
      if (!current || dirty & 8) {
        prop_dev(input, "value", ctx2[3]);
      }
      if (!current || dirty & 1) {
        prop_dev(input, "checked", ctx2[0]);
      }
      if (!current || dirty & 20 && input_tabindex_value !== (input_tabindex_value = ctx2[2] ? void 0 : ctx2[4])) {
        attr_dev(input, "tabindex", input_tabindex_value);
      }
      if (!current || dirty & 4) {
        prop_dev(input, "disabled", ctx2[2]);
      }
      const checkmarkfilled_changes = {};
      if (dirty & 32)
        checkmarkfilled_changes["aria-label"] = ctx2[5];
      if (dirty & 32)
        checkmarkfilled_changes.title = ctx2[5];
      checkmarkfilled.$set(checkmarkfilled_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 64) && { for: ctx2[6] },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(label, "bx--tile", true);
      toggle_class(label, "bx--tile--selectable", true);
      toggle_class(label, "bx--tile--is-selected", ctx2[0]);
      toggle_class(label, "bx--tile--light", ctx2[1]);
      toggle_class(label, "bx--tile--disabled", ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkfilled.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkfilled.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(label);
      destroy_component(checkmarkfilled);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment169.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance169($$self, $$props, $$invalidate) {
  const omit_props_names = ["checked", "light", "disabled", "value", "tabindex", "iconDescription", "id", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioTile", slots, ["default"]);
  let { checked = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { value = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { iconDescription = "Tile checkmark" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  const { add, update, selectedValue } = getContext("TileGroup");
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(11, $selectedValue = value2));
  add({ value, checked });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const change_handler_1 = () => {
    if (disabled)
      return;
    update(value);
  };
  const keydown_handler_12 = (e) => {
    if (disabled)
      return;
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      update(value);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("light" in $$new_props)
      $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("tabindex" in $$new_props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$new_props)
      $$invalidate(5, iconDescription = $$new_props.iconDescription);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(7, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    checked,
    light,
    disabled,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    getContext,
    CheckmarkFilled: CheckmarkFilled_default,
    add,
    update,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("light" in $$props)
      $$invalidate(1, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("tabindex" in $$props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("iconDescription" in $$props)
      $$invalidate(5, iconDescription = $$new_props.iconDescription);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(7, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2056) {
      $:
        $$invalidate(0, checked = value === $selectedValue);
    }
  };
  return [
    checked,
    light,
    disabled,
    value,
    tabindex,
    iconDescription,
    id,
    name,
    update,
    selectedValue,
    $$restProps,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    keydown_handler,
    change_handler_1,
    keydown_handler_12
  ];
}
var RadioTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance169, create_fragment169, safe_not_equal, {
      checked: 0,
      light: 1,
      disabled: 2,
      value: 3,
      tabindex: 4,
      iconDescription: 5,
      id: 6,
      name: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioTile",
      options,
      id: create_fragment169.name
    });
  }
  get checked() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioTile_default = RadioTile;

// node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte
var file158 = "node_modules/carbon-components-svelte/src/Tile/TileGroup.svelte";
function create_if_block96(ctx) {
  let legend_1;
  let t;
  const block = {
    c: function create() {
      legend_1 = element("legend");
      t = text(ctx[1]);
      toggle_class(legend_1, "bx--label", true);
      add_location(legend_1, file158, 38, 4, 882);
    },
    m: function mount(target, anchor) {
      insert_dev(target, legend_1, anchor);
      append_dev(legend_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(legend_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block96.name,
    type: "if",
    source: "(38:2) {#if legend}",
    ctx
  });
  return block;
}
function create_fragment170(ctx) {
  let fieldset;
  let t;
  let div;
  let current;
  let if_block = ctx[1] && create_if_block96(ctx);
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let fieldset_levels = [{ disabled: ctx[0] }, ctx[3]];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      add_location(div, file158, 40, 2, 943);
      set_attributes(fieldset, fieldset_data);
      toggle_class(fieldset, "bx--tile-group", true);
      add_location(fieldset, file158, 36, 0, 783);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, fieldset, anchor);
      if (if_block)
        if_block.m(fieldset, null);
      append_dev(fieldset, t);
      append_dev(fieldset, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block96(ctx2);
          if_block.c();
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        (!current || dirty & 1) && { disabled: ctx2[0] },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(fieldset, "bx--tile-group", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment170.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance170($$self, $$props, $$invalidate) {
  const omit_props_names = ["selected", "disabled", "legend"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TileGroup", slots, ["default"]);
  let { selected = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { legend = "" } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(5, $selectedValue = value));
  setContext("TileGroup", {
    selectedValue,
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      selectedValue.set(value);
      dispatch("select", value);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legend" in $$new_props)
      $$invalidate(1, legend = $$new_props.legend);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    legend,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legend" in $$props)
      $$invalidate(1, legend = $$new_props.legend);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(4, selected = $selectedValue);
    }
    if ($$self.$$.dirty & 16) {
      $:
        selectedValue.set(selected);
    }
  };
  return [
    disabled,
    legend,
    selectedValue,
    $$restProps,
    selected,
    $selectedValue,
    $$scope,
    slots
  ];
}
var TileGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance170, create_fragment170, safe_not_equal, { selected: 4, disabled: 0, legend: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TileGroup",
      options,
      id: create_fragment170.name
    });
  }
  get selected() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<TileGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<TileGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TileGroup_default = TileGroup;

// node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte
var file159 = "node_modules/carbon-components-svelte/src/TimePicker/TimePicker.svelte";
var get_labelText_slot_changes15 = (dirty) => ({});
var get_labelText_slot_context15 = (ctx) => ({});
function create_if_block_139(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[17].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[16], get_labelText_slot_context15);
  const labelText_slot_or_fallback = labelText_slot || fallback_block34(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[12]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", ctx[9]);
      toggle_class(label, "bx--label--disabled", ctx[7]);
      add_location(label, file159, 72, 8, 1816);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(labelText_slot_template, ctx2[16], dirty, get_labelText_slot_changes15),
            get_labelText_slot_context15
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 256)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 4096) {
        attr_dev(label, "for", ctx2[12]);
      }
      if (!current || dirty & 512) {
        toggle_class(label, "bx--visually-hidden", ctx2[9]);
      }
      if (!current || dirty & 128) {
        toggle_class(label, "bx--label--disabled", ctx2[7]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_139.name,
    type: "if",
    source: "(72:6) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block34(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[8]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256)
        set_data_dev(t, ctx2[8]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block34.name,
    type: "fallback",
    source: "(79:33)              ",
    ctx
  });
  return block;
}
function create_if_block97(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[11]);
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file159, 111, 4, 2777);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2048)
        set_data_dev(t, ctx2[11]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block97.name,
    type: "if",
    source: "(111:2) {#if invalid}",
    ctx
  });
  return block;
}
function create_fragment171(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let input;
  let input_data_invalid_value;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[8] || ctx[14].labelText) && create_if_block_139(ctx);
  let input_levels = [
    { type: "text" },
    {
      "data-invalid": input_data_invalid_value = ctx[10] || void 0
    },
    { pattern: ctx[4] },
    { placeholder: ctx[3] },
    { maxlength: ctx[5] },
    { id: ctx[12] },
    { name: ctx[13] },
    { disabled: ctx[7] },
    ctx[15]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  let if_block1 = ctx[10] && create_if_block97(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      input = element("input");
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      set_attributes(input, input_data);
      toggle_class(input, "bx--time-picker__input-field", true);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx[6]);
      toggle_class(input, "bx--text-input--invalid", ctx[10]);
      add_location(input, file159, 83, 6, 2099);
      toggle_class(div0, "bx--time-picker__input", true);
      add_location(div0, file159, 70, 4, 1721);
      toggle_class(div1, "bx--time-picker", true);
      toggle_class(div1, "bx--time-picker--light", ctx[6]);
      toggle_class(div1, "bx--time-picker--invalid", ctx[10]);
      toggle_class(div1, "bx--time-picker--sm", ctx[2] === "sm");
      toggle_class(div1, "bx--time-picker--xl", ctx[2] === "xl");
      toggle_class(div1, "bx--select--light", ctx[6]);
      add_location(div1, file159, 62, 2, 1449);
      toggle_class(div2, "bx--form-item", true);
      add_location(div2, file159, 55, 0, 1351);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t0);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[29](input);
      set_input_value(input, ctx[0]);
      append_dev(div1, t1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_dev(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[30]),
          listen_dev(input, "change", ctx[22], false, false, false),
          listen_dev(input, "input", ctx[23], false, false, false),
          listen_dev(input, "keydown", ctx[24], false, false, false),
          listen_dev(input, "keyup", ctx[25], false, false, false),
          listen_dev(input, "focus", ctx[26], false, false, false),
          listen_dev(input, "blur", ctx[27], false, false, false),
          listen_dev(input, "paste", ctx[28], false, false, false),
          listen_dev(div2, "click", ctx[18], false, false, false),
          listen_dev(div2, "mouseover", ctx[19], false, false, false),
          listen_dev(div2, "mouseenter", ctx[20], false, false, false),
          listen_dev(div2, "mouseleave", ctx[21], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[8] || ctx2[14].labelText) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16640) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_139(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        (!current || dirty & 1024 && input_data_invalid_value !== (input_data_invalid_value = ctx2[10] || void 0)) && { "data-invalid": input_data_invalid_value },
        (!current || dirty & 16) && { pattern: ctx2[4] },
        (!current || dirty & 8) && { placeholder: ctx2[3] },
        (!current || dirty & 32) && { maxlength: ctx2[5] },
        (!current || dirty & 4096) && { id: ctx2[12] },
        (!current || dirty & 8192) && { name: ctx2[13] },
        (!current || dirty & 128) && { disabled: ctx2[7] },
        dirty & 32768 && ctx2[15]
      ]));
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      toggle_class(input, "bx--time-picker__input-field", true);
      toggle_class(input, "bx--text-input", true);
      toggle_class(input, "bx--text-input--light", ctx2[6]);
      toggle_class(input, "bx--text-input--invalid", ctx2[10]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 64) {
        toggle_class(div1, "bx--time-picker--light", ctx2[6]);
      }
      if (!current || dirty & 1024) {
        toggle_class(div1, "bx--time-picker--invalid", ctx2[10]);
      }
      if (!current || dirty & 4) {
        toggle_class(div1, "bx--time-picker--sm", ctx2[2] === "sm");
      }
      if (!current || dirty & 4) {
        toggle_class(div1, "bx--time-picker--xl", ctx2[2] === "xl");
      }
      if (!current || dirty & 64) {
        toggle_class(div1, "bx--select--light", ctx2[6]);
      }
      if (ctx2[10]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block97(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block0)
        if_block0.d();
      ctx[29](null);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment171.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance171($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "value",
    "placeholder",
    "pattern",
    "maxlength",
    "light",
    "disabled",
    "labelText",
    "hideLabel",
    "invalid",
    "invalidText",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimePicker", slots, ["labelText", "default"]);
  const $$slots = compute_slots(slots);
  let { size = void 0 } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "hh:mm" } = $$props;
  let { pattern = "(1[012]|[1-9]):[0-5][0-9](\\s)?" } = $$props;
  let { maxlength = 5 } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$new_props)
      $$invalidate(4, pattern = $$new_props.pattern);
    if ("maxlength" in $$new_props)
      $$invalidate(5, maxlength = $$new_props.maxlength);
    if ("light" in $$new_props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("labelText" in $$new_props)
      $$invalidate(8, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(9, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$new_props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(11, invalidText = $$new_props.invalidText);
    if ("id" in $$new_props)
      $$invalidate(12, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(13, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    value,
    placeholder,
    pattern,
    maxlength,
    light,
    disabled,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("pattern" in $$props)
      $$invalidate(4, pattern = $$new_props.pattern);
    if ("maxlength" in $$props)
      $$invalidate(5, maxlength = $$new_props.maxlength);
    if ("light" in $$props)
      $$invalidate(6, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("labelText" in $$props)
      $$invalidate(8, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(9, hideLabel = $$new_props.hideLabel);
    if ("invalid" in $$props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(11, invalidText = $$new_props.invalidText);
    if ("id" in $$props)
      $$invalidate(12, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(13, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    ref,
    size,
    placeholder,
    pattern,
    maxlength,
    light,
    disabled,
    labelText,
    hideLabel,
    invalid,
    invalidText,
    id,
    name,
    $$slots,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    input_handler,
    keydown_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    paste_handler,
    input_binding,
    input_input_handler
  ];
}
var TimePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance171, create_fragment171, safe_not_equal, {
      size: 2,
      value: 0,
      placeholder: 3,
      pattern: 4,
      maxlength: 5,
      light: 6,
      disabled: 7,
      labelText: 8,
      hideLabel: 9,
      invalid: 10,
      invalidText: 11,
      id: 12,
      name: 13,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimePicker",
      options,
      id: create_fragment171.name
    });
  }
  get size() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pattern() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pattern(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TimePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TimePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimePicker_default = TimePicker;

// node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte
var file160 = "node_modules/carbon-components-svelte/src/TimePicker/TimePickerSelect.svelte";
var get_labelText_slot_changes16 = (dirty) => ({});
var get_labelText_slot_context16 = (ctx) => ({});
function create_if_block98(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[12].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[11], get_labelText_slot_context16);
  const labelText_slot_or_fallback = labelText_slot || fallback_block35(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "for", ctx[5]);
      toggle_class(label, "bx--label", true);
      toggle_class(label, "bx--visually-hidden", true);
      add_location(label, file160, 51, 4, 1210);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(labelText_slot_template, ctx2[11], dirty, get_labelText_slot_changes16),
            get_labelText_slot_context16
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 16)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 32) {
        attr_dev(label, "for", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block98.name,
    type: "if",
    source: "(51:2) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block35(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block35.name,
    type: "fallback",
    source: "(57:29)          ",
    ctx
  });
  return block;
}
function create_fragment172(ctx) {
  let div;
  let t0;
  let select;
  let t1;
  let chevrondown;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[4] || ctx[9].labelText) && create_if_block98(ctx);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  chevrondown = new ChevronDown_default({
    props: {
      "aria-label": ctx[3],
      title: ctx[3],
      class: "bx--select__arrow"
    },
    $$inline: true
  });
  let div_levels = [ctx[8]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      select = element("select");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(chevrondown.$$.fragment);
      attr_dev(select, "id", ctx[5]);
      attr_dev(select, "name", ctx[6]);
      select.disabled = ctx[2];
      toggle_class(select, "bx--select-input", true);
      add_location(select, file160, 62, 2, 1441);
      set_attributes(div, div_data);
      toggle_class(div, "bx--select", true);
      toggle_class(div, "bx--time-picker__select", true);
      add_location(div, file160, 41, 0, 1014);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t0);
      append_dev(div, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(select, ctx[0]);
      ctx[17](select);
      append_dev(div, t1);
      mount_component(chevrondown, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(select, "change", ctx[18], false, false, false),
          listen_dev(div, "click", ctx[13], false, false, false),
          listen_dev(div, "mouseover", ctx[14], false, false, false),
          listen_dev(div, "mouseenter", ctx[15], false, false, false),
          listen_dev(div, "mouseleave", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[4] || ctx2[9].labelText) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 528) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block98(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(select, "id", ctx2[5]);
      }
      if (!current || dirty & 64) {
        attr_dev(select, "name", ctx2[6]);
      }
      if (!current || dirty & 4) {
        prop_dev(select, "disabled", ctx2[2]);
      }
      if (!current || dirty & 1) {
        select_option(select, ctx2[0]);
      }
      const chevrondown_changes = {};
      if (dirty & 8)
        chevrondown_changes["aria-label"] = ctx2[3];
      if (dirty & 8)
        chevrondown_changes.title = ctx2[3];
      chevrondown.$set(chevrondown_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 256 && ctx2[8]]));
      toggle_class(div, "bx--select", true);
      toggle_class(div, "bx--time-picker__select", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      destroy_component(chevrondown);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment172.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance172($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "disabled", "iconDescription", "labelText", "id", "name", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimePickerSelect", slots, ["labelText", "default"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { disabled = false } = $$props;
  let { iconDescription = "Open list of options" } = $$props;
  let { labelText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { ref = null } = $$props;
  const selectedValue = writable(value);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
  setContext("TimePickerSelect", { selectedValue });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler = ({ target }) => {
    selectedValue.set(target.value);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("iconDescription" in $$new_props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("labelText" in $$new_props)
      $$invalidate(4, labelText = $$new_props.labelText);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    disabled,
    iconDescription,
    labelText,
    id,
    name,
    ref,
    setContext,
    writable,
    ChevronDown: ChevronDown_default,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("iconDescription" in $$props)
      $$invalidate(3, iconDescription = $$new_props.iconDescription);
    if ("labelText" in $$props)
      $$invalidate(4, labelText = $$new_props.labelText);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(0, value = $selectedValue);
    }
    if ($$self.$$.dirty & 1) {
      $:
        selectedValue.set(value);
    }
  };
  return [
    value,
    ref,
    disabled,
    iconDescription,
    labelText,
    id,
    name,
    selectedValue,
    $$restProps,
    $$slots,
    $selectedValue,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    select_binding,
    change_handler
  ];
}
var TimePickerSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance172, create_fragment172, safe_not_equal, {
      value: 0,
      disabled: 2,
      iconDescription: 3,
      labelText: 4,
      id: 5,
      name: 6,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimePickerSelect",
      options,
      id: create_fragment172.name
    });
  }
  get value() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TimePickerSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TimePickerSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimePickerSelect_default = TimePickerSelect;

// node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte
var file161 = "node_modules/carbon-components-svelte/src/Toggle/ToggleSkeleton.svelte";
var get_labelText_slot_changes17 = (dirty) => ({});
var get_labelText_slot_context17 = (ctx) => ({});
function create_if_block99(ctx) {
  let span;
  let current;
  const labelText_slot_template = ctx[7].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[6], get_labelText_slot_context17);
  const labelText_slot_or_fallback = labelText_slot || fallback_block36(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      toggle_class(span, "bx--toggle__label-text", true);
      add_location(span, file161, 39, 6, 853);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(labelText_slot_template, ctx2[6], dirty, get_labelText_slot_changes17),
            get_labelText_slot_context17
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 2)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block99.name,
    type: "if",
    source: "(39:4) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block36(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block36.name,
    type: "fallback",
    source: "(41:31)            ",
    ctx
  });
  return block;
}
function create_fragment173(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let t1;
  let span0;
  let t2;
  let span1;
  let t3;
  let span2;
  let label_aria_label_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[1] || ctx[5].labelText) && create_if_block99(ctx);
  let div_levels = [ctx[3]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      if (if_block)
        if_block.c();
      t1 = space();
      span0 = element("span");
      t2 = space();
      span1 = element("span");
      t3 = space();
      span2 = element("span");
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "id", ctx[2]);
      toggle_class(input, "bx--toggle", true);
      toggle_class(input, "bx--toggle--small", ctx[0] === "sm");
      toggle_class(input, "bx--skeleton", true);
      add_location(input, file161, 23, 2, 455);
      toggle_class(span0, "bx--toggle__text--left", true);
      add_location(span0, file161, 45, 4, 996);
      toggle_class(span1, "bx--toggle__appearance", true);
      add_location(span1, file161, 46, 4, 1052);
      toggle_class(span2, "bx--toggle__text--right", true);
      add_location(span2, file161, 47, 4, 1108);
      attr_dev(label, "aria-label", label_aria_label_value = ctx[1] ? void 0 : ctx[4]["aria-label"] || "Toggle is loading");
      attr_dev(label, "for", ctx[2]);
      toggle_class(label, "bx--toggle__label", true);
      toggle_class(label, "bx--skeleton", true);
      add_location(label, file161, 30, 2, 611);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file161, 15, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, input);
      append_dev(div, t0);
      append_dev(div, label);
      if (if_block)
        if_block.m(label, null);
      append_dev(label, t1);
      append_dev(label, span0);
      append_dev(label, t2);
      append_dev(label, span1);
      append_dev(label, t3);
      append_dev(label, span2);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[8], false, false, false),
          listen_dev(div, "mouseover", ctx[9], false, false, false),
          listen_dev(div, "mouseenter", ctx[10], false, false, false),
          listen_dev(div, "mouseleave", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 4) {
        attr_dev(input, "id", ctx2[2]);
      }
      if (!current || dirty & 1) {
        toggle_class(input, "bx--toggle--small", ctx2[0] === "sm");
      }
      if (ctx2[1] || ctx2[5].labelText) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 34) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block99(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 18 && label_aria_label_value !== (label_aria_label_value = ctx2[1] ? void 0 : ctx2[4]["aria-label"] || "Toggle is loading")) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
      if (!current || dirty & 4) {
        attr_dev(label, "for", ctx2[2]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 8 && ctx2[3]]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment173.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance173($$self, $$props, $$invalidate) {
  const omit_props_names = ["size", "labelText", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToggleSkeleton", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { size = "default" } = $$props;
  let { labelText = "" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("labelText" in $$new_props)
      $$invalidate(1, labelText = $$new_props.labelText);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ size, labelText, id });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("labelText" in $$props)
      $$invalidate(1, labelText = $$new_props.labelText);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    size,
    labelText,
    id,
    $$restProps,
    $$props,
    $$slots,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var ToggleSkeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance173, create_fragment173, safe_not_equal, { size: 0, labelText: 1, id: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleSkeleton",
      options,
      id: create_fragment173.name
    });
  }
  get size() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ToggleSkeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ToggleSkeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToggleSkeleton_default = ToggleSkeleton;

// node_modules/carbon-components-svelte/src/icons/Information.svelte
var file162 = "node_modules/carbon-components-svelte/src/icons/Information.svelte";
function create_if_block100(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file162, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block100.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment174(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = ctx[1] && create_if_block100(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M17 22L17 14 13 14 13 16 15 16 15 22 12 22 12 24 20 24 20 22 17 22zM16 8a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 8z");
      add_location(path0, file162, 24, 2, 579);
      attr_dev(path1, "d", "M16,30A14,14,0,1,1,30,16,14,14,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4Z");
      add_location(path1, file162, 26, 10, 714);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file162, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block100(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment174.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance174($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Information", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Information = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance174, create_fragment174, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Information",
      options,
      id: create_fragment174.name
    });
  }
  get size() {
    throw new Error("<Information>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Information>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Information>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Information>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Information_default = Information;

// node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte
var file163 = "node_modules/carbon-components-svelte/src/Tooltip/Tooltip.svelte";
var get_triggerText_slot_changes_1 = (dirty) => ({});
var get_triggerText_slot_context_1 = (ctx) => ({});
var get_icon_slot_changes4 = (dirty) => ({});
var get_icon_slot_context4 = (ctx) => ({});
var get_triggerText_slot_changes = (dirty) => ({});
var get_triggerText_slot_context = (ctx) => ({});
function create_else_block30(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const triggerText_slot_template = ctx[21].triggerText;
  const triggerText_slot = create_slot(triggerText_slot_template, ctx, ctx[20], get_triggerText_slot_context_1);
  const triggerText_slot_or_fallback = triggerText_slot || fallback_block_27(ctx);
  let div_levels = [ctx[12], { "aria-describedby": ctx[9] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (triggerText_slot_or_fallback)
        triggerText_slot_or_fallback.c();
      set_attributes(div, div_data);
      add_location(div, file163, 222, 4, 5809);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (triggerText_slot_or_fallback) {
        triggerText_slot_or_fallback.m(div, null);
      }
      ctx[28](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "mousedown", ctx[16], false, false, false),
          listen_dev(div, "focus", ctx[15], false, false, false),
          listen_dev(div, "blur", ctx[14], false, false, false),
          listen_dev(div, "keydown", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (triggerText_slot) {
        if (triggerText_slot.p && (!current || dirty[0] & 1048576)) {
          update_slot_base(
            triggerText_slot,
            triggerText_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(triggerText_slot_template, ctx2[20], dirty, get_triggerText_slot_changes_1),
            get_triggerText_slot_context_1
          );
        }
      } else {
        if (triggerText_slot_or_fallback && triggerText_slot_or_fallback.p && (!current || dirty[0] & 2048)) {
          triggerText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & 4096 && ctx2[12],
        (!current || dirty[0] & 512) && { "aria-describedby": ctx2[9] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(triggerText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(triggerText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (triggerText_slot_or_fallback)
        triggerText_slot_or_fallback.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block30.name,
    type: "else",
    source: "(222:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_140(ctx) {
  let div1;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  const triggerText_slot_template = ctx[21].triggerText;
  const triggerText_slot = create_slot(triggerText_slot_template, ctx, ctx[20], get_triggerText_slot_context);
  const triggerText_slot_or_fallback = triggerText_slot || fallback_block_113(ctx);
  const icon_slot_template = ctx[21].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[20], get_icon_slot_context4);
  const icon_slot_or_fallback = icon_slot || fallback_block37(ctx);
  let div0_levels = [ctx[12], { "aria-describedby": ctx[9] }];
  let div0_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div0_data = assign(div0_data, div0_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (triggerText_slot_or_fallback)
        triggerText_slot_or_fallback.c();
      t = space();
      div0 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      set_attributes(div0, div0_data);
      add_location(div0, file163, 208, 6, 5459);
      attr_dev(div1, "id", ctx[10]);
      toggle_class(div1, "bx--tooltip__label", true);
      add_location(div1, file163, 206, 4, 5326);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      if (triggerText_slot_or_fallback) {
        triggerText_slot_or_fallback.m(div1, null);
      }
      append_dev(div1, t);
      append_dev(div1, div0);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div0, null);
      }
      ctx[26](div0);
      ctx[27](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "mousedown", ctx[16], false, false, false),
          listen_dev(div0, "focus", ctx[15], false, false, false),
          listen_dev(div0, "keydown", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (triggerText_slot) {
        if (triggerText_slot.p && (!current || dirty[0] & 1048576)) {
          update_slot_base(
            triggerText_slot,
            triggerText_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(triggerText_slot_template, ctx2[20], dirty, get_triggerText_slot_changes),
            get_triggerText_slot_context
          );
        }
      } else {
        if (triggerText_slot_or_fallback && triggerText_slot_or_fallback.p && (!current || dirty[0] & 2048)) {
          triggerText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & 1048576)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(icon_slot_template, ctx2[20], dirty, get_icon_slot_changes4),
            get_icon_slot_context4
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & 384)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      set_attributes(div0, div0_data = get_spread_update(div0_levels, [
        dirty[0] & 4096 && ctx2[12],
        (!current || dirty[0] & 512) && { "aria-describedby": ctx2[9] }
      ]));
      if (!current || dirty[0] & 1024) {
        attr_dev(div1, "id", ctx2[10]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(triggerText_slot_or_fallback, local);
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(triggerText_slot_or_fallback, local);
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (triggerText_slot_or_fallback)
        triggerText_slot_or_fallback.d(detaching);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      ctx[26](null);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_140.name,
    type: "if",
    source: "(206:2) {#if !hideIcon}",
    ctx
  });
  return block;
}
function fallback_block_27(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[11]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_27.name,
    type: "fallback",
    source: "(232:31) {triggerText}",
    ctx
  });
  return block;
}
function fallback_block_113(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[11]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data_dev(t, ctx2[11]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_113.name,
    type: "fallback",
    source: "(208:31) {triggerText}",
    ctx
  });
  return block;
}
function fallback_block37(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    return {
      props: { name: ctx2[8] },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 256)
        switch_instance_changes.name = ctx2[8];
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block37.name,
    type: "fallback",
    source: "(217:26)            ",
    ctx
  });
  return block;
}
function create_if_block101(ctx) {
  let div1;
  let span;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  const block = {
    c: function create() {
      div1 = element("div");
      span = element("span");
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(span, "bx--tooltip__caret", true);
      add_location(span, file163, 250, 6, 6733);
      attr_dev(div0, "tabindex", "-1");
      attr_dev(div0, "role", "dialog");
      toggle_class(div0, "bx--tooltip__content", true);
      add_location(div0, file163, 252, 6, 6850);
      attr_dev(div1, "id", ctx[9]);
      attr_dev(div1, "data-floating-menu-direction", ctx[5]);
      toggle_class(div1, "bx--tooltip", true);
      toggle_class(div1, "bx--tooltip--shown", ctx[0]);
      toggle_class(div1, "bx--tooltip--top", ctx[5] === "top");
      toggle_class(div1, "bx--tooltip--right", ctx[5] === "right");
      toggle_class(div1, "bx--tooltip--bottom", ctx[5] === "bottom");
      toggle_class(div1, "bx--tooltip--left", ctx[5] === "left");
      toggle_class(div1, "bx--tooltip--align-center", ctx[4] === "center");
      toggle_class(div1, "bx--tooltip--align-start", ctx[4] === "start");
      toggle_class(div1, "bx--tooltip--align-end", ctx[4] === "end");
      add_location(div1, file163, 235, 4, 6110);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, span);
      append_dev(div1, t);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[29](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div0, "click", stop_propagation(ctx[22]), false, false, true),
          listen_dev(div0, "mousedown", stop_propagation(ctx[23]), false, false, true),
          listen_dev(div1, "keydown", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 512) {
        attr_dev(div1, "id", ctx2[9]);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(div1, "data-floating-menu-direction", ctx2[5]);
      }
      if (!current || dirty[0] & 1) {
        toggle_class(div1, "bx--tooltip--shown", ctx2[0]);
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--tooltip--top", ctx2[5] === "top");
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--tooltip--right", ctx2[5] === "right");
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--tooltip--bottom", ctx2[5] === "bottom");
      }
      if (!current || dirty[0] & 32) {
        toggle_class(div1, "bx--tooltip--left", ctx2[5] === "left");
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div1, "bx--tooltip--align-center", ctx2[4] === "center");
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div1, "bx--tooltip--align-start", ctx2[4] === "start");
      }
      if (!current || dirty[0] & 16) {
        toggle_class(div1, "bx--tooltip--align-end", ctx2[4] === "end");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block101.name,
    type: "if",
    source: "(235:2) {#if open}",
    ctx
  });
  return block;
}
function create_fragment175(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_140, create_else_block30];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0] && create_if_block101(ctx);
  let div_levels = [
    ctx[17],
    {
      style: div_style_value = (ctx[0] ? "z-index: 1;" : "") + ctx[17].style + "; position: relative;"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      set_attributes(div, div_data);
      add_location(div, file163, 201, 0, 5200);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "mousedown", ctx[24], false, false, false),
          listen_dev(window, "click", ctx[25], true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block101(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & 131072 && ctx2[17],
        (!current || dirty[0] & 131073 && div_style_value !== (div_style_value = (ctx2[0] ? "z-index: 1;" : "") + ctx2[17].style + "; position: relative;")) && { style: div_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment175.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance175($$self, $$props, $$invalidate) {
  let buttonProps;
  const omit_props_names = [
    "align",
    "direction",
    "open",
    "hideIcon",
    "icon",
    "iconDescription",
    "iconName",
    "tabindex",
    "tooltipId",
    "triggerId",
    "triggerText",
    "ref",
    "refTooltip",
    "refIcon"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["triggerText", "icon", "default"]);
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { open = false } = $$props;
  let { hideIcon = false } = $$props;
  let { icon = Information_default } = $$props;
  let { iconDescription = "" } = $$props;
  let { iconName = "" } = $$props;
  let { tabindex = "0" } = $$props;
  let { tooltipId = "ccs-" + Math.random().toString(36) } = $$props;
  let { triggerId = "ccs-" + Math.random().toString(36) } = $$props;
  let { triggerText = "" } = $$props;
  let { ref = null } = $$props;
  let { refTooltip = null } = $$props;
  let { refIcon = null } = $$props;
  const dispatch = createEventDispatcher();
  const tooltipOpen = writable(open);
  setContext("Tooltip", { tooltipOpen });
  function onKeydown(e) {
    if (e.key === "Escape" || e.key === "Tab") {
      e.stopPropagation();
      if (e.key === "Escape")
        refIcon == null ? void 0 : refIcon.focus();
      $$invalidate(0, open = false);
    } else if (e.key === " " || e.key === "Enter") {
      e.stopPropagation();
      e.preventDefault();
      $$invalidate(0, open = true);
    }
  }
  function onBlur({ relatedTarget }) {
    if (refTooltip && !refTooltip.contains(relatedTarget)) {
      $$invalidate(0, open = false);
    }
  }
  function onFocus() {
    $$invalidate(0, open = true);
  }
  function onMousedown() {
    const shouldClose = open;
    setTimeout(() => {
      $$invalidate(0, open = shouldClose ? false : true);
    });
  }
  afterUpdate(() => {
    if (open) {
      const button = ref.getBoundingClientRect();
      const tooltip = refTooltip.getBoundingClientRect();
      let iconWidth = 16;
      let iconHeight = 16;
      if (refIcon) {
        const icon2 = refIcon.getBoundingClientRect();
        iconWidth = icon2.width;
        iconHeight = icon2.height;
      }
      let offsetX = 0;
      let offsetY = 0;
      switch (direction) {
        case "bottom":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2);
          }
          offsetY = iconHeight / 2;
          break;
        case "right":
          offsetX = button.width + 6;
          offsetY = -1 * (tooltip.height / 2 + iconWidth / 2 - 3);
          break;
        case "left":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width + 6 + 1);
          } else {
            offsetX = -1 * (tooltip.width - button.width + iconWidth + 8);
          }
          offsetY = -1 * (tooltip.height / 2 + button.height) - 2;
          break;
        case "top":
          if (hideIcon) {
            offsetX = -1 * (tooltip.width / 2 - button.width / 2);
          } else {
            offsetX = -1 * (tooltip.width / 2 - button.width + iconWidth / 2 + 1);
          }
          offsetY = -1 * (tooltip.height + button.height + iconWidth / 2 - 1);
          break;
      }
      $$invalidate(2, refTooltip.style.left = offsetX + "px", refTooltip);
      $$invalidate(2, refTooltip.style.marginTop = offsetY + "px", refTooltip);
    }
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mousedown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const mousedown_handler_1 = ({ target }) => {
    if (open) {
      if (target.contains(refTooltip)) {
        if (refIcon) {
          refIcon.focus();
        } else if (ref) {
          ref.focus();
        }
      }
    }
  };
  const click_handler_13 = ({ target }) => {
    if (open && !ref.contains(target) && !refTooltip.contains(target)) {
      setTimeout(() => {
        $$invalidate(0, open = false);
      });
    }
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refIcon = $$value;
      $$invalidate(3, refIcon);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refTooltip = $$value;
      $$invalidate(2, refTooltip);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("align" in $$new_props)
      $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$new_props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("hideIcon" in $$new_props)
      $$invalidate(6, hideIcon = $$new_props.hideIcon);
    if ("icon" in $$new_props)
      $$invalidate(7, icon = $$new_props.icon);
    if ("iconDescription" in $$new_props)
      $$invalidate(18, iconDescription = $$new_props.iconDescription);
    if ("iconName" in $$new_props)
      $$invalidate(8, iconName = $$new_props.iconName);
    if ("tabindex" in $$new_props)
      $$invalidate(19, tabindex = $$new_props.tabindex);
    if ("tooltipId" in $$new_props)
      $$invalidate(9, tooltipId = $$new_props.tooltipId);
    if ("triggerId" in $$new_props)
      $$invalidate(10, triggerId = $$new_props.triggerId);
    if ("triggerText" in $$new_props)
      $$invalidate(11, triggerText = $$new_props.triggerText);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("refTooltip" in $$new_props)
      $$invalidate(2, refTooltip = $$new_props.refTooltip);
    if ("refIcon" in $$new_props)
      $$invalidate(3, refIcon = $$new_props.refIcon);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    align,
    direction,
    open,
    hideIcon,
    icon,
    iconDescription,
    iconName,
    tabindex,
    tooltipId,
    triggerId,
    triggerText,
    ref,
    refTooltip,
    refIcon,
    createEventDispatcher,
    afterUpdate,
    setContext,
    writable,
    Information: Information_default,
    dispatch,
    tooltipOpen,
    onKeydown,
    onBlur,
    onFocus,
    onMousedown,
    buttonProps
  });
  $$self.$inject_state = ($$new_props) => {
    if ("align" in $$props)
      $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("hideIcon" in $$props)
      $$invalidate(6, hideIcon = $$new_props.hideIcon);
    if ("icon" in $$props)
      $$invalidate(7, icon = $$new_props.icon);
    if ("iconDescription" in $$props)
      $$invalidate(18, iconDescription = $$new_props.iconDescription);
    if ("iconName" in $$props)
      $$invalidate(8, iconName = $$new_props.iconName);
    if ("tabindex" in $$props)
      $$invalidate(19, tabindex = $$new_props.tabindex);
    if ("tooltipId" in $$props)
      $$invalidate(9, tooltipId = $$new_props.tooltipId);
    if ("triggerId" in $$props)
      $$invalidate(10, triggerId = $$new_props.triggerId);
    if ("triggerText" in $$props)
      $$invalidate(11, triggerText = $$new_props.triggerText);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("refTooltip" in $$props)
      $$invalidate(2, refTooltip = $$new_props.refTooltip);
    if ("refIcon" in $$props)
      $$invalidate(3, refIcon = $$new_props.refIcon);
    if ("buttonProps" in $$props)
      $$invalidate(12, buttonProps = $$new_props.buttonProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $:
        tooltipOpen.set(open);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        dispatch(open ? "open" : "close");
    }
    $:
      $$invalidate(12, buttonProps = {
        role: "button",
        "aria-haspopup": "true",
        id: hideIcon ? triggerId : void 0,
        class: hideIcon ? "bx--tooltip__label" : "bx--tooltip__trigger",
        "aria-expanded": open,
        "aria-describedby": open ? tooltipId : void 0,
        "aria-labelledby": triggerText ? triggerId : void 0,
        "aria-label": triggerText ? void 0 : iconDescription,
        tabindex,
        style: hideIcon ? $$restProps.style : void 0
      });
  };
  return [
    open,
    ref,
    refTooltip,
    refIcon,
    align,
    direction,
    hideIcon,
    icon,
    iconName,
    tooltipId,
    triggerId,
    triggerText,
    buttonProps,
    onKeydown,
    onBlur,
    onFocus,
    onMousedown,
    $$restProps,
    iconDescription,
    tabindex,
    $$scope,
    slots,
    click_handler,
    mousedown_handler,
    mousedown_handler_1,
    click_handler_13,
    div0_binding,
    div1_binding,
    div_binding,
    div1_binding_1
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance175,
      create_fragment175,
      safe_not_equal,
      {
        align: 4,
        direction: 5,
        open: 0,
        hideIcon: 6,
        icon: 7,
        iconDescription: 18,
        iconName: 8,
        tabindex: 19,
        tooltipId: 9,
        triggerId: 10,
        triggerText: 11,
        ref: 1,
        refTooltip: 2,
        refIcon: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment175.name
    });
  }
  get align() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideIcon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideIcon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDescription() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDescription(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconName() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconName(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipId() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipId(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerId() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerId(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerText() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerText(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refTooltip() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refTooltip(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refIcon() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refIcon(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte
var file164 = "node_modules/carbon-components-svelte/src/Tooltip/TooltipFooter.svelte";
function create_fragment176(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div, "bx--tooltip__footer", true);
      add_location(div, file164, 26, 0, 586);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[5](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment176.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance176($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipFooter", slots, ["default"]);
  let { selectorPrimaryFocus = "a[href], button:not([disabled])" } = $$props;
  let ref = null;
  let open = false;
  const ctx = getContext("Tooltip");
  const unsubscribe = ctx.tooltipOpen.subscribe((tooltipOpen) => {
    $$invalidate(2, open = tooltipOpen);
  });
  onMount(() => {
    return () => {
      unsubscribe();
    };
  });
  const writable_props = ["selectorPrimaryFocus"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TooltipFooter> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("selectorPrimaryFocus" in $$props2)
      $$invalidate(1, selectorPrimaryFocus = $$props2.selectorPrimaryFocus);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    selectorPrimaryFocus,
    getContext,
    onMount,
    ref,
    open,
    ctx,
    unsubscribe
  });
  $$self.$inject_state = ($$props2) => {
    if ("selectorPrimaryFocus" in $$props2)
      $$invalidate(1, selectorPrimaryFocus = $$props2.selectorPrimaryFocus);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("open" in $$props2)
      $$invalidate(2, open = $$props2.open);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 7) {
      $:
        if (open && ref) {
          const node = ref.querySelector(selectorPrimaryFocus);
          if (node)
            node.focus();
        }
    }
  };
  return [ref, selectorPrimaryFocus, open, $$scope, slots, div_binding];
}
var TooltipFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance176, create_fragment176, safe_not_equal, { selectorPrimaryFocus: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipFooter",
      options,
      id: create_fragment176.name
    });
  }
  get selectorPrimaryFocus() {
    throw new Error("<TooltipFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorPrimaryFocus(value) {
    throw new Error("<TooltipFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipFooter_default = TooltipFooter;

// node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte
var file165 = "node_modules/carbon-components-svelte/src/TooltipDefinition/TooltipDefinition.svelte";
var get_tooltip_slot_changes = (dirty) => ({});
var get_tooltip_slot_context = (ctx) => ({});
function fallback_block38(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block38.name,
    type: "fallback",
    source: "(82:25) {tooltipText}",
    ctx
  });
  return block;
}
function create_fragment177(ctx) {
  let span;
  let button;
  let t;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const tooltip_slot_template = ctx[10].tooltip;
  const tooltip_slot = create_slot(tooltip_slot_template, ctx, ctx[9], get_tooltip_slot_context);
  const tooltip_slot_or_fallback = tooltip_slot || fallback_block38(ctx);
  let span_levels = [ctx[8]];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      div = element("div");
      if (tooltip_slot_or_fallback)
        tooltip_slot_or_fallback.c();
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-describedby", ctx[5]);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip__trigger--definition", true);
      toggle_class(button, "bx--tooltip--hidden", !ctx[0]);
      toggle_class(button, "bx--tooltip--visible", ctx[0]);
      toggle_class(button, "bx--tooltip--top", ctx[4] === "top");
      toggle_class(button, "bx--tooltip--bottom", ctx[4] === "bottom");
      toggle_class(button, "bx--tooltip--align-start", ctx[3] === "start");
      toggle_class(button, "bx--tooltip--align-center", ctx[3] === "center");
      toggle_class(button, "bx--tooltip--align-end", ctx[3] === "end");
      add_location(button, file165, 56, 2, 1146);
      attr_dev(div, "role", "tooltip");
      attr_dev(div, "id", ctx[5]);
      toggle_class(div, "bx--assistive-text", true);
      add_location(div, file165, 80, 2, 1861);
      set_attributes(span, span_data);
      toggle_class(span, "bx--tooltip--definition", true);
      toggle_class(span, "bx--tooltip--a11y", true);
      add_location(span, file165, 49, 0, 991);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      ctx[17](button);
      append_dev(span, t);
      append_dev(span, div);
      if (tooltip_slot_or_fallback) {
        tooltip_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "keydown", ctx[16], false, false, false),
          listen_dev(button, "click", ctx[11], false, false, false),
          listen_dev(button, "mouseover", ctx[12], false, false, false),
          listen_dev(button, "mouseenter", ctx[13], false, false, false),
          listen_dev(button, "mouseleave", ctx[14], false, false, false),
          listen_dev(button, "focus", ctx[15], false, false, false),
          listen_dev(button, "focus", ctx[7], false, false, false),
          listen_dev(button, "blur", ctx[6], false, false, false),
          listen_dev(span, "mouseenter", ctx[7], false, false, false),
          listen_dev(span, "mouseleave", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(button, "aria-describedby", ctx2[5]);
      }
      if (!current || dirty & 1) {
        toggle_class(button, "bx--tooltip--hidden", !ctx2[0]);
      }
      if (!current || dirty & 1) {
        toggle_class(button, "bx--tooltip--visible", ctx2[0]);
      }
      if (!current || dirty & 16) {
        toggle_class(button, "bx--tooltip--top", ctx2[4] === "top");
      }
      if (!current || dirty & 16) {
        toggle_class(button, "bx--tooltip--bottom", ctx2[4] === "bottom");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "bx--tooltip--align-start", ctx2[3] === "start");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "bx--tooltip--align-center", ctx2[3] === "center");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "bx--tooltip--align-end", ctx2[3] === "end");
      }
      if (tooltip_slot) {
        if (tooltip_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            tooltip_slot,
            tooltip_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(tooltip_slot_template, ctx2[9], dirty, get_tooltip_slot_changes),
            get_tooltip_slot_context
          );
        }
      } else {
        if (tooltip_slot_or_fallback && tooltip_slot_or_fallback.p && (!current || dirty & 4)) {
          tooltip_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 32) {
        attr_dev(div, "id", ctx2[5]);
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [dirty & 256 && ctx2[8]]));
      toggle_class(span, "bx--tooltip--definition", true);
      toggle_class(span, "bx--tooltip--a11y", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(tooltip_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(tooltip_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      if (tooltip_slot_or_fallback)
        tooltip_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment177.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance177($$self, $$props, $$invalidate) {
  const omit_props_names = ["tooltipText", "open", "align", "direction", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipDefinition", slots, ["default", "tooltip"]);
  let { tooltipText = "" } = $$props;
  let { open = false } = $$props;
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  const hide = () => $$invalidate(0, open = false);
  const show = () => $$invalidate(0, open = true);
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === "Escape")
      hide();
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tooltipText" in $$new_props)
      $$invalidate(2, tooltipText = $$new_props.tooltipText);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("align" in $$new_props)
      $$invalidate(3, align = $$new_props.align);
    if ("direction" in $$new_props)
      $$invalidate(4, direction = $$new_props.direction);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tooltipText,
    open,
    align,
    direction,
    id,
    ref,
    createEventDispatcher,
    dispatch,
    hide,
    show
  });
  $$self.$inject_state = ($$new_props) => {
    if ("tooltipText" in $$props)
      $$invalidate(2, tooltipText = $$new_props.tooltipText);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("align" in $$props)
      $$invalidate(3, align = $$new_props.align);
    if ("direction" in $$props)
      $$invalidate(4, direction = $$new_props.direction);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch(open ? "open" : "close");
    }
  };
  return [
    open,
    ref,
    tooltipText,
    align,
    direction,
    id,
    hide,
    show,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    keydown_handler,
    button_binding
  ];
}
var TooltipDefinition = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance177, create_fragment177, safe_not_equal, {
      tooltipText: 2,
      open: 0,
      align: 3,
      direction: 4,
      id: 5,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipDefinition",
      options,
      id: create_fragment177.name
    });
  }
  get tooltipText() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipText(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TooltipDefinition>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TooltipDefinition>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipDefinition_default = TooltipDefinition;

// node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte
var file166 = "node_modules/carbon-components-svelte/src/TooltipIcon/TooltipIcon.svelte";
var get_tooltipText_slot_changes = (dirty) => ({});
var get_tooltipText_slot_context = (ctx) => ({});
function fallback_block_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_114.name,
    type: "fallback",
    source: "(77:29) {tooltipText}",
    ctx
  });
  return block;
}
function fallback_block39(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block39.name,
    type: "fallback",
    source: "(79:8)      ",
    ctx
  });
  return block;
}
function create_fragment178(ctx) {
  let button;
  let span;
  let t;
  let button_style_value;
  let current;
  let mounted;
  let dispose;
  const tooltipText_slot_template = ctx[10].tooltipText;
  const tooltipText_slot = create_slot(tooltipText_slot_template, ctx, ctx[9], get_tooltipText_slot_context);
  const tooltipText_slot_or_fallback = tooltipText_slot || fallback_block_114(ctx);
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const default_slot_or_fallback = default_slot || fallback_block39(ctx);
  let button_levels = [
    { disabled: ctx[3] },
    { "aria-describedby": ctx[6] },
    ctx[8],
    {
      style: button_style_value = "cursor: " + (ctx[3] ? "not-allowed" : "default") + "; " + ctx[8].style
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      if (tooltipText_slot_or_fallback)
        tooltipText_slot_or_fallback.c();
      t = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr_dev(span, "id", ctx[6]);
      toggle_class(span, "bx--assistive-text", true);
      add_location(span, file166, 75, 2, 1856);
      set_attributes(button, button_data);
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(button, "bx--tooltip--hidden", ctx[7] || ctx[3]);
      toggle_class(button, "bx--tooltip--top", ctx[5] === "top");
      toggle_class(button, "bx--tooltip--right", ctx[5] === "right");
      toggle_class(button, "bx--tooltip--bottom", ctx[5] === "bottom");
      toggle_class(button, "bx--tooltip--left", ctx[5] === "left");
      toggle_class(button, "bx--tooltip--align-start", ctx[4] === "start");
      toggle_class(button, "bx--tooltip--align-center", ctx[4] === "center");
      toggle_class(button, "bx--tooltip--align-end", ctx[4] === "end");
      add_location(button, file166, 45, 0, 962);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, span);
      if (tooltipText_slot_or_fallback) {
        tooltipText_slot_or_fallback.m(span, null);
      }
      append_dev(button, t);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[17](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "keydown", ctx[16], false, false, false),
          listen_dev(button, "click", ctx[11], false, false, false),
          listen_dev(button, "mouseover", ctx[12], false, false, false),
          listen_dev(button, "mouseenter", ctx[13], false, false, false),
          listen_dev(button, "mouseenter", ctx[18], false, false, false),
          listen_dev(button, "mouseleave", ctx[14], false, false, false),
          listen_dev(button, "focus", ctx[15], false, false, false),
          listen_dev(button, "focus", ctx[19], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (tooltipText_slot) {
        if (tooltipText_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            tooltipText_slot,
            tooltipText_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(tooltipText_slot_template, ctx2[9], dirty, get_tooltipText_slot_changes),
            get_tooltipText_slot_context
          );
        }
      } else {
        if (tooltipText_slot_or_fallback && tooltipText_slot_or_fallback.p && (!current || dirty & 2)) {
          tooltipText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64) {
        attr_dev(span, "id", ctx2[6]);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & 8) && { disabled: ctx2[3] },
        (!current || dirty & 64) && { "aria-describedby": ctx2[6] },
        dirty & 256 && ctx2[8],
        (!current || dirty & 264 && button_style_value !== (button_style_value = "cursor: " + (ctx2[3] ? "not-allowed" : "default") + "; " + ctx2[8].style)) && { style: button_style_value }
      ]));
      toggle_class(button, "bx--tooltip__trigger", true);
      toggle_class(button, "bx--tooltip--a11y", true);
      toggle_class(button, "bx--tooltip--hidden", ctx2[7] || ctx2[3]);
      toggle_class(button, "bx--tooltip--top", ctx2[5] === "top");
      toggle_class(button, "bx--tooltip--right", ctx2[5] === "right");
      toggle_class(button, "bx--tooltip--bottom", ctx2[5] === "bottom");
      toggle_class(button, "bx--tooltip--left", ctx2[5] === "left");
      toggle_class(button, "bx--tooltip--align-start", ctx2[4] === "start");
      toggle_class(button, "bx--tooltip--align-center", ctx2[4] === "center");
      toggle_class(button, "bx--tooltip--align-end", ctx2[4] === "end");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tooltipText_slot_or_fallback, local);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tooltipText_slot_or_fallback, local);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (tooltipText_slot_or_fallback)
        tooltipText_slot_or_fallback.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment178.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance178($$self, $$props, $$invalidate) {
  const omit_props_names = ["tooltipText", "icon", "disabled", "align", "direction", "id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TooltipIcon", slots, ["tooltipText", "default"]);
  let { tooltipText = "" } = $$props;
  let { icon = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { align = "center" } = $$props;
  let { direction = "bottom" } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { ref = null } = $$props;
  let hidden = false;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const keydown_handler = ({ key }) => {
    if (key === "Escape") {
      $$invalidate(7, hidden = true);
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const mouseenter_handler_1 = () => {
    if (disabled)
      return;
    $$invalidate(7, hidden = false);
  };
  const focus_handler_1 = () => {
    if (disabled)
      return;
    $$invalidate(7, hidden = false);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tooltipText" in $$new_props)
      $$invalidate(1, tooltipText = $$new_props.tooltipText);
    if ("icon" in $$new_props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("align" in $$new_props)
      $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$new_props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tooltipText,
    icon,
    disabled,
    align,
    direction,
    id,
    ref,
    hidden
  });
  $$self.$inject_state = ($$new_props) => {
    if ("tooltipText" in $$props)
      $$invalidate(1, tooltipText = $$new_props.tooltipText);
    if ("icon" in $$props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("align" in $$props)
      $$invalidate(4, align = $$new_props.align);
    if ("direction" in $$props)
      $$invalidate(5, direction = $$new_props.direction);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("hidden" in $$props)
      $$invalidate(7, hidden = $$new_props.hidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    tooltipText,
    icon,
    disabled,
    align,
    direction,
    id,
    hidden,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    keydown_handler,
    button_binding,
    mouseenter_handler_1,
    focus_handler_1
  ];
}
var TooltipIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance178, create_fragment178, safe_not_equal, {
      tooltipText: 1,
      icon: 2,
      disabled: 3,
      align: 4,
      direction: 5,
      id: 6,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TooltipIcon",
      options,
      id: create_fragment178.name
    });
  }
  get tooltipText() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipText(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TooltipIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TooltipIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TooltipIcon_default = TooltipIcon;

// node_modules/carbon-components-svelte/src/icons/CaretDown.svelte
var file167 = "node_modules/carbon-components-svelte/src/icons/CaretDown.svelte";
function create_if_block102(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file167, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block102.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment179(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block102(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M24 12L16 22 8 12z");
      add_location(path, file167, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file167, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block102(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment179.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance179($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CaretDown", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var CaretDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance179, create_fragment179, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CaretDown",
      options,
      id: create_fragment179.name
    });
  }
  get size() {
    throw new Error("<CaretDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CaretDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CaretDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CaretDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CaretDown_default = CaretDown;

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte
var file168 = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNode.svelte";
function create_fragment180(ctx) {
  let li;
  let div;
  let switch_instance;
  let t0;
  let t1;
  let li_tabindex_value;
  let li_aria_current_value;
  let li_aria_selected_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return {
      props: { class: "bx--tree-node__icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      t1 = text(ctx[1]);
      toggle_class(div, "bx--tree-node__label", true);
      add_location(div, file168, 115, 2, 2978);
      attr_dev(li, "role", "treeitem");
      attr_dev(li, "id", ctx[0]);
      attr_dev(li, "tabindex", li_tabindex_value = ctx[2] ? void 0 : -1);
      attr_dev(li, "aria-current", li_aria_current_value = ctx[0] === ctx[7] || void 0);
      attr_dev(li, "aria-selected", li_aria_selected_value = ctx[2] ? void 0 : ctx[8].includes(ctx[0]));
      attr_dev(li, "aria-disabled", ctx[2]);
      toggle_class(li, "bx--tree-node", true);
      toggle_class(li, "bx--tree-leaf-node", true);
      toggle_class(li, "bx--tree-node--active", ctx[0] === ctx[7]);
      toggle_class(li, "bx--tree-node--selected", ctx[8].includes(ctx[0]));
      toggle_class(li, "bx--tree-node--disabled", ctx[2]);
      toggle_class(li, "bx--tree-node--with-icon", ctx[3]);
      add_location(li, file168, 77, 0, 1895);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append_dev(div, t0);
      append_dev(div, t1);
      ctx[14](div);
      ctx[15](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", stop_propagation(ctx[16]), false, false, true),
          listen_dev(li, "keydown", ctx[17], false, false, false),
          listen_dev(li, "focus", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t0);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty & 2)
        set_data_dev(t1, ctx2[1]);
      if (!current || dirty & 1) {
        attr_dev(li, "id", ctx2[0]);
      }
      if (!current || dirty & 4 && li_tabindex_value !== (li_tabindex_value = ctx2[2] ? void 0 : -1)) {
        attr_dev(li, "tabindex", li_tabindex_value);
      }
      if (!current || dirty & 129 && li_aria_current_value !== (li_aria_current_value = ctx2[0] === ctx2[7] || void 0)) {
        attr_dev(li, "aria-current", li_aria_current_value);
      }
      if (!current || dirty & 261 && li_aria_selected_value !== (li_aria_selected_value = ctx2[2] ? void 0 : ctx2[8].includes(ctx2[0]))) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty & 4) {
        attr_dev(li, "aria-disabled", ctx2[2]);
      }
      if (!current || dirty & 129) {
        toggle_class(li, "bx--tree-node--active", ctx2[0] === ctx2[7]);
      }
      if (!current || dirty & 257) {
        toggle_class(li, "bx--tree-node--selected", ctx2[8].includes(ctx2[0]));
      }
      if (!current || dirty & 4) {
        toggle_class(li, "bx--tree-node--disabled", ctx2[2]);
      }
      if (!current || dirty & 8) {
        toggle_class(li, "bx--tree-node--with-icon", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[14](null);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment180.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function computeTreeLeafDepth(node) {
  let depth = 0;
  if (node == null)
    return depth;
  let parentNode = node.parentNode;
  while (parentNode != null && parentNode.getAttribute("role") !== "tree") {
    parentNode = parentNode.parentNode;
    if (parentNode.tagName === "LI")
      depth++;
  }
  return depth;
}
function findParentTreeNode(node) {
  if (node.classList.contains("bx--tree-parent-node"))
    return node;
  if (node.classList.contains("bx--tree"))
    return null;
  return findParentTreeNode(node.parentNode);
}
function instance180($$self, $$props, $$invalidate) {
  let node;
  let $activeNodeId;
  let $selectedNodeIds;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewNode", slots, []);
  let { leaf = false } = $$props;
  let { id = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { disabled = false } = $$props;
  let { icon = void 0 } = $$props;
  let ref = null;
  let refLabel = null;
  let prevActiveId = void 0;
  const { activeNodeId, selectedNodeIds, clickNode, selectNode, focusNode } = getContext("TreeView");
  validate_store(activeNodeId, "activeNodeId");
  component_subscribe($$self, activeNodeId, (value) => $$invalidate(7, $activeNodeId = value));
  validate_store(selectedNodeIds, "selectedNodeIds");
  component_subscribe($$self, selectedNodeIds, (value) => $$invalidate(8, $selectedNodeIds = value));
  const offset = () => computeTreeLeafDepth(refLabel) + (leaf && icon ? 2 : 2.5);
  afterUpdate(() => {
    if (id === $activeNodeId && prevActiveId !== $activeNodeId) {
      if (!$selectedNodeIds.includes(id))
        selectNode(node);
    }
    prevActiveId = $activeNodeId;
  });
  const writable_props = ["leaf", "id", "text", "disabled", "icon"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TreeViewNode> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(4, refLabel);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  const click_handler = () => {
    if (disabled)
      return;
    clickNode(node);
  };
  const keydown_handler = (e) => {
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "Enter") {
      e.stopPropagation();
    }
    if (e.key === "ArrowLeft") {
      const parentNode = findParentTreeNode(ref.parentNode);
      if (parentNode)
        parentNode.focus();
    }
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (disabled)
        return;
      clickNode(node);
    }
  };
  const focus_handler = () => {
    focusNode(node);
  };
  $$self.$$set = ($$props2) => {
    if ("leaf" in $$props2)
      $$invalidate(13, leaf = $$props2.leaf);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("icon" in $$props2)
      $$invalidate(3, icon = $$props2.icon);
  };
  $$self.$capture_state = () => ({
    computeTreeLeafDepth,
    findParentTreeNode,
    leaf,
    id,
    text: text2,
    disabled,
    icon,
    afterUpdate,
    getContext,
    ref,
    refLabel,
    prevActiveId,
    activeNodeId,
    selectedNodeIds,
    clickNode,
    selectNode,
    focusNode,
    offset,
    node,
    $activeNodeId,
    $selectedNodeIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("leaf" in $$props2)
      $$invalidate(13, leaf = $$props2.leaf);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("icon" in $$props2)
      $$invalidate(3, icon = $$props2.icon);
    if ("ref" in $$props2)
      $$invalidate(5, ref = $$props2.ref);
    if ("refLabel" in $$props2)
      $$invalidate(4, refLabel = $$props2.refLabel);
    if ("prevActiveId" in $$props2)
      prevActiveId = $$props2.prevActiveId;
    if ("node" in $$props2)
      $$invalidate(6, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8195) {
      $:
        $$invalidate(6, node = { id, text: text2, expanded: false, leaf });
    }
    if ($$self.$$.dirty & 16) {
      $:
        if (refLabel) {
          $$invalidate(4, refLabel.style.marginLeft = `-${offset()}rem`, refLabel);
          $$invalidate(4, refLabel.style.paddingLeft = `${offset()}rem`, refLabel);
        }
    }
  };
  return [
    id,
    text2,
    disabled,
    icon,
    refLabel,
    ref,
    node,
    $activeNodeId,
    $selectedNodeIds,
    activeNodeId,
    selectedNodeIds,
    clickNode,
    focusNode,
    leaf,
    div_binding,
    li_binding,
    click_handler,
    keydown_handler,
    focus_handler
  ];
}
var TreeViewNode = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance180, create_fragment180, safe_not_equal, {
      leaf: 13,
      id: 0,
      text: 1,
      disabled: 2,
      icon: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewNode",
      options,
      id: create_fragment180.name
    });
  }
  get leaf() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leaf(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TreeViewNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TreeViewNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeViewNode_default = TreeViewNode;

// node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte
var file169 = "node_modules/carbon-components-svelte/src/TreeView/TreeViewNodeList.svelte";
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function get_each_context21(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function create_else_block_15(ctx) {
  let li;
  let div;
  let span0;
  let caretdown;
  let t0;
  let span1;
  let switch_instance;
  let t1;
  let t2;
  let t3;
  let li_tabindex_value;
  let li_aria_current_value;
  let li_aria_selected_value;
  let current;
  let mounted;
  let dispose;
  caretdown = new CaretDown_default({
    props: {
      class: "bx--tree-parent-node__toggle-icon " + (ctx[0] && "bx--tree-parent-node__toggle-icon--expanded")
    },
    $$inline: true
  });
  var switch_value = ctx[6];
  function switch_props(ctx2) {
    return {
      props: { class: "bx--tree-node__icon" },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let if_block = ctx[0] && create_if_block_227(ctx);
  const block = {
    c: function create() {
      li = element("li");
      div = element("div");
      span0 = element("span");
      create_component(caretdown.$$.fragment);
      t0 = space();
      span1 = element("span");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      t2 = text(ctx[4]);
      t3 = space();
      if (if_block)
        if_block.c();
      attr_dev(span0, "disabled", ctx[5]);
      toggle_class(span0, "bx--tree-parent-node__toggle", true);
      add_location(span0, file169, 135, 6, 3538);
      toggle_class(span1, "bx--tree-node__label__details", true);
      add_location(span1, file169, 150, 6, 3977);
      toggle_class(div, "bx--tree-node__label", true);
      add_location(div, file169, 133, 4, 3404);
      attr_dev(li, "role", "treeitem");
      attr_dev(li, "id", ctx[3]);
      attr_dev(li, "tabindex", li_tabindex_value = ctx[5] ? void 0 : -1);
      attr_dev(li, "aria-current", li_aria_current_value = ctx[3] === ctx[11] || void 0);
      attr_dev(li, "aria-selected", li_aria_selected_value = ctx[5] ? void 0 : ctx[12].includes(ctx[3]));
      attr_dev(li, "aria-disabled", ctx[5]);
      attr_dev(li, "aria-expanded", ctx[0]);
      toggle_class(li, "bx--tree-node", true);
      toggle_class(li, "bx--tree-parent-node", true);
      toggle_class(li, "bx--tree-node--active", ctx[3] === ctx[11]);
      toggle_class(li, "bx--tree-node--selected", ctx[12].includes(ctx[3]));
      toggle_class(li, "bx--tree-node--disabled", ctx[5]);
      toggle_class(li, "bx--tree-node--with-icon", ctx[6]);
      add_location(li, file169, 75, 2, 1836);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, div);
      append_dev(div, span0);
      mount_component(caretdown, span0, null);
      append_dev(div, t0);
      append_dev(div, span1);
      if (switch_instance)
        mount_component(switch_instance, span1, null);
      append_dev(span1, t1);
      append_dev(span1, t2);
      ctx[22](div);
      append_dev(li, t3);
      if (if_block)
        if_block.m(li, null);
      ctx[23](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(span0, "click", ctx[21], false, false, false),
          listen_dev(li, "click", stop_propagation(ctx[24]), false, false, true),
          listen_dev(li, "keydown", ctx[25], false, false, false),
          listen_dev(li, "focus", ctx[26], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const caretdown_changes = {};
      if (dirty[0] & 1)
        caretdown_changes.class = "bx--tree-parent-node__toggle-icon " + (ctx2[0] && "bx--tree-parent-node__toggle-icon--expanded");
      caretdown.$set(caretdown_changes);
      if (!current || dirty[0] & 32) {
        attr_dev(span0, "disabled", ctx2[5]);
      }
      if (switch_value !== (switch_value = ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, span1, t1);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & 16)
        set_data_dev(t2, ctx2[4]);
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_227(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 8) {
        attr_dev(li, "id", ctx2[3]);
      }
      if (!current || dirty[0] & 32 && li_tabindex_value !== (li_tabindex_value = ctx2[5] ? void 0 : -1)) {
        attr_dev(li, "tabindex", li_tabindex_value);
      }
      if (!current || dirty[0] & 2056 && li_aria_current_value !== (li_aria_current_value = ctx2[3] === ctx2[11] || void 0)) {
        attr_dev(li, "aria-current", li_aria_current_value);
      }
      if (!current || dirty[0] & 4136 && li_aria_selected_value !== (li_aria_selected_value = ctx2[5] ? void 0 : ctx2[12].includes(ctx2[3]))) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(li, "aria-disabled", ctx2[5]);
      }
      if (!current || dirty[0] & 1) {
        attr_dev(li, "aria-expanded", ctx2[0]);
      }
      if (!current || dirty[0] & 2056) {
        toggle_class(li, "bx--tree-node--active", ctx2[3] === ctx2[11]);
      }
      if (!current || dirty[0] & 4104) {
        toggle_class(li, "bx--tree-node--selected", ctx2[12].includes(ctx2[3]));
      }
      if (!current || dirty[0] & 32) {
        toggle_class(li, "bx--tree-node--disabled", ctx2[5]);
      }
      if (!current || dirty[0] & 64) {
        toggle_class(li, "bx--tree-node--with-icon", ctx2[6]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(caretdown.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(caretdown.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(caretdown);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[22](null);
      if (if_block)
        if_block.d();
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(75:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block103(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[30].id;
  validate_each_keys(ctx, each_value, get_each_context21, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context21(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block21(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context21, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block21, each_1_anchor, get_each_context21);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block103.name,
    type: "if",
    source: "(67:0) {#if root}",
    ctx
  });
  return block;
}
function create_if_block_227(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ctx[1];
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => ctx2[30].id;
  validate_each_keys(ctx, each_value_1, get_each_context_14, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_14(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_14(key, child_ctx));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(ul, "role", "group");
      toggle_class(ul, "bx--tree-node__children", true);
      add_location(ul, file169, 156, 6, 4165);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2) {
        each_value_1 = ctx2[1];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx2, each_value_1, get_each_context_14, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_14, null, get_each_context_14);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_227.name,
    type: "if",
    source: "(156:4) {#if expanded}",
    ctx
  });
  return block;
}
function create_else_block_22(ctx) {
  let treeviewnode;
  let current;
  const treeviewnode_spread_levels = [{ leaf: true }, ctx[30]];
  let treeviewnode_props = {};
  for (let i = 0; i < treeviewnode_spread_levels.length; i += 1) {
    treeviewnode_props = assign(treeviewnode_props, treeviewnode_spread_levels[i]);
  }
  treeviewnode = new TreeViewNode_default({
    props: treeviewnode_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnode_changes = dirty[0] & 2 ? get_spread_update(treeviewnode_spread_levels, [treeviewnode_spread_levels[0], get_spread_object(ctx2[30])]) : {};
      treeviewnode.$set(treeviewnode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treeviewnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_22.name,
    type: "else",
    source: "(161:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_320(ctx) {
  let treeviewnodelist;
  let current;
  const treeviewnodelist_spread_levels = [ctx[30]];
  let treeviewnodelist_props = {};
  for (let i = 0; i < treeviewnodelist_spread_levels.length; i += 1) {
    treeviewnodelist_props = assign(treeviewnodelist_props, treeviewnodelist_spread_levels[i]);
  }
  treeviewnodelist = new TreeViewNodeList({
    props: treeviewnodelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnodelist.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnodelist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnodelist_changes = dirty[0] & 2 ? get_spread_update(treeviewnodelist_spread_levels, [get_spread_object(ctx2[30])]) : {};
      treeviewnodelist.$set(treeviewnodelist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnodelist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_320.name,
    type: "if",
    source: "(159:10) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function create_each_block_14(key_1, ctx) {
  let first;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_320, create_else_block_22];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[30].children);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_14.name,
    type: "each",
    source: "(158:8) {#each children as child (child.id)}",
    ctx
  });
  return block;
}
function create_else_block31(ctx) {
  let treeviewnode;
  let current;
  const treeviewnode_spread_levels = [{ leaf: true }, ctx[30]];
  let treeviewnode_props = {};
  for (let i = 0; i < treeviewnode_spread_levels.length; i += 1) {
    treeviewnode_props = assign(treeviewnode_props, treeviewnode_spread_levels[i]);
  }
  treeviewnode = new TreeViewNode_default({
    props: treeviewnode_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnode.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnode, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnode_changes = dirty[0] & 2 ? get_spread_update(treeviewnode_spread_levels, [treeviewnode_spread_levels[0], get_spread_object(ctx2[30])]) : {};
      treeviewnode.$set(treeviewnode_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treeviewnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block31.name,
    type: "else",
    source: "(71:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_141(ctx) {
  let treeviewnodelist;
  let current;
  const treeviewnodelist_spread_levels = [ctx[30]];
  let treeviewnodelist_props = {};
  for (let i = 0; i < treeviewnodelist_spread_levels.length; i += 1) {
    treeviewnodelist_props = assign(treeviewnodelist_props, treeviewnodelist_spread_levels[i]);
  }
  treeviewnodelist = new TreeViewNodeList({
    props: treeviewnodelist_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(treeviewnodelist.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewnodelist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const treeviewnodelist_changes = dirty[0] & 2 ? get_spread_update(treeviewnodelist_spread_levels, [get_spread_object(ctx2[30])]) : {};
      treeviewnodelist.$set(treeviewnodelist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(treeviewnodelist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_141.name,
    type: "if",
    source: "(69:4) {#if Array.isArray(child.children)}",
    ctx
  });
  return block;
}
function create_each_block21(key_1, ctx) {
  let first;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_141, create_else_block31];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[30].children);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block21.name,
    type: "each",
    source: "(68:2) {#each children as child (child.id)}",
    ctx
  });
  return block;
}
function create_fragment181(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block103, create_else_block_15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment181.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance181($$self, $$props, $$invalidate) {
  let parent;
  let node;
  let $expandedNodeIds;
  let $activeNodeId;
  let $selectedNodeIds;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewNodeList", slots, []);
  let { children = [] } = $$props;
  let { expanded = false } = $$props;
  let { root = false } = $$props;
  let { id = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { disabled = false } = $$props;
  let { icon = void 0 } = $$props;
  let ref = null;
  let refLabel = null;
  let prevActiveId = void 0;
  const { activeNodeId, selectedNodeIds, expandedNodeIds, clickNode, selectNode, expandNode, focusNode, toggleNode } = getContext("TreeView");
  validate_store(activeNodeId, "activeNodeId");
  component_subscribe($$self, activeNodeId, (value) => $$invalidate(11, $activeNodeId = value));
  validate_store(selectedNodeIds, "selectedNodeIds");
  component_subscribe($$self, selectedNodeIds, (value) => $$invalidate(12, $selectedNodeIds = value));
  validate_store(expandedNodeIds, "expandedNodeIds");
  component_subscribe($$self, expandedNodeIds, (value) => $$invalidate(20, $expandedNodeIds = value));
  const offset = () => {
    const depth = computeTreeLeafDepth(refLabel);
    if (parent)
      return depth + 1;
    if (icon)
      return depth + 2;
    return depth + 2.5;
  };
  afterUpdate(() => {
    if (id === $activeNodeId && prevActiveId !== $activeNodeId) {
      if (!$selectedNodeIds.includes(id))
        selectNode(node);
    }
    prevActiveId = $activeNodeId;
  });
  const writable_props = ["children", "expanded", "root", "id", "text", "disabled", "icon"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TreeViewNodeList> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    if (disabled)
      return;
    $$invalidate(0, expanded = !expanded);
    expandNode(node, expanded);
    toggleNode(node);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refLabel = $$value;
      $$invalidate(7, refLabel);
    });
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(9, ref);
    });
  }
  const click_handler_13 = () => {
    if (disabled)
      return;
    clickNode(node);
  };
  const keydown_handler = (e) => {
    var _a;
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "Enter") {
      e.stopPropagation();
    }
    if (parent && e.key === "ArrowLeft") {
      $$invalidate(0, expanded = false);
      expandNode(node, false);
      toggleNode(node);
    }
    if (parent && e.key === "ArrowRight") {
      if (expanded) {
        (_a = ref.lastChild.firstElementChild) == null ? void 0 : _a.focus();
      } else {
        $$invalidate(0, expanded = true);
        expandNode(node, true);
        toggleNode(node);
      }
    }
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (disabled)
        return;
      $$invalidate(0, expanded = !expanded);
      toggleNode(node);
      clickNode(node);
      expandNode(node, expanded);
      ref.focus();
    }
  };
  const focus_handler = () => {
    focusNode(node);
  };
  $$self.$$set = ($$props2) => {
    if ("children" in $$props2)
      $$invalidate(1, children = $$props2.children);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("root" in $$props2)
      $$invalidate(2, root = $$props2.root);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
    if ("text" in $$props2)
      $$invalidate(4, text2 = $$props2.text);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("icon" in $$props2)
      $$invalidate(6, icon = $$props2.icon);
  };
  $$self.$capture_state = () => ({
    children,
    expanded,
    root,
    id,
    text: text2,
    disabled,
    icon,
    afterUpdate,
    getContext,
    CaretDown: CaretDown_default,
    TreeViewNode: TreeViewNode_default,
    computeTreeLeafDepth,
    ref,
    refLabel,
    prevActiveId,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode,
    selectNode,
    expandNode,
    focusNode,
    toggleNode,
    offset,
    parent,
    node,
    $expandedNodeIds,
    $activeNodeId,
    $selectedNodeIds
  });
  $$self.$inject_state = ($$props2) => {
    if ("children" in $$props2)
      $$invalidate(1, children = $$props2.children);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("root" in $$props2)
      $$invalidate(2, root = $$props2.root);
    if ("id" in $$props2)
      $$invalidate(3, id = $$props2.id);
    if ("text" in $$props2)
      $$invalidate(4, text2 = $$props2.text);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("icon" in $$props2)
      $$invalidate(6, icon = $$props2.icon);
    if ("ref" in $$props2)
      $$invalidate(9, ref = $$props2.ref);
    if ("refLabel" in $$props2)
      $$invalidate(7, refLabel = $$props2.refLabel);
    if ("prevActiveId" in $$props2)
      prevActiveId = $$props2.prevActiveId;
    if ("parent" in $$props2)
      $$invalidate(8, parent = $$props2.parent);
    if ("node" in $$props2)
      $$invalidate(10, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$invalidate(8, parent = Array.isArray(children));
    }
    if ($$self.$$.dirty[0] & 1048584) {
      $:
        $$invalidate(0, expanded = $expandedNodeIds.includes(id));
    }
    if ($$self.$$.dirty[0] & 281) {
      $:
        $$invalidate(10, node = { id, text: text2, expanded, leaf: !parent });
    }
    if ($$self.$$.dirty[0] & 128) {
      $:
        if (refLabel) {
          $$invalidate(7, refLabel.style.marginLeft = `-${offset()}rem`, refLabel);
          $$invalidate(7, refLabel.style.paddingLeft = `${offset()}rem`, refLabel);
        }
    }
  };
  return [
    expanded,
    children,
    root,
    id,
    text2,
    disabled,
    icon,
    refLabel,
    parent,
    ref,
    node,
    $activeNodeId,
    $selectedNodeIds,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode,
    expandNode,
    focusNode,
    toggleNode,
    $expandedNodeIds,
    click_handler,
    div_binding,
    li_binding,
    click_handler_13,
    keydown_handler,
    focus_handler
  ];
}
var TreeViewNodeList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance181,
      create_fragment181,
      safe_not_equal,
      {
        children: 1,
        expanded: 0,
        root: 2,
        id: 3,
        text: 4,
        disabled: 5,
        icon: 6
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewNodeList",
      options,
      id: create_fragment181.name
    });
  }
  get children() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<TreeViewNodeList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<TreeViewNodeList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeViewNodeList_default = TreeViewNodeList;

// node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte
var file170 = "node_modules/carbon-components-svelte/src/TreeView/TreeView.svelte";
var get_labelText_slot_changes18 = (dirty) => ({});
var get_labelText_slot_context18 = (ctx) => ({});
function create_if_block104(ctx) {
  let label;
  let current;
  const labelText_slot_template = ctx[17].labelText;
  const labelText_slot = create_slot(labelText_slot_template, ctx, ctx[16], get_labelText_slot_context18);
  const labelText_slot_or_fallback = labelText_slot || fallback_block40(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      attr_dev(label, "id", ctx[6]);
      toggle_class(label, "bx--label", true);
      add_location(label, file170, 185, 2, 4931);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(labelText_slot_template, ctx2[16], dirty, get_labelText_slot_changes18),
            get_labelText_slot_context18
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & 8)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block104.name,
    type: "if",
    source: "(184:0) {#if !hideLabel}",
    ctx
  });
  return block;
}
function fallback_block40(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block40.name,
    type: "fallback",
    source: "(187:27) {labelText}",
    ctx
  });
  return block;
}
function create_fragment182(ctx) {
  let t;
  let ul;
  let treeviewnodelist;
  let ul_aria_label_value;
  let ul_aria_labelledby_value;
  let ul_aria_multiselectable_value;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[4] && create_if_block104(ctx);
  treeviewnodelist = new TreeViewNodeList_default({
    props: {
      root: true,
      children: ctx[1]
    },
    $$inline: true
  });
  let ul_levels = [
    ctx[8],
    { role: "tree" },
    {
      "aria-label": ul_aria_label_value = ctx[4] ? ctx[3] : void 0
    },
    {
      "aria-labelledby": ul_aria_labelledby_value = !ctx[4] ? ctx[6] : void 0
    },
    {
      "aria-multiselectable": ul_aria_multiselectable_value = ctx[0].length > 1 || void 0
    }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      ul = element("ul");
      create_component(treeviewnodelist.$$.fragment);
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--tree", true);
      toggle_class(ul, "bx--tree--default", ctx[2] === "default");
      toggle_class(ul, "bx--tree--compact", ctx[2] === "compact");
      add_location(ul, file170, 190, 0, 5043);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, ul, anchor);
      mount_component(treeviewnodelist, ul, null);
      ctx[19](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(ul, "keydown", ctx[18], false, false, false),
          listen_dev(ul, "keydown", stop_propagation(ctx[7]), false, false, true)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block104(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const treeviewnodelist_changes = {};
      if (dirty & 2)
        treeviewnodelist_changes.children = ctx2[1];
      treeviewnodelist.$set(treeviewnodelist_changes);
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & 256 && ctx2[8],
        { role: "tree" },
        (!current || dirty & 24 && ul_aria_label_value !== (ul_aria_label_value = ctx2[4] ? ctx2[3] : void 0)) && { "aria-label": ul_aria_label_value },
        (!current || dirty & 16 && ul_aria_labelledby_value !== (ul_aria_labelledby_value = !ctx2[4] ? ctx2[6] : void 0)) && {
          "aria-labelledby": ul_aria_labelledby_value
        },
        (!current || dirty & 1 && ul_aria_multiselectable_value !== (ul_aria_multiselectable_value = ctx2[0].length > 1 || void 0)) && {
          "aria-multiselectable": ul_aria_multiselectable_value
        }
      ]));
      toggle_class(ul, "bx--tree", true);
      toggle_class(ul, "bx--tree--default", ctx2[2] === "default");
      toggle_class(ul, "bx--tree--compact", ctx2[2] === "compact");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(treeviewnodelist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(treeviewnodelist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(ul);
      destroy_component(treeviewnodelist);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment182.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance182($$self, $$props, $$invalidate) {
  let nodes;
  let nodeIds;
  const omit_props_names = [
    "children",
    "activeId",
    "selectedIds",
    "expandedIds",
    "size",
    "labelText",
    "hideLabel",
    "expandAll",
    "collapseAll",
    "expandNodes",
    "collapseNodes"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeView", slots, ["labelText"]);
  let { children = [] } = $$props;
  let { activeId = "" } = $$props;
  let { selectedIds = [] } = $$props;
  let { expandedIds = [] } = $$props;
  let { size = "default" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  function expandAll() {
    $$invalidate(10, expandedIds = [...nodeIds]);
  }
  function collapseAll() {
    $$invalidate(10, expandedIds = []);
  }
  function expandNodes(filterNode = (node) => false) {
    $$invalidate(10, expandedIds = nodes.filter((node) => {
      var _a;
      return filterNode(node) || ((_a = node.children) == null ? void 0 : _a.some((child) => filterNode(child) && child.children));
    }).map((node) => node.id));
  }
  function collapseNodes(filterNode = (node) => true) {
    $$invalidate(10, expandedIds = nodes.filter((node) => expandedIds.includes(node.id) && !filterNode(node)).map((node) => node.id));
  }
  const dispatch = createEventDispatcher();
  const labelId = `label-${Math.random().toString(36)}`;
  const activeNodeId = writable(activeId);
  const selectedNodeIds = writable(selectedIds);
  const expandedNodeIds = writable(expandedIds);
  let ref = null;
  let treeWalker = null;
  setContext("TreeView", {
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    clickNode: (node) => {
      $$invalidate(9, activeId = node.id);
      $$invalidate(0, selectedIds = [node.id]);
      dispatch("select", node);
    },
    selectNode: (node) => {
      $$invalidate(0, selectedIds = [node.id]);
    },
    expandNode: (node, expanded) => {
      if (expanded) {
        $$invalidate(10, expandedIds = [...expandedIds, node.id]);
      } else {
        $$invalidate(10, expandedIds = expandedIds.filter((_id) => _id !== node.id));
      }
    },
    focusNode: (node) => dispatch("focus", node),
    toggleNode: (node) => dispatch("toggle", node)
  });
  function handleKeyDown(e) {
    if (e.key === "ArrowUp" || e.key === "ArrowDown")
      e.preventDefault();
    treeWalker.currentNode = e.target;
    let node = null;
    if (e.key === "ArrowUp")
      node = treeWalker.previousNode();
    if (e.key === "ArrowDown")
      node = treeWalker.nextNode();
    if (node && node !== e.target) {
      node.tabIndex = "0";
      node.focus();
    }
  }
  onMount(() => {
    const firstFocusableNode = ref.querySelector("li.bx--tree-node:not(.bx--tree-node--disabled)");
    if (firstFocusableNode != null) {
      firstFocusableNode.tabIndex = "0";
    }
  });
  function traverse(children2) {
    let nodes2 = [];
    children2.forEach((node) => {
      nodes2.push(node);
      if (Array.isArray(node.children)) {
        nodes2 = [...nodes2, ...traverse(node.children)];
      }
    });
    return nodes2;
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("activeId" in $$new_props)
      $$invalidate(9, activeId = $$new_props.activeId);
    if ("selectedIds" in $$new_props)
      $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("expandedIds" in $$new_props)
      $$invalidate(10, expandedIds = $$new_props.expandedIds);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$new_props)
      $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    children,
    activeId,
    selectedIds,
    expandedIds,
    size,
    labelText,
    hideLabel,
    expandAll,
    collapseAll,
    expandNodes,
    collapseNodes,
    createEventDispatcher,
    setContext,
    onMount,
    writable,
    TreeViewNodeList: TreeViewNodeList_default,
    dispatch,
    labelId,
    activeNodeId,
    selectedNodeIds,
    expandedNodeIds,
    ref,
    treeWalker,
    handleKeyDown,
    traverse,
    nodes,
    nodeIds
  });
  $$self.$inject_state = ($$new_props) => {
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("activeId" in $$props)
      $$invalidate(9, activeId = $$new_props.activeId);
    if ("selectedIds" in $$props)
      $$invalidate(0, selectedIds = $$new_props.selectedIds);
    if ("expandedIds" in $$props)
      $$invalidate(10, expandedIds = $$new_props.expandedIds);
    if ("size" in $$props)
      $$invalidate(2, size = $$new_props.size);
    if ("labelText" in $$props)
      $$invalidate(3, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(4, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$props)
      $$invalidate(5, ref = $$new_props.ref);
    if ("treeWalker" in $$props)
      treeWalker = $$new_props.treeWalker;
    if ("nodes" in $$props)
      $$invalidate(15, nodes = $$new_props.nodes);
    if ("nodeIds" in $$props)
      nodeIds = $$new_props.nodeIds;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(15, nodes = traverse(children));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        nodeIds = nodes.map((node) => node.id);
    }
    if ($$self.$$.dirty & 512) {
      $:
        activeNodeId.set(activeId);
    }
    if ($$self.$$.dirty & 1) {
      $:
        selectedNodeIds.set(selectedIds);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        expandedNodeIds.set(expandedIds);
    }
    if ($$self.$$.dirty & 32) {
      $:
        if (ref) {
          treeWalker = document.createTreeWalker(ref, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => {
              if (node.classList.contains("bx--tree-node--disabled"))
                return NodeFilter.FILTER_REJECT;
              if (node.matches("li.bx--tree-node"))
                return NodeFilter.FILTER_ACCEPT;
              return NodeFilter.FILTER_SKIP;
            }
          });
        }
    }
  };
  return [
    selectedIds,
    children,
    size,
    labelText,
    hideLabel,
    ref,
    labelId,
    handleKeyDown,
    $$restProps,
    activeId,
    expandedIds,
    expandAll,
    collapseAll,
    expandNodes,
    collapseNodes,
    nodes,
    $$scope,
    slots,
    keydown_handler,
    ul_binding
  ];
}
var TreeView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance182, create_fragment182, safe_not_equal, {
      children: 1,
      activeId: 9,
      selectedIds: 0,
      expandedIds: 10,
      size: 2,
      labelText: 3,
      hideLabel: 4,
      expandAll: 11,
      collapseAll: 12,
      expandNodes: 13,
      collapseNodes: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeView",
      options,
      id: create_fragment182.name
    });
  }
  get children() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeId() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeId(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIds() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIds(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedIds() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedIds(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandAll() {
    return this.$$.ctx[11];
  }
  set expandAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseAll() {
    return this.$$.ctx[12];
  }
  set collapseAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandNodes() {
    return this.$$.ctx[13];
  }
  set expandNodes(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseNodes() {
    return this.$$.ctx[14];
  }
  set collapseNodes(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeView_default = TreeView;

// node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte
var file171 = "node_modules/carbon-components-svelte/src/Truncate/Truncate.svelte";
function create_fragment183(ctx) {
  let p;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let p_levels = [ctx[1]];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      set_attributes(p, p_data);
      toggle_class(p, "bx--text-truncate--end", ctx[0] === "end");
      toggle_class(p, "bx--text-truncate--front", ctx[0] === "front");
      add_location(p, file171, 5, 0, 80);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [dirty & 2 && ctx2[1]]));
      toggle_class(p, "bx--text-truncate--end", ctx2[0] === "end");
      toggle_class(p, "bx--text-truncate--front", ctx2[0] === "front");
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment183.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance183($$self, $$props, $$invalidate) {
  const omit_props_names = ["clamp"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Truncate", slots, ["default"]);
  let { clamp = "end" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("clamp" in $$new_props)
      $$invalidate(0, clamp = $$new_props.clamp);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ clamp });
  $$self.$inject_state = ($$new_props) => {
    if ("clamp" in $$props)
      $$invalidate(0, clamp = $$new_props.clamp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [clamp, $$restProps, $$scope, slots];
}
var Truncate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance183, create_fragment183, safe_not_equal, { clamp: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Truncate",
      options,
      id: create_fragment183.name
    });
  }
  get clamp() {
    throw new Error("<Truncate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clamp(value) {
    throw new Error("<Truncate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Truncate_default = Truncate;

// node_modules/carbon-components-svelte/src/Truncate/truncate.js
function truncate(node, options = {}) {
  const prefix = "bx--text-truncate--";
  function toggleClass2(front = false) {
    const classes = [...node.classList].filter((name) => !name.startsWith(prefix)).join(" ");
    node.className = `${classes} ${prefix}${front ? "front" : "end"}`;
  }
  toggleClass2(options.clamp === "front");
  return {
    update(options2) {
      toggleClass2(options2.clamp === "front");
    }
  };
}
var truncate_default = truncate;

// node_modules/carbon-components-svelte/src/icons/Menu.svelte
var file172 = "node_modules/carbon-components-svelte/src/icons/Menu.svelte";
function create_if_block105(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file172, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block105.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment184(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block105(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M4 6H28V8H4zM4 24H28V26H4zM4 12H28V14H4zM4 18H28V20H4z");
      add_location(path, file172, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file172, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block105(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment184.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance184($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance184, create_fragment184, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment184.name
    });
  }
  get size() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/carbon-components-svelte/src/UIShell/navStore.js
var shouldRenderHamburgerMenu = writable(false);
var isSideNavCollapsed = writable(false);
var isSideNavRail = writable(false);

// node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte
var file173 = "node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte";
function create_fragment185(ctx) {
  let button;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[0] ? ctx[4] : ctx[3];
  function switch_props(ctx2) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [
    { type: "button" },
    { title: ctx[2] },
    { "aria-label": ctx[2] },
    ctx[5]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
      add_location(button, file173, 31, 0, 758);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (switch_instance)
        mount_component(switch_instance, button, null);
      if (button.autofocus)
        button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[6], false, false, false),
          listen_dev(button, "click", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[0] ? ctx2[4] : ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & 4) && { title: ctx2[2] },
        (!current || dirty & 4) && { "aria-label": ctx2[2] },
        dirty & 32 && ctx2[5]
      ]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment185.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance185($$self, $$props, $$invalidate) {
  const omit_props_names = ["ariaLabel", "isOpen", "iconMenu", "iconClose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HamburgerMenu", slots, []);
  let { ariaLabel = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => $$invalidate(0, isOpen = !isOpen);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ariaLabel" in $$new_props)
      $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$new_props)
      $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props)
      $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ariaLabel,
    isOpen,
    iconMenu,
    iconClose,
    ref,
    Close: Close_default,
    Menu: Menu_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ariaLabel" in $$props)
      $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$props)
      $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props)
      $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    ref,
    ariaLabel,
    iconMenu,
    iconClose,
    $$restProps,
    click_handler,
    button_binding,
    click_handler_13
  ];
}
var HamburgerMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance185, create_fragment185, safe_not_equal, {
      ariaLabel: 2,
      isOpen: 0,
      iconMenu: 3,
      iconClose: 4,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HamburgerMenu",
      options,
      id: create_fragment185.name
    });
  }
  get ariaLabel() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HamburgerMenu_default = HamburgerMenu;

// node_modules/carbon-components-svelte/src/UIShell/Header.svelte
var file174 = "node_modules/carbon-components-svelte/src/UIShell/Header.svelte";
var get_platform_slot_changes = (dirty) => ({});
var get_platform_slot_context = (ctx) => ({});
var get_skip_to_content_slot_changes = (dirty) => ({});
var get_skip_to_content_slot_context = (ctx) => ({});
function create_if_block_143(ctx) {
  let hamburgermenu;
  let updating_isOpen;
  let current;
  function hamburgermenu_isOpen_binding(value) {
    ctx[19](value);
  }
  let hamburgermenu_props = {
    iconClose: ctx[8],
    iconMenu: ctx[7]
  };
  if (ctx[0] !== void 0) {
    hamburgermenu_props.isOpen = ctx[0];
  }
  hamburgermenu = new HamburgerMenu_default({
    props: hamburgermenu_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hamburgermenu, "isOpen", hamburgermenu_isOpen_binding));
  const block = {
    c: function create() {
      create_component(hamburgermenu.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(hamburgermenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hamburgermenu_changes = {};
      if (dirty & 256)
        hamburgermenu_changes.iconClose = ctx2[8];
      if (dirty & 128)
        hamburgermenu_changes.iconMenu = ctx2[7];
      if (!updating_isOpen && dirty & 1) {
        updating_isOpen = true;
        hamburgermenu_changes.isOpen = ctx2[0];
        add_flush_callback(() => updating_isOpen = false);
      }
      hamburgermenu.$set(hamburgermenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hamburgermenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburgermenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hamburgermenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_143.name,
    type: "if",
    source: "(83:2) {#if ($shouldRenderHamburgerMenu && winWidth < expansionBreakpoint) || persistentHamburgerMenu}",
    ctx
  });
  return block;
}
function create_if_block106(ctx) {
  let span;
  let t0;
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(ctx[3]);
      t1 = text("\xA0");
      toggle_class(span, "bx--header__name--prefix", true);
      add_location(span, file174, 97, 6, 2527);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t0);
      append_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t0, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block106.name,
    type: "if",
    source: "(97:4) {#if company}",
    ctx
  });
  return block;
}
function fallback_block41(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block41.name,
    type: "fallback",
    source: "(100:26) {platformName}",
    ctx
  });
  return block;
}
function create_fragment186(ctx) {
  let header;
  let t0;
  let t1;
  let a;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  add_render_callback(ctx[18]);
  const skip_to_content_slot_template = ctx[16]["skip-to-content"];
  const skip_to_content_slot = create_slot(skip_to_content_slot_template, ctx, ctx[15], get_skip_to_content_slot_context);
  let if_block0 = (ctx[11] && ctx[9] < ctx[6] || ctx[5]) && create_if_block_143(ctx);
  let if_block1 = ctx[3] && create_if_block106(ctx);
  const platform_slot_template = ctx[16].platform;
  const platform_slot = create_slot(platform_slot_template, ctx, ctx[15], get_platform_slot_context);
  const platform_slot_or_fallback = platform_slot || fallback_block41(ctx);
  let a_levels = [{ href: ctx[2] }, ctx[12]];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const block = {
    c: function create() {
      header = element("header");
      if (skip_to_content_slot)
        skip_to_content_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      a = element("a");
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (platform_slot_or_fallback)
        platform_slot_or_fallback.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__name", true);
      add_location(a, file174, 89, 2, 2386);
      attr_dev(header, "aria-label", ctx[10]);
      toggle_class(header, "bx--header", true);
      add_location(header, file174, 80, 0, 2064);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, header, anchor);
      if (skip_to_content_slot) {
        skip_to_content_slot.m(header, null);
      }
      append_dev(header, t0);
      if (if_block0)
        if_block0.m(header, null);
      append_dev(header, t1);
      append_dev(header, a);
      if (if_block1)
        if_block1.m(a, null);
      append_dev(a, t2);
      if (platform_slot_or_fallback) {
        platform_slot_or_fallback.m(a, null);
      }
      ctx[20](a);
      append_dev(header, t3);
      if (default_slot) {
        default_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "resize", ctx[18]),
          listen_dev(a, "click", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (skip_to_content_slot) {
        if (skip_to_content_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            skip_to_content_slot,
            skip_to_content_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(skip_to_content_slot_template, ctx2[15], dirty, get_skip_to_content_slot_changes),
            get_skip_to_content_slot_context
          );
        }
      }
      if (ctx2[11] && ctx2[9] < ctx2[6] || ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2656) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_143(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block106(ctx2);
          if_block1.c();
          if_block1.m(a, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (platform_slot) {
        if (platform_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            platform_slot,
            platform_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(platform_slot_template, ctx2[15], dirty, get_platform_slot_changes),
            get_platform_slot_context
          );
        }
      } else {
        if (platform_slot_or_fallback && platform_slot_or_fallback.p && (!current || dirty & 16)) {
          platform_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 4) && { href: ctx2[2] },
        dirty & 4096 && ctx2[12]
      ]));
      toggle_class(a, "bx--header__name", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1024) {
        attr_dev(header, "aria-label", ctx2[10]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(skip_to_content_slot, local);
      transition_in(if_block0);
      transition_in(platform_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skip_to_content_slot, local);
      transition_out(if_block0);
      transition_out(platform_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (skip_to_content_slot)
        skip_to_content_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (platform_slot_or_fallback)
        platform_slot_or_fallback.d(detaching);
      ctx[20](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment186.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance186($$self, $$props, $$invalidate) {
  let ariaLabel;
  const omit_props_names = [
    "expandedByDefault",
    "isSideNavOpen",
    "uiShellAriaLabel",
    "href",
    "company",
    "platformName",
    "persistentHamburgerMenu",
    "expansionBreakpoint",
    "ref",
    "iconMenu",
    "iconClose"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $shouldRenderHamburgerMenu;
  validate_store(shouldRenderHamburgerMenu, "shouldRenderHamburgerMenu");
  component_subscribe($$self, shouldRenderHamburgerMenu, ($$value) => $$invalidate(11, $shouldRenderHamburgerMenu = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["skip-to-content", "platform", "default"]);
  let { expandedByDefault = true } = $$props;
  let { isSideNavOpen = false } = $$props;
  let { uiShellAriaLabel = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { company = void 0 } = $$props;
  let { platformName = "" } = $$props;
  let { persistentHamburgerMenu = false } = $$props;
  let { expansionBreakpoint = 1056 } = $$props;
  let { ref = null } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let winWidth = void 0;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function onwindowresize() {
    $$invalidate(9, winWidth = window.innerWidth);
  }
  function hamburgermenu_isOpen_binding(value) {
    isSideNavOpen = value;
    $$invalidate(0, isSideNavOpen), $$invalidate(13, expandedByDefault), $$invalidate(9, winWidth), $$invalidate(6, expansionBreakpoint), $$invalidate(5, persistentHamburgerMenu);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expandedByDefault" in $$new_props)
      $$invalidate(13, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$new_props)
      $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$new_props)
      $$invalidate(14, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("company" in $$new_props)
      $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$new_props)
      $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$new_props)
      $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$new_props)
      $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$new_props)
      $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props)
      $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expandedByDefault,
    isSideNavOpen,
    uiShellAriaLabel,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    ref,
    iconMenu,
    iconClose,
    Close: Close_default,
    Menu: Menu_default,
    shouldRenderHamburgerMenu,
    HamburgerMenu: HamburgerMenu_default,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("expandedByDefault" in $$props)
      $$invalidate(13, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$props)
      $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$props)
      $$invalidate(14, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("company" in $$props)
      $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$props)
      $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$props)
      $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$props)
      $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$props)
      $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props)
      $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("winWidth" in $$props)
      $$invalidate(9, winWidth = $$new_props.winWidth);
    if ("ariaLabel" in $$props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8800) {
      $:
        $$invalidate(0, isSideNavOpen = expandedByDefault && winWidth >= expansionBreakpoint && !persistentHamburgerMenu);
    }
    $:
      $$invalidate(10, ariaLabel = company ? `${company} ` : "" + (uiShellAriaLabel || $$props["aria-label"] || platformName));
  };
  $$props = exclude_internal_props($$props);
  return [
    isSideNavOpen,
    ref,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    iconMenu,
    iconClose,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu,
    $$restProps,
    expandedByDefault,
    uiShellAriaLabel,
    $$scope,
    slots,
    click_handler,
    onwindowresize,
    hamburgermenu_isOpen_binding,
    a_binding
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance186, create_fragment186, safe_not_equal, {
      expandedByDefault: 13,
      isSideNavOpen: 0,
      uiShellAriaLabel: 14,
      href: 2,
      company: 3,
      platformName: 4,
      persistentHamburgerMenu: 5,
      expansionBreakpoint: 6,
      ref: 1,
      iconMenu: 7,
      iconClose: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment186.name
    });
  }
  get expandedByDefault() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedByDefault(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSideNavOpen() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSideNavOpen(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uiShellAriaLabel() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uiShellAriaLabel(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get company() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set company(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get platformName() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set platformName(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistentHamburgerMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistentHamburgerMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expansionBreakpoint() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expansionBreakpoint(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/carbon-components-svelte/src/icons/Switcher.svelte
var file175 = "node_modules/carbon-components-svelte/src/icons/Switcher.svelte";
function create_if_block107(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[1]);
      add_location(title_1, file175, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_dev(target, title_1, anchor);
      append_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block107.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment187(ctx) {
  let svg;
  let path;
  let if_block = ctx[1] && create_if_block107(ctx);
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: ctx[0] },
    { height: ctx[0] },
    ctx[2],
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      attr_dev(path, "d", "M14 4H18V8H14zM4 4H8V8H4zM24 4H28V8H24zM14 14H18V18H14zM4 14H8V18H4zM24 14H28V18H24zM14 24H18V28H14zM4 24H8V28H4zM24 24H28V28H24z");
      add_location(path, file175, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file175, 13, 0, 338);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block107(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & 1 && { width: ctx2[0] },
        dirty & 1 && { height: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment187.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance187($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switcher", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Switcher = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance187, create_fragment187, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switcher",
      options,
      id: create_fragment187.name
    });
  }
  get size() {
    throw new Error("<Switcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Switcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Switcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Switcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switcher_default = Switcher;

// node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte
var file176 = "node_modules/carbon-components-svelte/src/UIShell/HeaderAction.svelte";
function add_css(target) {
  append_styles(target, "svelte-187bdaq", ".action-text.svelte-187bdaq.svelte-187bdaq{display:inline-flex;align-items:center;width:auto;padding:0 1rem 2px 1rem;font-size:0.875rem;line-height:1.28572;letter-spacing:0.16px;color:#f4f4f4}.action-text.svelte-187bdaq>span.svelte-187bdaq{margin-left:0.75rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvR0UsWUFBWSw4QkFBQyxDQUFBLEFBQ1gsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsS0FBSyxDQUFFLElBQUksQ0FHWCxPQUFPLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUd4QixTQUFTLENBQUUsUUFBUSxDQUNuQixXQUFXLENBQUUsT0FBTyxDQUNwQixjQUFjLENBQUUsTUFBTSxDQUd0QixLQUFLLENBQUUsT0FBTyxBQUNoQixDQUFBLEFBRUEsMkJBQVksQ0FBRyxJQUFJLGVBQUMsQ0FBQSxBQUNsQixXQUFXLENBQUUsT0FBTyxBQUN0QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkhlYWRlckFjdGlvbi5zdmVsdGUiXX0= */");
}
var get_text_slot_changes = (dirty) => ({});
var get_text_slot_context = (ctx) => ({});
var get_icon_slot_changes5 = (dirty) => ({});
var get_icon_slot_context5 = (ctx) => ({});
var get_closeIcon_slot_changes = (dirty) => ({});
var get_closeIcon_slot_context = (ctx) => ({});
function create_else_block32(ctx) {
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[9], get_icon_slot_context5);
  const icon_slot_or_fallback = icon_slot || fallback_block_28(ctx);
  const block = {
    c: function create() {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(icon_slot_template, ctx2[9], dirty, get_icon_slot_changes5),
            get_icon_slot_context5
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 4)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block32.name,
    type: "else",
    source: "(77:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_228(ctx) {
  let current;
  const closeIcon_slot_template = ctx[10].closeIcon;
  const closeIcon_slot = create_slot(closeIcon_slot_template, ctx, ctx[9], get_closeIcon_slot_context);
  const closeIcon_slot_or_fallback = closeIcon_slot || fallback_block_115(ctx);
  const block = {
    c: function create() {
      if (closeIcon_slot_or_fallback)
        closeIcon_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (closeIcon_slot_or_fallback) {
        closeIcon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (closeIcon_slot) {
        if (closeIcon_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            closeIcon_slot,
            closeIcon_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(closeIcon_slot_template, ctx2[9], dirty, get_closeIcon_slot_changes),
            get_closeIcon_slot_context
          );
        }
      } else {
        if (closeIcon_slot_or_fallback && closeIcon_slot_or_fallback.p && (!current || dirty & 8)) {
          closeIcon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(closeIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closeIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (closeIcon_slot_or_fallback)
        closeIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_228.name,
    type: "if",
    source: "(73:2) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block_28(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_28.name,
    type: "fallback",
    source: "(78:22)        ",
    ctx
  });
  return block;
}
function fallback_block_115(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_115.name,
    type: "fallback",
    source: "(74:27)        ",
    ctx
  });
  return block;
}
function create_if_block_144(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(ctx[4]);
      attr_dev(span, "class", "svelte-187bdaq");
      add_location(span, file176, 82, 14, 2022);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_144.name,
    type: "if",
    source: "(83:4) {#if text}",
    ctx
  });
  return block;
}
function fallback_block42(ctx) {
  let if_block_anchor;
  let if_block = ctx[4] && create_if_block_144(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_144(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block42.name,
    type: "fallback",
    source: "(82:20)      ",
    ctx
  });
  return block;
}
function create_if_block108(ctx) {
  let div;
  let div_transition;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div, "bx--header-panel", true);
      toggle_class(div, "bx--header-panel--expanded", true);
      add_location(div, file176, 86, 2, 2082);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[15](div);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(default_slot_template, ctx[9], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              slide,
              {
                ...ctx[5],
                duration: ctx[5] === false ? 0 : ctx[5].duration
              },
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            slide,
            {
              ...ctx[5],
              duration: ctx[5] === false ? 0 : ctx[5].duration
            },
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[15](null);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block108.name,
    type: "if",
    source: "(86:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment188(ctx) {
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_228, create_else_block32];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const text_slot_template = ctx[10].text;
  const text_slot = create_slot(text_slot_template, ctx, ctx[9], get_text_slot_context);
  const text_slot_or_fallback = text_slot || fallback_block42(ctx);
  let button_levels = [{ type: "button" }, ctx[8]];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  let if_block1 = ctx[0] && create_if_block108(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if_block0.c();
      t0 = space();
      if (text_slot_or_fallback)
        text_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__action--active", ctx[0]);
      toggle_class(button, "action-text", ctx[4]);
      toggle_class(button, "svelte-187bdaq", true);
      add_location(button, file176, 59, 0, 1475);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_dev(button, t0);
      if (text_slot_or_fallback) {
        text_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[13](button);
      insert_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[12], false, false, false),
          listen_dev(button, "click", ctx[11], false, false, false),
          listen_dev(button, "click", stop_propagation(ctx[14]), false, false, true)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, t0);
      }
      if (text_slot) {
        if (text_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            text_slot,
            text_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(text_slot_template, ctx2[9], dirty, get_text_slot_changes),
            get_text_slot_context
          );
        }
      } else {
        if (text_slot_or_fallback && text_slot_or_fallback.p && (!current || dirty & 16)) {
          text_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [{ type: "button" }, dirty & 256 && ctx2[8]]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__action--active", ctx2[0]);
      toggle_class(button, "action-text", ctx2[4]);
      toggle_class(button, "svelte-187bdaq", true);
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block108(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(text_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(text_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if_blocks[current_block_type_index].d();
      if (text_slot_or_fallback)
        text_slot_or_fallback.d(detaching);
      ctx[13](null);
      if (detaching)
        detach_dev(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment188.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance188($$self, $$props, $$invalidate) {
  const omit_props_names = ["isOpen", "icon", "closeIcon", "text", "ref", "transition"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderAction", slots, ["closeIcon", "icon", "text", "default"]);
  let { isOpen = false } = $$props;
  let { icon = Switcher_default } = $$props;
  let { closeIcon = Close_default } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  let { transition = { duration: 200 } } = $$props;
  const dispatch = createEventDispatcher();
  let refPanel = null;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (isOpen && !ref.contains(target) && !refPanel.contains(target)) {
      $$invalidate(0, isOpen = false);
      dispatch("close");
    }
  };
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_2 = () => {
    $$invalidate(0, isOpen = !isOpen);
    dispatch(isOpen ? "open" : "close");
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refPanel = $$value;
      $$invalidate(6, refPanel);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("icon" in $$new_props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("closeIcon" in $$new_props)
      $$invalidate(3, closeIcon = $$new_props.closeIcon);
    if ("text" in $$new_props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("transition" in $$new_props)
      $$invalidate(5, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    isOpen,
    icon,
    closeIcon,
    text: text2,
    ref,
    transition,
    createEventDispatcher,
    slide,
    Close: Close_default,
    Switcher: Switcher_default,
    dispatch,
    refPanel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("icon" in $$props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("closeIcon" in $$props)
      $$invalidate(3, closeIcon = $$new_props.closeIcon);
    if ("text" in $$props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("transition" in $$props)
      $$invalidate(5, transition = $$new_props.transition);
    if ("refPanel" in $$props)
      $$invalidate(6, refPanel = $$new_props.refPanel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    ref,
    icon,
    closeIcon,
    text2,
    transition,
    refPanel,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    click_handler_13,
    button_binding,
    click_handler_2,
    div_binding
  ];
}
var HeaderAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance188,
      create_fragment188,
      safe_not_equal,
      {
        isOpen: 0,
        icon: 2,
        closeIcon: 3,
        text: 4,
        ref: 1,
        transition: 5
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderAction",
      options,
      id: create_fragment188.name
    });
  }
  get isOpen() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeIcon() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeIcon(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<HeaderAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<HeaderAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderAction_default = HeaderAction;

// node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte
var file177 = "node_modules/carbon-components-svelte/src/UIShell/HeaderActionLink.svelte";
function add_css2(target) {
  append_styles(target, "svelte-smaelc", ".bx--header__action.svelte-smaelc{display:flex;align-items:center;justify-content:center;padding-bottom:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyQWN0aW9uTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0NFLG1CQUFtQixjQUFDLENBQUEsQUFDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUV2QixjQUFjLENBQUUsR0FBRyxBQUNyQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkhlYWRlckFjdGlvbkxpbmsuc3ZlbHRlIl19 */");
}
var get_icon_slot_changes6 = (dirty) => ({});
var get_icon_slot_context6 = (ctx) => ({});
function fallback_block43(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block43.name,
    type: "fallback",
    source: "(29:20)      ",
    ctx
  });
  return block;
}
function create_fragment189(ctx) {
  let a;
  let a_rel_value;
  let current;
  const icon_slot_template = ctx[6].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[5], get_icon_slot_context6);
  const icon_slot_or_fallback = icon_slot || fallback_block43(ctx);
  let a_levels = [
    { href: ctx[2] },
    {
      rel: a_rel_value = ctx[4].target === "_blank" ? "noopener noreferrer" : void 0
    },
    ctx[4]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__action", true);
      toggle_class(a, "bx--header__action--active", ctx[1]);
      toggle_class(a, "svelte-smaelc", true);
      add_location(a, file177, 20, 0, 410);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(a, null);
      }
      ctx[7](a);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(icon_slot_template, ctx2[5], dirty, get_icon_slot_changes6),
            get_icon_slot_context6
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 8)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 4) && { href: ctx2[2] },
        (!current || dirty & 16 && a_rel_value !== (a_rel_value = ctx2[4].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & 16 && ctx2[4]
      ]));
      toggle_class(a, "bx--header__action", true);
      toggle_class(a, "bx--header__action--active", ctx2[1]);
      toggle_class(a, "svelte-smaelc", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment189.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance189($$self, $$props, $$invalidate) {
  const omit_props_names = ["linkIsActive", "href", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderActionLink", slots, ["icon"]);
  let { linkIsActive = false } = $$props;
  let { href = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("linkIsActive" in $$new_props)
      $$invalidate(1, linkIsActive = $$new_props.linkIsActive);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("icon" in $$new_props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ linkIsActive, href, icon, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("linkIsActive" in $$props)
      $$invalidate(1, linkIsActive = $$new_props.linkIsActive);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("icon" in $$props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, linkIsActive, href, icon, $$restProps, $$scope, slots, a_binding];
}
var HeaderActionLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance189,
      create_fragment189,
      safe_not_equal,
      {
        linkIsActive: 1,
        href: 2,
        icon: 3,
        ref: 0
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderActionLink",
      options,
      id: create_fragment189.name
    });
  }
  get linkIsActive() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linkIsActive(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderActionLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderActionLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderActionLink_default = HeaderActionLink;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte
var file178 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNav.svelte";
function create_fragment190(ctx) {
  let nav;
  let ul;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let ul_levels = [ctx[0], { role: "menubar" }];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  let nav_levels = [ctx[0], ctx[1]];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      toggle_class(ul, "bx--header__menu-bar", true);
      add_location(ul, file178, 8, 2, 199);
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--header__nav", true);
      add_location(nav, file178, 7, 0, 132);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [dirty & 1 && ctx2[0], { role: "menubar" }]));
      toggle_class(ul, "bx--header__menu-bar", true);
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & 1 && ctx2[0],
        dirty & 2 && ctx2[1]
      ]));
      toggle_class(nav, "bx--header__nav", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment190.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance190($$self, $$props, $$invalidate) {
  let props;
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNav", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ props });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("props" in $$props)
      $$invalidate(0, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, props = {
        "aria-label": $$props["aria-label"],
        "aria-labelledby": $$props["aria-labelledby"]
      });
  };
  $$props = exclude_internal_props($$props);
  return [props, $$restProps, $$scope, slots];
}
var HeaderNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance190, create_fragment190, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNav",
      options,
      id: create_fragment190.name
    });
  }
};
var HeaderNav_default = HeaderNav;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte
var file179 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavItem.svelte";
function create_fragment191(ctx) {
  let li;
  let a;
  let span;
  let t;
  let a_rel_value;
  let a_aria_current_value;
  let mounted;
  let dispose;
  let a_levels = [
    { role: "menuitem" },
    { tabindex: "0" },
    { href: ctx[1] },
    {
      rel: a_rel_value = ctx[7].target === "_blank" ? "noopener noreferrer" : void 0
    },
    {
      "aria-current": a_aria_current_value = ctx[3] ? "page" : void 0
    },
    ctx[7]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      span = element("span");
      t = text(ctx[2]);
      toggle_class(span, "bx--text-truncate--end", true);
      add_location(span, file179, 63, 4, 1382);
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__menu-item", true);
      add_location(a, file179, 40, 2, 844);
      attr_dev(li, "role", "none");
      add_location(li, file179, 39, 0, 825);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, span);
      append_dev(span, t);
      ctx[16](a);
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[8], false, false, false),
          listen_dev(a, "mouseover", ctx[9], false, false, false),
          listen_dev(a, "mouseenter", ctx[10], false, false, false),
          listen_dev(a, "mouseleave", ctx[11], false, false, false),
          listen_dev(a, "keyup", ctx[12], false, false, false),
          listen_dev(a, "keydown", ctx[13], false, false, false),
          listen_dev(a, "focus", ctx[14], false, false, false),
          listen_dev(a, "blur", ctx[15], false, false, false),
          listen_dev(a, "blur", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "menuitem" },
        { tabindex: "0" },
        dirty & 2 && { href: ctx2[1] },
        dirty & 128 && a_rel_value !== (a_rel_value = ctx2[7].target === "_blank" ? "noopener noreferrer" : void 0) && { rel: a_rel_value },
        dirty & 8 && a_aria_current_value !== (a_aria_current_value = ctx2[3] ? "page" : void 0) && { "aria-current": a_aria_current_value },
        dirty & 128 && ctx2[7]
      ]));
      toggle_class(a, "bx--header__menu-item", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment191.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance191($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "text", "isSelected", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNavItem", slots, []);
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { isSelected = false } = $$props;
  let { ref = null } = $$props;
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("HeaderNavMenu");
  let selectedItemIds = [];
  const unsubSelectedItems = ctx == null ? void 0 : ctx.selectedItems.subscribe((_selectedItems) => {
    $$invalidate(4, selectedItemIds = Object.keys(_selectedItems));
  });
  onMount(() => {
    return () => {
      if (unsubSelectedItems)
        unsubSelectedItems();
    };
  });
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  const blur_handler_1 = () => {
    if (selectedItemIds.indexOf(id) === selectedItemIds.length - 1) {
      ctx == null ? void 0 : ctx.closeMenu();
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("isSelected" in $$new_props)
      $$invalidate(3, isSelected = $$new_props.isSelected);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    href,
    text: text2,
    isSelected,
    ref,
    getContext,
    onMount,
    id,
    ctx,
    selectedItemIds,
    unsubSelectedItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("isSelected" in $$props)
      $$invalidate(3, isSelected = $$new_props.isSelected);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("selectedItemIds" in $$props)
      $$invalidate(4, selectedItemIds = $$new_props.selectedItemIds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        ctx == null ? void 0 : ctx.updateSelectedItems({ id, isSelected });
    }
  };
  return [
    ref,
    href,
    text2,
    isSelected,
    selectedItemIds,
    id,
    ctx,
    $$restProps,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keyup_handler,
    keydown_handler,
    focus_handler,
    blur_handler,
    a_binding,
    blur_handler_1
  ];
}
var HeaderNavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance191, create_fragment191, safe_not_equal, { href: 1, text: 2, isSelected: 3, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNavItem",
      options,
      id: create_fragment191.name
    });
  }
  get href() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSelected() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderNavItem_default = HeaderNavItem;

// node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte
var file180 = "node_modules/carbon-components-svelte/src/UIShell/HeaderNavMenu.svelte";
function create_fragment192(ctx) {
  let li;
  let a;
  let t0;
  let t1;
  let chevrondown;
  let a_style_value;
  let t2;
  let ul;
  let current;
  let mounted;
  let dispose;
  chevrondown = new ChevronDown_default({
    props: { class: "bx--header__menu-arrow" },
    $$inline: true
  });
  let a_levels = [
    { role: "menuitem" },
    { tabindex: "0" },
    { "aria-haspopup": "menu" },
    { "aria-expanded": ctx[0] },
    { "aria-label": ctx[3] },
    { href: ctx[2] },
    ctx[7],
    {
      style: a_style_value = ctx[7].style + "; z-index: 1"
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(ctx[3]);
      t1 = space();
      create_component(chevrondown.$$.fragment);
      t2 = space();
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__menu-item", true);
      toggle_class(a, "bx--header__menu-title", true);
      add_location(a, file180, 66, 2, 1358);
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "aria-label", ctx[3]);
      toggle_class(ul, "bx--header__menu", true);
      add_location(ul, file180, 96, 2, 2040);
      attr_dev(li, "role", "none");
      toggle_class(li, "bx--header__submenu", true);
      toggle_class(li, "bx--header__submenu--current", ctx[5]);
      add_location(li, file180, 49, 0, 996);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, t0);
      append_dev(a, t1);
      mount_component(chevrondown, a, null);
      ctx[20](a);
      append_dev(li, t2);
      append_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[22](ul);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[19], false, false, false),
          listen_dev(a, "keydown", ctx[11], false, false, false),
          listen_dev(a, "keydown", ctx[21], false, false, false),
          listen_dev(a, "click", prevent_default(ctx[12]), false, true, false),
          listen_dev(a, "mouseover", ctx[13], false, false, false),
          listen_dev(a, "mouseenter", ctx[14], false, false, false),
          listen_dev(a, "mouseleave", ctx[15], false, false, false),
          listen_dev(a, "keyup", ctx[16], false, false, false),
          listen_dev(a, "focus", ctx[17], false, false, false),
          listen_dev(a, "blur", ctx[18], false, false, false),
          listen_dev(li, "click", ctx[23], false, false, false),
          listen_dev(li, "keydown", ctx[24], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 8)
        set_data_dev(t0, ctx2[3]);
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { role: "menuitem" },
        { tabindex: "0" },
        { "aria-haspopup": "menu" },
        (!current || dirty & 1) && { "aria-expanded": ctx2[0] },
        (!current || dirty & 8) && { "aria-label": ctx2[3] },
        (!current || dirty & 4) && { href: ctx2[2] },
        dirty & 128 && ctx2[7],
        (!current || dirty & 128 && a_style_value !== (a_style_value = ctx2[7].style + "; z-index: 1")) && { style: a_style_value }
      ]));
      toggle_class(a, "bx--header__menu-item", true);
      toggle_class(a, "bx--header__menu-title", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8) {
        attr_dev(ul, "aria-label", ctx2[3]);
      }
      if (!current || dirty & 32) {
        toggle_class(li, "bx--header__submenu--current", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      destroy_component(chevrondown);
      ctx[20](null);
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment192.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance192($$self, $$props, $$invalidate) {
  let isCurrentSubmenu;
  const omit_props_names = ["expanded", "href", "text", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedItems;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderNavMenu", slots, ["default"]);
  let { expanded = false } = $$props;
  let { href = "/" } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  const selectedItems = writable({});
  validate_store(selectedItems, "selectedItems");
  component_subscribe($$self, selectedItems, (value) => $$invalidate(8, $selectedItems = value));
  let menuRef = null;
  setContext("HeaderNavMenu", {
    selectedItems,
    updateSelectedItems(item) {
      selectedItems.update((_items) => ({ ..._items, [item.id]: item.isSelected }));
    },
    closeMenu() {
      $$invalidate(0, expanded = false);
    }
  });
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseover_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function mouseleave_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keyup_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_13 = ({ target }) => {
    if (!ref.contains(target)) {
      $$invalidate(0, expanded = false);
    }
  };
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const keydown_handler_12 = (e) => {
    if (e.key === " ")
      e.preventDefault();
    if (e.key === "Enter" || e.key === " ") {
      $$invalidate(0, expanded = !expanded);
    }
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuRef = $$value;
      $$invalidate(4, menuRef);
    });
  }
  const click_handler_2 = (e) => {
    if (!menuRef.contains(e.target)) {
      e.preventDefault();
    }
    $$invalidate(0, expanded = !expanded);
  };
  const keydown_handler_2 = (e) => {
    if (e.key === "Enter") {
      e.stopPropagation();
      $$invalidate(0, expanded = !expanded);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expanded,
    href,
    text: text2,
    ref,
    setContext,
    writable,
    ChevronDown: ChevronDown_default,
    selectedItems,
    menuRef,
    isCurrentSubmenu,
    $selectedItems
  });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("menuRef" in $$props)
      $$invalidate(4, menuRef = $$new_props.menuRef);
    if ("isCurrentSubmenu" in $$props)
      $$invalidate(5, isCurrentSubmenu = $$new_props.isCurrentSubmenu);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(5, isCurrentSubmenu = Object.values($selectedItems).filter(Boolean).length > 0);
    }
  };
  return [
    expanded,
    ref,
    href,
    text2,
    menuRef,
    isCurrentSubmenu,
    selectedItems,
    $$restProps,
    $selectedItems,
    $$scope,
    slots,
    keydown_handler,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    click_handler_13,
    a_binding,
    keydown_handler_12,
    ul_binding,
    click_handler_2,
    keydown_handler_2
  ];
}
var HeaderNavMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance192, create_fragment192, safe_not_equal, { expanded: 0, href: 2, text: 3, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderNavMenu",
      options,
      id: create_fragment192.name
    });
  }
  get expanded() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderNavMenu_default = HeaderNavMenu;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte
var file181 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelDivider.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1tbdbmc", "li.svelte-1tbdbmc{margin:2rem 1rem 0;color:#525252}span.svelte-1tbdbmc{font-size:0.75rem;line-height:1.3;letter-spacing:0.02rem;color:#c6c6c6}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyUGFuZWxEaXZpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnQkUsRUFBRSxlQUFDLENBQUEsQUFDRCxNQUFNLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQ25CLEtBQUssQ0FBRSxPQUFPLEFBQ2hCLENBQUEsQUFDQSxJQUFJLGVBQUMsQ0FBQSxBQUNILFNBQVMsQ0FBRSxPQUFPLENBQ2xCLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLGNBQWMsQ0FBRSxPQUFPLENBQ3ZCLEtBQUssQ0FBRSxPQUFPLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSGVhZGVyUGFuZWxEaXZpZGVyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block109(ctx) {
  let li;
  let span;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(span, "class", "svelte-1tbdbmc");
      add_location(span, file181, 2, 4, 33);
      attr_dev(li, "class", "svelte-1tbdbmc");
      add_location(li, file181, 1, 2, 24);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block109.name,
    type: "if",
    source: "(1:0) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment193(ctx) {
  let t;
  let hr;
  let current;
  let if_block = ctx[0].default && create_if_block109(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      hr = element("hr");
      toggle_class(hr, "bx--switcher__item--divider", true);
      add_location(hr, file181, 7, 0, 81);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, hr, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0].default) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block109(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(hr);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment193.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance193($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelDivider", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HeaderPanelDivider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [$$slots, $$scope, slots];
}
var HeaderPanelDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance193, create_fragment193, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelDivider",
      options,
      id: create_fragment193.name
    });
  }
};
var HeaderPanelDivider_default = HeaderPanelDivider;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte
var file182 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLink.svelte";
function create_fragment194(ctx) {
  let li;
  let a;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let a_levels = [
    { href: ctx[1] },
    {
      rel: a_rel_value = ctx[2].target === "_blank" ? "noopener noreferrer" : void 0
    },
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--switcher__item-link", true);
      add_location(a, file182, 12, 2, 239);
      toggle_class(li, "bx--switcher__item", true);
      add_location(li, file182, 11, 0, 198);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      ctx[6](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 2) && { href: ctx2[1] },
        (!current || dirty & 4 && a_rel_value !== (a_rel_value = ctx2[2].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(a, "bx--switcher__item-link", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment194.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance194($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelLink", slots, ["default"]);
  let { href = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, href, $$restProps, $$scope, slots, click_handler, a_binding];
}
var HeaderPanelLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance194, create_fragment194, safe_not_equal, { href: 1, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelLink",
      options,
      id: create_fragment194.name
    });
  }
  get href() {
    throw new Error("<HeaderPanelLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<HeaderPanelLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderPanelLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderPanelLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderPanelLink_default = HeaderPanelLink;

// node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte
var file183 = "node_modules/carbon-components-svelte/src/UIShell/HeaderPanelLinks.svelte";
function create_fragment195(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      toggle_class(ul, "bx--switcher__item", true);
      add_location(ul, file183, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment195.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance195($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderPanelLinks", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HeaderPanelLinks> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var HeaderPanelLinks = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance195, create_fragment195, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderPanelLinks",
      options,
      id: create_fragment195.name
    });
  }
};
var HeaderPanelLinks_default = HeaderPanelLinks;

// node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte
var file184 = "node_modules/carbon-components-svelte/src/UIShell/HeaderUtilities.svelte";
function create_fragment196(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      toggle_class(div, "bx--header__global", true);
      add_location(div, file184, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment196.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance196($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderUtilities", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HeaderUtilities> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var HeaderUtilities = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance196, create_fragment196, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderUtilities",
      options,
      id: create_fragment196.name
    });
  }
};
var HeaderUtilities_default = HeaderUtilities;

// node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte
var file185 = "node_modules/carbon-components-svelte/src/UIShell/SideNav.svelte";
function create_if_block110(ctx) {
  let div;
  let div_style_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "style", div_style_value = ctx[0] && "z-index: 6000");
      toggle_class(div, "bx--side-nav__overlay", true);
      toggle_class(div, "bx--side-nav__overlay-active", ctx[0]);
      add_location(div, file185, 58, 2, 1365);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[11], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && div_style_value !== (div_style_value = ctx2[0] && "z-index: 6000")) {
        attr_dev(div, "style", div_style_value);
      }
      if (dirty & 1) {
        toggle_class(div, "bx--side-nav__overlay-active", ctx2[0]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block110.name,
    type: "if",
    source: "(57:0) {#if !fixed}",
    ctx
  });
  return block;
}
function create_fragment197(ctx) {
  let t;
  let nav;
  let nav_aria_hidden_value;
  let current;
  let mounted;
  let dispose;
  add_render_callback(ctx[10]);
  let if_block = !ctx[1] && create_if_block110(ctx);
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let nav_levels = [
    {
      "aria-hidden": nav_aria_hidden_value = !ctx[0]
    },
    { "aria-label": ctx[3] },
    ctx[7]
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      nav = element("nav");
      if (default_slot)
        default_slot.c();
      set_attributes(nav, nav_data);
      toggle_class(nav, "bx--side-nav__navigation", true);
      toggle_class(nav, "bx--side-nav", true);
      toggle_class(nav, "bx--side-nav--ux", true);
      toggle_class(nav, "bx--side-nav--expanded", ctx[2] && ctx[5] >= ctx[4] ? false : ctx[0]);
      toggle_class(nav, "bx--side-nav--collapsed", !ctx[0] && !ctx[2]);
      toggle_class(nav, "bx--side-nav--rail", ctx[2]);
      add_location(nav, file185, 68, 0, 1603);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, nav, anchor);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "resize", ctx[10]);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block110(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        (!current || dirty & 1 && nav_aria_hidden_value !== (nav_aria_hidden_value = !ctx2[0])) && { "aria-hidden": nav_aria_hidden_value },
        (!current || dirty & 8) && { "aria-label": ctx2[3] },
        dirty & 128 && ctx2[7]
      ]));
      toggle_class(nav, "bx--side-nav__navigation", true);
      toggle_class(nav, "bx--side-nav", true);
      toggle_class(nav, "bx--side-nav--ux", true);
      toggle_class(nav, "bx--side-nav--expanded", ctx2[2] && ctx2[5] >= ctx2[4] ? false : ctx2[0]);
      toggle_class(nav, "bx--side-nav--collapsed", !ctx2[0] && !ctx2[2]);
      toggle_class(nav, "bx--side-nav--rail", ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment197.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance197($$self, $$props, $$invalidate) {
  const omit_props_names = ["fixed", "rail", "ariaLabel", "isOpen", "expansionBreakpoint"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $isSideNavRail;
  let $isSideNavCollapsed;
  validate_store(isSideNavRail, "isSideNavRail");
  component_subscribe($$self, isSideNavRail, ($$value) => $$invalidate(12, $isSideNavRail = $$value));
  validate_store(isSideNavCollapsed, "isSideNavCollapsed");
  component_subscribe($$self, isSideNavCollapsed, ($$value) => $$invalidate(13, $isSideNavCollapsed = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNav", slots, ["default"]);
  let { fixed = false } = $$props;
  let { rail = false } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { expansionBreakpoint = 1056 } = $$props;
  const dispatch = createEventDispatcher();
  let winWidth = void 0;
  onMount(() => {
    shouldRenderHamburgerMenu.set(true);
    return () => shouldRenderHamburgerMenu.set(false);
  });
  function onwindowresize() {
    $$invalidate(5, winWidth = window.innerWidth);
  }
  const click_handler = () => {
    dispatch("click:overlay");
    $$invalidate(0, isOpen = false);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("fixed" in $$new_props)
      $$invalidate(1, fixed = $$new_props.fixed);
    if ("rail" in $$new_props)
      $$invalidate(2, rail = $$new_props.rail);
    if ("ariaLabel" in $$new_props)
      $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("expansionBreakpoint" in $$new_props)
      $$invalidate(4, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fixed,
    rail,
    ariaLabel,
    isOpen,
    expansionBreakpoint,
    onMount,
    createEventDispatcher,
    shouldRenderHamburgerMenu,
    isSideNavCollapsed,
    isSideNavRail,
    dispatch,
    winWidth,
    $isSideNavRail,
    $isSideNavCollapsed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("fixed" in $$props)
      $$invalidate(1, fixed = $$new_props.fixed);
    if ("rail" in $$props)
      $$invalidate(2, rail = $$new_props.rail);
    if ("ariaLabel" in $$props)
      $$invalidate(3, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("expansionBreakpoint" in $$props)
      $$invalidate(4, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("winWidth" in $$props)
      $$invalidate(5, winWidth = $$new_props.winWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch(isOpen ? "open" : "close");
    }
    if ($$self.$$.dirty & 1) {
      $:
        set_store_value(isSideNavCollapsed, $isSideNavCollapsed = !isOpen, $isSideNavCollapsed);
    }
    if ($$self.$$.dirty & 4) {
      $:
        set_store_value(isSideNavRail, $isSideNavRail = rail, $isSideNavRail);
    }
  };
  return [
    isOpen,
    fixed,
    rail,
    ariaLabel,
    expansionBreakpoint,
    winWidth,
    dispatch,
    $$restProps,
    $$scope,
    slots,
    onwindowresize,
    click_handler
  ];
}
var SideNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance197, create_fragment197, safe_not_equal, {
      fixed: 1,
      rail: 2,
      ariaLabel: 3,
      isOpen: 0,
      expansionBreakpoint: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNav",
      options,
      id: create_fragment197.name
    });
  }
  get fixed() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rail() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rail(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expansionBreakpoint() {
    throw new Error("<SideNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expansionBreakpoint(value) {
    throw new Error("<SideNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNav_default = SideNav;

// node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte
var file186 = "node_modules/carbon-components-svelte/src/UIShell/SideNavItems.svelte";
function create_fragment198(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      toggle_class(ul, "bx--side-nav__items", true);
      add_location(ul, file186, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment198.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance198($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavItems", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SideNavItems> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var SideNavItems = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance198, create_fragment198, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavItems",
      options,
      id: create_fragment198.name
    });
  }
};
var SideNavItems_default = SideNavItems;

// node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte
var file187 = "node_modules/carbon-components-svelte/src/UIShell/SideNavLink.svelte";
var get_icon_slot_changes7 = (dirty) => ({});
var get_icon_slot_context7 = (ctx) => ({});
function create_if_block111(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[8].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[7], get_icon_slot_context7);
  const icon_slot_or_fallback = icon_slot || fallback_block_116(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--side-nav__icon", true);
      toggle_class(div, "bx--side-nav__icon--small", true);
      add_location(div, file187, 38, 6, 880);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(icon_slot_template, ctx2[7], dirty, get_icon_slot_changes7),
            get_icon_slot_context7
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 16)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block111.name,
    type: "if",
    source: "(38:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block_116(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_116.name,
    type: "fallback",
    source: "(43:26)            ",
    ctx
  });
  return block;
}
function fallback_block44(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block44.name,
    type: "fallback",
    source: "(49:12)          ",
    ctx
  });
  return block;
}
function create_fragment199(ctx) {
  let li;
  let a;
  let t;
  let span;
  let a_aria_current_value;
  let a_rel_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[6].icon || ctx[4]) && create_if_block111(ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const default_slot_or_fallback = default_slot || fallback_block44(ctx);
  let a_levels = [
    {
      "aria-current": a_aria_current_value = ctx[1] ? "page" : void 0
    },
    { href: ctx[2] },
    {
      rel: a_rel_value = ctx[5].target === "_blank" ? "noopener noreferrer" : void 0
    },
    ctx[5]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      toggle_class(span, "bx--side-nav__link-text", true);
      add_location(span, file187, 47, 4, 1099);
      set_attributes(a, a_data);
      toggle_class(a, "bx--side-nav__link", true);
      toggle_class(a, "bx--side-nav__link--current", ctx[1]);
      add_location(a, file187, 27, 2, 538);
      toggle_class(li, "bx--side-nav__item", true);
      add_location(li, file187, 26, 0, 497);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      if (if_block)
        if_block.m(a, null);
      append_dev(a, t);
      append_dev(a, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[10](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[9], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[6].icon || ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 80) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block111(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 8)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 2 && a_aria_current_value !== (a_aria_current_value = ctx2[1] ? "page" : void 0)) && { "aria-current": a_aria_current_value },
        (!current || dirty & 4) && { href: ctx2[2] },
        (!current || dirty & 32 && a_rel_value !== (a_rel_value = ctx2[5].target === "_blank" ? "noopener noreferrer" : void 0)) && { rel: a_rel_value },
        dirty & 32 && ctx2[5]
      ]));
      toggle_class(a, "bx--side-nav__link", true);
      toggle_class(a, "bx--side-nav__link--current", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block)
        if_block.d();
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment199.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance199($$self, $$props, $$invalidate) {
  const omit_props_names = ["isSelected", "href", "text", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavLink", slots, ["icon", "default"]);
  const $$slots = compute_slots(slots);
  let { isSelected = false } = $$props;
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSelected" in $$new_props)
      $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("icon" in $$new_props)
      $$invalidate(4, icon = $$new_props.icon);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ isSelected, href, text: text2, icon, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("isSelected" in $$props)
      $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("icon" in $$props)
      $$invalidate(4, icon = $$new_props.icon);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    isSelected,
    href,
    text2,
    icon,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    a_binding
  ];
}
var SideNavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance199, create_fragment199, safe_not_equal, {
      isSelected: 1,
      href: 2,
      text: 3,
      icon: 4,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavLink",
      options,
      id: create_fragment199.name
    });
  }
  get isSelected() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavLink_default = SideNavLink;

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte
var file188 = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenu.svelte";
var get_icon_slot_changes8 = (dirty) => ({});
var get_icon_slot_context8 = (ctx) => ({});
function create_if_block112(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[7].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[6], get_icon_slot_context8);
  const icon_slot_or_fallback = icon_slot || fallback_block45(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      toggle_class(div, "bx--side-nav__icon", true);
      add_location(div, file188, 35, 6, 792);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(icon_slot_template, ctx2[6], dirty, get_icon_slot_changes8),
            get_icon_slot_context8
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & 8)) {
          icon_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block112.name,
    type: "if",
    source: "(35:4) {#if $$slots.icon || icon}",
    ctx
  });
  return block;
}
function fallback_block45(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block45.name,
    type: "fallback",
    source: "(37:26)            ",
    ctx
  });
  return block;
}
function create_fragment200(ctx) {
  let li;
  let button;
  let t0;
  let span;
  let t1;
  let t2;
  let div;
  let chevrondown;
  let t3;
  let ul;
  let ul_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[5].icon || ctx[3]) && create_if_block112(ctx);
  chevrondown = new ChevronDown_default({ $$inline: true });
  let button_levels = [
    { type: "button" },
    { "aria-expanded": ctx[0] },
    ctx[4]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      li = element("li");
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(ctx[2]);
      t2 = space();
      div = element("div");
      create_component(chevrondown.$$.fragment);
      t3 = space();
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      toggle_class(span, "bx--side-nav__submenu-title", true);
      add_location(span, file188, 41, 4, 947);
      toggle_class(div, "bx--side-nav__icon", true);
      toggle_class(div, "bx--side-nav__icon--small", true);
      toggle_class(div, "bx--side-nav__submenu-chevron", true);
      add_location(div, file188, 42, 4, 1014);
      set_attributes(button, button_data);
      toggle_class(button, "bx--side-nav__submenu", true);
      add_location(button, file188, 23, 2, 538);
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "style", ul_style_value = ctx[0] && "max-height: none");
      toggle_class(ul, "bx--side-nav__menu", true);
      add_location(ul, file188, 50, 2, 1210);
      toggle_class(li, "bx--side-nav__item", true);
      toggle_class(li, "bx--side-nav__item--icon", ctx[3]);
      add_location(li, file188, 22, 0, 457);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, button);
      if (if_block)
        if_block.m(button, null);
      append_dev(button, t0);
      append_dev(button, span);
      append_dev(span, t1);
      append_dev(button, t2);
      append_dev(button, div);
      mount_component(chevrondown, div, null);
      if (button.autofocus)
        button.focus();
      ctx[9](button);
      append_dev(li, t3);
      append_dev(li, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[8], false, false, false),
          listen_dev(button, "click", ctx[10], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[5].icon || ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 40) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block112(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 4)
        set_data_dev(t1, ctx2[2]);
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & 1) && { "aria-expanded": ctx2[0] },
        dirty & 16 && ctx2[4]
      ]));
      toggle_class(button, "bx--side-nav__submenu", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && ul_style_value !== (ul_style_value = ctx2[0] && "max-height: none")) {
        attr_dev(ul, "style", ul_style_value);
      }
      if (!current || dirty & 8) {
        toggle_class(li, "bx--side-nav__item--icon", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block)
        if_block.d();
      destroy_component(chevrondown);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment200.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance200($$self, $$props, $$invalidate) {
  const omit_props_names = ["expanded", "text", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavMenu", slots, ["icon", "default"]);
  const $$slots = compute_slots(slots);
  let { expanded = false } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_13 = () => {
    $$invalidate(0, expanded = !expanded);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expanded" in $$new_props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("text" in $$new_props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("icon" in $$new_props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ expanded, text: text2, icon, ref, ChevronDown: ChevronDown_default });
  $$self.$inject_state = ($$new_props) => {
    if ("expanded" in $$props)
      $$invalidate(0, expanded = $$new_props.expanded);
    if ("text" in $$props)
      $$invalidate(2, text2 = $$new_props.text);
    if ("icon" in $$props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    expanded,
    ref,
    text2,
    icon,
    $$restProps,
    $$slots,
    $$scope,
    slots,
    click_handler,
    button_binding,
    click_handler_13
  ];
}
var SideNavMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance200, create_fragment200, safe_not_equal, { expanded: 0, text: 2, icon: 3, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavMenu",
      options,
      id: create_fragment200.name
    });
  }
  get expanded() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavMenu_default = SideNavMenu;

// node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte
var file189 = "node_modules/carbon-components-svelte/src/UIShell/SideNavMenuItem.svelte";
function fallback_block46(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block46.name,
    type: "fallback",
    source: "(30:55) {text}",
    ctx
  });
  return block;
}
function create_fragment201(ctx) {
  let li;
  let a;
  let span;
  let a_aria_current_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const default_slot_or_fallback = default_slot || fallback_block46(ctx);
  let a_levels = [
    {
      "aria-current": a_aria_current_value = ctx[1] ? "page" : void 0
    },
    { href: ctx[2] },
    ctx[4]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      toggle_class(span, "bx--side-nav__link-text", true);
      add_location(span, file189, 29, 4, 587);
      set_attributes(a, a_data);
      toggle_class(a, "bx--side-nav__link", true);
      add_location(a, file189, 21, 2, 411);
      toggle_class(li, "bx--side-nav__menu-item", true);
      add_location(li, file189, 20, 0, 365);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      append_dev(a, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[8](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[7], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 8)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 2 && a_aria_current_value !== (a_aria_current_value = ctx2[1] ? "page" : void 0)) && { "aria-current": a_aria_current_value },
        (!current || dirty & 4) && { href: ctx2[2] },
        dirty & 16 && ctx2[4]
      ]));
      toggle_class(a, "bx--side-nav__link", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[8](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment201.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance201($$self, $$props, $$invalidate) {
  const omit_props_names = ["isSelected", "href", "text", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavMenuItem", slots, ["default"]);
  let { isSelected = false } = $$props;
  let { href = void 0 } = $$props;
  let { text: text2 = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSelected" in $$new_props)
      $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$new_props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ isSelected, href, text: text2, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("isSelected" in $$props)
      $$invalidate(1, isSelected = $$new_props.isSelected);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("text" in $$props)
      $$invalidate(3, text2 = $$new_props.text);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    isSelected,
    href,
    text2,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    a_binding
  ];
}
var SideNavMenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance201, create_fragment201, safe_not_equal, { isSelected: 1, href: 2, text: 3, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavMenuItem",
      options,
      id: create_fragment201.name
    });
  }
  get isSelected() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSelected(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<SideNavMenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<SideNavMenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SideNavMenuItem_default = SideNavMenuItem;

// node_modules/carbon-components-svelte/src/UIShell/Content.svelte
var file190 = "node_modules/carbon-components-svelte/src/UIShell/Content.svelte";
function create_fragment202(ctx) {
  let main;
  let main_style_value;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let main_levels = [
    { id: ctx[0] },
    ctx[2],
    {
      style: main_style_value = (ctx[1] ? "margin-left: 0;" : "") + " " + ctx[2].style
    }
  ];
  let main_data = {};
  for (let i = 0; i < main_levels.length; i += 1) {
    main_data = assign(main_data, main_levels[i]);
  }
  const block = {
    c: function create() {
      main = element("main");
      if (default_slot)
        default_slot.c();
      set_attributes(main, main_data);
      toggle_class(main, "bx--content", true);
      add_location(main, file190, 16, 0, 504);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, main, anchor);
      if (default_slot) {
        default_slot.m(main, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(main, main_data = get_spread_update(main_levels, [
        (!current || dirty & 1) && { id: ctx2[0] },
        dirty & 4 && ctx2[2],
        (!current || dirty & 6 && main_style_value !== (main_style_value = (ctx2[1] ? "margin-left: 0;" : "") + " " + ctx2[2].style)) && { style: main_style_value }
      ]));
      toggle_class(main, "bx--content", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(main);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment202.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance202($$self, $$props, $$invalidate) {
  let unsetLeftMargin;
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $isSideNavRail;
  let $isSideNavCollapsed;
  validate_store(isSideNavRail, "isSideNavRail");
  component_subscribe($$self, isSideNavRail, ($$value) => $$invalidate(3, $isSideNavRail = $$value));
  validate_store(isSideNavCollapsed, "isSideNavCollapsed");
  component_subscribe($$self, isSideNavCollapsed, ($$value) => $$invalidate(4, $isSideNavCollapsed = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Content", slots, ["default"]);
  let { id = "main-content" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    isSideNavCollapsed,
    isSideNavRail,
    unsetLeftMargin,
    $isSideNavRail,
    $isSideNavCollapsed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("unsetLeftMargin" in $$props)
      $$invalidate(1, unsetLeftMargin = $$new_props.unsetLeftMargin);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 24) {
      $:
        $$invalidate(1, unsetLeftMargin = $isSideNavCollapsed && !$isSideNavRail);
    }
  };
  return [
    id,
    unsetLeftMargin,
    $$restProps,
    $isSideNavRail,
    $isSideNavCollapsed,
    $$scope,
    slots
  ];
}
var Content = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance202, create_fragment202, safe_not_equal, { id: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Content",
      options,
      id: create_fragment202.name
    });
  }
  get id() {
    throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Content_default = Content;

// node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte
var file191 = "node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte";
function fallback_block47(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Skip to main content");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block47.name,
    type: "fallback",
    source: "(16:8) Skip to main content",
    ctx
  });
  return block;
}
function create_fragment203(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const default_slot_or_fallback = default_slot || fallback_block47(ctx);
  let a_levels = [
    { href: ctx[0] },
    { tabindex: ctx[1] },
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(a, a_data);
      toggle_class(a, "bx--skip-to-content", true);
      add_location(a, file191, 8, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 1) && { href: ctx2[0] },
        (!current || dirty & 2) && { tabindex: ctx2[1] },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(a, "bx--skip-to-content", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment203.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance203($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "tabindex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SkipToContent", slots, ["default"]);
  let { href = "#main-content" } = $$props;
  let { tabindex = "0" } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("tabindex" in $$new_props)
      $$invalidate(1, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ href, tabindex });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("tabindex" in $$props)
      $$invalidate(1, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, tabindex, $$restProps, $$scope, slots, click_handler];
}
var SkipToContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance203, create_fragment203, safe_not_equal, { href: 0, tabindex: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipToContent",
      options,
      id: create_fragment203.name
    });
  }
  get href() {
    throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SkipToContent_default = SkipToContent;

// node_modules/carbon-components-svelte/src/UIShell/HeaderGlobalAction.svelte
var file192 = "node_modules/carbon-components-svelte/src/UIShell/HeaderGlobalAction.svelte";
function fallback_block48(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block48.name,
    type: "fallback",
    source: "(23:8)      ",
    ctx
  });
  return block;
}
function create_fragment204(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const default_slot_or_fallback = default_slot || fallback_block48(ctx);
  let button_levels = [{ type: "button" }, ctx[3]];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__action--active", ctx[1]);
      add_location(button, file192, 14, 0, 310);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [{ type: "button" }, dirty & 8 && ctx2[3]]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__action--active", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment204.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance204($$self, $$props, $$invalidate) {
  const omit_props_names = ["isActive", "icon", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderGlobalAction", slots, ["default"]);
  let { isActive = false } = $$props;
  let { icon = void 0 } = $$props;
  let { ref = null } = $$props;
  function click_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isActive" in $$new_props)
      $$invalidate(1, isActive = $$new_props.isActive);
    if ("icon" in $$new_props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ isActive, icon, ref });
  $$self.$inject_state = ($$new_props) => {
    if ("isActive" in $$props)
      $$invalidate(1, isActive = $$new_props.isActive);
    if ("icon" in $$props)
      $$invalidate(2, icon = $$new_props.icon);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    isActive,
    icon,
    $$restProps,
    $$scope,
    slots,
    click_handler,
    button_binding
  ];
}
var HeaderGlobalAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance204, create_fragment204, safe_not_equal, { isActive: 1, icon: 2, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderGlobalAction",
      options,
      id: create_fragment204.name
    });
  }
  get isActive() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isActive(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderGlobalAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderGlobalAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderGlobalAction_default = HeaderGlobalAction;

// node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte
var file193 = "node_modules/carbon-components-svelte/src/UIShell/HeaderSearch.svelte";
function add_css4(target) {
  append_styles(target, "svelte-13u0dam", 'label.svelte-13u0dam.svelte-13u0dam{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;white-space:nowrap;border:0;visibility:inherit;clip:rect(0, 0, 0, 0)}[role="search"].svelte-13u0dam.svelte-13u0dam{position:relative;display:flex;max-width:28rem;width:100%;margin-left:0.5rem;height:3rem;background-color:#393939;color:#fff;transition:max-width 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      background 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}[role="search"].svelte-13u0dam.svelte-13u0dam:not(.active){max-width:3rem;background-color:#161616}[role="search"].active.svelte-13u0dam.svelte-13u0dam{outline:2px solid #fff;outline-offset:-2px}[aria-haspopup="menu"].svelte-13u0dam.svelte-13u0dam{display:flex;flex-grow:1;border-bottom:1px solid #393939}input.svelte-13u0dam.svelte-13u0dam{width:100%;height:3rem;padding:0;font-size:1rem;font-weight:400;line-height:1.375rem;letter-spacing:0;color:#fff;caret-color:#fff;background-color:initial;border:none;outline:none;transition:opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}input.svelte-13u0dam.svelte-13u0dam:not(.active){opacity:0;pointer-events:none}button.svelte-13u0dam.svelte-13u0dam{width:3rem;height:100%;padding:0;flex-shrink:0;opacity:1;transition:background-color 0.11s cubic-bezier(0.2, 0, 0.38, 0.9),\n      opacity 0.11s cubic-bezier(0.2, 0, 0.38, 0.9)}.disabled.svelte-13u0dam.svelte-13u0dam{border:none;pointer-events:none}[aria-label="Clear search"].svelte-13u0dam.svelte-13u0dam:hover{background-color:#4c4c4c}.hidden.svelte-13u0dam.svelte-13u0dam{opacity:0;display:none}ul.svelte-13u0dam.svelte-13u0dam{position:absolute;z-index:10000;padding:1rem 0;left:0;right:0;top:3rem;background-color:#161616;border:1px solid #393939;border-top:none;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.5)}[role="menuitem"].svelte-13u0dam.svelte-13u0dam{padding:6px 1rem;cursor:pointer;font-size:0.875rem;font-weight:600;line-height:1.29;letter-spacing:0.16px;transition:all 70ms cubic-bezier(0.2, 0, 0.38, 0.9);display:block;text-decoration:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#c6c6c6}.selected.svelte-13u0dam.svelte-13u0dam,[role="menuitem"].svelte-13u0dam.svelte-13u0dam:hover{background-color:#353535;color:#f4f4f4}[role="menuitem"].svelte-13u0dam span.svelte-13u0dam{font-size:0.75rem;font-weight:400;line-height:1.34;letter-spacing:0.32px;text-transform:lowercase;color:#c6c6c6}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyU2VhcmNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtS0UsS0FBSyw4QkFBQyxDQUFBLEFBQ0osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLENBQUMsQ0FDVixRQUFRLENBQUUsTUFBTSxDQUNoQixXQUFXLENBQUUsTUFBTSxDQUNuQixNQUFNLENBQUUsQ0FBQyxDQUNULFVBQVUsQ0FBRSxPQUFPLENBQ25CLElBQUksQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUN4QixDQUFBLEFBRUEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLDhCQUFDLENBQUEsQUFDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBQ1gsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsTUFBTSxDQUFFLElBQUksQ0FDWixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLEtBQUssQ0FBRSxJQUFJLENBQ1gsVUFBVSxDQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQTtNQUN6RCxVQUFVLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ3BELENBQUEsQUFFQSxDQUFDLElBQUksQ0FBQyxRQUFRLCtCQUFDLEtBQUssT0FBTyxDQUFDLEFBQUMsQ0FBQSxBQUMzQixTQUFTLENBQUUsSUFBSSxDQUNmLGdCQUFnQixDQUFFLE9BQU8sQUFDM0IsQ0FBQSxBQUVBLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLDhCQUFDLENBQUEsQUFDckIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN2QixjQUFjLENBQUUsSUFBSSxBQUN0QixDQUFBLEFBRUEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLDhCQUFDLENBQUEsQUFDckIsT0FBTyxDQUFFLElBQUksQ0FDYixTQUFTLENBQUUsQ0FBQyxDQUNaLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQUFDbEMsQ0FBQSxBQUVBLEtBQUssOEJBQUMsQ0FBQSxBQUNKLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsQ0FBQyxDQUNWLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsV0FBVyxDQUFFLFFBQVEsQ0FDckIsY0FBYyxDQUFFLENBQUMsQ0FDakIsS0FBSyxDQUFFLElBQUksQ0FDWCxXQUFXLENBQUUsSUFBSSxDQUNqQixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMzRCxDQUFBLEFBRUEsbUNBQUssS0FBSyxPQUFPLENBQUMsQUFBQyxDQUFBLEFBQ2pCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsY0FBYyxDQUFFLElBQUksQUFDdEIsQ0FBQSxBQUVBLE1BQU0sOEJBQUMsQ0FBQSxBQUNMLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsQ0FBQyxDQUNWLFdBQVcsQ0FBRSxDQUFDLENBQ2QsT0FBTyxDQUFFLENBQUMsQ0FDVixVQUFVLENBQUUsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUE7TUFDaEUsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUNqRCxDQUFBLEFBRUEsU0FBUyw4QkFBQyxDQUFBLEFBQ1IsTUFBTSxDQUFFLElBQUksQ0FDWixjQUFjLENBQUUsSUFBSSxBQUN0QixDQUFBLEFBRUEsQ0FBQyxVQUFVLENBQUMsY0FBYywrQkFBQyxNQUFNLEFBQUMsQ0FBQSxBQUNoQyxnQkFBZ0IsQ0FBRSxPQUFPLEFBQzNCLENBQUEsQUFFQSxPQUFPLDhCQUFDLENBQUEsQUFDTixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxJQUFJLEFBQ2YsQ0FBQSxBQUVBLEVBQUUsOEJBQUMsQ0FBQSxBQUNELFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsT0FBTyxDQUFFLElBQUksQ0FBQyxDQUFDLENBQ2YsSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLEdBQUcsQ0FBRSxJQUFJLENBQ1QsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQ3pCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDNUMsQ0FBQSxBQUVBLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyw4QkFBQyxDQUFBLEFBQ2hCLE9BQU8sQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUNqQixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxRQUFRLENBQ25CLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLFVBQVUsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3BELE9BQU8sQ0FBRSxLQUFLLENBQ2QsZUFBZSxDQUFFLElBQUksQ0FDckIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsS0FBSyxDQUFFLE9BQU8sQUFDaEIsQ0FBQSxBQUVBLHVDQUFTLENBQ1QsQ0FBQyxJQUFJLENBQUMsVUFBVSwrQkFBQyxNQUFNLEFBQUMsQ0FBQSxBQUN0QixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLEtBQUssQ0FBRSxPQUFPLEFBQ2hCLENBQUEsQUFFQSxDQUFDLElBQUksQ0FBQyxVQUFVLGdCQUFDLENBQUMsSUFBSSxlQUFDLENBQUEsQUFDckIsU0FBUyxDQUFFLE9BQU8sQ0FDbEIsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsV0FBVyxDQUFFLElBQUksQ0FDakIsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsY0FBYyxDQUFFLFNBQVMsQ0FDekIsS0FBSyxDQUFFLE9BQU8sQUFDaEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJIZWFkZXJTZWFyY2guc3ZlbHRlIl19 */');
}
function get_each_context22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  child_ctx[30] = i;
  return child_ctx;
}
var get_default_slot_changes13 = (dirty) => ({ result: dirty & 16 });
var get_default_slot_context13 = (ctx) => ({
  result: ctx[28],
  index: ctx[30]
});
function create_if_block113(ctx) {
  let ul;
  let current;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block22(get_each_context22(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(ul, "aria-labelledby", "search-label");
      attr_dev(ul, "role", "menu");
      attr_dev(ul, "id", "search-menu");
      attr_dev(ul, "class", "svelte-13u0dam");
      add_location(ul, file193, 136, 4, 3548);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4692) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context22(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block22(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block113.name,
    type: "if",
    source: "(136:2) {#if active && results.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_145(ctx) {
  let span;
  let t0;
  let t1_value = ctx[28].description + "";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("\u2013 ");
      t1 = text(t1_value);
      attr_dev(span, "class", "svelte-13u0dam");
      add_location(span, file193, 153, 38, 4171);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t0);
      append_dev(span, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = ctx2[28].description + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_145.name,
    type: "if",
    source: "(154:14) {#if result.description}",
    ctx
  });
  return block;
}
function fallback_block49(ctx) {
  let t0_value = ctx[28].text + "";
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[28].description && create_if_block_145(ctx);
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = ctx2[28].text + ""))
        set_data_dev(t0, t0_value);
      if (ctx2[28].description) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_145(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block49.name,
    type: "fallback",
    source: "(152:48)                ",
    ctx
  });
  return block;
}
function create_each_block22(ctx) {
  let li;
  let a;
  let a_id_value;
  let a_href_value;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context13);
  const default_slot_or_fallback = default_slot || fallback_block49(ctx);
  function click_handler_2() {
    return ctx[26](ctx[30]);
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      attr_dev(a, "tabindex", "-1");
      attr_dev(a, "id", a_id_value = "search-menuitem-" + ctx[30]);
      attr_dev(a, "role", "menuitem");
      attr_dev(a, "href", a_href_value = ctx[28].href);
      attr_dev(a, "class", "svelte-13u0dam");
      toggle_class(a, "selected", ctx[6] === `search-menuitem-${ctx[30]}`);
      add_location(a, file193, 139, 10, 3683);
      attr_dev(li, "role", "none");
      add_location(li, file193, 138, 8, 3656);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      append_dev(li, a);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      append_dev(li, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(click_handler_2), false, true, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4112)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[12],
            !current ? get_all_dirty_from_scope(ctx[12]) : get_slot_changes(default_slot_template, ctx[12], dirty, get_default_slot_changes13),
            get_default_slot_context13
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 16)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 16 && a_href_value !== (a_href_value = ctx[28].href)) {
        attr_dev(a, "href", a_href_value);
      }
      if (!current || dirty & 64) {
        toggle_class(a, "selected", ctx[6] === `search-menuitem-${ctx[30]}`);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block22.name,
    type: "each",
    source: "(138:6) {#each results as result, i}",
    ctx
  });
  return block;
}
function create_fragment205(ctx) {
  let div1;
  let label;
  let t1;
  let div0;
  let button0;
  let iconsearch;
  let button0_tabindex_value;
  let t2;
  let input;
  let input_tabindex_value;
  let t3;
  let button1;
  let close;
  let button1_tabindex_value;
  let t4;
  let current;
  let mounted;
  let dispose;
  iconsearch = new IconSearch_default({
    props: { size: 20, title: "Search" },
    $$inline: true
  });
  let input_levels = [
    { type: "text" },
    { autocomplete: "off" },
    { placeholder: "Search..." },
    {
      tabindex: input_tabindex_value = ctx[0] ? "0" : "-1"
    },
    ctx[10],
    { id: "search-input" },
    { "aria-autocomplete": "list" },
    { "aria-controls": "search-menu" },
    {
      "aria-activedescendant": ctx[6]
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  close = new Close_default({
    props: { size: 20, title: "Close" },
    $$inline: true
  });
  let if_block = ctx[0] && ctx[4].length > 0 && create_if_block113(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      label.textContent = "Search";
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      create_component(iconsearch.$$.fragment);
      t2 = space();
      input = element("input");
      t3 = space();
      button1 = element("button");
      create_component(close.$$.fragment);
      t4 = space();
      if (if_block)
        if_block.c();
      attr_dev(label, "for", "search-input");
      attr_dev(label, "id", "search-label");
      attr_dev(label, "class", "svelte-13u0dam");
      add_location(label, file193, 62, 2, 1655);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "aria-label", "Search");
      attr_dev(button0, "aria-expanded", ctx[0]);
      attr_dev(button0, "tabindex", button0_tabindex_value = ctx[0] ? "-1" : "0");
      attr_dev(button0, "class", "svelte-13u0dam");
      toggle_class(button0, "bx--header__action", true);
      toggle_class(button0, "disabled", ctx[0]);
      add_location(button0, file193, 64, 4, 1771);
      set_attributes(input, input_data);
      toggle_class(input, "active", ctx[0]);
      toggle_class(input, "svelte-13u0dam", true);
      add_location(input, file193, 77, 4, 2097);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "aria-label", "Clear search");
      attr_dev(button1, "tabindex", button1_tabindex_value = ctx[0] ? "0" : "-1");
      attr_dev(button1, "class", "svelte-13u0dam");
      toggle_class(button1, "bx--header__action", true);
      toggle_class(button1, "hidden", !ctx[0]);
      add_location(button1, file193, 120, 4, 3186);
      attr_dev(div0, "aria-owns", "search-menu");
      attr_dev(div0, "aria-haspopup", "menu");
      attr_dev(div0, "class", "svelte-13u0dam");
      add_location(div0, file193, 63, 2, 1716);
      attr_dev(div1, "role", "search");
      attr_dev(div1, "class", "svelte-13u0dam");
      toggle_class(div1, "active", ctx[0]);
      add_location(div1, file193, 61, 0, 1596);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, label);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div0, button0);
      mount_component(iconsearch, button0, null);
      append_dev(div0, t2);
      append_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[22](input);
      set_input_value(input, ctx[3]);
      append_dev(div0, t3);
      append_dev(div0, button1);
      mount_component(close, button1, null);
      append_dev(div1, t4);
      if (if_block)
        if_block.m(div1, null);
      ctx[27](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "mouseup", ctx[20], false, false, false),
          listen_dev(button0, "click", ctx[21], false, false, false),
          listen_dev(input, "input", ctx[23]),
          listen_dev(input, "change", ctx[14], false, false, false),
          listen_dev(input, "input", ctx[15], false, false, false),
          listen_dev(input, "focus", ctx[16], false, false, false),
          listen_dev(input, "blur", ctx[17], false, false, false),
          listen_dev(input, "keydown", ctx[18], false, false, false),
          listen_dev(input, "keydown", ctx[24], false, false, false),
          listen_dev(input, "paste", ctx[19], false, false, false),
          listen_dev(button1, "click", ctx[25], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        attr_dev(button0, "aria-expanded", ctx2[0]);
      }
      if (!current || dirty & 1 && button0_tabindex_value !== (button0_tabindex_value = ctx2[0] ? "-1" : "0")) {
        attr_dev(button0, "tabindex", button0_tabindex_value);
      }
      if (!current || dirty & 1) {
        toggle_class(button0, "disabled", ctx2[0]);
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        { autocomplete: "off" },
        { placeholder: "Search..." },
        (!current || dirty & 1 && input_tabindex_value !== (input_tabindex_value = ctx2[0] ? "0" : "-1")) && { tabindex: input_tabindex_value },
        dirty & 1024 && ctx2[10],
        { id: "search-input" },
        { "aria-autocomplete": "list" },
        { "aria-controls": "search-menu" },
        (!current || dirty & 64) && {
          "aria-activedescendant": ctx2[6]
        }
      ]));
      if (dirty & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
      toggle_class(input, "active", ctx2[0]);
      toggle_class(input, "svelte-13u0dam", true);
      if (!current || dirty & 1 && button1_tabindex_value !== (button1_tabindex_value = ctx2[0] ? "0" : "-1")) {
        attr_dev(button1, "tabindex", button1_tabindex_value);
      }
      if (!current || dirty & 1) {
        toggle_class(button1, "hidden", !ctx2[0]);
      }
      if (ctx2[0] && ctx2[4].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block113(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1) {
        toggle_class(div1, "active", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconsearch.$$.fragment, local);
      transition_in(close.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconsearch.$$.fragment, local);
      transition_out(close.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(iconsearch);
      ctx[22](null);
      destroy_component(close);
      if (if_block)
        if_block.d();
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment205.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance205($$self, $$props, $$invalidate) {
  let selectedResult;
  let selectedId;
  const omit_props_names = ["value", "active", "ref", "results", "selectedResultIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeaderSearch", slots, ["default"]);
  let { value = "" } = $$props;
  let { active = false } = $$props;
  let { ref = null } = $$props;
  let { results = [] } = $$props;
  let { selectedResultIndex = 0 } = $$props;
  const dispatch = createEventDispatcher();
  let refSearch = null;
  function reset() {
    $$invalidate(0, active = false);
    $$invalidate(3, value = "");
    $$invalidate(2, selectedResultIndex = 0);
  }
  function selectResult() {
    dispatch("select", {
      value,
      selectedResultIndex,
      selectedResult
    });
    reset();
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function input_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function focus_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function blur_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function keydown_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function paste_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const mouseup_handler = ({ target }) => {
    if (active && !refSearch.contains(target))
      $$invalidate(0, active = false);
  };
  const click_handler = () => {
    $$invalidate(0, active = true);
  };
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(3, value);
  }
  const keydown_handler_12 = (e) => {
    switch (e.key) {
      case "Enter":
        selectResult();
        break;
      case "ArrowDown":
        e.preventDefault();
        if (selectedResultIndex === results.length - 1) {
          $$invalidate(2, selectedResultIndex = 0);
        } else {
          $$invalidate(2, selectedResultIndex += 1);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (selectedResultIndex === 0) {
          $$invalidate(2, selectedResultIndex = results.length - 1);
        } else {
          $$invalidate(2, selectedResultIndex -= 1);
        }
        break;
    }
  };
  const click_handler_13 = () => {
    reset();
    dispatch("clear");
  };
  const click_handler_2 = async (i) => {
    $$invalidate(2, selectedResultIndex = i);
    await tick();
    selectResult();
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refSearch = $$value;
      $$invalidate(5, refSearch);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(3, value = $$new_props.value);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("results" in $$new_props)
      $$invalidate(4, results = $$new_props.results);
    if ("selectedResultIndex" in $$new_props)
      $$invalidate(2, selectedResultIndex = $$new_props.selectedResultIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    active,
    ref,
    results,
    selectedResultIndex,
    createEventDispatcher,
    tick,
    Close: Close_default,
    IconSearch: IconSearch_default,
    dispatch,
    refSearch,
    reset,
    selectResult,
    selectedResult,
    selectedId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(3, value = $$new_props.value);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("results" in $$props)
      $$invalidate(4, results = $$new_props.results);
    if ("selectedResultIndex" in $$props)
      $$invalidate(2, selectedResultIndex = $$new_props.selectedResultIndex);
    if ("refSearch" in $$props)
      $$invalidate(5, refSearch = $$new_props.refSearch);
    if ("selectedResult" in $$props)
      $$invalidate(11, selectedResult = $$new_props.selectedResult);
    if ("selectedId" in $$props)
      $$invalidate(6, selectedId = $$new_props.selectedId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        if (active && ref)
          ref.focus();
    }
    if ($$self.$$.dirty & 1) {
      $:
        dispatch(active ? "active" : "inactive");
    }
    if ($$self.$$.dirty & 20) {
      $:
        $$invalidate(11, selectedResult = results[selectedResultIndex]);
    }
    if ($$self.$$.dirty & 2052) {
      $:
        $$invalidate(6, selectedId = selectedResult ? `search-menuitem-${selectedResultIndex}` : void 0);
    }
  };
  return [
    active,
    ref,
    selectedResultIndex,
    value,
    results,
    refSearch,
    selectedId,
    dispatch,
    reset,
    selectResult,
    $$restProps,
    selectedResult,
    $$scope,
    slots,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    paste_handler,
    mouseup_handler,
    click_handler,
    input_binding,
    input_input_handler,
    keydown_handler_12,
    click_handler_13,
    click_handler_2,
    div1_binding
  ];
}
var HeaderSearch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance205,
      create_fragment205,
      safe_not_equal,
      {
        value: 3,
        active: 0,
        ref: 1,
        results: 4,
        selectedResultIndex: 2
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeaderSearch",
      options,
      id: create_fragment205.name
    });
  }
  get value() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get results() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set results(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedResultIndex() {
    throw new Error("<HeaderSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedResultIndex(value) {
    throw new Error("<HeaderSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeaderSearch_default = HeaderSearch;

// node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte
var file194 = "node_modules/carbon-components-svelte/src/UIShell/SideNavDivider.svelte";
function create_fragment206(ctx) {
  let li;
  let li_levels = [{ role: "separator" }, ctx[0]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      set_attributes(li, li_data);
      toggle_class(li, "bx--side-nav__divider", true);
      add_location(li, file194, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(li, li_data = get_spread_update(li_levels, [{ role: "separator" }, dirty & 1 && ctx2[0]]));
      toggle_class(li, "bx--side-nav__divider", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment206.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance206($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SideNavDivider", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var SideNavDivider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance206, create_fragment206, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SideNavDivider",
      options,
      id: create_fragment206.name
    });
  }
};
var SideNavDivider_default = SideNavDivider;
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  AccordionSkeleton_default as AccordionSkeleton,
  AspectRatio_default as AspectRatio,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  BreadcrumbSkeleton_default as BreadcrumbSkeleton,
  Breakpoint_default as Breakpoint,
  Button_default as Button,
  ButtonSet_default as ButtonSet,
  ButtonSkeleton_default as ButtonSkeleton,
  Checkbox_default as Checkbox,
  CheckboxSkeleton_default as CheckboxSkeleton,
  ClickableTile_default as ClickableTile,
  CodeSnippet_default as CodeSnippet,
  CodeSnippetSkeleton_default as CodeSnippetSkeleton,
  Column_default as Column,
  ComboBox_default as ComboBox,
  ComposedModal_default as ComposedModal,
  Content_default as Content,
  ContentSwitcher_default as ContentSwitcher,
  ContextMenu_default as ContextMenu,
  ContextMenuDivider_default as ContextMenuDivider,
  ContextMenuGroup_default as ContextMenuGroup,
  ContextMenuOption_default as ContextMenuOption,
  ContextMenuRadioGroup_default as ContextMenuRadioGroup,
  CopyButton_default as CopyButton,
  DataTable_default as DataTable,
  DataTableSkeleton_default as DataTableSkeleton,
  DatePicker_default as DatePicker,
  DatePickerInput_default as DatePickerInput,
  DatePickerSkeleton_default as DatePickerSkeleton,
  Dropdown_default as Dropdown,
  DropdownSkeleton_default as DropdownSkeleton,
  ExpandableTile_default as ExpandableTile,
  FileUploader_default as FileUploader,
  FileUploaderButton_default as FileUploaderButton,
  FileUploaderDropContainer_default as FileUploaderDropContainer,
  FileUploaderItem_default as FileUploaderItem,
  FileUploaderSkeleton_default as FileUploaderSkeleton,
  Filename_default as Filename,
  FluidForm_default as FluidForm,
  Form_default as Form,
  FormGroup_default as FormGroup,
  FormItem_default as FormItem,
  FormLabel_default as FormLabel,
  Grid_default as Grid,
  Header_default as Header,
  HeaderAction_default as HeaderAction,
  HeaderActionLink_default as HeaderActionLink,
  HeaderGlobalAction_default as HeaderGlobalAction,
  HeaderNav_default as HeaderNav,
  HeaderNavItem_default as HeaderNavItem,
  HeaderNavMenu_default as HeaderNavMenu,
  HeaderPanelDivider_default as HeaderPanelDivider,
  HeaderPanelLink_default as HeaderPanelLink,
  HeaderPanelLinks_default as HeaderPanelLinks,
  HeaderSearch_default as HeaderSearch,
  HeaderUtilities_default as HeaderUtilities,
  ImageLoader_default as ImageLoader,
  InlineLoading_default as InlineLoading,
  InlineNotification_default as InlineNotification,
  Link_default as Link,
  ListBox_default as ListBox,
  ListBoxField_default as ListBoxField,
  ListBoxMenu_default as ListBoxMenu,
  ListBoxMenuIcon_default as ListBoxMenuIcon,
  ListBoxMenuItem_default as ListBoxMenuItem,
  ListBoxSelection_default as ListBoxSelection,
  ListItem_default as ListItem,
  Loading_default as Loading,
  LocalStorage_default as LocalStorage,
  Modal_default as Modal,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  MultiSelect_default as MultiSelect,
  NotificationActionButton_default as NotificationActionButton,
  NotificationButton_default as NotificationButton,
  NotificationIcon_default as NotificationIcon,
  NumberInput_default as NumberInput,
  NumberInputSkeleton_default as NumberInputSkeleton,
  OrderedList_default as OrderedList,
  OutboundLink_default as OutboundLink,
  OverflowMenu_default as OverflowMenu,
  OverflowMenuItem_default as OverflowMenuItem,
  Pagination_default as Pagination,
  PaginationNav_default as PaginationNav,
  PaginationSkeleton_default as PaginationSkeleton,
  PasswordInput_default as PasswordInput,
  Popover_default as Popover,
  ProgressBar_default as ProgressBar,
  ProgressIndicator_default as ProgressIndicator,
  ProgressIndicatorSkeleton_default as ProgressIndicatorSkeleton,
  ProgressStep_default as ProgressStep,
  RadioButton_default as RadioButton,
  RadioButtonGroup_default as RadioButtonGroup,
  RadioButtonSkeleton_default as RadioButtonSkeleton,
  RadioTile_default as RadioTile,
  RecursiveList_default as RecursiveList,
  Row_default as Row,
  Search_default as Search,
  SearchSkeleton_default as SearchSkeleton,
  Select_default as Select,
  SelectItem_default as SelectItem,
  SelectItemGroup_default as SelectItemGroup,
  SelectSkeleton_default as SelectSkeleton,
  SelectableTile_default as SelectableTile,
  SideNav_default as SideNav,
  SideNavDivider_default as SideNavDivider,
  SideNavItems_default as SideNavItems,
  SideNavLink_default as SideNavLink,
  SideNavMenu_default as SideNavMenu,
  SideNavMenuItem_default as SideNavMenuItem,
  SkeletonPlaceholder_default as SkeletonPlaceholder,
  SkeletonText_default as SkeletonText,
  SkipToContent_default as SkipToContent,
  Slider_default as Slider,
  SliderSkeleton_default as SliderSkeleton,
  StructuredList_default as StructuredList,
  StructuredListBody_default as StructuredListBody,
  StructuredListCell_default as StructuredListCell,
  StructuredListHead_default as StructuredListHead,
  StructuredListInput_default as StructuredListInput,
  StructuredListRow_default as StructuredListRow,
  StructuredListSkeleton_default as StructuredListSkeleton,
  Switch_default as Switch,
  Tab_default as Tab,
  TabContent_default as TabContent,
  Table_default as Table,
  TableBody_default as TableBody,
  TableCell_default as TableCell,
  TableContainer_default as TableContainer,
  TableHead_default as TableHead,
  TableHeader_default as TableHeader,
  TableRow_default as TableRow,
  Tabs_default as Tabs,
  TabsSkeleton_default as TabsSkeleton,
  Tag_default as Tag,
  TagSkeleton_default as TagSkeleton,
  TextArea_default as TextArea,
  TextAreaSkeleton_default as TextAreaSkeleton,
  TextInput_default as TextInput,
  TextInputSkeleton_default as TextInputSkeleton,
  Theme_default as Theme,
  Tile_default as Tile,
  TileGroup_default as TileGroup,
  TimePicker_default as TimePicker,
  TimePickerSelect_default as TimePickerSelect,
  ToastNotification_default as ToastNotification,
  Toggle_default as Toggle,
  ToggleSkeleton_default as ToggleSkeleton,
  Toolbar_default as Toolbar,
  ToolbarBatchActions_default as ToolbarBatchActions,
  ToolbarContent_default as ToolbarContent,
  ToolbarMenu_default as ToolbarMenu,
  ToolbarMenuItem_default as ToolbarMenuItem,
  ToolbarSearch_default as ToolbarSearch,
  Tooltip_default as Tooltip,
  TooltipDefinition_default as TooltipDefinition,
  TooltipFooter_default as TooltipFooter,
  TooltipIcon_default as TooltipIcon,
  TreeView_default as TreeView,
  Truncate_default as Truncate,
  UnorderedList_default as UnorderedList,
  breakpointObserver_default as breakpointObserver,
  breakpoints_default as breakpoints,
  truncate_default as truncate
};
//# sourceMappingURL=carbon-components-svelte.js.map
