import {
  MDCComponent,
  MDCFoundation,
  MDCRipple,
  MDCRippleFoundation,
  applyPassive,
  classMap,
  dispatch,
  dist_default,
  exclude,
  forwardEventsBuilder,
  matches,
  prefixFilter,
  useActions
} from "./chunk-QH7DRB7N.js";
import {
  __assign,
  __extends,
  __read,
  __spreadArray,
  __values
} from "./chunk-3L2CPHNC.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  compute_rest_props,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_current_component,
  get_spread_update,
  init,
  insert_dev,
  is_function,
  listen_dev,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  space,
  svg_element,
  validate_slots
} from "./chunk-NLMIYH64.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@material/switch/deprecated/constants.js
var cssClasses = {
  CHECKED: "mdc-switch--checked",
  DISABLED: "mdc-switch--disabled"
};
var strings = {
  ARIA_CHECKED_ATTR: "aria-checked",
  NATIVE_CONTROL_SELECTOR: ".mdc-switch__native-control",
  RIPPLE_SURFACE_SELECTOR: ".mdc-switch__thumb-underlay"
};

// node_modules/@material/switch/deprecated/foundation.js
var MDCSwitchFoundation = function(_super) {
  __extends(MDCSwitchFoundation3, _super);
  function MDCSwitchFoundation3(adapter) {
    return _super.call(this, __assign(__assign({}, MDCSwitchFoundation3.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCSwitchFoundation3, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSwitchFoundation3, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSwitchFoundation3, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        setNativeControlChecked: function() {
          return void 0;
        },
        setNativeControlDisabled: function() {
          return void 0;
        },
        setNativeControlAttr: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSwitchFoundation3.prototype.setChecked = function(checked) {
    this.adapter.setNativeControlChecked(checked);
    this.updateAriaChecked(checked);
    this.updateCheckedStyling(checked);
  };
  MDCSwitchFoundation3.prototype.setDisabled = function(disabled) {
    this.adapter.setNativeControlDisabled(disabled);
    if (disabled) {
      this.adapter.addClass(cssClasses.DISABLED);
    } else {
      this.adapter.removeClass(cssClasses.DISABLED);
    }
  };
  MDCSwitchFoundation3.prototype.handleChange = function(evt) {
    var nativeControl = evt.target;
    this.updateAriaChecked(nativeControl.checked);
    this.updateCheckedStyling(nativeControl.checked);
  };
  MDCSwitchFoundation3.prototype.updateCheckedStyling = function(checked) {
    if (checked) {
      this.adapter.addClass(cssClasses.CHECKED);
    } else {
      this.adapter.removeClass(cssClasses.CHECKED);
    }
  };
  MDCSwitchFoundation3.prototype.updateAriaChecked = function(checked) {
    this.adapter.setNativeControlAttr(strings.ARIA_CHECKED_ATTR, "" + !!checked);
  };
  return MDCSwitchFoundation3;
}(MDCFoundation);

// node_modules/@material/switch/deprecated/component.js
var MDCSwitch = function(_super) {
  __extends(MDCSwitch3, _super);
  function MDCSwitch3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.rippleSurface = _this.createRipple();
    return _this;
  }
  MDCSwitch3.attachTo = function(root) {
    return new MDCSwitch3(root);
  };
  MDCSwitch3.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.rippleSurface.destroy();
    this.nativeControl.removeEventListener("change", this.changeHandler);
  };
  MDCSwitch3.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.changeHandler = function() {
      var _a;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      (_a = _this.foundation).handleChange.apply(_a, __spreadArray([], __read(args)));
    };
    this.nativeControl.addEventListener("change", this.changeHandler);
    this.checked = this.checked;
  };
  MDCSwitch3.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      setNativeControlChecked: function(checked) {
        return _this.nativeControl.checked = checked;
      },
      setNativeControlDisabled: function(disabled) {
        return _this.nativeControl.disabled = disabled;
      },
      setNativeControlAttr: function(attr, value) {
        _this.nativeControl.setAttribute(attr, value);
      }
    };
    return new MDCSwitchFoundation(adapter);
  };
  Object.defineProperty(MDCSwitch3.prototype, "ripple", {
    get: function() {
      return this.rippleSurface;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSwitch3.prototype, "checked", {
    get: function() {
      return this.nativeControl.checked;
    },
    set: function(checked) {
      this.foundation.setChecked(checked);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSwitch3.prototype, "disabled", {
    get: function() {
      return this.nativeControl.disabled;
    },
    set: function(disabled) {
      this.foundation.setDisabled(disabled);
    },
    enumerable: false,
    configurable: true
  });
  MDCSwitch3.prototype.createRipple = function() {
    var _this = this;
    var RIPPLE_SURFACE_SELECTOR = MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
    var rippleSurface = this.root.querySelector(RIPPLE_SURFACE_SELECTOR);
    var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { addClass: function(className) {
      return rippleSurface.classList.add(className);
    }, computeBoundingRect: function() {
      return rippleSurface.getBoundingClientRect();
    }, deregisterInteractionHandler: function(evtType, handler) {
      _this.nativeControl.removeEventListener(evtType, handler, applyPassive());
    }, isSurfaceActive: function() {
      return matches(_this.nativeControl, ":active");
    }, isUnbounded: function() {
      return true;
    }, registerInteractionHandler: function(evtType, handler) {
      _this.nativeControl.addEventListener(evtType, handler, applyPassive());
    }, removeClass: function(className) {
      rippleSurface.classList.remove(className);
    }, updateCssVariable: function(varName, value) {
      rippleSurface.style.setProperty(varName, value);
    } });
    return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
  };
  Object.defineProperty(MDCSwitch3.prototype, "nativeControl", {
    get: function() {
      var NATIVE_CONTROL_SELECTOR = MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
      return this.root.querySelector(NATIVE_CONTROL_SELECTOR);
    },
    enumerable: false,
    configurable: true
  });
  return MDCSwitch3;
}(MDCComponent);

// node_modules/@material/switch/constants.js
var CssClasses;
(function(CssClasses2) {
  CssClasses2["PROCESSING"] = "mdc-switch--processing";
  CssClasses2["SELECTED"] = "mdc-switch--selected";
  CssClasses2["UNSELECTED"] = "mdc-switch--unselected";
})(CssClasses || (CssClasses = {}));
var Selectors;
(function(Selectors2) {
  Selectors2["RIPPLE"] = ".mdc-switch__ripple";
})(Selectors || (Selectors = {}));

// node_modules/@material/base/observer.js
function observeProperty(target, property, observer) {
  var targetObservers = installObserver(target, property);
  var observers = targetObservers.getObservers(property);
  observers.push(observer);
  return function() {
    observers.splice(observers.indexOf(observer), 1);
  };
}
var allTargetObservers = /* @__PURE__ */ new WeakMap();
function installObserver(target, property) {
  var observersMap = /* @__PURE__ */ new Map();
  if (!allTargetObservers.has(target)) {
    allTargetObservers.set(target, {
      isEnabled: true,
      getObservers: function(key) {
        var observers = observersMap.get(key) || [];
        if (!observersMap.has(key)) {
          observersMap.set(key, observers);
        }
        return observers;
      },
      installedProperties: /* @__PURE__ */ new Set()
    });
  }
  var targetObservers = allTargetObservers.get(target);
  if (targetObservers.installedProperties.has(property)) {
    return targetObservers;
  }
  var descriptor = getDescriptor(target, property) || {
    configurable: true,
    enumerable: true,
    value: target[property],
    writable: true
  };
  var observedDescriptor = __assign({}, descriptor);
  var descGet = descriptor.get, descSet = descriptor.set;
  if ("value" in descriptor) {
    delete observedDescriptor.value;
    delete observedDescriptor.writable;
    var value_1 = descriptor.value;
    descGet = function() {
      return value_1;
    };
    if (descriptor.writable) {
      descSet = function(newValue) {
        value_1 = newValue;
      };
    }
  }
  if (descGet) {
    observedDescriptor.get = function() {
      return descGet.call(this);
    };
  }
  if (descSet) {
    observedDescriptor.set = function(newValue) {
      var e_4, _a;
      var previous = descGet ? descGet.call(this) : newValue;
      descSet.call(this, newValue);
      if (targetObservers.isEnabled && (!descGet || newValue !== previous)) {
        try {
          for (var _b = __values(targetObservers.getObservers(property)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer(newValue, previous);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
    };
  }
  targetObservers.installedProperties.add(property);
  Object.defineProperty(target, property, observedDescriptor);
  return targetObservers;
}
function getDescriptor(target, property) {
  var descriptorTarget = target;
  var descriptor;
  while (descriptorTarget) {
    descriptor = Object.getOwnPropertyDescriptor(descriptorTarget, property);
    if (descriptor) {
      break;
    }
    descriptorTarget = Object.getPrototypeOf(descriptorTarget);
  }
  return descriptor;
}
function setObserversEnabled(target, enabled) {
  var targetObservers = allTargetObservers.get(target);
  if (targetObservers) {
    targetObservers.isEnabled = enabled;
  }
}

// node_modules/@material/base/observer-foundation.js
var MDCObserverFoundation = function(_super) {
  __extends(MDCObserverFoundation2, _super);
  function MDCObserverFoundation2(adapter) {
    var _this = _super.call(this, adapter) || this;
    _this.unobserves = /* @__PURE__ */ new Set();
    return _this;
  }
  MDCObserverFoundation2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.unobserve();
  };
  MDCObserverFoundation2.prototype.observe = function(target, observers) {
    var e_1, _a;
    var _this = this;
    var cleanup = [];
    try {
      for (var _b = __values(Object.keys(observers)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var property = _c.value;
        var observer = observers[property].bind(this);
        cleanup.push(this.observeProperty(target, property, observer));
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var unobserve = function() {
      var e_2, _a2;
      try {
        for (var cleanup_1 = __values(cleanup), cleanup_1_1 = cleanup_1.next(); !cleanup_1_1.done; cleanup_1_1 = cleanup_1.next()) {
          var cleanupFn = cleanup_1_1.value;
          cleanupFn();
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (cleanup_1_1 && !cleanup_1_1.done && (_a2 = cleanup_1.return))
            _a2.call(cleanup_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      _this.unobserves.delete(unobserve);
    };
    this.unobserves.add(unobserve);
    return unobserve;
  };
  MDCObserverFoundation2.prototype.observeProperty = function(target, property, observer) {
    return observeProperty(target, property, observer);
  };
  MDCObserverFoundation2.prototype.setObserversEnabled = function(target, enabled) {
    setObserversEnabled(target, enabled);
  };
  MDCObserverFoundation2.prototype.unobserve = function() {
    var e_3, _a;
    try {
      for (var _b = __values(__spreadArray([], __read(this.unobserves))), _c = _b.next(); !_c.done; _c = _b.next()) {
        var unobserve = _c.value;
        unobserve();
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  return MDCObserverFoundation2;
}(MDCFoundation);

// node_modules/@material/switch/foundation.js
var MDCSwitchFoundation2 = function(_super) {
  __extends(MDCSwitchFoundation3, _super);
  function MDCSwitchFoundation3(adapter) {
    var _this = _super.call(this, adapter) || this;
    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }
  MDCSwitchFoundation3.prototype.init = function() {
    this.observe(this.adapter.state, {
      disabled: this.stopProcessingIfDisabled,
      processing: this.stopProcessingIfDisabled
    });
  };
  MDCSwitchFoundation3.prototype.handleClick = function() {
    if (this.adapter.state.disabled) {
      return;
    }
    this.adapter.state.selected = !this.adapter.state.selected;
  };
  MDCSwitchFoundation3.prototype.stopProcessingIfDisabled = function() {
    if (this.adapter.state.disabled) {
      this.adapter.state.processing = false;
    }
  };
  return MDCSwitchFoundation3;
}(MDCObserverFoundation);
var MDCSwitchRenderFoundation = function(_super) {
  __extends(MDCSwitchRenderFoundation2, _super);
  function MDCSwitchRenderFoundation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSwitchRenderFoundation2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.observe(this.adapter.state, {
      disabled: this.onDisabledChange,
      processing: this.onProcessingChange,
      selected: this.onSelectedChange
    });
  };
  MDCSwitchRenderFoundation2.prototype.initFromDOM = function() {
    this.setObserversEnabled(this.adapter.state, false);
    this.adapter.state.selected = this.adapter.hasClass(CssClasses.SELECTED);
    this.onSelectedChange();
    this.adapter.state.disabled = this.adapter.isDisabled();
    this.adapter.state.processing = this.adapter.hasClass(CssClasses.PROCESSING);
    this.setObserversEnabled(this.adapter.state, true);
    this.stopProcessingIfDisabled();
  };
  MDCSwitchRenderFoundation2.prototype.onDisabledChange = function() {
    this.adapter.setDisabled(this.adapter.state.disabled);
  };
  MDCSwitchRenderFoundation2.prototype.onProcessingChange = function() {
    this.toggleClass(this.adapter.state.processing, CssClasses.PROCESSING);
  };
  MDCSwitchRenderFoundation2.prototype.onSelectedChange = function() {
    this.adapter.setAriaChecked(String(this.adapter.state.selected));
    this.toggleClass(this.adapter.state.selected, CssClasses.SELECTED);
    this.toggleClass(!this.adapter.state.selected, CssClasses.UNSELECTED);
  };
  MDCSwitchRenderFoundation2.prototype.toggleClass = function(addClass, className) {
    if (addClass) {
      this.adapter.addClass(className);
    } else {
      this.adapter.removeClass(className);
    }
  };
  return MDCSwitchRenderFoundation2;
}(MDCSwitchFoundation2);

// node_modules/@material/switch/component.js
var MDCSwitch2 = function(_super) {
  __extends(MDCSwitch3, _super);
  function MDCSwitch3(root, foundation) {
    var _this = _super.call(this, root, foundation) || this;
    _this.root = root;
    return _this;
  }
  MDCSwitch3.attachTo = function(root) {
    return new MDCSwitch3(root);
  };
  MDCSwitch3.prototype.initialize = function() {
    this.ripple = new MDCRipple(this.root, this.createRippleFoundation());
  };
  MDCSwitch3.prototype.initialSyncWithDOM = function() {
    var rippleElement = this.root.querySelector(Selectors.RIPPLE);
    if (!rippleElement) {
      throw new Error("Switch " + Selectors.RIPPLE + " element is required.");
    }
    this.rippleElement = rippleElement;
    this.root.addEventListener("click", this.foundation.handleClick);
    this.foundation.initFromDOM();
  };
  MDCSwitch3.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.ripple.destroy();
    this.root.removeEventListener("click", this.foundation.handleClick);
  };
  MDCSwitch3.prototype.getDefaultFoundation = function() {
    return new MDCSwitchRenderFoundation(this.createAdapter());
  };
  MDCSwitch3.prototype.createAdapter = function() {
    var _this = this;
    return {
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      isDisabled: function() {
        return _this.root.disabled;
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      setAriaChecked: function(ariaChecked) {
        return _this.root.setAttribute("aria-checked", ariaChecked);
      },
      setDisabled: function(disabled) {
        _this.root.disabled = disabled;
      },
      state: this
    };
  };
  MDCSwitch3.prototype.createRippleFoundation = function() {
    return new MDCRippleFoundation(this.createRippleAdapter());
  };
  MDCSwitch3.prototype.createRippleAdapter = function() {
    var _this = this;
    return __assign(__assign({}, MDCRipple.createAdapter(this)), { computeBoundingRect: function() {
      return _this.rippleElement.getBoundingClientRect();
    }, isUnbounded: function() {
      return true;
    } });
  };
  return MDCSwitch3;
}(MDCComponent);

// node_modules/@smui/switch/dist/Switch.svelte
var file = "node_modules/@smui/switch/dist/Switch.svelte";
function create_if_block_1(ctx) {
  let div;
  let svg0;
  let path0;
  let t;
  let svg1;
  let path1;
  let div_class_value;
  let useActions_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[8]]: true,
        "mdc-switch__icons": true
      })
    },
    prefixFilter(ctx[19], "icons$")
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t = space();
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      attr_dev(path0, "d", "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z");
      add_location(path0, file, 51, 12, 1407);
      attr_dev(svg0, "class", "mdc-switch__icon mdc-switch__icon--on");
      attr_dev(svg0, "viewBox", "0 0 24 24");
      add_location(svg0, file, 47, 10, 1288);
      attr_dev(path1, "d", "M20 13H4v-2h16v2z");
      add_location(path1, file, 59, 12, 1661);
      attr_dev(svg1, "class", "mdc-switch__icon mdc-switch__icon--off");
      attr_dev(svg1, "viewBox", "0 0 24 24");
      add_location(svg1, file, 55, 10, 1541);
      set_attributes(div, div_data);
      add_location(div, file, 39, 8, 1061);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg0);
      append_dev(svg0, path0);
      append_dev(div, t);
      append_dev(div, svg1);
      append_dev(svg1, path1);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(null, div, ctx[7]));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & 256 && div_class_value !== (div_class_value = classMap({
          [ctx2[8]]: true,
          "mdc-switch__icons": true
        })) && { class: div_class_value },
        dirty[0] & 524288 && prefixFilter(ctx2[19], "icons$")
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 128)
        useActions_action.update.call(null, ctx2[7]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(39:6) {#if icons}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div1;
  let div0;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      attr_dev(div0, "class", "mdc-switch__focus-ring");
      add_location(div0, file, 67, 6, 1829);
      attr_dev(div1, "class", "mdc-switch__focus-ring-wrapper");
      add_location(div1, file, 66, 4, 1778);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(66:2) {#if focusRing}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let button;
  let div0;
  let t0;
  let div5;
  let div4;
  let div2;
  let div1;
  let t1;
  let div3;
  let t2;
  let t3;
  let button_class_value;
  let button_aria_checked_value;
  let useActions_action;
  let forwardEvents_action;
  let Ripple_action;
  let mounted;
  let dispose;
  let if_block0 = ctx[6] && create_if_block_1(ctx);
  let if_block1 = ctx[4] && create_if_block(ctx);
  let button_levels = [
    {
      class: button_class_value = classMap({
        [ctx[3]]: true,
        "mdc-switch": true,
        "mdc-switch--unselected": !ctx[10],
        "mdc-switch--selected": ctx[10],
        "mdc-switch--processing": ctx[1],
        "smui-switch--color-secondary": ctx[5] === "secondary",
        ...ctx[12]
      })
    },
    { type: "button" },
    { role: "switch" },
    {
      "aria-checked": button_aria_checked_value = ctx[10] ? "true" : "false"
    },
    { disabled: ctx[0] },
    ctx[16],
    exclude(ctx[19], ["icons$"])
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      t1 = space();
      div3 = element("div");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div0, "class", "mdc-switch__track");
      add_location(div0, file, 31, 2, 758);
      attr_dev(div1, "class", "mdc-elevation-overlay");
      add_location(div1, file, 35, 8, 917);
      attr_dev(div2, "class", "mdc-switch__shadow");
      add_location(div2, file, 34, 6, 876);
      attr_dev(div3, "class", "mdc-switch__ripple");
      add_location(div3, file, 37, 6, 974);
      attr_dev(div4, "class", "mdc-switch__handle");
      add_location(div4, file, 33, 4, 837);
      attr_dev(div5, "class", "mdc-switch__handle-track");
      add_location(div5, file, 32, 2, 794);
      set_attributes(button, button_data);
      add_location(button, file, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, div0);
      append_dev(button, t0);
      append_dev(button, div5);
      append_dev(div5, div4);
      append_dev(div4, div2);
      append_dev(div2, div1);
      append_dev(div4, t1);
      append_dev(div4, div3);
      ctx[28](div3);
      append_dev(div4, t2);
      if (if_block0)
        if_block0.m(div4, null);
      append_dev(button, t3);
      if (if_block1)
        if_block1.m(button, null);
      if (button.autofocus)
        button.focus();
      ctx[29](button);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, button, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[15].call(null, button)),
          action_destroyer(Ripple_action = dist_default.call(null, button, {
            unbounded: true,
            color: ctx[5],
            active: ctx[14],
            rippleElement: ctx[13],
            disabled: ctx[0],
            addClass: ctx[17],
            removeClass: ctx[18]
          })),
          listen_dev(button, "click", ctx[30], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div4, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty[0] & 5162 && button_class_value !== (button_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-switch": true,
          "mdc-switch--unselected": !ctx2[10],
          "mdc-switch--selected": ctx2[10],
          "mdc-switch--processing": ctx2[1],
          "smui-switch--color-secondary": ctx2[5] === "secondary",
          ...ctx2[12]
        })) && { class: button_class_value },
        { type: "button" },
        { role: "switch" },
        dirty[0] & 1024 && button_aria_checked_value !== (button_aria_checked_value = ctx2[10] ? "true" : "false") && {
          "aria-checked": button_aria_checked_value
        },
        dirty[0] & 1 && { disabled: ctx2[0] },
        ctx2[16],
        dirty[0] & 524288 && exclude(ctx2[19], ["icons$"])
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 4)
        useActions_action.update.call(null, ctx2[2]);
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 24609)
        Ripple_action.update.call(null, {
          unbounded: true,
          color: ctx2[5],
          active: ctx2[14],
          rippleElement: ctx2[13],
          disabled: ctx2[0],
          addClass: ctx2[17],
          removeClass: ctx2[18]
        });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      ctx[28](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "disabled",
    "focusRing",
    "color",
    "group",
    "checked",
    "value",
    "processing",
    "icons",
    "icons$use",
    "icons$class",
    "getId",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, []);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { focusRing = false } = $$props;
  let { color = "primary" } = $$props;
  let { group = uninitializedValue } = $$props;
  let { checked = uninitializedValue } = $$props;
  let { value = null } = $$props;
  let { processing = false } = $$props;
  let { icons = true } = $$props;
  let { icons$use = [] } = $$props;
  let { icons$class = "" } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let rippleElement;
  let rippleActive = false;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let selected = isUninitializedValue(group) ? isUninitializedValue(checked) ? false : checked : group.indexOf(value) !== -1;
  let state = {
    get disabled() {
      return disabled;
    },
    set disabled(value2) {
      $$invalidate(0, disabled = value2);
    },
    get processing() {
      return processing;
    },
    set processing(value2) {
      $$invalidate(1, processing = value2);
    },
    get selected() {
      return selected;
    },
    set selected(value2) {
      $$invalidate(10, selected = value2);
    }
  };
  let previousChecked = checked;
  let previousGroup = isUninitializedValue(group) ? [] : [...group];
  let previousSelected = selected;
  onMount(() => {
    $$invalidate(11, instance = new MDCSwitchRenderFoundation({
      addClass,
      hasClass,
      isDisabled: () => disabled,
      removeClass,
      setAriaChecked: () => {
      },
      setDisabled: (value2) => {
        $$invalidate(0, disabled = value2);
      },
      state
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get checked() {
        return selected;
      },
      set checked(checked2) {
        if (selected !== checked2) {
          state.selected = checked2;
          if (element2) {
            dispatch(element2, "SMUISwitch:change", { selected: checked2, value });
          }
        }
      },
      activateRipple() {
        if (!disabled) {
          $$invalidate(14, rippleActive = true);
        }
      },
      deactivateRipple() {
        $$invalidate(14, rippleActive = false);
      }
    };
    dispatch(element2, "SMUIGenericInput:mount", accessor);
    instance.init();
    instance.initFromDOM();
    return () => {
      dispatch(element2, "SMUIGenericInput:unmount", accessor);
      instance.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function getId() {
    return inputProps && inputProps.id;
  }
  function getElement() {
    return element2;
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleElement = $$value;
      $$invalidate(13, rippleElement);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  const click_handler = () => instance && instance.handleClick();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("focusRing" in $$new_props)
      $$invalidate(4, focusRing = $$new_props.focusRing);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("group" in $$new_props)
      $$invalidate(20, group = $$new_props.group);
    if ("checked" in $$new_props)
      $$invalidate(21, checked = $$new_props.checked);
    if ("value" in $$new_props)
      $$invalidate(22, value = $$new_props.value);
    if ("processing" in $$new_props)
      $$invalidate(1, processing = $$new_props.processing);
    if ("icons" in $$new_props)
      $$invalidate(6, icons = $$new_props.icons);
    if ("icons$use" in $$new_props)
      $$invalidate(7, icons$use = $$new_props.icons$use);
    if ("icons$class" in $$new_props)
      $$invalidate(8, icons$class = $$new_props.icons$class);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCSwitchRenderFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    disabled,
    focusRing,
    color,
    group,
    checked,
    value,
    processing,
    icons,
    icons$use,
    icons$class,
    element: element2,
    instance,
    internalClasses,
    rippleElement,
    rippleActive,
    inputProps,
    selected,
    state,
    previousChecked,
    previousGroup,
    previousSelected,
    hasClass,
    addClass,
    removeClass,
    getId,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("focusRing" in $$props)
      $$invalidate(4, focusRing = $$new_props.focusRing);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("group" in $$props)
      $$invalidate(20, group = $$new_props.group);
    if ("checked" in $$props)
      $$invalidate(21, checked = $$new_props.checked);
    if ("value" in $$props)
      $$invalidate(22, value = $$new_props.value);
    if ("processing" in $$props)
      $$invalidate(1, processing = $$new_props.processing);
    if ("icons" in $$props)
      $$invalidate(6, icons = $$new_props.icons);
    if ("icons$use" in $$props)
      $$invalidate(7, icons$use = $$new_props.icons$use);
    if ("icons$class" in $$props)
      $$invalidate(8, icons$class = $$new_props.icons$class);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(11, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("rippleElement" in $$props)
      $$invalidate(13, rippleElement = $$new_props.rippleElement);
    if ("rippleActive" in $$props)
      $$invalidate(14, rippleActive = $$new_props.rippleActive);
    if ("inputProps" in $$props)
      $$invalidate(16, inputProps = $$new_props.inputProps);
    if ("selected" in $$props)
      $$invalidate(10, selected = $$new_props.selected);
    if ("state" in $$props)
      state = $$new_props.state;
    if ("previousChecked" in $$props)
      $$invalidate(25, previousChecked = $$new_props.previousChecked);
    if ("previousGroup" in $$props)
      $$invalidate(26, previousGroup = $$new_props.previousGroup);
    if ("previousSelected" in $$props)
      $$invalidate(27, previousSelected = $$new_props.previousSelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 242222592) {
      $: {
        let notifyChange = false;
        if (!isUninitializedValue(group)) {
          if (previousSelected !== selected) {
            const idx = group.indexOf(value);
            if (selected && idx === -1) {
              group.push(value);
              $$invalidate(20, group), $$invalidate(27, previousSelected), $$invalidate(10, selected), $$invalidate(22, value), $$invalidate(26, previousGroup), $$invalidate(21, checked), $$invalidate(25, previousChecked), $$invalidate(9, element2);
            } else if (!selected && idx !== -1) {
              group.splice(idx, 1);
              $$invalidate(20, group), $$invalidate(27, previousSelected), $$invalidate(10, selected), $$invalidate(22, value), $$invalidate(26, previousGroup), $$invalidate(21, checked), $$invalidate(25, previousChecked), $$invalidate(9, element2);
            }
            notifyChange = true;
          } else {
            const idxPrev = previousGroup.indexOf(value);
            const idx = group.indexOf(value);
            if (idxPrev > -1 && idx === -1) {
              state.selected = false;
            } else if (idx > -1 && idxPrev === -1) {
              state.selected = true;
            }
          }
        }
        if (isUninitializedValue(checked)) {
          if (previousSelected !== selected) {
            notifyChange = true;
          }
        } else if (checked !== selected) {
          if (checked === previousChecked) {
            $$invalidate(21, checked = selected);
            notifyChange = true;
          } else {
            state.selected = checked;
          }
        }
        $$invalidate(25, previousChecked = checked);
        $$invalidate(26, previousGroup = isUninitializedValue(group) ? [] : [...group]);
        $$invalidate(27, previousSelected = selected);
        if (notifyChange && element2) {
          dispatch(element2, "SMUISwitch:change", { selected, value });
        }
      }
    }
  };
  return [
    disabled,
    processing,
    use,
    className,
    focusRing,
    color,
    icons,
    icons$use,
    icons$class,
    element2,
    selected,
    instance,
    internalClasses,
    rippleElement,
    rippleActive,
    forwardEvents,
    inputProps,
    addClass,
    removeClass,
    $$restProps,
    group,
    checked,
    value,
    getId,
    getElement,
    previousChecked,
    previousGroup,
    previousSelected,
    div3_binding,
    button_binding,
    click_handler
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        disabled: 0,
        focusRing: 4,
        color: 5,
        group: 20,
        checked: 21,
        value: 22,
        processing: 1,
        icons: 6,
        icons$use: 7,
        icons$class: 8,
        getId: 23,
        getElement: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusRing() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusRing(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get processing() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set processing(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons$use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons$use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons$class() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons$class(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    return this.$$.ctx[23];
  }
  set getId(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[24];
  }
  set getElement(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/@smui/switch/dist/index.js
var dist_default2 = Switch_default;
export {
  dist_default2 as default
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2021 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@smui_switch.js.map
