<svelte:component
  this={component}
  {tag}
  bind:this={element}
  use={[
    ...(nonInteractive
      ? []
      : [
          [
            Ripple,
            {
              ripple: !input,
              unbounded: false,
              color:
                (activated || selected) && color == null ? 'primary' : color,
              disabled,
              addClass,
              removeClass,
              addStyle,
            },
          ],
        ]),
    forwardEvents,
    ...use,
  ]}
  class={classMap({
    [className]: true,
    'mdc-deprecated-list-item': !wrapper,
    'mdc-deprecated-list-item__wrapper': wrapper,
    'mdc-deprecated-list-item--activated': activated,
    'mdc-deprecated-list-item--selected': selected,
    'mdc-deprecated-list-item--disabled': disabled,
    'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,
    'smui-menu-item--non-interactive': nonInteractive,
    ...internalClasses,
  })}
  style={Object.entries(internalStyles)
    .map(([name, value]) => `${name}: ${value};`)
    .concat([style])
    .join(' ')}
  {...nav && activated ? { 'aria-current': 'page' } : {}}
  {...!nav || wrapper ? { role } : {}}
  {...!nav && role === 'option'
    ? { 'aria-selected': selected ? 'true' : 'false' }
    : {}}
  {...!nav && (role === 'radio' || role === 'checkbox')
    ? { 'aria-checked': input && input.checked ? 'true' : 'false' }
    : {}}
  {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}
  data-menu-item-skip-restore-focus={skipRestoreFocus || undefined}
  {tabindex}
  on:click={action}
  on:keydown={handleKeydown}
  on:SMUIGenericInput:mount={handleInputMount}
  on:SMUIGenericInput:unmount={() => (input = undefined)}
  {href}
  {...internalAttrs}
  {...$$restProps}
  >{#if ripple}<span class="mdc-deprecated-list-item__ripple" />{/if}<slot
  /></svelte:component
>

<script context="module">"use strict";
let counter = 0;
</script>

<script>var _a;
import { onMount, onDestroy, getContext, setContext } from 'svelte';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, dispatch, } from '@smui/common/internal';
import Ripple from '@smui/ripple';
import { SmuiElement } from '@smui/common';
const forwardEvents = forwardEventsBuilder(get_current_component());
let uninitializedValue = () => { };
function isUninitializedValue(value) {
    return value === uninitializedValue;
}
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let style = '';
export let color = undefined;
export let nonInteractive = (_a = getContext('SMUI:list:nonInteractive')) !== null && _a !== void 0 ? _a : false;
setContext('SMUI:list:nonInteractive', undefined);
export let ripple = !nonInteractive;
export let wrapper = false;
export let activated = false;
export let role = wrapper
    ? 'presentation'
    : getContext('SMUI:list:item:role');
setContext('SMUI:list:item:role', undefined);
export let selected = false;
export let disabled = false;
export let skipRestoreFocus = false;
let tabindexProp = uninitializedValue;
export { tabindexProp as tabindex };
export let inputId = 'SMUI-form-field-list-' + counter++;
export let href = undefined;
let element;
let internalClasses = {};
let internalStyles = {};
let internalAttrs = {};
let input;
let addTabindexIfNoItemsSelectedRaf;
let nav = getContext('SMUI:list:item:nav');
$: tabindex = isUninitializedValue(tabindexProp)
    ? !nonInteractive && !disabled && (selected || (input && input.checked))
        ? 0
        : -1
    : tabindexProp;
export let component = SmuiElement;
export let tag = (component === SmuiElement
    ? nav
        ? href
            ? 'a'
            : 'span'
        : 'li'
    : undefined);
setContext('SMUI:generic:input:props', { id: inputId });
// Reset separator context, because we aren't directly under a list anymore.
setContext('SMUI:separator:context', undefined);
onMount(() => {
    // Tabindex needs to be '0' if this is the first non-disabled list item, and
    // no other item is selected.
    if (!selected && !nonInteractive) {
        let first = true;
        let el = element;
        while (el.previousSibling) {
            el = el.previousSibling;
            if (el.nodeType === 1 &&
                el.classList.contains('mdc-deprecated-list-item') &&
                !el.classList.contains('mdc-deprecated-list-item--disabled')) {
                first = false;
                break;
            }
        }
        if (first) {
            // This is first, so now set up a check that no other items are
            // selected.
            addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(addTabindexIfNoItemsSelected);
        }
    }
    const accessor = {
        _smui_list_item_accessor: true,
        get element() {
            return getElement();
        },
        get selected() {
            return selected;
        },
        set selected(value) {
            selected = value;
        },
        hasClass,
        addClass,
        removeClass,
        getAttr,
        addAttr,
        removeAttr,
        getPrimaryText,
        // For inputs within item.
        get checked() {
            var _a;
            return (_a = (input && input.checked)) !== null && _a !== void 0 ? _a : false;
        },
        set checked(value) {
            if (input) {
                input.checked = !!value;
            }
        },
        get hasCheckbox() {
            return !!(input && '_smui_checkbox_accessor' in input);
        },
        get hasRadio() {
            return !!(input && '_smui_radio_accessor' in input);
        },
        activateRipple() {
            if (input) {
                input.activateRipple();
            }
        },
        deactivateRipple() {
            if (input) {
                input.deactivateRipple();
            }
        },
        // For select options.
        getValue() {
            return $$restProps.value;
        },
        // For autocomplete
        action,
        get tabindex() {
            return tabindex;
        },
        set tabindex(value) {
            tabindexProp = value;
        },
        get disabled() {
            return disabled;
        },
        get activated() {
            return activated;
        },
        set activated(value) {
            activated = value;
        },
    };
    dispatch(getElement(), 'SMUIListItem:mount', accessor);
    return () => {
        dispatch(getElement(), 'SMUIListItem:unmount', accessor);
    };
});
onDestroy(() => {
    if (addTabindexIfNoItemsSelectedRaf) {
        window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    }
});
function hasClass(className) {
    return className in internalClasses
        ? internalClasses[className]
        : getElement().classList.contains(className);
}
function addClass(className) {
    if (!internalClasses[className]) {
        internalClasses[className] = true;
    }
}
function removeClass(className) {
    if (!(className in internalClasses) || internalClasses[className]) {
        internalClasses[className] = false;
    }
}
function addStyle(name, value) {
    if (internalStyles[name] != value) {
        if (value === '' || value == null) {
            delete internalStyles[name];
            internalStyles = internalStyles;
        }
        else {
            internalStyles[name] = value;
        }
    }
}
function getAttr(name) {
    var _a;
    return name in internalAttrs
        ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null
        : getElement().getAttribute(name);
}
function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
        internalAttrs[name] = value;
    }
}
function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
        internalAttrs[name] = undefined;
    }
}
function addTabindexIfNoItemsSelected() {
    // Look through next siblings to see if none of them are selected.
    let noneSelected = true;
    let el = element.getElement();
    while (el.nextElementSibling) {
        el = el.nextElementSibling;
        if (el.nodeType === 1 &&
            el.classList.contains('mdc-deprecated-list-item')) {
            const tabindexAttr = el.attributes.getNamedItem('tabindex');
            if (tabindexAttr && tabindexAttr.value === '0') {
                noneSelected = false;
                break;
            }
        }
    }
    if (noneSelected) {
        // This is the first element, and no other element is selected, so the
        // tabindex should be '0'.
        tabindex = 0;
    }
}
function handleKeydown(e) {
    const isEnter = e.key === 'Enter';
    const isSpace = e.key === 'Space';
    if (isEnter || isSpace) {
        action(e);
    }
}
function handleInputMount(e) {
    if ('_smui_checkbox_accessor' in e.detail ||
        '_smui_radio_accessor' in e.detail) {
        input = e.detail;
    }
}
export function action(e) {
    if (!disabled) {
        dispatch(getElement(), 'SMUI:action', e);
    }
}
export function getPrimaryText() {
    var _a, _b, _c;
    const element = getElement();
    const primaryText = element.querySelector('.mdc-deprecated-list-item__primary-text');
    if (primaryText) {
        return (_a = primaryText.textContent) !== null && _a !== void 0 ? _a : '';
    }
    const text = element.querySelector('.mdc-deprecated-list-item__text');
    if (text) {
        return (_b = text.textContent) !== null && _b !== void 0 ? _b : '';
    }
    return (_c = element.textContent) !== null && _c !== void 0 ? _c : '';
}
export function getElement() {
    return element.getElement();
}
</script>
