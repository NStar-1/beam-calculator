<svelte:component
  this={component}
  {tag}
  bind:this={element}
  use={[forwardEvents, ...use]}
  class={classMap({
    [className]: true,
    'mdc-deprecated-list': true,
    'mdc-deprecated-list--non-interactive': nonInteractive,
    'mdc-deprecated-list--dense': dense,
    'mdc-deprecated-list--textual-list': textualList,
    'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,
    'mdc-deprecated-list--icon-list': iconList,
    'mdc-deprecated-list--image-list': imageList,
    'mdc-deprecated-list--thumbnail-list': thumbnailList,
    'mdc-deprecated-list--video-list': videoList,
    'mdc-deprecated-list--two-line': twoLine,
    'smui-list--three-line': threeLine && !twoLine,
  })}
  {role}
  on:keydown={handleKeydown}
  on:focusin={handleFocusin}
  on:focusout={handleFocusout}
  on:click={handleClick}
  on:SMUIListItem:mount={handleItemMount}
  on:SMUIListItem:unmount={handleItemUnmount}
  on:SMUI:action={handleAction}
  {...$$restProps}
>
  <slot />
</svelte:component>

<script>var _a;
import { MDCListFoundation } from '@material/list';
import { ponyfill } from '@material/dom';
import { onMount, onDestroy, getContext, setContext } from 'svelte';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, dispatch, } from '@smui/common/internal';
import { SmuiElement } from '@smui/common';
const { closest, matches } = ponyfill;
const forwardEvents = forwardEventsBuilder(get_current_component());
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let nonInteractive = false;
export let dense = false;
export let textualList = false;
export let avatarList = false;
export let iconList = false;
export let imageList = false;
export let thumbnailList = false;
export let videoList = false;
export let twoLine = false;
export let threeLine = false;
export let vertical = true;
export let wrapFocus = (_a = getContext('SMUI:list:wrapFocus')) !== null && _a !== void 0 ? _a : false;
export let singleSelection = false;
export let disabledItemsFocusable = false;
export let selectedIndex = -1;
export let radioList = false;
export let checkList = false;
export let hasTypeahead = false;
let element;
let instance;
let items = [];
let role = getContext('SMUI:list:role');
let nav = getContext('SMUI:list:nav');
const itemAccessorMap = new WeakMap();
let selectionDialog = getContext('SMUI:dialog:selection');
let addLayoutListener = getContext('SMUI:addLayoutListener');
let removeLayoutListener;
export let component = SmuiElement;
export let tag = (component === SmuiElement
    ? nav
        ? 'nav'
        : 'ul'
    : undefined);
setContext('SMUI:list:nonInteractive', nonInteractive);
setContext('SMUI:separator:context', 'list');
if (!role) {
    if (singleSelection) {
        role = 'listbox';
        setContext('SMUI:list:item:role', 'option');
    }
    else if (radioList) {
        role = 'radiogroup';
        setContext('SMUI:list:item:role', 'radio');
    }
    else if (checkList) {
        role = 'group';
        setContext('SMUI:list:item:role', 'checkbox');
    }
    else {
        role = 'list';
        setContext('SMUI:list:item:role', undefined);
    }
}
$: if (instance) {
    instance.setVerticalOrientation(vertical);
}
$: if (instance) {
    instance.setWrapFocus(wrapFocus);
}
$: if (instance) {
    instance.setHasTypeahead(hasTypeahead);
}
$: if (instance) {
    instance.setSingleSelection(singleSelection);
}
$: if (instance) {
    instance.setDisabledItemsFocusable(disabledItemsFocusable);
}
$: if (instance && singleSelection && getSelectedIndex() !== selectedIndex) {
    instance.setSelectedIndex(selectedIndex);
}
if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
}
onMount(() => {
    instance = new MDCListFoundation({
        addClassForElementIndex,
        focusItemAtIndex,
        getAttributeForElementIndex: (index, name) => { var _a, _b; return (_b = (_a = getOrderedList()[index]) === null || _a === void 0 ? void 0 : _a.getAttr(name)) !== null && _b !== void 0 ? _b : null; },
        getFocusedElementIndex: () => document.activeElement
            ? getOrderedList()
                .map((accessor) => accessor.element)
                .indexOf(document.activeElement)
            : -1,
        getListItemCount: () => items.length,
        getPrimaryTextAtIndex,
        hasCheckboxAtIndex: (index) => { var _a, _b; return (_b = (_a = getOrderedList()[index]) === null || _a === void 0 ? void 0 : _a.hasCheckbox) !== null && _b !== void 0 ? _b : false; },
        hasRadioAtIndex: (index) => { var _a, _b; return (_b = (_a = getOrderedList()[index]) === null || _a === void 0 ? void 0 : _a.hasRadio) !== null && _b !== void 0 ? _b : false; },
        isCheckboxCheckedAtIndex: (index) => {
            var _a;
            const listItem = getOrderedList()[index];
            return (_a = ((listItem === null || listItem === void 0 ? void 0 : listItem.hasCheckbox) && listItem.checked)) !== null && _a !== void 0 ? _a : false;
        },
        isFocusInsideList: () => element != null &&
            getElement() !== document.activeElement &&
            getElement().contains(document.activeElement),
        isRootFocused: () => element != null && document.activeElement === getElement(),
        listItemAtIndexHasClass,
        notifyAction: (index) => {
            selectedIndex = index;
            if (element != null) {
                dispatch(getElement(), 'SMUIList:action', { index }, undefined, true);
            }
        },
        notifySelectionChange: (changedIndices) => {
            if (element != null) {
                dispatch(getElement(), 'SMUIList:selectionChange', {
                    changedIndices,
                });
            }
        },
        removeClassForElementIndex,
        setAttributeForElementIndex,
        setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
            getOrderedList()[index].checked = isChecked;
        },
        setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
            const listItem = getOrderedList()[listItemIndex];
            const selector = 'button:not(:disabled), a';
            Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
                el.setAttribute('tabindex', tabIndexValue);
            });
        },
    });
    const accessor = {
        get element() {
            return getElement();
        },
        get items() {
            return items;
        },
        get typeaheadInProgress() {
            return instance.isTypeaheadInProgress();
        },
        typeaheadMatchItem(nextChar, startingIndex) {
            return instance.typeaheadMatchItem(nextChar, startingIndex, 
            /** skipFocus */ true);
        },
        getOrderedList,
        focusItemAtIndex,
        addClassForElementIndex,
        removeClassForElementIndex,
        setAttributeForElementIndex,
        removeAttributeForElementIndex,
        getAttributeFromElementIndex,
        getPrimaryTextAtIndex,
    };
    dispatch(getElement(), 'SMUIList:mount', accessor);
    instance.init();
    instance.layout();
    return () => {
        instance.destroy();
    };
});
onDestroy(() => {
    if (removeLayoutListener) {
        removeLayoutListener();
    }
});
function handleItemMount(event) {
    items.push(event.detail);
    itemAccessorMap.set(event.detail.element, event.detail);
    if (singleSelection && event.detail.selected) {
        selectedIndex = getListItemIndex(event.detail.element);
    }
    event.stopPropagation();
}
function handleItemUnmount(event) {
    var _a;
    const idx = (_a = (event.detail && items.indexOf(event.detail))) !== null && _a !== void 0 ? _a : -1;
    if (idx !== -1) {
        items.splice(idx, 1);
        items = items;
        itemAccessorMap.delete(event.detail.element);
    }
    event.stopPropagation();
}
function handleKeydown(event) {
    if (instance && event.target) {
        instance.handleKeydown(event, event.target.classList.contains('mdc-deprecated-list-item'), getListItemIndex(event.target));
    }
}
function handleFocusin(event) {
    if (instance && event.target) {
        instance.handleFocusIn(getListItemIndex(event.target));
    }
}
function handleFocusout(event) {
    if (instance && event.target) {
        instance.handleFocusOut(getListItemIndex(event.target));
    }
}
function handleClick(event) {
    if (instance && event.target) {
        instance.handleClick(getListItemIndex(event.target), !matches(event.target, 'input[type="checkbox"], input[type="radio"]'), event);
    }
}
function handleAction(event) {
    if (radioList || checkList) {
        const index = getListItemIndex(event.target);
        if (index !== -1) {
            const item = getOrderedList()[index];
            if (item && ((radioList && !item.checked) || checkList)) {
                if (!matches(event.detail.target, 'input[type="checkbox"], input[type="radio"]')) {
                    item.checked = !item.checked;
                }
                item.activateRipple();
                window.requestAnimationFrame(() => {
                    item.deactivateRipple();
                });
            }
        }
    }
}
function getOrderedList() {
    if (element == null) {
        return [];
    }
    return [...getElement().children]
        .map((element) => itemAccessorMap.get(element))
        .filter((accessor) => accessor && accessor._smui_list_item_accessor);
}
function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor &&
        'focus' in accessor.element &&
        accessor.element.focus();
}
function listItemAtIndexHasClass(index, className) {
    var _a;
    const accessor = getOrderedList()[index];
    return (_a = (accessor && accessor.hasClass(className))) !== null && _a !== void 0 ? _a : false;
}
function addClassForElementIndex(index, className) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className);
}
function removeClassForElementIndex(index, className) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className);
}
function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
}
function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
}
function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
        return accessor.getAttr(name);
    }
    else {
        return null;
    }
}
function getPrimaryTextAtIndex(index) {
    var _a;
    const accessor = getOrderedList()[index];
    return (_a = (accessor && accessor.getPrimaryText())) !== null && _a !== void 0 ? _a : '';
}
function getListItemIndex(element) {
    const nearestParent = closest(element, '.mdc-deprecated-list-item, .mdc-deprecated-list');
    // Get the index of the element if it is a list item.
    if (nearestParent && matches(nearestParent, '.mdc-deprecated-list-item')) {
        return getOrderedList()
            .map((item) => item === null || item === void 0 ? void 0 : item.element)
            .indexOf(nearestParent);
    }
    return -1;
}
export function layout() {
    return instance.layout();
}
export function setEnabled(itemIndex, isEnabled) {
    return instance.setEnabled(itemIndex, isEnabled);
}
export function getTypeaheadInProgress() {
    return instance.isTypeaheadInProgress();
}
export function getSelectedIndex() {
    return instance.getSelectedIndex();
}
export function getFocusedItemIndex() {
    return instance.getFocusedItemIndex();
}
export function getElement() {
    return element.getElement();
}
</script>
