<div
  bind:this={element}
  use:useActions={use}
  use:forwardEvents
  class={classMap({
    [className]: true,
    'mdc-text-field-helper-text': true,
    'mdc-text-field-helper-text--persistent': persistent,
    'mdc-text-field-helper-text--validation-msg': validationMsg,
    ...internalClasses,
  })}
  aria-hidden={persistent ? undefined : 'true'}
  {id}
  {...internalAttrs}
  {...$$restProps}
>
  {#if content == null}<slot />{:else}{content}{/if}
</div>

<script context="module">"use strict";
let counter = 0;
</script>

<script>import { MDCTextFieldHelperTextFoundation } from '@material/textfield';
import { onMount } from 'svelte';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, useActions, dispatch, } from '@smui/common/internal';
const forwardEvents = forwardEventsBuilder(get_current_component());
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let id = 'SMUI-textfield-helper-text-' + counter++;
export let persistent = false;
export let validationMsg = false;
let element;
let instance;
let internalClasses = {};
let internalAttrs = {};
let content = undefined;
onMount(() => {
    instance = new MDCTextFieldHelperTextFoundation({
        addClass,
        removeClass,
        hasClass,
        getAttr,
        setAttr: addAttr,
        removeAttr,
        setContent: (value) => {
            content = value;
        },
    });
    if (id.startsWith('SMUI-textfield-helper-text-')) {
        dispatch(getElement(), 'SMUITextfieldHelperText:id', id);
    }
    dispatch(getElement(), 'SMUITextfieldHelperText:mount', instance);
    instance.init();
    return () => {
        dispatch(getElement(), 'SMUITextfieldHelperText:unmount', instance);
        instance.destroy();
    };
});
function hasClass(className) {
    return className in internalClasses
        ? internalClasses[className]
        : getElement().classList.contains(className);
}
function addClass(className) {
    if (!internalClasses[className]) {
        internalClasses[className] = true;
    }
}
function removeClass(className) {
    if (!(className in internalClasses) || internalClasses[className]) {
        internalClasses[className] = false;
    }
}
function getAttr(name) {
    var _a;
    return name in internalAttrs
        ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null
        : getElement().getAttribute(name);
}
function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
        internalAttrs[name] = value;
    }
}
function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
        internalAttrs[name] = undefined;
    }
}
export function getElement() {
    return element;
}
</script>
