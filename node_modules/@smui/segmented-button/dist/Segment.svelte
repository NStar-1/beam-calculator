<button
  bind:this={element}
  use:Ripple={{
    ripple,
    unbounded: false,
    addClass,
    removeClass,
    addStyle,
  }}
  use:forwardEvents
  use:useActions={use}
  class={classMap({
    [className]: true,
    'mdc-segmented-button__segment': true,
    'mdc-segmented-button__segment--touch': touch,
    'mdc-segmented-button__segment--selected': selected,
    ...internalClasses,
  })}
  style={Object.entries(internalStyles)
    .map(([name, value]) => `${name}: ${value};`)
    .concat([style])
    .join(' ')}
  role={singleSelect ? 'radio' : undefined}
  aria-pressed={!singleSelect ? (selected ? 'true' : 'false') : undefined}
  aria-checked={singleSelect ? (selected ? 'true' : 'false') : undefined}
  on:click={(event) =>
    !event.defaultPrevented &&
    instance &&
    !manualSelection &&
    instance.handleClick()}
  {...internalAttrs}
  {...$$restProps}
  >{#if ripple}<div class="mdc-segmented-button__ripple" />{/if}<slot
  />{#if touch}<div class="mdc-segmented-button__segment__touch" />{/if}</button
>

<script>import { MDCSegmentedButtonSegmentFoundation } from '@material/segmented-button/dist/mdc.segmentedButton.js';
import { onMount, getContext } from 'svelte';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, useActions, dispatch, } from '@smui/common/internal';
import Ripple from '@smui/ripple';
const forwardEvents = forwardEventsBuilder(get_current_component());
let uninitializedValue = () => { };
function isUninitializedValue(value) {
    return value === uninitializedValue;
}
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let style = '';
let segmentId;
export { segmentId as segment };
export let ripple = true;
export let touch = false;
const initialSelectedStore = getContext('SMUI:segmented-button:segment:initialSelected');
// Some trickery to detect uninitialized values but also have the right types.
/** You don't need to set this unless you are manually handling selection. */
export let selected = uninitializedValue;
let manualSelection = !isUninitializedValue(selected);
if (isUninitializedValue(selected)) {
    selected = $initialSelectedStore;
}
// Done with the trickery.
let element;
let instance;
let internalClasses = {};
let internalStyles = {};
let internalAttrs = {};
const singleSelect = getContext('SMUI:segmented-button:singleSelect');
const index = getContext('SMUI:segmented-button:segment:index');
if (!segmentId) {
    throw new Error('The segment property is required! It should be passed down from the SegmentedButton to the Segment.');
}
$: if (instance && instance.isSelected() && !selected) {
    instance.setUnselected();
}
$: if (instance && !instance.isSelected() && selected) {
    instance.setSelected();
}
onMount(() => {
    instance = new MDCSegmentedButtonSegmentFoundation({
        isSingleSelect: () => {
            return $singleSelect;
        },
        getAttr,
        setAttr: addAttr,
        addClass,
        removeClass,
        hasClass,
        notifySelectedChange: (value) => {
            selected = value;
            dispatch(getElement(), 'selected', {
                index: $index,
                selected,
                segmentId,
            });
        },
        getRootBoundingClientRect: () => {
            return getElement().getBoundingClientRect();
        },
    });
    const accessor = {
        segmentId,
        get selected() {
            return selected;
        },
        set selected(value) {
            if (selected !== value) {
                selected = value;
            }
        },
    };
    dispatch(getElement(), 'SMUISegmentedButtonSegment:mount', accessor);
    instance.init();
    return () => {
        dispatch(getElement(), 'SMUISegmentedButtonSegment:unmount', accessor);
        instance.destroy();
    };
});
function hasClass(className) {
    return className in internalClasses
        ? internalClasses[className]
        : getElement().classList.contains(className);
}
function addClass(className) {
    if (!internalClasses[className]) {
        internalClasses[className] = true;
    }
}
function removeClass(className) {
    if (!(className in internalClasses) || internalClasses[className]) {
        internalClasses[className] = false;
    }
}
function getAttr(name) {
    var _a;
    return name in internalAttrs
        ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null
        : getElement().getAttribute(name);
}
function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
        internalAttrs[name] = value;
    }
}
function addStyle(name, value) {
    if (internalStyles[name] != value) {
        if (value === '' || value == null) {
            delete internalStyles[name];
            internalStyles = internalStyles;
        }
        else {
            internalStyles[name] = value;
        }
    }
}
export function getElement() {
    return element;
}
</script>
