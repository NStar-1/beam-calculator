<div
  bind:this={element}
  use:useActions={use}
  use:forwardEvents
  class={classMap({
    [className]: true,
    'mdc-data-table': true,
    'mdc-data-table--sticky-header': stickyHeader,
    ...internalClasses,
  })}
  on:SMUICheckbox:mount={() => instance && postMount && instance.layout()}
  on:SMUIDataTableHeader:mount={(event) => (header = event.detail)}
  on:SMUIDataTableHeader:unmount={() => (header = undefined)}
  on:SMUIDataTableBody:mount={(event) => (body = event.detail)}
  on:SMUIDataTableBody:unmount={() => (body = undefined)}
  on:SMUIDataTableHeaderCheckbox:change={() =>
    instance && instance.handleHeaderRowCheckboxChange()}
  on:SMUIDataTableHeader:click={handleHeaderRowClick}
  on:SMUIDataTableRow:click={handleRowClick}
  on:SMUIDataTableBodyCheckbox:change={(event) =>
    instance && instance.handleRowCheckboxChange(event)}
  {...exclude($$restProps, ['container$', 'table$'])}
>
  <div
    bind:this={container}
    use:useActions={container$use}
    class={classMap({
      [container$class]: true,
      'mdc-data-table__table-container': true,
    })}
    {...prefixFilter($$restProps, 'container$')}
  >
    <table
      use:useActions={table$use}
      class={classMap({
        [table$class]: true,
        'mdc-data-table__table': true,
      })}
      {...prefixFilter($$restProps, 'table$')}
    >
      <slot />
    </table>
  </div>

  {#if $$slots.progress}
    <div
      class="mdc-data-table__progress-indicator"
      style={Object.entries(progressIndicatorStyles)
        .map(([name, value]) => `${name}: ${value};`)
        .join(' ')}
    >
      <div class="mdc-data-table__scrim" />
      <slot name="progress" />
    </div>
  {/if}

  <slot name="paginate" />
</div>

<script>import { MDCDataTableFoundation } from '@material/data-table';
import { ponyfill } from '@material/dom';
import { onMount, onDestroy, getContext, setContext } from 'svelte';
import { writable } from 'svelte/store';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, exclude, prefixFilter, useActions, dispatch, } from '@smui/common/internal';
const { closest } = ponyfill;
const forwardEvents = forwardEventsBuilder(get_current_component());
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let stickyHeader = false;
export let sortable = false;
export let sort = null;
export let sortDirection = 'ascending';
export let sortAscendingAriaLabel = 'sorted, ascending';
export let sortDescendingAriaLabel = 'sorted, descending';
export let container$use = [];
export let container$class = '';
export let table$use = [];
export let table$class = '';
let element;
let instance;
let container;
let header = undefined;
let body = undefined;
let internalClasses = {};
let progressIndicatorStyles = {
    height: 'auto',
    top: 'initial',
};
let addLayoutListener = getContext('SMUI:addLayoutListener');
let removeLayoutListener;
let postMount = false;
let progressClosed = writable(false);
let sortStore = writable(sort);
let sortDirectionStore = writable(sortDirection);
setContext('SMUI:checkbox:context', 'data-table');
setContext('SMUI:linear-progress:context', 'data-table');
setContext('SMUI:linear-progress:closed', progressClosed);
setContext('SMUI:data-table:sortable', sortable);
setContext('SMUI:data-table:sort', sortStore);
setContext('SMUI:data-table:sortDirection', sortDirectionStore);
setContext('SMUI:data-table:sortAscendingAriaLabel', sortAscendingAriaLabel);
setContext('SMUI:data-table:sortDescendingAriaLabel', sortDescendingAriaLabel);
$: $sortStore = sort;
$: $sortDirectionStore = sortDirection;
if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
}
let previousProgressClosed = undefined;
$: if ($$slots.progress &&
    instance &&
    previousProgressClosed !== $progressClosed) {
    previousProgressClosed = $progressClosed;
    if ($progressClosed) {
        instance.hideProgress();
    }
    else {
        instance.showProgress();
    }
}
onMount(() => {
    instance = new MDCDataTableFoundation({
        addClass,
        removeClass,
        getHeaderCellElements: () => { var _a; return (_a = header === null || header === void 0 ? void 0 : header.cells.map((accessor) => accessor.element)) !== null && _a !== void 0 ? _a : []; },
        getHeaderCellCount: () => { var _a; return (_a = header === null || header === void 0 ? void 0 : header.cells.length) !== null && _a !== void 0 ? _a : 0; },
        getAttributeByHeaderCellIndex: (index, name) => {
            var _a;
            return (_a = header === null || header === void 0 ? void 0 : header.orderedCells[index].getAttr(name)) !== null && _a !== void 0 ? _a : null;
        },
        setAttributeByHeaderCellIndex: (index, name, value) => {
            header === null || header === void 0 ? void 0 : header.orderedCells[index].addAttr(name, value);
        },
        setClassNameByHeaderCellIndex: (index, className) => {
            header === null || header === void 0 ? void 0 : header.orderedCells[index].addClass(className);
        },
        removeClassNameByHeaderCellIndex: (index, className) => {
            header === null || header === void 0 ? void 0 : header.orderedCells[index].removeClass(className);
        },
        notifySortAction: (data) => {
            sort = data.columnId;
            sortDirection = data.sortValue;
            dispatch(getElement(), 'SMUIDataTable:sorted', data, undefined, true);
        },
        getTableContainerHeight: () => container.getBoundingClientRect().height,
        getTableHeaderHeight: () => {
            const tableHeader = getElement().querySelector('.mdc-data-table__header-row');
            if (!tableHeader) {
                throw new Error('MDCDataTable: Table header element not found.');
            }
            return tableHeader.getBoundingClientRect().height;
        },
        setProgressIndicatorStyles: (styles) => {
            progressIndicatorStyles = styles;
        },
        addClassAtRowIndex: (rowIndex, className) => {
            body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].addClass(className);
        },
        getRowCount: () => { var _a; return (_a = body === null || body === void 0 ? void 0 : body.rows.length) !== null && _a !== void 0 ? _a : 0; },
        getRowElements: () => { var _a; return (_a = body === null || body === void 0 ? void 0 : body.rows.map((accessor) => accessor.element)) !== null && _a !== void 0 ? _a : []; },
        getRowIdAtIndex: (rowIndex) => { var _a; return (_a = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].rowId) !== null && _a !== void 0 ? _a : null; },
        getRowIndexByChildElement: (el) => {
            var _a;
            return ((_a = body === null || body === void 0 ? void 0 : body.orderedRows.map((accessor) => accessor.element).indexOf(closest(el, '.mdc-data-table__row'))) !== null && _a !== void 0 ? _a : -1);
        },
        getSelectedRowCount: () => { var _a; return (_a = body === null || body === void 0 ? void 0 : body.rows.filter((accessor) => accessor.selected).length) !== null && _a !== void 0 ? _a : 0; },
        isCheckboxAtRowIndexChecked: (rowIndex) => {
            const checkbox = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].checkbox;
            if (checkbox) {
                return checkbox.checked;
            }
            return false;
        },
        isHeaderRowCheckboxChecked: () => {
            const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
            if (checkbox) {
                return checkbox.checked;
            }
            return false;
        },
        isRowsSelectable: () => !!getElement().querySelector('.mdc-data-table__row-checkbox') ||
            !!getElement().querySelector('.mdc-data-table__header-row-checkbox'),
        notifyRowSelectionChanged: (data) => {
            const row = body === null || body === void 0 ? void 0 : body.orderedRows[data.rowIndex];
            if (row) {
                dispatch(getElement(), 'SMUIDataTable:rowSelectionChanged', {
                    row: row.element,
                    rowId: row.rowId,
                    rowIndex: data.rowIndex,
                    selected: data.selected,
                }, undefined, true);
            }
        },
        notifySelectedAll: () => {
            setHeaderRowCheckboxIndeterminate(false);
            dispatch(getElement(), 'SMUIDataTable:selectedAll', undefined, undefined, true);
        },
        notifyUnselectedAll: () => {
            setHeaderRowCheckboxIndeterminate(false);
            dispatch(getElement(), 'SMUIDataTable:unselectedAll', undefined, undefined, true);
        },
        notifyRowClick: (detail) => {
            dispatch(getElement(), 'SMUIDataTable:rowClick', detail, undefined, true);
        },
        registerHeaderRowCheckbox: () => {
            // Handled automatically.
        },
        registerRowCheckboxes: () => {
            // Handled automatically.
        },
        removeClassAtRowIndex: (rowIndex, className) => {
            body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].removeClass(className);
        },
        setAttributeAtRowIndex: (rowIndex, name, value) => {
            body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].addAttr(name, value);
        },
        setHeaderRowCheckboxChecked: (checked) => {
            const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
            if (checkbox) {
                checkbox.checked = checked;
            }
        },
        setHeaderRowCheckboxIndeterminate,
        setRowCheckboxCheckedAtIndex: (rowIndex, checked) => {
            const checkbox = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].checkbox;
            if (checkbox) {
                checkbox.checked = checked;
            }
        },
        setSortStatusLabelByHeaderCellIndex: (_columnIndex, _sortValue) => {
            // Handled automatically.
        },
    });
    instance.init();
    instance.layout();
    postMount = true;
    return () => {
        instance.destroy();
    };
});
onDestroy(() => {
    if (removeLayoutListener) {
        removeLayoutListener();
    }
});
function addClass(className) {
    if (!internalClasses[className]) {
        internalClasses[className] = true;
    }
}
function removeClass(className) {
    if (!(className in internalClasses) || internalClasses[className]) {
        internalClasses[className] = false;
    }
}
function setHeaderRowCheckboxIndeterminate(indeterminate) {
    const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
    if (checkbox) {
        checkbox.indeterminate = indeterminate;
    }
}
function handleHeaderRowClick(event) {
    if (!instance || !event.detail.target) {
        return;
    }
    const headerCell = closest(event.detail.target, '.mdc-data-table__header-cell--with-sort');
    if (headerCell) {
        handleSortAction(headerCell);
    }
}
function handleRowClick(event) {
    if (!instance || !event.detail.target) {
        return;
    }
    const row = closest(event.detail.target, '.mdc-data-table__row');
    if (row && instance) {
        instance.handleRowClick({ rowId: event.detail.rowId, row });
    }
}
function handleSortAction(headerCell) {
    var _a, _b;
    const orderedCells = (_a = header === null || header === void 0 ? void 0 : header.orderedCells) !== null && _a !== void 0 ? _a : [];
    const columnIndex = orderedCells
        .map((accessor) => accessor.element)
        .indexOf(headerCell);
    if (columnIndex === -1) {
        return;
    }
    const columnId = (_b = orderedCells[columnIndex].columnId) !== null && _b !== void 0 ? _b : null;
    instance.handleSortAction({ columnId, columnIndex, headerCell });
}
export function layout() {
    return instance.layout();
}
export function getElement() {
    return element;
}
</script>
