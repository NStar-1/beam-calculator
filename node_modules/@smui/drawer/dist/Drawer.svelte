<aside
  bind:this={element}
  use:useActions={use}
  use:forwardEvents
  class={classMap({
    [className]: true,
    'mdc-drawer': true,
    'mdc-drawer--dismissible': variant === 'dismissible',
    'mdc-drawer--modal': variant === 'modal',
    'smui-drawer__absolute': variant === 'modal' && !fixed,
    ...internalClasses,
  })}
  on:keydown={instance && instance.handleKeydown.bind(instance)}
  on:transitionend={instance && instance.handleTransitionEnd.bind(instance)}
  {...$$restProps}
>
  <slot />
</aside>

<script>import { MDCDismissibleDrawerFoundation, MDCModalDrawerFoundation, } from '@material/drawer';
import { focusTrap as domFocusTrap } from '@material/dom';
import { onMount, onDestroy, setContext } from 'svelte';
import { get_current_component } from 'svelte/internal';
import { forwardEventsBuilder, classMap, useActions, dispatch, } from '@smui/common/internal';
const { FocusTrap } = domFocusTrap;
const forwardEvents = forwardEventsBuilder(get_current_component());
// Remember to update $$Props if you add/remove/rename props.
export let use = [];
let className = '';
export { className as class };
export let variant = undefined;
export let open = false;
export let fixed = true;
let element;
let instance = undefined;
let internalClasses = {};
let previousFocus = null;
let focusTrap;
let scrim = false;
setContext('SMUI:list:nav', true);
setContext('SMUI:list:item:nav', true);
setContext('SMUI:list:wrapFocus', true);
$: if (instance && instance.isOpen() !== open) {
    if (open) {
        instance.open();
    }
    else {
        instance.close();
    }
}
let oldVariant = variant;
$: if (oldVariant !== variant) {
    oldVariant = variant;
    instance && instance.destroy();
    internalClasses = {};
    instance = getInstance();
    instance && instance.init();
}
onMount(() => {
    focusTrap = new FocusTrap(element, {
        // Component handles focusing on active nav item.
        skipInitialFocus: true,
    });
    instance = getInstance();
    instance && instance.init();
});
onDestroy(() => {
    instance && instance.destroy();
    scrim &&
        scrim.removeEventListener('SMUIDrawerScrim:click', handleScrimClick);
});
function getInstance() {
    var _a, _b;
    if (scrim) {
        scrim.removeEventListener('SMUIDrawerScrim:click', handleScrimClick);
    }
    if (variant === 'modal') {
        scrim = (_b = (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector('.mdc-drawer-scrim')) !== null && _b !== void 0 ? _b : false;
        if (scrim) {
            scrim.addEventListener('SMUIDrawerScrim:click', handleScrimClick);
        }
    }
    const Foundation = variant === 'dismissible'
        ? MDCDismissibleDrawerFoundation
        : variant === 'modal'
            ? MDCModalDrawerFoundation
            : undefined;
    return Foundation
        ? new Foundation({
            addClass,
            removeClass,
            hasClass,
            elementHasClass: (element, className) => element.classList.contains(className),
            saveFocus: () => (previousFocus = document.activeElement),
            restoreFocus: () => {
                if (previousFocus &&
                    'focus' in previousFocus &&
                    element.contains(document.activeElement)) {
                    previousFocus.focus();
                }
            },
            focusActiveNavigationItem: () => {
                const activeNavItemEl = element.querySelector('.mdc-list-item--activated,.mdc-deprecated-list-item--activated');
                if (activeNavItemEl) {
                    activeNavItemEl.focus();
                }
            },
            notifyClose: () => {
                open = false;
                dispatch(element, 'SMUIDrawer:closed', undefined, undefined, true);
            },
            notifyOpen: () => {
                open = true;
                dispatch(element, 'SMUIDrawer:opened', undefined, undefined, true);
            },
            trapFocus: () => focusTrap.trapFocus(),
            releaseFocus: () => focusTrap.releaseFocus(),
        })
        : undefined;
}
function hasClass(className) {
    return className in internalClasses
        ? internalClasses[className]
        : getElement().classList.contains(className);
}
function addClass(className) {
    if (!internalClasses[className]) {
        internalClasses[className] = true;
    }
}
function removeClass(className) {
    if (!(className in internalClasses) || internalClasses[className]) {
        internalClasses[className] = false;
    }
}
function handleScrimClick() {
    instance && 'handleScrimClick' in instance && instance.handleScrimClick();
}
export function setOpen(value) {
    open = value;
}
export function isOpen() {
    return open;
}
export function getElement() {
    return element;
}
</script>
